!function(t){var n={};function e(c){if(n[c])return n[c].exports;var l=n[c]={i:c,l:!1,exports:{}};return t[c].call(l.exports,l,l.exports,e),l.l=!0,l.exports}e.m=t,e.c=n,e.d=function(t,n,c){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:c})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var c=Object.create(null);if(e.r(c),Object.defineProperty(c,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var l in t)e.d(c,l,function(n){return t[n]}.bind(null,l));return c},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=86)}([function(module,exports,__webpack_require__){eval("var DataFactory = __webpack_require__(80)\n\nmodule.exports = DataFactory\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvaW5kZXguanM/OWI5MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFvQjs7QUFFOUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBEYXRhRmFjdG9yeSA9IHJlcXVpcmUoJy4vbGliL2RhdGEtZmFjdG9yeScpXG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YUZhY3RvcnlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("var store = __webpack_require__(17)('wks');\nvar uid = __webpack_require__(12);\nvar Symbol = __webpack_require__(3).Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanM/MmI0YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsRUFBVztBQUMvQixVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQixhQUFhLG1CQUFPLENBQUMsQ0FBVztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(9);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanM/Y2I3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")},function(module,exports){eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanM/NzcyNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(6)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcz85ZTFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsQ0FBVTtBQUNwQyxpQ0FBaUMsUUFBUSxtQkFBbUIsVUFBVSxFQUFFLEVBQUU7QUFDMUUsQ0FBQyIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){eval("var dP = __webpack_require__(7);\nvar createDesc = __webpack_require__(16);\nmodule.exports = __webpack_require__(4) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzPzMyZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxtQkFBTyxDQUFDLENBQWM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsRUFBa0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsQ0FBZ0I7QUFDekM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n")},function(module,exports){eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcz83OWU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){eval("var anObject = __webpack_require__(2);\nvar IE8_DOM_DEFINE = __webpack_require__(41);\nvar toPrimitive = __webpack_require__(27);\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(4) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanM/ODZjYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFtQjtBQUNoRCxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFpQjtBQUMzQzs7QUFFQSxZQUFZLG1CQUFPLENBQUMsQ0FBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n")},function(module,exports){eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanM/NjlhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n")},function(module,exports){eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanM/ZDNmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(3);\nvar hide = __webpack_require__(5);\nvar has = __webpack_require__(8);\nvar SRC = __webpack_require__(12)('src');\nvar $toString = __webpack_require__(57);\nvar TO_STRING = 'toString';\nvar TPL = ('' + $toString).split(TO_STRING);\n\n__webpack_require__(18).inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcz8yYWJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxDQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxDQUFTO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQyxDQUFRO0FBQzFCLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCLGdCQUFnQixtQkFBTyxDQUFDLEVBQXVCO0FBQy9DO0FBQ0E7O0FBRUEsbUJBQU8sQ0FBQyxFQUFTO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4vX2Z1bmN0aW9uLXRvLXN0cmluZycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(61);\nvar defined = __webpack_require__(21);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzPzY4MjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsRUFBWTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsRUFBWTtBQUNsQztBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n")},function(module,exports){eval("var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanM/Y2E1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(46)('asyncIterator');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanM/YWM0ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLEVBQWUiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n")},function(module,exports,__webpack_require__){"use strict";eval("\n// ECMAScript 6 symbols shim\nvar global = __webpack_require__(3);\nvar has = __webpack_require__(8);\nvar DESCRIPTORS = __webpack_require__(4);\nvar $export = __webpack_require__(31);\nvar redefine = __webpack_require__(10);\nvar META = __webpack_require__(70).KEY;\nvar $fails = __webpack_require__(6);\nvar shared = __webpack_require__(17);\nvar setToStringTag = __webpack_require__(34);\nvar uid = __webpack_require__(12);\nvar wks = __webpack_require__(1);\nvar wksExt = __webpack_require__(47);\nvar wksDefine = __webpack_require__(46);\nvar enumKeys = __webpack_require__(71);\nvar isArray = __webpack_require__(72);\nvar anObject = __webpack_require__(2);\nvar isObject = __webpack_require__(9);\nvar toObject = __webpack_require__(35);\nvar toIObject = __webpack_require__(11);\nvar toPrimitive = __webpack_require__(27);\nvar createDesc = __webpack_require__(16);\nvar _create = __webpack_require__(44);\nvar gOPNExt = __webpack_require__(73);\nvar $GOPD = __webpack_require__(74);\nvar $GOPS = __webpack_require__(48);\nvar $DP = __webpack_require__(7);\nvar $keys = __webpack_require__(22);\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  __webpack_require__(49).f = gOPNExt.f = $getOwnPropertyNames;\n  __webpack_require__(36).f = $propertyIsEnumerable;\n  $GOPS.f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !__webpack_require__(19)) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\nvar FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });\n\n$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    return $GOPS.f(toObject(it));\n  }\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(5)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanM/OGE4MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLENBQVc7QUFDaEMsVUFBVSxtQkFBTyxDQUFDLENBQVE7QUFDMUIsa0JBQWtCLG1CQUFPLENBQUMsQ0FBZ0I7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLEVBQVc7QUFDakMsZUFBZSxtQkFBTyxDQUFDLEVBQWE7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLEVBQVM7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLENBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLEVBQVc7QUFDaEMscUJBQXFCLG1CQUFPLENBQUMsRUFBc0I7QUFDbkQsVUFBVSxtQkFBTyxDQUFDLEVBQVE7QUFDMUIsVUFBVSxtQkFBTyxDQUFDLENBQVE7QUFDMUIsYUFBYSxtQkFBTyxDQUFDLEVBQVk7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsRUFBZTtBQUN2QyxlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyxjQUFjLG1CQUFPLENBQUMsRUFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLEVBQWlCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLEVBQWtCO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyxFQUFrQjtBQUN4QyxjQUFjLG1CQUFPLENBQUMsRUFBb0I7QUFDMUMsWUFBWSxtQkFBTyxDQUFDLEVBQWdCO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQyxFQUFnQjtBQUNwQyxVQUFVLG1CQUFPLENBQUMsQ0FBYztBQUNoQyxZQUFZLG1CQUFPLENBQUMsRUFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0IsdUJBQXVCLFdBQVcsSUFBSTtBQUM1RCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGdDQUFnQztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEVBQUUsbUJBQU8sQ0FBQyxFQUFnQjtBQUMxQixFQUFFLG1CQUFPLENBQUMsRUFBZTtBQUN6Qjs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyxFQUFZO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELGtCQUFrQjs7QUFFNUU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1Qjs7QUFFM0Msb0RBQW9ELDZCQUE2Qjs7QUFFakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsMEJBQTBCLGdCQUFnQjtBQUMxQyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsOENBQThDLFlBQVksRUFBRTs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPLFFBQVEsaUNBQWlDO0FBQ3BHLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esb0NBQW9DLG1CQUFPLENBQUMsQ0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICRHT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nICYmICEhJEdPUFMuZjtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgJEdPUFMuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSAkZmFpbHMoZnVuY3Rpb24gKCkgeyAkR09QUy5mKDEpOyB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBGQUlMU19PTl9QUklNSVRJVkVTLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiAkR09QUy5mKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){eval('!function(t,e){ true?module.exports=e():undefined}(window,(function(){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(n,i,function(e){return t[e]}.bind(null,i));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=205)}([function(t,e,r){t.exports=r(28)},function(t,e){function r(t,e,r,n,i,o,a){try{var s=t[o](a),u=s.value}catch(t){return void r(t)}s.done?e(u):Promise.resolve(u).then(n,i)}t.exports=function(t){return function(){var e=this,n=arguments;return new Promise((function(i,o){var a=t.apply(e,n);function s(t){r(a,i,o,s,u,"next",t)}function u(t){r(a,i,o,s,u,"throw",t)}s(void 0)}))}}},function(t,e,r){var n=r(4),i=r(22).f,o=r(14),a=r(17),s=r(62),u=r(101),c=r(68);t.exports=function(t,e){var r,f,l,h,p,d=t.target,v=t.global,g=t.stat;if(r=v?n:g?n[d]||s(d,{}):(n[d]||{}).prototype)for(f in e){if(h=e[f],l=t.noTargetGet?(p=i(r,f))&&p.value:r[f],!c(v?f:d+(g?".":"#")+f,t.forced)&&void 0!==l){if(typeof h==typeof l)continue;u(h,l)}(t.sham||l&&l.sham)&&o(h,"sham",!0),a(r,f,h,t)}}},function(t,e,r){var n=r(4),i=r(64),o=r(13),a=r(65),s=r(69),u=r(107),c=i("wks"),f=n.Symbol,l=u?f:f&&f.withoutSetter||a;t.exports=function(t){return o(c,t)||(s&&o(f,t)?c[t]=f[t]:c[t]=l("Symbol."+t)),c[t]}},function(t,e,r){(function(e){var r=function(t){return t&&t.Math==Math&&t};t.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof e&&e)||Function("return this")()}).call(this,r(21))},function(t,e){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,e,r){"use strict";var n="http://www.w3.org/1999/02/22-rdf-syntax-ns#",i="http://www.w3.org/2001/XMLSchema#",o="http://www.w3.org/2000/10/swap/";e.a={xsd:{decimal:i+"decimal",boolean:i+"boolean",double:i+"double",integer:i+"integer",string:i+"string"},rdf:{type:n+"type",nil:n+"nil",first:n+"first",rest:n+"rest",langString:n+"langString"},owl:{sameAs:"http://www.w3.org/2002/07/owl#sameAs"},r:{forSome:o+"reify#forSome",forAll:o+"reify#forAll"},log:{implies:o+"log#implies"}}},function(t,e,r){var n=r(5);t.exports=!n((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},function(t,e,r){var n=r(10);t.exports=function(t){if(!n(t))throw TypeError(String(t)+" is not an object");return t}},function(t,e,r){var n=r(169),i=r(170),o=r(171);t.exports=function(t){return n(t)||i(t)||o()}},function(t,e){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,e,r){var n=r(7),i=r(99),o=r(8),a=r(43),s=Object.defineProperty;e.f=n?s:function(t,e,r){if(o(t),e=a(e,!0),o(r),i)try{return s(t,e,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported");return"value"in r&&(t[e]=r.value),t}},function(t,e,r){var n=r(60),i=r(20);t.exports=function(t){return n(i(t))}},function(t,e){var r={}.hasOwnProperty;t.exports=function(t,e){return r.call(t,e)}},function(t,e,r){var n=r(7),i=r(11),o=r(31);t.exports=n?function(t,e,r){return i.f(t,e,o(1,r))}:function(t,e,r){return t[e]=r,t}},function(t,e,r){var n=r(32),i=Math.min;t.exports=function(t){return t>0?i(n(t),9007199254740991):0}},function(t,e){function r(e){return t.exports=r=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},r(e)}t.exports=r},function(t,e,r){var n=r(4),i=r(14),o=r(13),a=r(62),s=r(63),u=r(24),c=u.get,f=u.enforce,l=String(String).split("String");(t.exports=function(t,e,r,s){var u=!!s&&!!s.unsafe,c=!!s&&!!s.enumerable,h=!!s&&!!s.noTargetGet;"function"==typeof r&&("string"!=typeof e||o(r,"name")||i(r,"name",e),f(r).source=l.join("string"==typeof e?e:"")),t!==n?(u?!h&&t[e]&&(c=!0):delete t[e],c?t[e]=r:i(t,e,r)):c?t[e]=r:a(e,r)})(Function.prototype,"toString",(function(){return"function"==typeof this&&c(this).source||s(this)}))},function(t,e){t.exports=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}},function(t,e){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,e){t.exports=function(t){if(null==t)throw TypeError("Can\'t call method on "+t);return t}},function(t,e){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(t){"object"==typeof window&&(r=window)}t.exports=r},function(t,e,r){var n=r(7),i=r(59),o=r(31),a=r(12),s=r(43),u=r(13),c=r(99),f=Object.getOwnPropertyDescriptor;e.f=n?f:function(t,e){if(t=a(t),e=s(e,!0),c)try{return f(t,e)}catch(t){}if(u(t,e))return o(!i.f.call(t,e),t[e])}},function(t,e,r){"use strict";var n=r(55),i=Object.keys||function(t){var e=[];for(var r in t)e.push(r);return e};t.exports=l;var o=r(39);o.inherits=r(29);var a=r(138),s=r(95);o.inherits(l,a);for(var u=i(s.prototype),c=0;c<u.length;c++){var f=u[c];l.prototype[f]||(l.prototype[f]=s.prototype[f])}function l(t){if(!(this instanceof l))return new l(t);a.call(this,t),s.call(this,t),t&&!1===t.readable&&(this.readable=!1),t&&!1===t.writable&&(this.writable=!1),this.allowHalfOpen=!0,t&&!1===t.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",h)}function h(){this.allowHalfOpen||this._writableState.ended||n.nextTick(p,this)}function p(t){t.end()}Object.defineProperty(l.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(l.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(t){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=t,this._writableState.destroyed=t)}}),l.prototype._destroy=function(t,e){this.push(null),this.end(),n.nextTick(e,t)}},function(t,e,r){var n,i,o,a=r(147),s=r(4),u=r(10),c=r(14),f=r(13),l=r(44),h=r(45),p=s.WeakMap;if(a){var d=new p,v=d.get,g=d.has,y=d.set;n=function(t,e){return y.call(d,t,e),e},i=function(t){return v.call(d,t)||{}},o=function(t){return g.call(d,t)}}else{var b=l("state");h[b]=!0,n=function(t,e){return c(t,b,e),e},i=function(t){return f(t,b)?t[b]:{}},o=function(t){return f(t,b)}}t.exports={set:n,get:i,has:o,enforce:function(t){return o(t)?i(t):n(t,{})},getterFor:function(t){return function(e){var r;if(!u(e)||(r=i(e)).type!==t)throw TypeError("Incompatible receiver, "+t+" required");return r}}}},function(t,e){t.exports=!1},function(t,e,r){var n=r(103),i=r(4),o=function(t){return"function"==typeof t?t:void 0};t.exports=function(t,e){return arguments.length<2?o(n[t])||o(i[t]):n[t]&&n[t][e]||i[t]&&i[t][e]}},function(t,e,r){var n=r(20);t.exports=function(t){return Object(n(t))}},function(t,e,r){var n=function(t){"use strict";var e=Object.prototype,r=e.hasOwnProperty,n="function"==typeof Symbol?Symbol:{},i=n.iterator||"@@iterator",o=n.asyncIterator||"@@asyncIterator",a=n.toStringTag||"@@toStringTag";function s(t,e,r,n){var i=e&&e.prototype instanceof f?e:f,o=Object.create(i.prototype),a=new x(n||[]);return o._invoke=function(t,e,r){var n="suspendedStart";return function(i,o){if("executing"===n)throw new Error("Generator is already running");if("completed"===n){if("throw"===i)throw o;return E()}for(r.method=i,r.arg=o;;){var a=r.delegate;if(a){var s=_(a,r);if(s){if(s===c)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if("suspendedStart"===n)throw n="completed",r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n="executing";var f=u(t,e,r);if("normal"===f.type){if(n=r.done?"completed":"suspendedYield",f.arg===c)continue;return{value:f.arg,done:r.done}}"throw"===f.type&&(n="completed",r.method="throw",r.arg=f.arg)}}}(t,r,a),o}function u(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=s;var c={};function f(){}function l(){}function h(){}var p={};p[i]=function(){return this};var d=Object.getPrototypeOf,v=d&&d(d(k([])));v&&v!==e&&r.call(v,i)&&(p=v);var g=h.prototype=f.prototype=Object.create(p);function y(t){["next","throw","return"].forEach((function(e){t[e]=function(t){return this._invoke(e,t)}}))}function b(t){var e;this._invoke=function(n,i){function o(){return new Promise((function(e,o){!function e(n,i,o,a){var s=u(t[n],t,i);if("throw"!==s.type){var c=s.arg,f=c.value;return f&&"object"==typeof f&&r.call(f,"__await")?Promise.resolve(f.__await).then((function(t){e("next",t,o,a)}),(function(t){e("throw",t,o,a)})):Promise.resolve(f).then((function(t){c.value=t,o(c)}),(function(t){return e("throw",t,o,a)}))}a(s.arg)}(n,i,e,o)}))}return e=e?e.then(o,o):o()}}function _(t,e){var r=t.iterator[e.method];if(void 0===r){if(e.delegate=null,"throw"===e.method){if(t.iterator.return&&(e.method="return",e.arg=void 0,_(t,e),"throw"===e.method))return c;e.method="throw",e.arg=new TypeError("The iterator does not provide a \'throw\' method")}return c}var n=u(r,t.iterator,e.arg);if("throw"===n.type)return e.method="throw",e.arg=n.arg,e.delegate=null,c;var i=n.arg;return i?i.done?(e[t.resultName]=i.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,c):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,c)}function m(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function w(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function x(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(m,this),this.reset(!0)}function k(t){if(t){var e=t[i];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,o=function e(){for(;++n<t.length;)if(r.call(t,n))return e.value=t[n],e.done=!1,e;return e.value=void 0,e.done=!0,e};return o.next=o}}return{next:E}}function E(){return{value:void 0,done:!0}}return l.prototype=g.constructor=h,h.constructor=l,h[a]=l.displayName="GeneratorFunction",t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===l||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,h):(t.__proto__=h,a in t||(t[a]="GeneratorFunction")),t.prototype=Object.create(g),t},t.awrap=function(t){return{__await:t}},y(b.prototype),b.prototype[o]=function(){return this},t.AsyncIterator=b,t.async=function(e,r,n,i){var o=new b(s(e,r,n,i));return t.isGeneratorFunction(r)?o:o.next().then((function(t){return t.done?t.value:o.next()}))},y(g),g[a]="Generator",g[i]=function(){return this},g.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=k,x.prototype={constructor:x,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(w),!t)for(var e in this)"t"===e.charAt(0)&&r.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function n(r,n){return a.type="throw",a.arg=t,e.next=r,n&&(e.method="next",e.arg=void 0),!!n}for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i],a=o.completion;if("root"===o.tryLoc)return n("end");if(o.tryLoc<=this.prev){var s=r.call(o,"catchLoc"),u=r.call(o,"finallyLoc");if(s&&u){if(this.prev<o.catchLoc)return n(o.catchLoc,!0);if(this.prev<o.finallyLoc)return n(o.finallyLoc)}else if(s){if(this.prev<o.catchLoc)return n(o.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return n(o.finallyLoc)}}}},abrupt:function(t,e){for(var n=this.tryEntries.length-1;n>=0;--n){var i=this.tryEntries[n];if(i.tryLoc<=this.prev&&r.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,c):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),c},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),w(r),c}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var i=n.arg;w(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,r){return this.delegate={iterator:k(t),resultName:e,nextLoc:r},"next"===this.method&&(this.arg=void 0),c}},t}(t.exports);try{regeneratorRuntime=n}catch(t){Function("r","regeneratorRuntime = r")(n)}},function(t,e){"function"==typeof Object.create?t.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:t.exports=function(t,e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},function(t,e){function r(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}t.exports=function(t,e,n){return e&&r(t.prototype,e),n&&r(t,n),t}},function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},function(t,e){var r=Math.ceil,n=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?n:r)(t)}},function(t,e,r){var n=r(71),i=r(60),o=r(27),a=r(15),s=r(112),u=[].push,c=function(t){var e=1==t,r=2==t,c=3==t,f=4==t,l=6==t,h=5==t||l;return function(p,d,v,g){for(var y,b,_=o(p),m=i(_),w=n(d,v,3),x=a(m.length),k=0,E=g||s,S=e?E(p,x):r?E(p,0):void 0;x>k;k++)if((h||k in m)&&(b=w(y=m[k],k,_),t))if(e)S[k]=b;else if(b)switch(t){case 3:return!0;case 5:return y;case 6:return k;case 2:u.call(S,y)}else if(f)return!1;return l?-1:c||f?f:S}};t.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6)}},function(t,e){t.exports={}},function(t,e,r){"use strict";var n=r(2),i=r(53);n({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(t,e,r){"use strict";var n=r(5);t.exports=function(t,e){var r=[][t];return!r||!n((function(){r.call(null,e||function(){throw 1},1)}))}},function(t,e,r){"use strict";var n=r(2),i=r(33).map,o=r(5),a=r(54)("map"),s=a&&!o((function(){[].map.call({length:-1,0:1},(function(t){throw t}))}));n({target:"Array",proto:!0,forced:!a||!s},{map:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},function(t,e){var r,n,i=t.exports={};function o(){throw new Error("setTimeout has not been defined")}function a(){throw new Error("clearTimeout has not been defined")}function s(t){if(r===setTimeout)return setTimeout(t,0);if((r===o||!r)&&setTimeout)return r=setTimeout,setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:o}catch(t){r=o}try{n="function"==typeof clearTimeout?clearTimeout:a}catch(t){n=a}}();var u,c=[],f=!1,l=-1;function h(){f&&u&&(f=!1,u.length?c=u.concat(c):l=-1,c.length&&p())}function p(){if(!f){var t=s(h);f=!0;for(var e=c.length;e;){for(u=c,c=[];++l<e;)u&&u[l].run();l=-1,e=c.length}u=null,f=!1,function(t){if(n===clearTimeout)return clearTimeout(t);if((n===a||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function d(t,e){this.fun=t,this.array=e}function v(){}i.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];c.push(new d(t,e)),1!==c.length||f||s(p)},d.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=v,i.addListener=v,i.once=v,i.off=v,i.removeListener=v,i.removeAllListeners=v,i.emit=v,i.prependListener=v,i.prependOnceListener=v,i.listeners=function(t){return[]},i.binding=function(t){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(t){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(t,e,r){(function(t){function r(t){return Object.prototype.toString.call(t)}e.isArray=function(t){return Array.isArray?Array.isArray(t):"[object Array]"===r(t)},e.isBoolean=function(t){return"boolean"==typeof t},e.isNull=function(t){return null===t},e.isNullOrUndefined=function(t){return null==t},e.isNumber=function(t){return"number"==typeof t},e.isString=function(t){return"string"==typeof t},e.isSymbol=function(t){return"symbol"==typeof t},e.isUndefined=function(t){return void 0===t},e.isRegExp=function(t){return"[object RegExp]"===r(t)},e.isObject=function(t){return"object"==typeof t&&null!==t},e.isDate=function(t){return"[object Date]"===r(t)},e.isError=function(t){return"[object Error]"===r(t)||t instanceof Error},e.isFunction=function(t){return"function"==typeof t},e.isPrimitive=function(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||void 0===t},e.isBuffer=t.isBuffer}).call(this,r(92).Buffer)},function(t,e,r){var n=r(96),i=r(155);t.exports=function(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?i(t):e}},function(t,e,r){var n=r(80);t.exports=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&n(t,e)}},function(t,e,r){var n=r(166),i=r(167),o=r(168);t.exports=function(t,e){return n(t)||i(t,e)||o()}},function(t,e,r){var n=r(10);t.exports=function(t,e){if(!n(t))return t;var r,i;if(e&&"function"==typeof(r=t.toString)&&!n(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!n(i=r.call(t)))return i;if(!e&&"function"==typeof(r=t.toString)&&!n(i=r.call(t)))return i;throw TypeError("Can\'t convert object to primitive value")}},function(t,e,r){var n=r(64),i=r(65),o=n("keys");t.exports=function(t){return o[t]||(o[t]=i(t))}},function(t,e){t.exports={}},function(t,e,r){var n=r(104),i=r(67).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return n(t,i)}},function(t,e,r){var n=r(19);t.exports=Array.isArray||function(t){return"Array"==n(t)}},function(t,e,r){var n=r(104),i=r(67);t.exports=Object.keys||function(t){return n(t,i)}},function(t,e,r){var n=r(11).f,i=r(13),o=r(3)("toStringTag");t.exports=function(t,e,r){t&&!i(t=r?t:t.prototype,o)&&n(t,o,{configurable:!0,value:e})}},function(t,e){t.exports=function(t){if("function"!=typeof t)throw TypeError(String(t)+" is not a function");return t}},function(t,e,r){"use strict";var n=r(12),i=r(113),o=r(34),a=r(24),s=r(114),u=a.set,c=a.getterFor("Array Iterator");t.exports=s(Array,"Array",(function(t,e){u(this,{type:"Array Iterator",target:n(t),index:0,kind:e})}),(function(){var t=c(this),e=t.target,r=t.kind,n=t.index++;return!e||n>=e.length?(t.target=void 0,{value:void 0,done:!0}):"keys"==r?{value:n,done:!1}:"values"==r?{value:e[n],done:!1}:{value:[n,e[n]],done:!1}}),"values"),o.Arguments=o.Array,i("keys"),i("values"),i("entries")},function(t,e,r){var n=r(72),i=r(17),o=r(154);n||i(Object.prototype,"toString",o,{unsafe:!0})},function(t,e,r){"use strict";var n,i,o=r(73),a=r(119),s=RegExp.prototype.exec,u=String.prototype.replace,c=s,f=(n=/a/,i=/b*/g,s.call(n,"a"),s.call(i,"a"),0!==n.lastIndex||0!==i.lastIndex),l=a.UNSUPPORTED_Y||a.BROKEN_CARET,h=void 0!==/()??/.exec("")[1];(f||h||l)&&(c=function(t){var e,r,n,i,a=this,c=l&&a.sticky,p=o.call(a),d=a.source,v=0,g=t;return c&&(-1===(p=p.replace("y","")).indexOf("g")&&(p+="g"),g=String(t).slice(a.lastIndex),a.lastIndex>0&&(!a.multiline||a.multiline&&"\\n"!==t[a.lastIndex-1])&&(d="(?: "+d+")",g=" "+g,v++),r=new RegExp("^(?:"+d+")",p)),h&&(r=new RegExp("^"+d+"$(?!\\\\s)",p)),f&&(e=a.lastIndex),n=s.call(c?r:a,g),c?n?(n.input=n.input.slice(v),n[0]=n[0].slice(v),n.index=a.lastIndex,a.lastIndex+=n[0].length):a.lastIndex=0:f&&n&&(a.lastIndex=a.global?n.index+n[0].length:e),h&&n&&n.length>1&&u.call(n[0],r,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(n[i]=void 0)})),n}),t.exports=c},function(t,e,r){var n=r(5),i=r(3),o=r(83),a=i("species");t.exports=function(t){return o>=51||!n((function(){var e=[];return(e.constructor={})[a]=function(){return{foo:1}},1!==e[t](Boolean).foo}))}},function(t,e,r){"use strict";(function(e){!e.version||0===e.version.indexOf("v0.")||0===e.version.indexOf("v1.")&&0!==e.version.indexOf("v1.8.")?t.exports={nextTick:function(t,r,n,i){if("function"!=typeof t)throw new TypeError(\'"callback" argument must be a function\');var o,a,s=arguments.length;switch(s){case 0:case 1:return e.nextTick(t);case 2:return e.nextTick((function(){t.call(null,r)}));case 3:return e.nextTick((function(){t.call(null,r,n)}));case 4:return e.nextTick((function(){t.call(null,r,n,i)}));default:for(o=new Array(s-1),a=0;a<o.length;)o[a++]=arguments[a];return e.nextTick((function(){t.apply(null,o)}))}}}:t.exports=e}).call(this,r(38))},function(t,e,r){var n=r(92),i=n.Buffer;function o(t,e){for(var r in t)e[r]=t[r]}function a(t,e,r){return i(t,e,r)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?t.exports=n:(o(n,e),e.Buffer=a),o(i,a),a.from=function(t,e,r){if("number"==typeof t)throw new TypeError("Argument must not be a number");return i(t,e,r)},a.alloc=function(t,e,r){if("number"!=typeof t)throw new TypeError("Argument must be a number");var n=i(t);return void 0!==e?"string"==typeof r?n.fill(e,r):n.fill(e):n.fill(0),n},a.allocUnsafe=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return i(t)},a.allocUnsafeSlow=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return n.SlowBuffer(t)}},function(t,e,r){var n=r(156);function i(e,r,o){return"undefined"!=typeof Reflect&&Reflect.get?t.exports=i=Reflect.get:t.exports=i=function(t,e,r){var i=n(t,e);if(i){var o=Object.getOwnPropertyDescriptor(i,e);return o.get?o.get.call(r):o.value}},i(e,r,o||e)}t.exports=i},function(t,e,r){(function(n){e.log=function(...t){return"object"==typeof console&&console.log&&console.log(...t)},e.formatArgs=function(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;e.splice(1,0,r,"color: inherit");let n=0,i=0;e[0].replace(/%[a-zA-Z%]/g,t=>{"%%"!==t&&(n++,"%c"===t&&(i=n))}),e.splice(i,0,r)},e.save=function(t){try{t?e.storage.setItem("debug",t):e.storage.removeItem("debug")}catch(t){}},e.load=function(){let t;try{t=e.storage.getItem("debug")}catch(t){}!t&&void 0!==n&&"env"in n&&(t=n.env.DEBUG);return t},e.useColors=function(){if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/))return!1;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/)},e.storage=function(){try{return localStorage}catch(t){}}(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.exports=r(172)(e);const{formatters:i}=t.exports;i.j=function(t){try{return JSON.stringify(t)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}).call(this,r(38))},function(t,e,r){"use strict";var n={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,o=i&&!n.call({1:2},1);e.f=o?function(t){var e=i(this,t);return!!e&&e.enumerable}:n},function(t,e,r){var n=r(5),i=r(19),o="".split;t.exports=n((function(){return!Object("z").propertyIsEnumerable(0)}))?function(t){return"String"==i(t)?o.call(t,""):Object(t)}:Object},function(t,e,r){var n=r(4),i=r(10),o=n.document,a=i(o)&&i(o.createElement);t.exports=function(t){return a?o.createElement(t):{}}},function(t,e,r){var n=r(4),i=r(14);t.exports=function(t,e){try{i(n,t,e)}catch(r){n[t]=e}return e}},function(t,e,r){var n=r(100),i=Function.toString;"function"!=typeof n.inspectSource&&(n.inspectSource=function(t){return i.call(t)}),t.exports=n.inspectSource},function(t,e,r){var n=r(25),i=r(100);(t.exports=function(t,e){return i[t]||(i[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.6.1",mode:n?"pure":"global",copyright:" 2019 Denis Pushkarev (zloirock.ru)"})},function(t,e){var r=0,n=Math.random();t.exports=function(t){return"Symbol("+String(void 0===t?"":t)+")_"+(++r+n).toString(36)}},function(t,e,r){var n=r(12),i=r(15),o=r(105),a=function(t){return function(e,r,a){var s,u=n(e),c=i(u.length),f=o(a,c);if(t&&r!=r){for(;c>f;)if((s=u[f++])!=s)return!0}else for(;c>f;f++)if((t||f in u)&&u[f]===r)return t||f||0;return!t&&-1}};t.exports={includes:a(!0),indexOf:a(!1)}},function(t,e){t.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(t,e,r){var n=r(5),i=/#|\\.prototype\\./,o=function(t,e){var r=s[a(t)];return r==c||r!=u&&("function"==typeof e?n(e):!!e)},a=o.normalize=function(t){return String(t).replace(i,".").toLowerCase()},s=o.data={},u=o.NATIVE="N",c=o.POLYFILL="P";t.exports=o},function(t,e,r){var n=r(5);t.exports=!!Object.getOwnPropertySymbols&&!n((function(){return!String(Symbol())}))},function(t,e,r){var n,i=r(8),o=r(108),a=r(67),s=r(45),u=r(109),c=r(61),f=r(44),l=f("IE_PROTO"),h=function(){},p=function(t){return"<script>"+t+"<\\/script>"},d=function(){try{n=document.domain&&new ActiveXObject("htmlfile")}catch(t){}var t,e;d=n?function(t){t.write(p("")),t.close();var e=t.parentWindow.Object;return t=null,e}(n):((e=c("iframe")).style.display="none",u.appendChild(e),e.src=String("javascript:"),(t=e.contentWindow.document).open(),t.write(p("document.F=Object")),t.close(),t.F);for(var r=a.length;r--;)delete d.prototype[a[r]];return d()};s[l]=!0,t.exports=Object.create||function(t,e){var r;return null!==t?(h.prototype=i(t),r=new h,h.prototype=null,r[l]=t):r=d(),void 0===e?r:o(r,e)}},function(t,e,r){var n=r(50);t.exports=function(t,e,r){if(n(t),void 0===e)return t;switch(r){case 0:return function(){return t.call(e)};case 1:return function(r){return t.call(e,r)};case 2:return function(r,n){return t.call(e,r,n)};case 3:return function(r,n,i){return t.call(e,r,n,i)}}return function(){return t.apply(e,arguments)}}},function(t,e,r){var n={};n[r(3)("toStringTag")]="z",t.exports="[object z]"===String(n)},function(t,e,r){"use strict";var n=r(8);t.exports=function(){var t=n(this),e="";return t.global&&(e+="g"),t.ignoreCase&&(e+="i"),t.multiline&&(e+="m"),t.dotAll&&(e+="s"),t.unicode&&(e+="u"),t.sticky&&(e+="y"),e}},function(t,e,r){"use strict";var n=r(120).charAt,i=r(24),o=r(114),a=i.set,s=i.getterFor("String Iterator");o(String,"String",(function(t){a(this,{type:"String Iterator",string:String(t),index:0})}),(function(){var t,e=s(this),r=e.string,i=e.index;return i>=r.length?{value:void 0,done:!0}:(t=n(r,i),e.index+=t.length,{value:t,done:!1})}))},function(t,e,r){"use strict";var n=r(76),i=r(8),o=r(15),a=r(20),s=r(77),u=r(78);n("match",1,(function(t,e,r){return[function(e){var r=a(this),n=null==e?void 0:e[t];return void 0!==n?n.call(e,r):new RegExp(e)[t](String(r))},function(t){var n=r(e,t,this);if(n.done)return n.value;var a=i(t),c=String(this);if(!a.global)return u(a,c);var f=a.unicode;a.lastIndex=0;for(var l,h=[],p=0;null!==(l=u(a,c));){var d=String(l[0]);h[p]=d,""===d&&(a.lastIndex=s(c,o(a.lastIndex),f)),p++}return 0===p?null:h}]}))},function(t,e,r){"use strict";var n=r(17),i=r(5),o=r(3),a=r(53),s=r(14),u=o("species"),c=!i((function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")})),f="$0"==="a".replace(/./,"$0"),l=!i((function(){var t=/(?:)/,e=t.exec;t.exec=function(){return e.apply(this,arguments)};var r="ab".split(t);return 2!==r.length||"a"!==r[0]||"b"!==r[1]}));t.exports=function(t,e,r,h){var p=o(t),d=!i((function(){var e={};return e[p]=function(){return 7},7!=""[t](e)})),v=d&&!i((function(){var e=!1,r=/a/;return"split"===t&&((r={}).constructor={},r.constructor[u]=function(){return r},r.flags="",r[p]=/./[p]),r.exec=function(){return e=!0,null},r[p](""),!e}));if(!d||!v||"replace"===t&&(!c||!f)||"split"===t&&!l){var g=/./[p],y=r(p,""[t],(function(t,e,r,n,i){return e.exec===a?d&&!i?{done:!0,value:g.call(e,r,n)}:{done:!0,value:t.call(r,e,n)}:{done:!1}}),{REPLACE_KEEPS_$0:f}),b=y[0],_=y[1];n(String.prototype,t,b),n(RegExp.prototype,p,2==e?function(t,e){return _.call(t,this,e)}:function(t){return _.call(t,this)})}h&&s(RegExp.prototype[p],"sham",!0)}},function(t,e,r){"use strict";var n=r(120).charAt;t.exports=function(t,e,r){return e+(r?n(t,e).length:1)}},function(t,e,r){var n=r(19),i=r(53);t.exports=function(t,e){var r=t.exec;if("function"==typeof r){var o=r.call(t,e);if("object"!=typeof o)throw TypeError("RegExp exec method returned something other than an Object or null");return o}if("RegExp"!==n(t))throw TypeError("RegExp#exec called on incompatible receiver");return i.call(t,e)}},function(t,e,r){var n=r(4),i=r(121),o=r(51),a=r(14),s=r(3),u=s("iterator"),c=s("toStringTag"),f=o.values;for(var l in i){var h=n[l],p=h&&h.prototype;if(p){if(p[u]!==f)try{a(p,u,f)}catch(t){p[u]=f}if(p[c]||a(p,c,l),i[l])for(var d in o)if(p[d]!==o[d])try{a(p,d,o[d])}catch(t){p[d]=o[d]}}}},function(t,e){function r(e,n){return t.exports=r=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},r(e,n)}t.exports=r},function(t,e,r){"use strict";var n=r(2),i=r(5),o=r(47),a=r(10),s=r(27),u=r(15),c=r(82),f=r(112),l=r(54),h=r(3),p=r(83),d=h("isConcatSpreadable"),v=p>=51||!i((function(){var t=[];return t[d]=!1,t.concat()[0]!==t})),g=l("concat"),y=function(t){if(!a(t))return!1;var e=t[d];return void 0!==e?!!e:o(t)};n({target:"Array",proto:!0,forced:!v||!g},{concat:function(t){var e,r,n,i,o,a=s(this),l=f(a,0),h=0;for(e=-1,n=arguments.length;e<n;e++)if(o=-1===e?a:arguments[e],y(o)){if(h+(i=u(o.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(r=0;r<i;r++,h++)r in o&&c(l,h,o[r])}else{if(h>=9007199254740991)throw TypeError("Maximum allowed index exceeded");c(l,h++,o)}return l.length=h,l}})},function(t,e,r){"use strict";var n=r(43),i=r(11),o=r(31);t.exports=function(t,e,r){var a=n(e);a in t?i.f(t,a,o(0,r)):t[a]=r}},function(t,e,r){var n,i,o=r(4),a=r(122),s=o.process,u=s&&s.versions,c=u&&u.v8;c?i=(n=c.split("."))[0]+n[1]:a&&(!(n=a.match(/Edge\\/(\\d+)/))||n[1]>=74)&&(n=a.match(/Chrome\\/(\\d+)/))&&(i=n[1]),t.exports=i&&+i},function(t,e,r){"use strict";var n=r(2),i=r(33).filter,o=r(5),a=r(54)("filter"),s=a&&!o((function(){[].filter.call({length:-1,0:1},(function(t){throw t}))}));n({target:"Array",proto:!0,forced:!a||!s},{filter:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},function(t,e,r){"use strict";var n=r(2),i=r(123);n({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(t,e,r){"use strict";var n=r(2),i=r(66).includes,o=r(113);n({target:"Array",proto:!0},{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(t,e,r){var n=r(7),i=r(11).f,o=Function.prototype,a=o.toString,s=/^\\s*function ([^ (]*)/;n&&!("name"in o)&&i(o,"name",{configurable:!0,get:function(){try{return a.call(this).match(s)[1]}catch(t){return""}}})},function(t,e,r){var n=r(10),i=r(19),o=r(3)("match");t.exports=function(t){var e;return n(t)&&(void 0!==(e=t[o])?!!e:"RegExp"==i(t))}},function(t,e,r){"use strict";var n=r(76),i=r(8),o=r(27),a=r(15),s=r(32),u=r(20),c=r(77),f=r(78),l=Math.max,h=Math.min,p=Math.floor,d=/\\$([$&\'`]|\\d\\d?|<[^>]*>)/g,v=/\\$([$&\'`]|\\d\\d?)/g;n("replace",2,(function(t,e,r,n){return[function(r,n){var i=u(this),o=null==r?void 0:r[t];return void 0!==o?o.call(r,i,n):e.call(String(i),r,n)},function(t,o){if(n.REPLACE_KEEPS_$0||"string"==typeof o&&-1===o.indexOf("$0")){var u=r(e,t,this,o);if(u.done)return u.value}var p=i(t),d=String(this),v="function"==typeof o;v||(o=String(o));var y=p.global;if(y){var b=p.unicode;p.lastIndex=0}for(var _=[];;){var m=f(p,d);if(null===m)break;if(_.push(m),!y)break;""===String(m[0])&&(p.lastIndex=c(d,a(p.lastIndex),b))}for(var w,x="",k=0,E=0;E<_.length;E++){m=_[E];for(var S=String(m[0]),j=l(h(s(m.index),d.length),0),R=[],C=1;C<m.length;C++)R.push(void 0===(w=m[C])?w:String(w));var I=m.groups;if(v){var O=[S].concat(R,j,d);void 0!==I&&O.push(I);var T=String(o.apply(void 0,O))}else T=g(S,d,j,R,I,o);j>=k&&(x+=d.slice(k,j)+T,k=j+S.length)}return x+d.slice(k)}];function g(t,r,n,i,a,s){var u=n+t.length,c=i.length,f=v;return void 0!==a&&(a=o(a),f=d),e.call(s,f,(function(e,o){var s;switch(o.charAt(0)){case"$":return"$";case"&":return t;case"`":return r.slice(0,n);case"\'":return r.slice(u);case"<":s=a[o.slice(1,-1)];break;default:var f=+o;if(0===f)return e;if(f>c){var l=p(f/10);return 0===l?e:l<=c?void 0===i[l-1]?o.charAt(1):i[l-1]+o.charAt(1):e}s=i[f-1]}return void 0===s?"":s}))}}))},function(t,e,r){var n=r(4),i=r(121),o=r(123),a=r(14);for(var s in i){var u=n[s],c=u&&u.prototype;if(c&&c.forEach!==o)try{a(c,"forEach",o)}catch(t){c.forEach=o}}},function(t,e,r){"use strict";var n,i,o,a,s=r(2),u=r(25),c=r(4),f=r(26),l=r(177),h=r(17),p=r(178),d=r(49),v=r(125),g=r(10),y=r(50),b=r(179),_=r(19),m=r(63),w=r(180),x=r(184),k=r(132),E=r(133).set,S=r(185),j=r(186),R=r(187),C=r(135),I=r(188),O=r(24),T=r(68),P=r(3),A=r(83),L=P("species"),F="Promise",M=O.get,N=O.set,B=O.getterFor(F),D=l,U=c.TypeError,q=c.document,G=c.process,W=f("fetch"),z=C.f,Y=z,Q="process"==_(G),$=!!(q&&q.createEvent&&c.dispatchEvent),H=T(F,(function(){if(!(m(D)!==String(D))){if(66===A)return!0;if(!Q&&"function"!=typeof PromiseRejectionEvent)return!0}if(u&&!D.prototype.finally)return!0;if(A>=51&&/native code/.test(D))return!1;var t=D.resolve(1),e=function(t){t((function(){}),(function(){}))};return(t.constructor={})[L]=e,!(t.then((function(){}))instanceof e)})),K=H||!x((function(t){D.all(t).catch((function(){}))})),V=function(t){var e;return!(!g(t)||"function"!=typeof(e=t.then))&&e},Z=function(t,e,r){if(!e.notified){e.notified=!0;var n=e.reactions;S((function(){for(var i=e.value,o=1==e.state,a=0;n.length>a;){var s,u,c,f=n[a++],l=o?f.ok:f.fail,h=f.resolve,p=f.reject,d=f.domain;try{l?(o||(2===e.rejection&&et(t,e),e.rejection=1),!0===l?s=i:(d&&d.enter(),s=l(i),d&&(d.exit(),c=!0)),s===f.promise?p(U("Promise-chain cycle")):(u=V(s))?u.call(s,h,p):h(s)):p(i)}catch(t){d&&!c&&d.exit(),p(t)}}e.reactions=[],e.notified=!1,r&&!e.rejection&&X(t,e)}))}},J=function(t,e,r){var n,i;$?((n=q.createEvent("Event")).promise=e,n.reason=r,n.initEvent(t,!1,!0),c.dispatchEvent(n)):n={promise:e,reason:r},(i=c["on"+t])?i(n):"unhandledrejection"===t&&R("Unhandled promise rejection",r)},X=function(t,e){E.call(c,(function(){var r,n=e.value;if(tt(e)&&(r=I((function(){Q?G.emit("unhandledRejection",n,t):J("unhandledrejection",t,n)})),e.rejection=Q||tt(e)?2:1,r.error))throw r.value}))},tt=function(t){return 1!==t.rejection&&!t.parent},et=function(t,e){E.call(c,(function(){Q?G.emit("rejectionHandled",t):J("rejectionhandled",t,e.value)}))},rt=function(t,e,r,n){return function(i){t(e,r,i,n)}},nt=function(t,e,r,n){e.done||(e.done=!0,n&&(e=n),e.value=r,e.state=2,Z(t,e,!0))},it=function(t,e,r,n){if(!e.done){e.done=!0,n&&(e=n);try{if(t===r)throw U("Promise can\'t be resolved itself");var i=V(r);i?S((function(){var n={done:!1};try{i.call(r,rt(it,t,n,e),rt(nt,t,n,e))}catch(r){nt(t,n,r,e)}})):(e.value=r,e.state=1,Z(t,e,!1))}catch(r){nt(t,{done:!1},r,e)}}};H&&(D=function(t){b(this,D,F),y(t),n.call(this);var e=M(this);try{t(rt(it,this,e),rt(nt,this,e))}catch(t){nt(this,e,t)}},(n=function(t){N(this,{type:F,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=p(D.prototype,{then:function(t,e){var r=B(this),n=z(k(this,D));return n.ok="function"!=typeof t||t,n.fail="function"==typeof e&&e,n.domain=Q?G.domain:void 0,r.parent=!0,r.reactions.push(n),0!=r.state&&Z(this,r,!1),n.promise},catch:function(t){return this.then(void 0,t)}}),i=function(){var t=new n,e=M(t);this.promise=t,this.resolve=rt(it,t,e),this.reject=rt(nt,t,e)},C.f=z=function(t){return t===D||t===o?new i(t):Y(t)},u||"function"!=typeof l||(a=l.prototype.then,h(l.prototype,"then",(function(t,e){var r=this;return new D((function(t,e){a.call(r,t,e)})).then(t,e)}),{unsafe:!0}),"function"==typeof W&&s({global:!0,enumerable:!0,forced:!0},{fetch:function(t){return j(D,W.apply(c,arguments))}}))),s({global:!0,wrap:!0,forced:H},{Promise:D}),d(D,F,!1,!0),v(F),o=f(F),s({target:F,stat:!0,forced:H},{reject:function(t){var e=z(this);return e.reject.call(void 0,t),e.promise}}),s({target:F,stat:!0,forced:u||H},{resolve:function(t){return j(u&&this===o?D:this,t)}}),s({target:F,stat:!0,forced:K},{all:function(t){var e=this,r=z(e),n=r.resolve,i=r.reject,o=I((function(){var r=y(e.resolve),o=[],a=0,s=1;w(t,(function(t){var u=a++,c=!1;o.push(void 0),s++,r.call(e,t).then((function(t){c||(c=!0,o[u]=t,--s||n(o))}),i)})),--s||n(o)}));return o.error&&i(o.value),r.promise},race:function(t){var e=this,r=z(e),n=r.reject,i=I((function(){var i=y(e.resolve);w(t,(function(t){i.call(e,t).then(r.resolve,n)}))}));return i.error&&n(i.value),r.promise}})},function(t,e,r){"use strict";(function(t){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\nvar n=r(190),i=r(191),o=r(137);function a(){return u.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function s(t,e){if(a()<e)throw new RangeError("Invalid typed array length");return u.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=u.prototype:(null===t&&(t=new u(e)),t.length=e),t}function u(t,e,r){if(!(u.TYPED_ARRAY_SUPPORT||this instanceof u))return new u(t,e,r);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return l(this,t)}return c(this,t,e,r)}function c(t,e,r,n){if("number"==typeof e)throw new TypeError(\'"value" argument must not be a number\');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,r,n){if(e.byteLength,r<0||e.byteLength<r)throw new RangeError("\'offset\' is out of bounds");if(e.byteLength<r+(n||0))throw new RangeError("\'length\' is out of bounds");e=void 0===r&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,r):new Uint8Array(e,r,n);u.TYPED_ARRAY_SUPPORT?(t=e).__proto__=u.prototype:t=h(t,e);return t}(t,e,r,n):"string"==typeof e?function(t,e,r){"string"==typeof r&&""!==r||(r="utf8");if(!u.isEncoding(r))throw new TypeError(\'"encoding" must be a valid string encoding\');var n=0|d(e,r),i=(t=s(t,n)).write(e,r);i!==n&&(t=t.slice(0,i));return t}(t,e,r):function(t,e){if(u.isBuffer(e)){var r=0|p(e.length);return 0===(t=s(t,r)).length||e.copy(t,0,0,r),t}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||(n=e.length)!=n?s(t,0):h(t,e);if("Buffer"===e.type&&o(e.data))return h(t,e.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function f(t){if("number"!=typeof t)throw new TypeError(\'"size" argument must be a number\');if(t<0)throw new RangeError(\'"size" argument must not be negative\')}function l(t,e){if(f(e),t=s(t,e<0?0:0|p(e)),!u.TYPED_ARRAY_SUPPORT)for(var r=0;r<e;++r)t[r]=0;return t}function h(t,e){var r=e.length<0?0:0|p(e.length);t=s(t,r);for(var n=0;n<r;n+=1)t[n]=255&e[n];return t}function p(t){if(t>=a())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+a().toString(16)+" bytes");return 0|t}function d(t,e){if(u.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var r=t.length;if(0===r)return 0;for(var n=!1;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return U(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return q(t).length;default:if(n)return U(t).length;e=(""+e).toLowerCase(),n=!0}}function v(t,e,r){var n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return I(this,e,r);case"utf8":case"utf-8":return j(this,e,r);case"ascii":return R(this,e,r);case"latin1":case"binary":return C(this,e,r);case"base64":return S(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,e,r);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function g(t,e,r){var n=t[e];t[e]=t[r],t[r]=n}function y(t,e,r,n,i){if(0===t.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(i)return-1;r=t.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof e&&(e=u.from(e,n)),u.isBuffer(e))return 0===e.length?-1:b(t,e,r,n,i);if("number"==typeof e)return e&=255,u.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):b(t,[e],r,n,i);throw new TypeError("val must be string, number or Buffer")}function b(t,e,r,n,i){var o,a=1,s=t.length,u=e.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||e.length<2)return-1;a=2,s/=2,u/=2,r/=2}function c(t,e){return 1===a?t[e]:t.readUInt16BE(e*a)}if(i){var f=-1;for(o=r;o<s;o++)if(c(t,o)===c(e,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===u)return f*a}else-1!==f&&(o-=o-f),f=-1}else for(r+u>s&&(r=s-u),o=r;o>=0;o--){for(var l=!0,h=0;h<u;h++)if(c(t,o+h)!==c(e,h)){l=!1;break}if(l)return o}return-1}function _(t,e,r,n){r=Number(r)||0;var i=t.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=e.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var a=0;a<n;++a){var s=parseInt(e.substr(2*a,2),16);if(isNaN(s))return a;t[r+a]=s}return a}function m(t,e,r,n){return G(U(e,t.length-r),t,r,n)}function w(t,e,r,n){return G(function(t){for(var e=[],r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,n)}function x(t,e,r,n){return w(t,e,r,n)}function k(t,e,r,n){return G(q(e),t,r,n)}function E(t,e,r,n){return G(function(t,e){for(var r,n,i,o=[],a=0;a<t.length&&!((e-=2)<0);++a)r=t.charCodeAt(a),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(e,t.length-r),t,r,n)}function S(t,e,r){return 0===e&&r===t.length?n.fromByteArray(t):n.fromByteArray(t.slice(e,r))}function j(t,e,r){r=Math.min(t.length,r);for(var n=[],i=e;i<r;){var o,a,s,u,c=t[i],f=null,l=c>239?4:c>223?3:c>191?2:1;if(i+l<=r)switch(l){case 1:c<128&&(f=c);break;case 2:128==(192&(o=t[i+1]))&&(u=(31&c)<<6|63&o)>127&&(f=u);break;case 3:o=t[i+1],a=t[i+2],128==(192&o)&&128==(192&a)&&(u=(15&c)<<12|(63&o)<<6|63&a)>2047&&(u<55296||u>57343)&&(f=u);break;case 4:o=t[i+1],a=t[i+2],s=t[i+3],128==(192&o)&&128==(192&a)&&128==(192&s)&&(u=(15&c)<<18|(63&o)<<12|(63&a)<<6|63&s)>65535&&u<1114112&&(f=u)}null===f?(f=65533,l=1):f>65535&&(f-=65536,n.push(f>>>10&1023|55296),f=56320|1023&f),n.push(f),i+=l}return function(t){var e=t.length;if(e<=4096)return String.fromCharCode.apply(String,t);var r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=4096));return r}(n)}e.Buffer=u,e.SlowBuffer=function(t){+t!=t&&(t=0);return u.alloc(+t)},e.INSPECT_MAX_BYTES=50,u.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}(),e.kMaxLength=a(),u.poolSize=8192,u._augment=function(t){return t.__proto__=u.prototype,t},u.from=function(t,e,r){return c(null,t,e,r)},u.TYPED_ARRAY_SUPPORT&&(u.prototype.__proto__=Uint8Array.prototype,u.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&u[Symbol.species]===u&&Object.defineProperty(u,Symbol.species,{value:null,configurable:!0})),u.alloc=function(t,e,r){return function(t,e,r,n){return f(e),e<=0?s(t,e):void 0!==r?"string"==typeof n?s(t,e).fill(r,n):s(t,e).fill(r):s(t,e)}(null,t,e,r)},u.allocUnsafe=function(t){return l(null,t)},u.allocUnsafeSlow=function(t){return l(null,t)},u.isBuffer=function(t){return!(null==t||!t._isBuffer)},u.compare=function(t,e){if(!u.isBuffer(t)||!u.isBuffer(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var r=t.length,n=e.length,i=0,o=Math.min(r,n);i<o;++i)if(t[i]!==e[i]){r=t[i],n=e[i];break}return r<n?-1:n<r?1:0},u.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(t,e){if(!o(t))throw new TypeError(\'"list" argument must be an Array of Buffers\');if(0===t.length)return u.alloc(0);var r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var n=u.allocUnsafe(e),i=0;for(r=0;r<t.length;++r){var a=t[r];if(!u.isBuffer(a))throw new TypeError(\'"list" argument must be an Array of Buffers\');a.copy(n,i),i+=a.length}return n},u.byteLength=d,u.prototype._isBuffer=!0,u.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)g(this,e,e+1);return this},u.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)g(this,e,e+3),g(this,e+1,e+2);return this},u.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)g(this,e,e+7),g(this,e+1,e+6),g(this,e+2,e+5),g(this,e+3,e+4);return this},u.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?j(this,0,t):v.apply(this,arguments)},u.prototype.equals=function(t){if(!u.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===u.compare(this,t)},u.prototype.inspect=function(){var t="",r=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(t+=" ... ")),"<Buffer "+t+">"},u.prototype.compare=function(t,e,r,n,i){if(!u.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),e<0||r>t.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&e>=r)return 0;if(n>=i)return-1;if(e>=r)return 1;if(this===t)return 0;for(var o=(i>>>=0)-(n>>>=0),a=(r>>>=0)-(e>>>=0),s=Math.min(o,a),c=this.slice(n,i),f=t.slice(e,r),l=0;l<s;++l)if(c[l]!==f[l]){o=c[l],a=f[l];break}return o<a?-1:a<o?1:0},u.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},u.prototype.indexOf=function(t,e,r){return y(this,t,e,r,!0)},u.prototype.lastIndexOf=function(t,e,r){return y(this,t,e,r,!1)},u.prototype.write=function(t,e,r,n){if(void 0===e)n="utf8",r=this.length,e=0;else if(void 0===r&&"string"==typeof e)n=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-e;if((void 0===r||r>i)&&(r=i),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return _(this,t,e,r);case"utf8":case"utf-8":return m(this,t,e,r);case"ascii":return w(this,t,e,r);case"latin1":case"binary":return x(this,t,e,r);case"base64":return k(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,t,e,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function R(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;i<r;++i)n+=String.fromCharCode(127&t[i]);return n}function C(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;i<r;++i)n+=String.fromCharCode(t[i]);return n}function I(t,e,r){var n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);for(var i="",o=e;o<r;++o)i+=D(t[o]);return i}function O(t,e,r){for(var n=t.slice(e,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function T(t,e,r){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function P(t,e,r,n,i,o){if(!u.isBuffer(t))throw new TypeError(\'"buffer" argument must be a Buffer instance\');if(e>i||e<o)throw new RangeError(\'"value" argument is out of bounds\');if(r+n>t.length)throw new RangeError("Index out of range")}function A(t,e,r,n){e<0&&(e=65535+e+1);for(var i=0,o=Math.min(t.length-r,2);i<o;++i)t[r+i]=(e&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function L(t,e,r,n){e<0&&(e=4294967295+e+1);for(var i=0,o=Math.min(t.length-r,4);i<o;++i)t[r+i]=e>>>8*(n?i:3-i)&255}function F(t,e,r,n,i,o){if(r+n>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function M(t,e,r,n,o){return o||F(t,0,r,4),i.write(t,e,r,n,23,4),r+4}function N(t,e,r,n,o){return o||F(t,0,r,8),i.write(t,e,r,n,52,8),r+8}u.prototype.slice=function(t,e){var r,n=this.length;if((t=~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),(e=void 0===e?n:~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),e<t&&(e=t),u.TYPED_ARRAY_SUPPORT)(r=this.subarray(t,e)).__proto__=u.prototype;else{var i=e-t;r=new u(i,void 0);for(var o=0;o<i;++o)r[o]=this[o+t]}return r},u.prototype.readUIntLE=function(t,e,r){t|=0,e|=0,r||T(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return n},u.prototype.readUIntBE=function(t,e,r){t|=0,e|=0,r||T(t,e,this.length);for(var n=this[t+--e],i=1;e>0&&(i*=256);)n+=this[t+--e]*i;return n},u.prototype.readUInt8=function(t,e){return e||T(t,1,this.length),this[t]},u.prototype.readUInt16LE=function(t,e){return e||T(t,2,this.length),this[t]|this[t+1]<<8},u.prototype.readUInt16BE=function(t,e){return e||T(t,2,this.length),this[t]<<8|this[t+1]},u.prototype.readUInt32LE=function(t,e){return e||T(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},u.prototype.readUInt32BE=function(t,e){return e||T(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},u.prototype.readIntLE=function(t,e,r){t|=0,e|=0,r||T(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*e)),n},u.prototype.readIntBE=function(t,e,r){t|=0,e|=0,r||T(t,e,this.length);for(var n=e,i=1,o=this[t+--n];n>0&&(i*=256);)o+=this[t+--n]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*e)),o},u.prototype.readInt8=function(t,e){return e||T(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},u.prototype.readInt16LE=function(t,e){e||T(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt16BE=function(t,e){e||T(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt32LE=function(t,e){return e||T(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},u.prototype.readInt32BE=function(t,e){return e||T(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},u.prototype.readFloatLE=function(t,e){return e||T(t,4,this.length),i.read(this,t,!0,23,4)},u.prototype.readFloatBE=function(t,e){return e||T(t,4,this.length),i.read(this,t,!1,23,4)},u.prototype.readDoubleLE=function(t,e){return e||T(t,8,this.length),i.read(this,t,!0,52,8)},u.prototype.readDoubleBE=function(t,e){return e||T(t,8,this.length),i.read(this,t,!1,52,8)},u.prototype.writeUIntLE=function(t,e,r,n){(t=+t,e|=0,r|=0,n)||P(this,t,e,r,Math.pow(2,8*r)-1,0);var i=1,o=0;for(this[e]=255&t;++o<r&&(i*=256);)this[e+o]=t/i&255;return e+r},u.prototype.writeUIntBE=function(t,e,r,n){(t=+t,e|=0,r|=0,n)||P(this,t,e,r,Math.pow(2,8*r)-1,0);var i=r-1,o=1;for(this[e+i]=255&t;--i>=0&&(o*=256);)this[e+i]=t/o&255;return e+r},u.prototype.writeUInt8=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,1,255,0),u.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},u.prototype.writeUInt16LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):A(this,t,e,!0),e+2},u.prototype.writeUInt16BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):A(this,t,e,!1),e+2},u.prototype.writeUInt32LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):L(this,t,e,!0),e+4},u.prototype.writeUInt32BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):L(this,t,e,!1),e+4},u.prototype.writeIntLE=function(t,e,r,n){if(t=+t,e|=0,!n){var i=Math.pow(2,8*r-1);P(this,t,e,r,i-1,-i)}var o=0,a=1,s=0;for(this[e]=255&t;++o<r&&(a*=256);)t<0&&0===s&&0!==this[e+o-1]&&(s=1),this[e+o]=(t/a>>0)-s&255;return e+r},u.prototype.writeIntBE=function(t,e,r,n){if(t=+t,e|=0,!n){var i=Math.pow(2,8*r-1);P(this,t,e,r,i-1,-i)}var o=r-1,a=1,s=0;for(this[e+o]=255&t;--o>=0&&(a*=256);)t<0&&0===s&&0!==this[e+o+1]&&(s=1),this[e+o]=(t/a>>0)-s&255;return e+r},u.prototype.writeInt8=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,1,127,-128),u.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},u.prototype.writeInt16LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):A(this,t,e,!0),e+2},u.prototype.writeInt16BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):A(this,t,e,!1),e+2},u.prototype.writeInt32LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,2147483647,-2147483648),u.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):L(this,t,e,!0),e+4},u.prototype.writeInt32BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):L(this,t,e,!1),e+4},u.prototype.writeFloatLE=function(t,e,r){return M(this,t,e,!0,r)},u.prototype.writeFloatBE=function(t,e,r){return M(this,t,e,!1,r)},u.prototype.writeDoubleLE=function(t,e,r){return N(this,t,e,!0,r)},u.prototype.writeDoubleBE=function(t,e,r){return N(this,t,e,!1,r)},u.prototype.copy=function(t,e,r,n){if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);var i,o=n-r;if(this===t&&r<e&&e<n)for(i=o-1;i>=0;--i)t[i+e]=this[i+r];else if(o<1e3||!u.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)t[i+e]=this[i+r];else Uint8Array.prototype.set.call(t,this.subarray(r,r+o),e);return o},u.prototype.fill=function(t,e,r,n){if("string"==typeof t){if("string"==typeof e?(n=e,e=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===t.length){var i=t.charCodeAt(0);i<256&&(t=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!u.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<r)throw new RangeError("Out of range index");if(r<=e)return this;var o;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),"number"==typeof t)for(o=e;o<r;++o)this[o]=t;else{var a=u.isBuffer(t)?t:U(new u(t,n).toString()),s=a.length;for(o=0;o<r-e;++o)this[o+e]=a[o%s]}return this};var B=/[^+\\/0-9A-Za-z-_]/g;function D(t){return t<16?"0"+t.toString(16):t.toString(16)}function U(t,e){var r;e=e||1/0;for(var n=t.length,i=null,o=[],a=0;a<n;++a){if((r=t.charCodeAt(a))>55295&&r<57344){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(a+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((e-=1)<0)break;o.push(r)}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function q(t){return n.toByteArray(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\\s+|\\s+$/g,"")}(t).replace(B,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function G(t,e,r,n){for(var i=0;i<n&&!(i+r>=e.length||i>=t.length);++i)e[i+r]=t[i];return i}}).call(this,r(21))},function(t,e,r){"use strict";var n,i="object"==typeof Reflect?Reflect:null,o=i&&"function"==typeof i.apply?i.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};n=i&&"function"==typeof i.ownKeys?i.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var a=Number.isNaN||function(t){return t!=t};function s(){s.init.call(this)}t.exports=s,s.EventEmitter=s,s.prototype._events=void 0,s.prototype._eventsCount=0,s.prototype._maxListeners=void 0;var u=10;function c(t){if("function"!=typeof t)throw new TypeError(\'The "listener" argument must be of type Function. Received type \'+typeof t)}function f(t){return void 0===t._maxListeners?s.defaultMaxListeners:t._maxListeners}function l(t,e,r,n){var i,o,a,s;if(c(r),void 0===(o=t._events)?(o=t._events=Object.create(null),t._eventsCount=0):(void 0!==o.newListener&&(t.emit("newListener",e,r.listener?r.listener:r),o=t._events),a=o[e]),void 0===a)a=o[e]=r,++t._eventsCount;else if("function"==typeof a?a=o[e]=n?[r,a]:[a,r]:n?a.unshift(r):a.push(r),(i=f(t))>0&&a.length>i&&!a.warned){a.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=t,u.type=e,u.count=a.length,s=u,console&&console.warn&&console.warn(s)}return t}function h(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function p(t,e,r){var n={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},i=h.bind(n);return i.listener=r,n.wrapFn=i,i}function d(t,e,r){var n=t._events;if(void 0===n)return[];var i=n[e];return void 0===i?[]:"function"==typeof i?r?[i.listener||i]:[i]:r?function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(i):g(i,i.length)}function v(t){var e=this._events;if(void 0!==e){var r=e[t];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function g(t,e){for(var r=new Array(e),n=0;n<e;++n)r[n]=t[n];return r}Object.defineProperty(s,"defaultMaxListeners",{enumerable:!0,get:function(){return u},set:function(t){if("number"!=typeof t||t<0||a(t))throw new RangeError(\'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received \'+t+".");u=t}}),s.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},s.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||a(t))throw new RangeError(\'The value of "n" is out of range. It must be a non-negative number. Received \'+t+".");return this._maxListeners=t,this},s.prototype.getMaxListeners=function(){return f(this)},s.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var n="error"===t,i=this._events;if(void 0!==i)n=n&&void 0===i.error;else if(!n)return!1;if(n){var a;if(e.length>0&&(a=e[0]),a instanceof Error)throw a;var s=new Error("Unhandled error."+(a?" ("+a.message+")":""));throw s.context=a,s}var u=i[t];if(void 0===u)return!1;if("function"==typeof u)o(u,this,e);else{var c=u.length,f=g(u,c);for(r=0;r<c;++r)o(f[r],this,e)}return!0},s.prototype.addListener=function(t,e){return l(this,t,e,!1)},s.prototype.on=s.prototype.addListener,s.prototype.prependListener=function(t,e){return l(this,t,e,!0)},s.prototype.once=function(t,e){return c(e),this.on(t,p(this,t,e)),this},s.prototype.prependOnceListener=function(t,e){return c(e),this.prependListener(t,p(this,t,e)),this},s.prototype.removeListener=function(t,e){var r,n,i,o,a;if(c(e),void 0===(n=this._events))return this;if(void 0===(r=n[t]))return this;if(r===e||r.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete n[t],n.removeListener&&this.emit("removeListener",t,r.listener||e));else if("function"!=typeof r){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===e||r[o].listener===e){a=r[o].listener,i=o;break}if(i<0)return this;0===i?r.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(r,i),1===r.length&&(n[t]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",t,a||e)}return this},s.prototype.off=s.prototype.removeListener,s.prototype.removeAllListeners=function(t){var e,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[t]),this;if(0===arguments.length){var i,o=Object.keys(r);for(n=0;n<o.length;++n)"removeListener"!==(i=o[n])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=r[t]))this.removeListener(t,e);else if(void 0!==e)for(n=e.length-1;n>=0;n--)this.removeListener(t,e[n]);return this},s.prototype.listeners=function(t){return d(this,t,!0)},s.prototype.rawListeners=function(t){return d(this,t,!1)},s.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):v.call(t,e)},s.prototype.listenerCount=v,s.prototype.eventNames=function(){return this._eventsCount>0?n(this._events):[]}},function(t,e,r){(e=t.exports=r(138)).Stream=e,e.Readable=e,e.Writable=r(95),e.Duplex=r(23),e.Transform=r(142),e.PassThrough=r(196)},function(t,e,r){"use strict";(function(e,n,i){var o=r(55);function a(t){var e=this;this.next=null,this.entry=null,this.finish=function(){!function(t,e,r){var n=t.entry;t.entry=null;for(;n;){var i=n.callback;e.pendingcb--,i(r),n=n.next}e.corkedRequestsFree?e.corkedRequestsFree.next=t:e.corkedRequestsFree=t}(e,t)}}t.exports=b;var s,u=!e.browser&&["v0.10","v0.9."].indexOf(e.version.slice(0,5))>-1?n:o.nextTick;b.WritableState=y;var c=r(39);c.inherits=r(29);var f={deprecate:r(195)},l=r(139),h=r(56).Buffer,p=i.Uint8Array||function(){};var d,v=r(140);function g(){}function y(t,e){s=s||r(23),t=t||{};var n=e instanceof s;this.objectMode=!!t.objectMode,n&&(this.objectMode=this.objectMode||!!t.writableObjectMode);var i=t.highWaterMark,c=t.writableHighWaterMark,f=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:n&&(c||0===c)?c:f,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var l=!1===t.decodeStrings;this.decodeStrings=!l,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(t){!function(t,e){var r=t._writableState,n=r.sync,i=r.writecb;if(function(t){t.writing=!1,t.writecb=null,t.length-=t.writelen,t.writelen=0}(r),e)!function(t,e,r,n,i){--e.pendingcb,r?(o.nextTick(i,n),o.nextTick(E,t,e),t._writableState.errorEmitted=!0,t.emit("error",n)):(i(n),t._writableState.errorEmitted=!0,t.emit("error",n),E(t,e))}(t,r,n,e,i);else{var a=x(r);a||r.corked||r.bufferProcessing||!r.bufferedRequest||w(t,r),n?u(m,t,r,a,i):m(t,r,a,i)}}(e,t)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new a(this)}function b(t){if(s=s||r(23),!(d.call(b,this)||this instanceof s))return new b(t);this._writableState=new y(t,this),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final)),l.call(this)}function _(t,e,r,n,i,o,a){e.writelen=n,e.writecb=a,e.writing=!0,e.sync=!0,r?t._writev(i,e.onwrite):t._write(i,o,e.onwrite),e.sync=!1}function m(t,e,r,n){r||function(t,e){0===e.length&&e.needDrain&&(e.needDrain=!1,t.emit("drain"))}(t,e),e.pendingcb--,n(),E(t,e)}function w(t,e){e.bufferProcessing=!0;var r=e.bufferedRequest;if(t._writev&&r&&r.next){var n=e.bufferedRequestCount,i=new Array(n),o=e.corkedRequestsFree;o.entry=r;for(var s=0,u=!0;r;)i[s]=r,r.isBuf||(u=!1),r=r.next,s+=1;i.allBuffers=u,_(t,e,!0,e.length,i,"",o.finish),e.pendingcb++,e.lastBufferedRequest=null,o.next?(e.corkedRequestsFree=o.next,o.next=null):e.corkedRequestsFree=new a(e),e.bufferedRequestCount=0}else{for(;r;){var c=r.chunk,f=r.encoding,l=r.callback;if(_(t,e,!1,e.objectMode?1:c.length,c,f,l),r=r.next,e.bufferedRequestCount--,e.writing)break}null===r&&(e.lastBufferedRequest=null)}e.bufferedRequest=r,e.bufferProcessing=!1}function x(t){return t.ending&&0===t.length&&null===t.bufferedRequest&&!t.finished&&!t.writing}function k(t,e){t._final((function(r){e.pendingcb--,r&&t.emit("error",r),e.prefinished=!0,t.emit("prefinish"),E(t,e)}))}function E(t,e){var r=x(e);return r&&(!function(t,e){e.prefinished||e.finalCalled||("function"==typeof t._final?(e.pendingcb++,e.finalCalled=!0,o.nextTick(k,t,e)):(e.prefinished=!0,t.emit("prefinish")))}(t,e),0===e.pendingcb&&(e.finished=!0,t.emit("finish"))),r}c.inherits(b,l),y.prototype.getBuffer=function(){for(var t=this.bufferedRequest,e=[];t;)e.push(t),t=t.next;return e},function(){try{Object.defineProperty(y.prototype,"buffer",{get:f.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(t){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(d=Function.prototype[Symbol.hasInstance],Object.defineProperty(b,Symbol.hasInstance,{value:function(t){return!!d.call(this,t)||this===b&&(t&&t._writableState instanceof y)}})):d=function(t){return t instanceof this},b.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},b.prototype.write=function(t,e,r){var n,i=this._writableState,a=!1,s=!i.objectMode&&(n=t,h.isBuffer(n)||n instanceof p);return s&&!h.isBuffer(t)&&(t=function(t){return h.from(t)}(t)),"function"==typeof e&&(r=e,e=null),s?e="buffer":e||(e=i.defaultEncoding),"function"!=typeof r&&(r=g),i.ended?function(t,e){var r=new Error("write after end");t.emit("error",r),o.nextTick(e,r)}(this,r):(s||function(t,e,r,n){var i=!0,a=!1;return null===r?a=new TypeError("May not write null values to stream"):"string"==typeof r||void 0===r||e.objectMode||(a=new TypeError("Invalid non-string/buffer chunk")),a&&(t.emit("error",a),o.nextTick(n,a),i=!1),i}(this,i,t,r))&&(i.pendingcb++,a=function(t,e,r,n,i,o){if(!r){var a=function(t,e,r){t.objectMode||!1===t.decodeStrings||"string"!=typeof e||(e=h.from(e,r));return e}(e,n,i);n!==a&&(r=!0,i="buffer",n=a)}var s=e.objectMode?1:n.length;e.length+=s;var u=e.length<e.highWaterMark;u||(e.needDrain=!0);if(e.writing||e.corked){var c=e.lastBufferedRequest;e.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:o,next:null},c?c.next=e.lastBufferedRequest:e.bufferedRequest=e.lastBufferedRequest,e.bufferedRequestCount+=1}else _(t,e,!1,s,n,i,o);return u}(this,i,s,t,e,r)),a},b.prototype.cork=function(){this._writableState.corked++},b.prototype.uncork=function(){var t=this._writableState;t.corked&&(t.corked--,t.writing||t.corked||t.finished||t.bufferProcessing||!t.bufferedRequest||w(this,t))},b.prototype.setDefaultEncoding=function(t){if("string"==typeof t&&(t=t.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((t+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+t);return this._writableState.defaultEncoding=t,this},Object.defineProperty(b.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),b.prototype._write=function(t,e,r){r(new Error("_write() is not implemented"))},b.prototype._writev=null,b.prototype.end=function(t,e,r){var n=this._writableState;"function"==typeof t?(r=t,t=null,e=null):"function"==typeof e&&(r=e,e=null),null!=t&&this.write(t,e),n.corked&&(n.corked=1,this.uncork()),n.ending||n.finished||function(t,e,r){e.ending=!0,E(t,e),r&&(e.finished?o.nextTick(r):t.once("finish",r));e.ended=!0,t.writable=!1}(this,n,r)},Object.defineProperty(b.prototype,"destroyed",{get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(t){this._writableState&&(this._writableState.destroyed=t)}}),b.prototype.destroy=v.destroy,b.prototype._undestroy=v.undestroy,b.prototype._destroy=function(t,e){this.end(),e(t)}}).call(this,r(38),r(136).setImmediate,r(21))},function(t,e){function r(e){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?t.exports=r=function(t){return typeof t}:t.exports=r=function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},r(e)}t.exports=r},function(t,e,r){var n=r(16),i=r(80),o=r(202),a=r(203);function s(e){var r="function"==typeof Map?new Map:void 0;return t.exports=s=function(t){if(null===t||!o(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,e)}function e(){return a(t,arguments,n(this).constructor)}return e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),i(e,t)},s(e)}t.exports=s},function(t,e,r){"use strict";var n=r(2),i=r(4),o=r(26),a=r(25),s=r(7),u=r(69),c=r(107),f=r(5),l=r(13),h=r(47),p=r(10),d=r(8),v=r(27),g=r(12),y=r(43),b=r(31),_=r(70),m=r(48),w=r(46),x=r(148),k=r(106),E=r(22),S=r(11),j=r(59),R=r(14),C=r(17),I=r(64),O=r(44),T=r(45),P=r(65),A=r(3),L=r(110),F=r(111),M=r(49),N=r(24),B=r(33).forEach,D=O("hidden"),U=A("toPrimitive"),q=N.set,G=N.getterFor("Symbol"),W=Object.prototype,z=i.Symbol,Y=o("JSON","stringify"),Q=E.f,$=S.f,H=x.f,K=j.f,V=I("symbols"),Z=I("op-symbols"),J=I("string-to-symbol-registry"),X=I("symbol-to-string-registry"),tt=I("wks"),et=i.QObject,rt=!et||!et.prototype||!et.prototype.findChild,nt=s&&f((function(){return 7!=_($({},"a",{get:function(){return $(this,"a",{value:7}).a}})).a}))?function(t,e,r){var n=Q(W,e);n&&delete W[e],$(t,e,r),n&&t!==W&&$(W,e,n)}:$,it=function(t,e){var r=V[t]=_(z.prototype);return q(r,{type:"Symbol",tag:t,description:e}),s||(r.description=e),r},ot=c?function(t){return"symbol"==typeof t}:function(t){return Object(t)instanceof z},at=function(t,e,r){t===W&&at(Z,e,r),d(t);var n=y(e,!0);return d(r),l(V,n)?(r.enumerable?(l(t,D)&&t[D][n]&&(t[D][n]=!1),r=_(r,{enumerable:b(0,!1)})):(l(t,D)||$(t,D,b(1,{})),t[D][n]=!0),nt(t,n,r)):$(t,n,r)},st=function(t,e){d(t);var r=g(e),n=m(r).concat(lt(r));return B(n,(function(e){s&&!ut.call(r,e)||at(t,e,r[e])})),t},ut=function(t){var e=y(t,!0),r=K.call(this,e);return!(this===W&&l(V,e)&&!l(Z,e))&&(!(r||!l(this,e)||!l(V,e)||l(this,D)&&this[D][e])||r)},ct=function(t,e){var r=g(t),n=y(e,!0);if(r!==W||!l(V,n)||l(Z,n)){var i=Q(r,n);return!i||!l(V,n)||l(r,D)&&r[D][n]||(i.enumerable=!0),i}},ft=function(t){var e=H(g(t)),r=[];return B(e,(function(t){l(V,t)||l(T,t)||r.push(t)})),r},lt=function(t){var e=t===W,r=H(e?Z:g(t)),n=[];return B(r,(function(t){!l(V,t)||e&&!l(W,t)||n.push(V[t])})),n};(u||(C((z=function(){if(this instanceof z)throw TypeError("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=P(t),r=function(t){this===W&&r.call(Z,t),l(this,D)&&l(this[D],e)&&(this[D][e]=!1),nt(this,e,b(1,t))};return s&&rt&&nt(W,e,{configurable:!0,set:r}),it(e,t)}).prototype,"toString",(function(){return G(this).tag})),C(z,"withoutSetter",(function(t){return it(P(t),t)})),j.f=ut,S.f=at,E.f=ct,w.f=x.f=ft,k.f=lt,L.f=function(t){return it(A(t),t)},s&&($(z.prototype,"description",{configurable:!0,get:function(){return G(this).description}}),a||C(W,"propertyIsEnumerable",ut,{unsafe:!0}))),n({global:!0,wrap:!0,forced:!u,sham:!u},{Symbol:z}),B(m(tt),(function(t){F(t)})),n({target:"Symbol",stat:!0,forced:!u},{for:function(t){var e=String(t);if(l(J,e))return J[e];var r=z(e);return J[e]=r,X[r]=e,r},keyFor:function(t){if(!ot(t))throw TypeError(t+" is not a symbol");if(l(X,t))return X[t]},useSetter:function(){rt=!0},useSimple:function(){rt=!1}}),n({target:"Object",stat:!0,forced:!u,sham:!s},{create:function(t,e){return void 0===e?_(t):st(_(t),e)},defineProperty:at,defineProperties:st,getOwnPropertyDescriptor:ct}),n({target:"Object",stat:!0,forced:!u},{getOwnPropertyNames:ft,getOwnPropertySymbols:lt}),n({target:"Object",stat:!0,forced:f((function(){k.f(1)}))},{getOwnPropertySymbols:function(t){return k.f(v(t))}}),Y)&&n({target:"JSON",stat:!0,forced:!u||f((function(){var t=z();return"[null]"!=Y([t])||"{}"!=Y({a:t})||"{}"!=Y(Object(t))}))},{stringify:function(t,e,r){for(var n,i=[t],o=1;arguments.length>o;)i.push(arguments[o++]);if(n=e,(p(e)||void 0!==t)&&!ot(t))return h(e)||(e=function(t,e){if("function"==typeof n&&(e=n.call(this,t,e)),!ot(e))return e}),i[1]=e,Y.apply(null,i)}});z.prototype[U]||R(z.prototype,U,z.prototype.valueOf),M(z,"Symbol"),T[D]=!0},function(t,e,r){var n=r(7),i=r(5),o=r(61);t.exports=!n&&!i((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(t,e,r){var n=r(4),i=r(62),o=n["__core-js_shared__"]||i("__core-js_shared__",{});t.exports=o},function(t,e,r){var n=r(13),i=r(102),o=r(22),a=r(11);t.exports=function(t,e){for(var r=i(e),s=a.f,u=o.f,c=0;c<r.length;c++){var f=r[c];n(t,f)||s(t,f,u(e,f))}}},function(t,e,r){var n=r(26),i=r(46),o=r(106),a=r(8);t.exports=n("Reflect","ownKeys")||function(t){var e=i.f(a(t)),r=o.f;return r?e.concat(r(t)):e}},function(t,e,r){var n=r(4);t.exports=n},function(t,e,r){var n=r(13),i=r(12),o=r(66).indexOf,a=r(45);t.exports=function(t,e){var r,s=i(t),u=0,c=[];for(r in s)!n(a,r)&&n(s,r)&&c.push(r);for(;e.length>u;)n(s,r=e[u++])&&(~o(c,r)||c.push(r));return c}},function(t,e,r){var n=r(32),i=Math.max,o=Math.min;t.exports=function(t,e){var r=n(t);return r<0?i(r+e,0):o(r,e)}},function(t,e){e.f=Object.getOwnPropertySymbols},function(t,e,r){var n=r(69);t.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(t,e,r){var n=r(7),i=r(11),o=r(8),a=r(48);t.exports=n?Object.defineProperties:function(t,e){o(t);for(var r,n=a(e),s=n.length,u=0;s>u;)i.f(t,r=n[u++],e[r]);return t}},function(t,e,r){var n=r(26);t.exports=n("document","documentElement")},function(t,e,r){var n=r(3);e.f=n},function(t,e,r){var n=r(103),i=r(13),o=r(110),a=r(11).f;t.exports=function(t){var e=n.Symbol||(n.Symbol={});i(e,t)||a(e,t,{value:o.f(t)})}},function(t,e,r){var n=r(10),i=r(47),o=r(3)("species");t.exports=function(t,e){var r;return i(t)&&("function"!=typeof(r=t.constructor)||r!==Array&&!i(r.prototype)?n(r)&&null===(r=r[o])&&(r=void 0):r=void 0),new(void 0===r?Array:r)(0===e?0:e)}},function(t,e,r){var n=r(3),i=r(70),o=r(11),a=n("unscopables"),s=Array.prototype;null==s[a]&&o.f(s,a,{configurable:!0,value:i(null)}),t.exports=function(t){s[a][t]=!0}},function(t,e,r){"use strict";var n=r(2),i=r(151),o=r(116),a=r(117),s=r(49),u=r(14),c=r(17),f=r(3),l=r(25),h=r(34),p=r(115),d=p.IteratorPrototype,v=p.BUGGY_SAFARI_ITERATORS,g=f("iterator"),y=function(){return this};t.exports=function(t,e,r,f,p,b,_){i(r,e,f);var m,w,x,k=function(t){if(t===p&&C)return C;if(!v&&t in j)return j[t];switch(t){case"keys":case"values":case"entries":return function(){return new r(this,t)}}return function(){return new r(this)}},E=e+" Iterator",S=!1,j=t.prototype,R=j[g]||j["@@iterator"]||p&&j[p],C=!v&&R||k(p),I="Array"==e&&j.entries||R;if(I&&(m=o(I.call(new t)),d!==Object.prototype&&m.next&&(l||o(m)===d||(a?a(m,d):"function"!=typeof m[g]&&u(m,g,y)),s(m,E,!0,!0),l&&(h[E]=y))),"values"==p&&R&&"values"!==R.name&&(S=!0,C=function(){return R.call(this)}),l&&!_||j[g]===C||u(j,g,C),h[e]=C,p)if(w={values:k("values"),keys:b?C:k("keys"),entries:k("entries")},_)for(x in w)(v||S||!(x in j))&&c(j,x,w[x]);else n({target:e,proto:!0,forced:v||S},w);return w}},function(t,e,r){"use strict";var n,i,o,a=r(116),s=r(14),u=r(13),c=r(3),f=r(25),l=c("iterator"),h=!1;[].keys&&("next"in(o=[].keys())?(i=a(a(o)))!==Object.prototype&&(n=i):h=!0),null==n&&(n={}),f||u(n,l)||s(n,l,(function(){return this})),t.exports={IteratorPrototype:n,BUGGY_SAFARI_ITERATORS:h}},function(t,e,r){var n=r(13),i=r(27),o=r(44),a=r(152),s=o("IE_PROTO"),u=Object.prototype;t.exports=a?Object.getPrototypeOf:function(t){return t=i(t),n(t,s)?t[s]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,e,r){var n=r(8),i=r(153);t.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,r={};try{(t=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(r,[]),e=r instanceof Array}catch(t){}return function(r,o){return n(r),i(o),e?t.call(r,o):r.__proto__=o,r}}():void 0)},function(t,e,r){var n=r(72),i=r(19),o=r(3)("toStringTag"),a="Arguments"==i(function(){return arguments}());t.exports=n?i:function(t){var e,r,n;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,e){try{return t[e]}catch(t){}}(e=Object(t),o))?r:a?i(e):"Object"==(n=i(e))&&"function"==typeof e.callee?"Arguments":n}},function(t,e,r){"use strict";var n=r(5);function i(t,e){return RegExp(t,e)}e.UNSUPPORTED_Y=n((function(){var t=i("a","y");return t.lastIndex=2,null!=t.exec("abcd")})),e.BROKEN_CARET=n((function(){var t=i("^r","gy");return t.lastIndex=2,null!=t.exec("str")}))},function(t,e,r){var n=r(32),i=r(20),o=function(t){return function(e,r){var o,a,s=String(i(e)),u=n(r),c=s.length;return u<0||u>=c?t?"":void 0:(o=s.charCodeAt(u))<55296||o>56319||u+1===c||(a=s.charCodeAt(u+1))<56320||a>57343?t?s.charAt(u):o:t?s.slice(u,u+2):a-56320+(o-55296<<10)+65536}};t.exports={codeAt:o(!1),charAt:o(!0)}},function(t,e){t.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(t,e,r){var n=r(26);t.exports=n("navigator","userAgent")||""},function(t,e,r){"use strict";var n=r(33).forEach,i=r(36);t.exports=i("forEach")?function(t){return n(this,t,arguments.length>1?arguments[1]:void 0)}:[].forEach},function(t,e,r){var n=r(2),i=r(27),o=r(48);n({target:"Object",stat:!0,forced:r(5)((function(){o(1)}))},{keys:function(t){return o(i(t))}})},function(t,e,r){"use strict";var n=r(26),i=r(11),o=r(3),a=r(7),s=o("species");t.exports=function(t){var e=n(t),r=i.f;a&&e&&!e[s]&&r(e,s,{configurable:!0,get:function(){return this}})}},function(t,e,r){"use strict";var n,i=r(2),o=r(22).f,a=r(15),s=r(127),u=r(20),c=r(128),f=r(25),l="".endsWith,h=Math.min,p=c("endsWith");i({target:"String",proto:!0,forced:!!(f||p||(n=o(String.prototype,"endsWith"),!n||n.writable))&&!p},{endsWith:function(t){var e=String(u(this));s(t);var r=arguments.length>1?arguments[1]:void 0,n=a(e.length),i=void 0===r?n:h(a(r),n),o=String(t);return l?l.call(e,o,i):e.slice(i-o.length,i)===o}})},function(t,e,r){var n=r(88);t.exports=function(t){if(n(t))throw TypeError("The method doesn\'t accept regular expressions");return t}},function(t,e,r){var n=r(3)("match");t.exports=function(t){var e=/./;try{"/./"[t](e)}catch(r){try{return e[n]=!1,"/./"[t](e)}catch(t){}}return!1}},function(t,e,r){"use strict";var n=r(2),i=r(127),o=r(20);n({target:"String",proto:!0,forced:!r(128)("includes")},{includes:function(t){return!!~String(o(this)).indexOf(i(t),arguments.length>1?arguments[1]:void 0)}})},function(t,e,r){var n=r(2),i=r(175);n({target:"Array",proto:!0,forced:i!==[].lastIndexOf},{lastIndexOf:i})},function(t,e,r){"use strict";var n=r(2),i=r(10),o=r(47),a=r(105),s=r(15),u=r(12),c=r(82),f=r(54),l=r(3)("species"),h=[].slice,p=Math.max;n({target:"Array",proto:!0,forced:!f("slice")},{slice:function(t,e){var r,n,f,d=u(this),v=s(d.length),g=a(t,v),y=a(void 0===e?v:e,v);if(o(d)&&("function"!=typeof(r=d.constructor)||r!==Array&&!o(r.prototype)?i(r)&&null===(r=r[l])&&(r=void 0):r=void 0,r===Array||void 0===r))return h.call(d,g,y);for(n=new(void 0===r?Array:r)(p(y-g,0)),f=0;g<y;g++,f++)g in d&&c(n,f,d[g]);return n.length=f,n}})},function(t,e,r){var n=r(8),i=r(50),o=r(3)("species");t.exports=function(t,e){var r,a=n(t).constructor;return void 0===a||null==(r=n(a)[o])?e:i(r)}},function(t,e,r){var n,i,o,a=r(4),s=r(5),u=r(19),c=r(71),f=r(109),l=r(61),h=r(134),p=a.location,d=a.setImmediate,v=a.clearImmediate,g=a.process,y=a.MessageChannel,b=a.Dispatch,_=0,m={},w=function(t){if(m.hasOwnProperty(t)){var e=m[t];delete m[t],e()}},x=function(t){return function(){w(t)}},k=function(t){w(t.data)},E=function(t){a.postMessage(t+"",p.protocol+"//"+p.host)};d&&v||(d=function(t){for(var e=[],r=1;arguments.length>r;)e.push(arguments[r++]);return m[++_]=function(){("function"==typeof t?t:Function(t)).apply(void 0,e)},n(_),_},v=function(t){delete m[t]},"process"==u(g)?n=function(t){g.nextTick(x(t))}:b&&b.now?n=function(t){b.now(x(t))}:y&&!h?(o=(i=new y).port2,i.port1.onmessage=k,n=c(o.postMessage,o,1)):!a.addEventListener||"function"!=typeof postMessage||a.importScripts||s(E)?n="onreadystatechange"in l("script")?function(t){f.appendChild(l("script")).onreadystatechange=function(){f.removeChild(this),w(t)}}:function(t){setTimeout(x(t),0)}:(n=E,a.addEventListener("message",k,!1))),t.exports={set:d,clear:v}},function(t,e,r){var n=r(122);t.exports=/(iphone|ipod|ipad).*applewebkit/i.test(n)},function(t,e,r){"use strict";var n=r(50),i=function(t){var e,r;this.promise=new t((function(t,n){if(void 0!==e||void 0!==r)throw TypeError("Bad Promise constructor");e=t,r=n})),this.resolve=n(e),this.reject=n(r)};t.exports.f=function(t){return new i(t)}},function(t,e,r){(function(t){var n=void 0!==t&&t||"undefined"!=typeof self&&self||window,i=Function.prototype.apply;function o(t,e){this._id=t,this._clearFn=e}e.setTimeout=function(){return new o(i.call(setTimeout,n,arguments),clearTimeout)},e.setInterval=function(){return new o(i.call(setInterval,n,arguments),clearInterval)},e.clearTimeout=e.clearInterval=function(t){t&&t.close()},o.prototype.unref=o.prototype.ref=function(){},o.prototype.close=function(){this._clearFn.call(n,this._id)},e.enroll=function(t,e){clearTimeout(t._idleTimeoutId),t._idleTimeout=e},e.unenroll=function(t){clearTimeout(t._idleTimeoutId),t._idleTimeout=-1},e._unrefActive=e.active=function(t){clearTimeout(t._idleTimeoutId);var e=t._idleTimeout;e>=0&&(t._idleTimeoutId=setTimeout((function(){t._onTimeout&&t._onTimeout()}),e))},r(189),e.setImmediate="undefined"!=typeof self&&self.setImmediate||void 0!==t&&t.setImmediate||this&&this.setImmediate,e.clearImmediate="undefined"!=typeof self&&self.clearImmediate||void 0!==t&&t.clearImmediate||this&&this.clearImmediate}).call(this,r(21))},function(t,e){var r={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==r.call(t)}},function(t,e,r){"use strict";(function(e,n){var i=r(55);t.exports=_;var o,a=r(137);_.ReadableState=b;r(93).EventEmitter;var s=function(t,e){return t.listeners(e).length},u=r(139),c=r(56).Buffer,f=e.Uint8Array||function(){};var l=r(39);l.inherits=r(29);var h=r(192),p=void 0;p=h&&h.debuglog?h.debuglog("stream"):function(){};var d,v=r(193),g=r(140);l.inherits(_,u);var y=["error","close","destroy","pause","resume"];function b(t,e){t=t||{};var n=e instanceof(o=o||r(23));this.objectMode=!!t.objectMode,n&&(this.objectMode=this.objectMode||!!t.readableObjectMode);var i=t.highWaterMark,a=t.readableHighWaterMark,s=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:n&&(a||0===a)?a:s,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new v,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(d||(d=r(141).StringDecoder),this.decoder=new d(t.encoding),this.encoding=t.encoding)}function _(t){if(o=o||r(23),!(this instanceof _))return new _(t);this._readableState=new b(t,this),this.readable=!0,t&&("function"==typeof t.read&&(this._read=t.read),"function"==typeof t.destroy&&(this._destroy=t.destroy)),u.call(this)}function m(t,e,r,n,i){var o,a=t._readableState;null===e?(a.reading=!1,function(t,e){if(e.ended)return;if(e.decoder){var r=e.decoder.end();r&&r.length&&(e.buffer.push(r),e.length+=e.objectMode?1:r.length)}e.ended=!0,k(t)}(t,a)):(i||(o=function(t,e){var r;n=e,c.isBuffer(n)||n instanceof f||"string"==typeof e||void 0===e||t.objectMode||(r=new TypeError("Invalid non-string/buffer chunk"));var n;return r}(a,e)),o?t.emit("error",o):a.objectMode||e&&e.length>0?("string"==typeof e||a.objectMode||Object.getPrototypeOf(e)===c.prototype||(e=function(t){return c.from(t)}(e)),n?a.endEmitted?t.emit("error",new Error("stream.unshift() after end event")):w(t,a,e,!0):a.ended?t.emit("error",new Error("stream.push() after EOF")):(a.reading=!1,a.decoder&&!r?(e=a.decoder.write(e),a.objectMode||0!==e.length?w(t,a,e,!1):S(t,a)):w(t,a,e,!1))):n||(a.reading=!1));return function(t){return!t.ended&&(t.needReadable||t.length<t.highWaterMark||0===t.length)}(a)}function w(t,e,r,n){e.flowing&&0===e.length&&!e.sync?(t.emit("data",r),t.read(0)):(e.length+=e.objectMode?1:r.length,n?e.buffer.unshift(r):e.buffer.push(r),e.needReadable&&k(t)),S(t,e)}Object.defineProperty(_.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(t){this._readableState&&(this._readableState.destroyed=t)}}),_.prototype.destroy=g.destroy,_.prototype._undestroy=g.undestroy,_.prototype._destroy=function(t,e){this.push(null),e(t)},_.prototype.push=function(t,e){var r,n=this._readableState;return n.objectMode?r=!0:"string"==typeof t&&((e=e||n.defaultEncoding)!==n.encoding&&(t=c.from(t,e),e=""),r=!0),m(this,t,e,!1,r)},_.prototype.unshift=function(t){return m(this,t,null,!0,!1)},_.prototype.isPaused=function(){return!1===this._readableState.flowing},_.prototype.setEncoding=function(t){return d||(d=r(141).StringDecoder),this._readableState.decoder=new d(t),this._readableState.encoding=t,this};function x(t,e){return t<=0||0===e.length&&e.ended?0:e.objectMode?1:t!=t?e.flowing&&e.length?e.buffer.head.data.length:e.length:(t>e.highWaterMark&&(e.highWaterMark=function(t){return t>=8388608?t=8388608:(t--,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t++),t}(t)),t<=e.length?t:e.ended?e.length:(e.needReadable=!0,0))}function k(t){var e=t._readableState;e.needReadable=!1,e.emittedReadable||(p("emitReadable",e.flowing),e.emittedReadable=!0,e.sync?i.nextTick(E,t):E(t))}function E(t){p("emit readable"),t.emit("readable"),I(t)}function S(t,e){e.readingMore||(e.readingMore=!0,i.nextTick(j,t,e))}function j(t,e){for(var r=e.length;!e.reading&&!e.flowing&&!e.ended&&e.length<e.highWaterMark&&(p("maybeReadMore read 0"),t.read(0),r!==e.length);)r=e.length;e.readingMore=!1}function R(t){p("readable nexttick read 0"),t.read(0)}function C(t,e){e.reading||(p("resume read 0"),t.read(0)),e.resumeScheduled=!1,e.awaitDrain=0,t.emit("resume"),I(t),e.flowing&&!e.reading&&t.read(0)}function I(t){var e=t._readableState;for(p("flow",e.flowing);e.flowing&&null!==t.read(););}function O(t,e){return 0===e.length?null:(e.objectMode?r=e.buffer.shift():!t||t>=e.length?(r=e.decoder?e.buffer.join(""):1===e.buffer.length?e.buffer.head.data:e.buffer.concat(e.length),e.buffer.clear()):r=function(t,e,r){var n;t<e.head.data.length?(n=e.head.data.slice(0,t),e.head.data=e.head.data.slice(t)):n=t===e.head.data.length?e.shift():r?function(t,e){var r=e.head,n=1,i=r.data;t-=i.length;for(;r=r.next;){var o=r.data,a=t>o.length?o.length:t;if(a===o.length?i+=o:i+=o.slice(0,t),0===(t-=a)){a===o.length?(++n,r.next?e.head=r.next:e.head=e.tail=null):(e.head=r,r.data=o.slice(a));break}++n}return e.length-=n,i}(t,e):function(t,e){var r=c.allocUnsafe(t),n=e.head,i=1;n.data.copy(r),t-=n.data.length;for(;n=n.next;){var o=n.data,a=t>o.length?o.length:t;if(o.copy(r,r.length-t,0,a),0===(t-=a)){a===o.length?(++i,n.next?e.head=n.next:e.head=e.tail=null):(e.head=n,n.data=o.slice(a));break}++i}return e.length-=i,r}(t,e);return n}(t,e.buffer,e.decoder),r);var r}function T(t){var e=t._readableState;if(e.length>0)throw new Error(\'"endReadable()" called on non-empty stream\');e.endEmitted||(e.ended=!0,i.nextTick(P,e,t))}function P(t,e){t.endEmitted||0!==t.length||(t.endEmitted=!0,e.readable=!1,e.emit("end"))}function A(t,e){for(var r=0,n=t.length;r<n;r++)if(t[r]===e)return r;return-1}_.prototype.read=function(t){p("read",t),t=parseInt(t,10);var e=this._readableState,r=t;if(0!==t&&(e.emittedReadable=!1),0===t&&e.needReadable&&(e.length>=e.highWaterMark||e.ended))return p("read: emitReadable",e.length,e.ended),0===e.length&&e.ended?T(this):k(this),null;if(0===(t=x(t,e))&&e.ended)return 0===e.length&&T(this),null;var n,i=e.needReadable;return p("need readable",i),(0===e.length||e.length-t<e.highWaterMark)&&p("length less than watermark",i=!0),e.ended||e.reading?p("reading or ended",i=!1):i&&(p("do read"),e.reading=!0,e.sync=!0,0===e.length&&(e.needReadable=!0),this._read(e.highWaterMark),e.sync=!1,e.reading||(t=x(r,e))),null===(n=t>0?O(t,e):null)?(e.needReadable=!0,t=0):e.length-=t,0===e.length&&(e.ended||(e.needReadable=!0),r!==t&&e.ended&&T(this)),null!==n&&this.emit("data",n),n},_.prototype._read=function(t){this.emit("error",new Error("_read() is not implemented"))},_.prototype.pipe=function(t,e){var r=this,o=this._readableState;switch(o.pipesCount){case 0:o.pipes=t;break;case 1:o.pipes=[o.pipes,t];break;default:o.pipes.push(t)}o.pipesCount+=1,p("pipe count=%d opts=%j",o.pipesCount,e);var u=(!e||!1!==e.end)&&t!==n.stdout&&t!==n.stderr?f:_;function c(e,n){p("onunpipe"),e===r&&n&&!1===n.hasUnpiped&&(n.hasUnpiped=!0,p("cleanup"),t.removeListener("close",y),t.removeListener("finish",b),t.removeListener("drain",l),t.removeListener("error",g),t.removeListener("unpipe",c),r.removeListener("end",f),r.removeListener("end",_),r.removeListener("data",v),h=!0,!o.awaitDrain||t._writableState&&!t._writableState.needDrain||l())}function f(){p("onend"),t.end()}o.endEmitted?i.nextTick(u):r.once("end",u),t.on("unpipe",c);var l=function(t){return function(){var e=t._readableState;p("pipeOnDrain",e.awaitDrain),e.awaitDrain&&e.awaitDrain--,0===e.awaitDrain&&s(t,"data")&&(e.flowing=!0,I(t))}}(r);t.on("drain",l);var h=!1;var d=!1;function v(e){p("ondata"),d=!1,!1!==t.write(e)||d||((1===o.pipesCount&&o.pipes===t||o.pipesCount>1&&-1!==A(o.pipes,t))&&!h&&(p("false write response, pause",r._readableState.awaitDrain),r._readableState.awaitDrain++,d=!0),r.pause())}function g(e){p("onerror",e),_(),t.removeListener("error",g),0===s(t,"error")&&t.emit("error",e)}function y(){t.removeListener("finish",b),_()}function b(){p("onfinish"),t.removeListener("close",y),_()}function _(){p("unpipe"),r.unpipe(t)}return r.on("data",v),function(t,e,r){if("function"==typeof t.prependListener)return t.prependListener(e,r);t._events&&t._events[e]?a(t._events[e])?t._events[e].unshift(r):t._events[e]=[r,t._events[e]]:t.on(e,r)}(t,"error",g),t.once("close",y),t.once("finish",b),t.emit("pipe",r),o.flowing||(p("pipe resume"),r.resume()),t},_.prototype.unpipe=function(t){var e=this._readableState,r={hasUnpiped:!1};if(0===e.pipesCount)return this;if(1===e.pipesCount)return t&&t!==e.pipes||(t||(t=e.pipes),e.pipes=null,e.pipesCount=0,e.flowing=!1,t&&t.emit("unpipe",this,r)),this;if(!t){var n=e.pipes,i=e.pipesCount;e.pipes=null,e.pipesCount=0,e.flowing=!1;for(var o=0;o<i;o++)n[o].emit("unpipe",this,r);return this}var a=A(e.pipes,t);return-1===a||(e.pipes.splice(a,1),e.pipesCount-=1,1===e.pipesCount&&(e.pipes=e.pipes[0]),t.emit("unpipe",this,r)),this},_.prototype.on=function(t,e){var r=u.prototype.on.call(this,t,e);if("data"===t)!1!==this._readableState.flowing&&this.resume();else if("readable"===t){var n=this._readableState;n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.emittedReadable=!1,n.reading?n.length&&k(this):i.nextTick(R,this))}return r},_.prototype.addListener=_.prototype.on,_.prototype.resume=function(){var t=this._readableState;return t.flowing||(p("resume"),t.flowing=!0,function(t,e){e.resumeScheduled||(e.resumeScheduled=!0,i.nextTick(C,t,e))}(this,t)),this},_.prototype.pause=function(){return p("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(p("pause"),this._readableState.flowing=!1,this.emit("pause")),this},_.prototype.wrap=function(t){var e=this,r=this._readableState,n=!1;for(var i in t.on("end",(function(){if(p("wrapped end"),r.decoder&&!r.ended){var t=r.decoder.end();t&&t.length&&e.push(t)}e.push(null)})),t.on("data",(function(i){(p("wrapped data"),r.decoder&&(i=r.decoder.write(i)),r.objectMode&&null==i)||(r.objectMode||i&&i.length)&&(e.push(i)||(n=!0,t.pause()))})),t)void 0===this[i]&&"function"==typeof t[i]&&(this[i]=function(e){return function(){return t[e].apply(t,arguments)}}(i));for(var o=0;o<y.length;o++)t.on(y[o],this.emit.bind(this,y[o]));return this._read=function(e){p("wrapped _read",e),n&&(n=!1,t.resume())},this},Object.defineProperty(_.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),_._fromList=O}).call(this,r(21),r(38))},function(t,e,r){t.exports=r(93).EventEmitter},function(t,e,r){"use strict";var n=r(55);function i(t,e){t.emit("error",e)}t.exports={destroy:function(t,e){var r=this,o=this._readableState&&this._readableState.destroyed,a=this._writableState&&this._writableState.destroyed;return o||a?(e?e(t):!t||this._writableState&&this._writableState.errorEmitted||n.nextTick(i,this,t),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(t||null,(function(t){!e&&t?(n.nextTick(i,r,t),r._writableState&&(r._writableState.errorEmitted=!0)):e&&e(t)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}}},function(t,e,r){"use strict";var n=r(56).Buffer,i=n.isEncoding||function(t){switch((t=""+t)&&t.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function o(t){var e;switch(this.encoding=function(t){var e=function(t){if(!t)return"utf8";for(var e;;)switch(t){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return t;default:if(e)return;t=(""+t).toLowerCase(),e=!0}}(t);if("string"!=typeof e&&(n.isEncoding===i||!i(t)))throw new Error("Unknown encoding: "+t);return e||t}(t),this.encoding){case"utf16le":this.text=u,this.end=c,e=4;break;case"utf8":this.fillLast=s,e=4;break;case"base64":this.text=f,this.end=l,e=3;break;default:return this.write=h,void(this.end=p)}this.lastNeed=0,this.lastTotal=0,this.lastChar=n.allocUnsafe(e)}function a(t){return t<=127?0:t>>5==6?2:t>>4==14?3:t>>3==30?4:t>>6==2?-1:-2}function s(t){var e=this.lastTotal-this.lastNeed,r=function(t,e,r){if(128!=(192&e[0]))return t.lastNeed=0,"";if(t.lastNeed>1&&e.length>1){if(128!=(192&e[1]))return t.lastNeed=1,"";if(t.lastNeed>2&&e.length>2&&128!=(192&e[2]))return t.lastNeed=2,""}}(this,t);return void 0!==r?r:this.lastNeed<=t.length?(t.copy(this.lastChar,e,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(t.copy(this.lastChar,e,0,t.length),void(this.lastNeed-=t.length))}function u(t,e){if((t.length-e)%2==0){var r=t.toString("utf16le",e);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=t[t.length-1],t.toString("utf16le",e,t.length-1)}function c(t){var e=t&&t.length?this.write(t):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return e+this.lastChar.toString("utf16le",0,r)}return e}function f(t,e){var r=(t.length-e)%3;return 0===r?t.toString("base64",e):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=t[t.length-1]:(this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1]),t.toString("base64",e,t.length-r))}function l(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+this.lastChar.toString("base64",0,3-this.lastNeed):e}function h(t){return t.toString(this.encoding)}function p(t){return t&&t.length?this.write(t):""}e.StringDecoder=o,o.prototype.write=function(t){if(0===t.length)return"";var e,r;if(this.lastNeed){if(void 0===(e=this.fillLast(t)))return"";r=this.lastNeed,this.lastNeed=0}else r=0;return r<t.length?e?e+this.text(t,r):this.text(t,r):e||""},o.prototype.end=function(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+"":e},o.prototype.text=function(t,e){var r=function(t,e,r){var n=e.length-1;if(n<r)return 0;var i=a(e[n]);if(i>=0)return i>0&&(t.lastNeed=i-1),i;if(--n<r||-2===i)return 0;if((i=a(e[n]))>=0)return i>0&&(t.lastNeed=i-2),i;if(--n<r||-2===i)return 0;if((i=a(e[n]))>=0)return i>0&&(2===i?i=0:t.lastNeed=i-3),i;return 0}(this,t,e);if(!this.lastNeed)return t.toString("utf8",e);this.lastTotal=r;var n=t.length-(r-this.lastNeed);return t.copy(this.lastChar,0,n),t.toString("utf8",e,n)},o.prototype.fillLast=function(t){if(this.lastNeed<=t.length)return t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,t.length),this.lastNeed-=t.length}},function(t,e,r){"use strict";t.exports=a;var n=r(23),i=r(39);function o(t,e){var r=this._transformState;r.transforming=!1;var n=r.writecb;if(!n)return this.emit("error",new Error("write callback called multiple times"));r.writechunk=null,r.writecb=null,null!=e&&this.push(e),n(t);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}function a(t){if(!(this instanceof a))return new a(t);n.call(this,t),this._transformState={afterTransform:o.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,t&&("function"==typeof t.transform&&(this._transform=t.transform),"function"==typeof t.flush&&(this._flush=t.flush)),this.on("prefinish",s)}function s(){var t=this;"function"==typeof this._flush?this._flush((function(e,r){u(t,e,r)})):u(this,null,null)}function u(t,e,r){if(e)return t.emit("error",e);if(null!=r&&t.push(r),t._writableState.length)throw new Error("Calling transform done when ws.length != 0");if(t._transformState.transforming)throw new Error("Calling transform done when still transforming");return t.push(null)}i.inherits=r(29),i.inherits(a,n),a.prototype.push=function(t,e){return this._transformState.needTransform=!1,n.prototype.push.call(this,t,e)},a.prototype._transform=function(t,e,r){throw new Error("_transform() is not implemented")},a.prototype._write=function(t,e,r){var n=this._transformState;if(n.writecb=r,n.writechunk=t,n.writeencoding=e,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},a.prototype._read=function(t){var e=this._transformState;null!==e.writechunk&&e.writecb&&!e.transforming?(e.transforming=!0,this._transform(e.writechunk,e.writeencoding,e.afterTransform)):e.needTransform=!0},a.prototype._destroy=function(t,e){var r=this;n.prototype._destroy.call(this,t,(function(t){e(t),r.emit("close")}))}},function(t,e){t.exports=function(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}},function(t,e){const r={acl:"http://www.w3.org/ns/auth/acl#",arg:"http://www.w3.org/ns/pim/arg#",cal:"http://www.w3.org/2002/12/cal/ical#",contact:"http://www.w3.org/2000/10/swap/pim/contact#",dc:"http://purl.org/dc/elements/1.1/",dct:"http://purl.org/dc/terms/",doap:"http://usefulinc.com/ns/doap#",foaf:"http://xmlns.com/foaf/0.1/",http:"http://www.w3.org/2007/ont/http#",httph:"http://www.w3.org/2007/ont/httph#",icalTZ:"http://www.w3.org/2002/12/cal/icaltzd#",ldp:"http://www.w3.org/ns/ldp#",link:"http://www.w3.org/2007/ont/link#",log:"http://www.w3.org/2000/10/swap/log#",meeting:"http://www.w3.org/ns/pim/meeting#",mo:"http://purl.org/ontology/mo/",owl:"http://www.w3.org/2002/07/owl#",pad:"http://www.w3.org/ns/pim/pad#",patch:"http://www.w3.org/ns/pim/patch#",qu:"http://www.w3.org/2000/10/swap/pim/qif#",trip:"http://www.w3.org/ns/pim/trip#",rdf:"http://www.w3.org/1999/02/22-rdf-syntax-ns#",rdfs:"http://www.w3.org/2000/01/rdf-schema#",rss:"http://purl.org/rss/1.0/",sched:"http://www.w3.org/ns/pim/schedule#",schema:"http:/schema.org/",sioc:"http://rdfs.org/sioc/ns#",solid:"http://www.w3.org/ns/solid/terms#",space:"http://www.w3.org/ns/pim/space#",stat:"http://www.w3.org/ns/posix/stat#",tab:"http://www.w3.org/2007/ont/link#",tabont:"http://www.w3.org/2007/ont/link#",ui:"http://www.w3.org/ns/ui#",vcard:"http://www.w3.org/2006/vcard/ns#",wf:"http://www.w3.org/2005/01/wf/flow#",xsd:"http://www.w3.org/2001/XMLSchema#"};t.exports=function(t={namedNode:t=>t}){const e={};for(const n in r){const i=r[n];e[n]=function(e=""){return t.namedNode(i+e)}}return e}},function(t,e,r){"use strict";(function(t,n){r.d(e,"a",(function(){return h}));var i=r(6);const{xsd:o}=i.a,{fromCharCode:a}=String;var s=/\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\[uU]|\\\\(.)/g,u={"\\\\":"\\\\","\'":"\'",\'"\':\'"\',n:"\\n",r:"\\r",t:"\\t",f:"\\f",b:"\\b",_:"_","~":"~",".":".","-":"-","!":"!",$:"$","&":"&","(":"(",")":")","*":"*","+":"+",",":",",";":";","=":"=","/":"/","?":"?","#":"#","@":"@","%":"%"},c=/[\\x00-\\x20<>\\\\"\\{\\}\\|\\^\\`]/,f={_iri:!0,_unescapedIri:!0,_simpleQuotedString:!0,_langcode:!0,_blank:!0,_newline:!0,_comment:!0,_whitespace:!0,_endOfFile:!0},l=/$0^/;class h{constructor(t){if(this._iri=/^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/,this._unescapedIri=/^<([^\\x00-\\x20<>\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/,this._simpleQuotedString=/^"([^"\\\\\\r\\n]*)"(?=[^"])/,this._simpleApostropheString=/^\'([^\'\\\\\\r\\n]*)\'(?=[^\'])/,this._langcode=/^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i,this._prefix=/^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/,this._prefixed=/^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}"\'<]))/,this._variable=/^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}"\'<])/,this._blank=/^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}"\'<]))/,this._number=/^[\\-+]?(?:\\d+\\.?\\d*([eE](?:[\\-\\+])?\\d+)|\\d*\\.?\\d+)(?=\\.?[,;:\\s#()\\[\\]\\{\\}"\'<])/,this._boolean=/^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}"\'<])/,this._keyword=/^@[a-z]+(?=[\\s#<:])/i,this._sparqlKeyword=/^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i,this._shortPredicates=/^a(?=[\\s()\\[\\]\\{\\}"\'<])/,this._newline=/^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/,this._comment=/#([^\\n\\r]*)/,this._whitespace=/^[ \\t]+/,this._endOfFile=/^(?:#[^\\n\\r]*)?$/,t=t||{},this._lineMode=!!t.lineMode)for(var e in this._n3Mode=!1,this)!(e in f)&&this[e]instanceof RegExp&&(this[e]=l);else this._n3Mode=!1!==t.n3;this._comments=!!t.comments,this._literalClosingPos=0}_tokenizeToEnd(t,e){for(var r=this._input,n=this._comments;;){for(var i,a;i=this._newline.exec(r);)n&&(a=this._comment.exec(i[0]))&&t(null,{line:this._line,type:"comment",value:a[1],prefix:""}),r=r.substr(i[0].length,r.length),this._line++;if(!i&&(i=this._whitespace.exec(r))&&(r=r.substr(i[0].length,r.length)),this._endOfFile.test(r))return e&&(n&&(a=this._comment.exec(r))&&t(null,{line:this._line,type:"comment",value:a[1],prefix:""}),t(r=null,{line:this._line,type:"eof",value:"",prefix:""})),this._input=r;var s=this._line,u="",f="",l="",h=r[0],p=null,d=0,v=!1;switch(h){case"^":if(r.length<3)break;if("^"!==r[1]){this._n3Mode&&(d=1,u="^");break}if(this._previousMarker="^^","<"!==(r=r.substr(2))[0]){v=!0;break}case"<":if(p=this._unescapedIri.exec(r))u="IRI",f=p[1];else if(p=this._iri.exec(r)){if(null===(f=this._unescape(p[1]))||c.test(f))return y(this);u="IRI"}else this._n3Mode&&r.length>1&&"="===r[1]&&(u="inverse",d=2,f=">");break;case"_":((p=this._blank.exec(r))||e&&(p=this._blank.exec(r+" ")))&&(u="blank",l="_",f=p[1]);break;case\'"\':if(p=this._simpleQuotedString.exec(r))f=p[1];else if(({value:f,matchLength:d}=this._parseLiteral(r)),null===f)return y(this);null===p&&0===d||(u="literal",this._literalClosingPos=0);break;case"\'":if(!this._lineMode){if(p=this._simpleApostropheString.exec(r))f=p[1];else if(({value:f,matchLength:d}=this._parseLiteral(r)),null===f)return y(this);null===p&&0===d||(u="literal",this._literalClosingPos=0)}break;case"?":this._n3Mode&&(p=this._variable.exec(r))&&(u="var",f=p[0]);break;case"@":"literal"===this._previousMarker&&(p=this._langcode.exec(r))?(u="langcode",f=p[1]):(p=this._keyword.exec(r))&&(u=p[0]);break;case".":if(1===r.length?e:r[1]<"0"||r[1]>"9"){u=".",d=1;break}case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"+":case"-":(p=this._number.exec(r)||e&&(p=this._number.exec(r+" ")))&&(u="literal",f=p[0],l=p[1]?o.double:/^[+\\-]?\\d+$/.test(p[0])?o.integer:o.decimal);break;case"B":case"b":case"p":case"P":case"G":case"g":(p=this._sparqlKeyword.exec(r))?u=p[0].toUpperCase():v=!0;break;case"f":case"t":(p=this._boolean.exec(r))?(u="literal",f=p[0],l=o.boolean):v=!0;break;case"a":(p=this._shortPredicates.exec(r))?(u="abbreviation",f="a"):v=!0;break;case"=":this._n3Mode&&r.length>1&&(u="abbreviation",">"!==r[1]?(d=1,f="="):(d=2,f=">"));break;case"!":if(!this._n3Mode)break;case",":case";":case"[":case"]":case"(":case")":case"{":case"}":this._lineMode||(d=1,u=h);break;default:v=!0}if(v&&("@prefix"!==this._previousMarker&&"PREFIX"!==this._previousMarker||!(p=this._prefix.exec(r))?((p=this._prefixed.exec(r))||e&&(p=this._prefixed.exec(r+" ")))&&(u="prefixed",l=p[1]||"",f=this._unescape(p[2])):(u="prefix",f=p[1]||"")),"^^"===this._previousMarker)switch(u){case"prefixed":u="type";break;case"IRI":u="typeIRI";break;default:u=""}if(!u)return e||!/^\'\'\'|^"""/.test(r)&&/\\n|\\r/.test(r)?y(this):this._input=r;var g={line:s,type:u,value:f,prefix:l};t(null,g),this.previousToken=g,this._previousMarker=u,r=r.substr(d||p[0].length,r.length)}function y(e){t(e._syntaxError(/^\\S*/.exec(r)[0]))}}_unescape(t){try{return t.replace(s,(function(t,e,r,n){var i;if(e){if(i=parseInt(e,16),isNaN(i))throw new Error;return a(i)}if(r){if(i=parseInt(r,16),isNaN(i))throw new Error;return i<=65535?a(i):a(55296+(i-=65536)/1024,56320+(1023&i))}var o=u[n];if(!o)throw new Error;return o}))}catch(t){return null}}_parseLiteral(t){if(t.length>=3){const e=t.match(/^(?:"""|"|\'\'\'|\'|)/)[0],r=e.length;let n=Math.max(this._literalClosingPos,r);for(;(n=t.indexOf(e,n))>0;){let e=0;for(;"\\\\"===t[n-e-1];)e++;if(e%2==0){const e=t.substring(r,n),i=e.split(/\\r\\n|\\r|\\n/).length-1,o=n+r;if(1===r&&0!==i||3===r&&this._lineMode)break;return this._line+=i,{value:this._unescape(e),matchLength:o}}n++}this._literalClosingPos=t.length-r+1}return{value:"",matchLength:0}}_syntaxError(t){this._input=null;var e=new Error(\'Unexpected "\'+t+\'" on line \'+this._line+".");return e.context={token:void 0,line:this._line,previousToken:this.previousToken},e}tokenize(e,r){var i=this;if(this._line=1,"string"==typeof e){if(this._input=e,"function"!=typeof r){var o,a=[];if(this._tokenizeToEnd((function(t,e){t?o=t:a.push(e)}),!0),o)throw o;return a}t((function(){i._tokenizeToEnd(r,!0)}))}else this._input="",this._pendingBuffer=null,"function"==typeof e.setEncoding&&e.setEncoding("utf8"),e.on("data",(function(t){null!==i._input&&0!==t.length&&(i._pendingBuffer&&(t=n.concat([i._pendingBuffer,t]),i._pendingBuffer=null),128&t[t.length-1]?i._pendingBuffer=t:(i._input+=t,i._tokenizeToEnd(r,!1)))})),e.on("end",(function(){null!==i._input&&i._tokenizeToEnd(r,!0)})),e.on("error",r)}}}).call(this,r(136).setImmediate,r(92).Buffer)},function(t,e,r){t.exports=i;var n=r(93).EventEmitter;function i(){n.call(this)}r(29)(i,n),i.Readable=r(94),i.Writable=r(197),i.Duplex=r(198),i.Transform=r(199),i.PassThrough=r(200),i.Stream=i,i.prototype.pipe=function(t,e){var r=this;function i(e){t.writable&&!1===t.write(e)&&r.pause&&r.pause()}function o(){r.readable&&r.resume&&r.resume()}r.on("data",i),t.on("drain",o),t._isStdio||e&&!1===e.end||(r.on("end",s),r.on("close",u));var a=!1;function s(){a||(a=!0,t.end())}function u(){a||(a=!0,"function"==typeof t.destroy&&t.destroy())}function c(t){if(f(),0===n.listenerCount(this,"error"))throw t}function f(){r.removeListener("data",i),t.removeListener("drain",o),r.removeListener("end",s),r.removeListener("close",u),r.removeListener("error",c),t.removeListener("error",c),r.removeListener("end",f),r.removeListener("close",f),t.removeListener("close",f)}return r.on("error",c),t.on("error",c),r.on("end",f),r.on("close",f),t.on("close",f),t.emit("pipe",r),t}},function(t,e,r){var n=r(4),i=r(63),o=n.WeakMap;t.exports="function"==typeof o&&/native code/.test(i(o))},function(t,e,r){var n=r(12),i=r(46).f,o={}.toString,a="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return a&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return a.slice()}}(t):i(n(t))}},function(t,e,r){"use strict";var n=r(2),i=r(7),o=r(4),a=r(13),s=r(10),u=r(11).f,c=r(101),f=o.Symbol;if(i&&"function"==typeof f&&(!("description"in f.prototype)||void 0!==f().description)){var l={},h=function(){var t=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof h?new f(t):void 0===t?f():f(t);return""===t&&(l[e]=!0),e};c(h,f);var p=h.prototype=f.prototype;p.constructor=h;var d=p.toString,v="Symbol(test)"==String(f("test")),g=/^Symbol\\((.*)\\)[^)]+$/;u(p,"description",{configurable:!0,get:function(){var t=s(this)?this.valueOf():this,e=d.call(t);if(a(l,t))return"";var r=v?e.slice(7,-1):e.replace(g,"$1");return""===r?void 0:r}}),n({global:!0,forced:!0},{Symbol:h})}},function(t,e,r){r(111)("iterator")},function(t,e,r){"use strict";var n=r(115).IteratorPrototype,i=r(70),o=r(31),a=r(49),s=r(34),u=function(){return this};t.exports=function(t,e,r){var c=e+" Iterator";return t.prototype=i(n,{next:o(1,r)}),a(t,c,!1,!0),s[c]=u,t}},function(t,e,r){var n=r(5);t.exports=!n((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype}))},function(t,e,r){var n=r(10);t.exports=function(t){if(!n(t)&&null!==t)throw TypeError("Can\'t set "+String(t)+" as a prototype");return t}},function(t,e,r){"use strict";var n=r(72),i=r(118);t.exports=n?{}.toString:function(){return"[object "+i(this)+"]"}},function(t,e){t.exports=function(t){if(void 0===t)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return t}},function(t,e,r){var n=r(16);t.exports=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=n(t)););return t}},function(t,e,r){var n=r(2),i=r(7);n({target:"Object",stat:!0,forced:!i,sham:!i},{defineProperties:r(108)})},function(t,e,r){var n=r(2),i=r(7);n({target:"Object",stat:!0,forced:!i,sham:!i},{defineProperty:r(11).f})},function(t,e,r){var n=r(2),i=r(160).entries;n({target:"Object",stat:!0},{entries:function(t){return i(t)}})},function(t,e,r){var n=r(7),i=r(48),o=r(12),a=r(59).f,s=function(t){return function(e){for(var r,s=o(e),u=i(s),c=u.length,f=0,l=[];c>f;)r=u[f++],n&&!a.call(s,r)||l.push(t?[r,s[r]]:s[r]);return l}};t.exports={entries:s(!0),values:s(!1)}},function(t,e,r){var n=r(2),i=r(5),o=r(12),a=r(22).f,s=r(7),u=i((function(){a(1)}));n({target:"Object",stat:!0,forced:!s||u,sham:!s},{getOwnPropertyDescriptor:function(t,e){return a(o(t),e)}})},function(t,e,r){var n=r(2),i=r(7),o=r(102),a=r(12),s=r(22),u=r(82);n({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(t){for(var e,r,n=a(t),i=s.f,c=o(n),f={},l=0;c.length>l;)void 0!==(r=i(n,e=c[l++]))&&u(f,e,r);return f}})},function(t,e,r){var n=r(7),i=r(4),o=r(68),a=r(164),s=r(11).f,u=r(46).f,c=r(88),f=r(73),l=r(119),h=r(17),p=r(5),d=r(24).set,v=r(125),g=r(3)("match"),y=i.RegExp,b=y.prototype,_=/a/g,m=/a/g,w=new y(_)!==_,x=l.UNSUPPORTED_Y;if(n&&o("RegExp",!w||x||p((function(){return m[g]=!1,y(_)!=_||y(m)==m||"/a/i"!=y(_,"i")})))){for(var k=function(t,e){var r,n=this instanceof k,i=c(t),o=void 0===e;if(!n&&i&&t.constructor===k&&o)return t;w?i&&!o&&(t=t.source):t instanceof k&&(o&&(e=f.call(t)),t=t.source),x&&(r=!!e&&e.indexOf("y")>-1)&&(e=e.replace(/y/g,""));var s=a(w?new y(t,e):y(t,e),n?this:b,k);return x&&r&&d(s,{sticky:r}),s},E=function(t){t in k||s(k,t,{configurable:!0,get:function(){return y[t]},set:function(e){y[t]=e}})},S=u(y),j=0;S.length>j;)E(S[j++]);b.constructor=k,k.prototype=b,h(i,"RegExp",k)}v("RegExp")},function(t,e,r){var n=r(10),i=r(117);t.exports=function(t,e,r){var o,a;return i&&"function"==typeof(o=e.constructor)&&o!==r&&n(a=o.prototype)&&a!==r.prototype&&i(t,a),t}},function(t,e,r){"use strict";var n=r(17),i=r(8),o=r(5),a=r(73),s=RegExp.prototype,u=s.toString,c=o((function(){return"/a/b"!=u.call({source:"a",flags:"b"})})),f="toString"!=u.name;(c||f)&&n(RegExp.prototype,"toString",(function(){var t=i(this),e=String(t.source),r=t.flags;return"/"+e+"/"+String(void 0===r&&t instanceof RegExp&&!("flags"in s)?a.call(t):r)}),{unsafe:!0})},function(t,e){t.exports=function(t){if(Array.isArray(t))return t}},function(t,e){t.exports=function(t,e){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)){var r=[],n=!0,i=!1,o=void 0;try{for(var a,s=t[Symbol.iterator]();!(n=(a=s.next()).done)&&(r.push(a.value),!e||r.length!==e);n=!0);}catch(t){i=!0,o=t}finally{try{n||null==s.return||s.return()}finally{if(i)throw o}}return r}}},function(t,e){t.exports=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}},function(t,e){t.exports=function(t){if(Array.isArray(t)){for(var e=0,r=new Array(t.length);e<t.length;e++)r[e]=t[e];return r}}},function(t,e){t.exports=function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}},function(t,e){t.exports=function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}},function(t,e,r){t.exports=function(t){function e(t){let e=0;for(let r=0;r<t.length;r++)e=(e<<5)-e+t.charCodeAt(r),e|=0;return n.colors[Math.abs(e)%n.colors.length]}function n(t){let r;function a(...t){if(!a.enabled)return;const e=a,i=Number(new Date),o=i-(r||i);e.diff=o,e.prev=r,e.curr=i,r=i,t[0]=n.coerce(t[0]),"string"!=typeof t[0]&&t.unshift("%O");let s=0;t[0]=t[0].replace(/%([a-zA-Z%])/g,(r,i)=>{if("%%"===r)return r;s++;const o=n.formatters[i];if("function"==typeof o){const n=t[s];r=o.call(e,n),t.splice(s,1),s--}return r}),n.formatArgs.call(e,t),(e.log||n.log).apply(e,t)}return a.namespace=t,a.enabled=n.enabled(t),a.useColors=n.useColors(),a.color=e(t),a.destroy=i,a.extend=o,"function"==typeof n.init&&n.init(a),n.instances.push(a),a}function i(){const t=n.instances.indexOf(this);return-1!==t&&(n.instances.splice(t,1),!0)}function o(t,e){const r=n(this.namespace+(void 0===e?":":e)+t);return r.log=this.log,r}function a(t){return t.toString().substring(2,t.toString().length-2).replace(/\\.\\*\\?$/,"*")}return n.debug=n,n.default=n,n.coerce=function(t){if(t instanceof Error)return t.stack||t.message;return t},n.disable=function(){const t=[...n.names.map(a),...n.skips.map(a).map(t=>"-"+t)].join(",");return n.enable(""),t},n.enable=function(t){let e;n.save(t),n.names=[],n.skips=[];const r=("string"==typeof t?t:"").split(/[\\s,]+/),i=r.length;for(e=0;e<i;e++)r[e]&&("-"===(t=r[e].replace(/\\*/g,".*?"))[0]?n.skips.push(new RegExp("^"+t.substr(1)+"$")):n.names.push(new RegExp("^"+t+"$")));for(e=0;e<n.instances.length;e++){const t=n.instances[e];t.enabled=n.enabled(t.namespace)}},n.enabled=function(t){if("*"===t[t.length-1])return!0;let e,r;for(e=0,r=n.skips.length;e<r;e++)if(n.skips[e].test(t))return!1;for(e=0,r=n.names.length;e<r;e++)if(n.names[e].test(t))return!0;return!1},n.humanize=r(173),Object.keys(t).forEach(e=>{n[e]=t[e]}),n.instances=[],n.names=[],n.skips=[],n.formatters={},n.selectColor=e,n.enable(n.load()),n}},function(t,e){var r=1e3,n=6e4,i=60*n,o=24*i;function a(t,e,r,n){var i=e>=1.5*r;return Math.round(t/r)+" "+n+(i?"s":"")}t.exports=function(t,e){e=e||{};var s=typeof t;if("string"===s&&t.length>0)return function(t){if((t=String(t)).length>100)return;var e=/^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);if(!e)return;var a=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*a;case"weeks":case"week":case"w":return 6048e5*a;case"days":case"day":case"d":return a*o;case"hours":case"hour":case"hrs":case"hr":case"h":return a*i;case"minutes":case"minute":case"mins":case"min":case"m":return a*n;case"seconds":case"second":case"secs":case"sec":case"s":return a*r;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return a;default:return}}(t);if("number"===s&&isFinite(t))return e.long?function(t){var e=Math.abs(t);if(e>=o)return a(t,e,o,"day");if(e>=i)return a(t,e,i,"hour");if(e>=n)return a(t,e,n,"minute");if(e>=r)return a(t,e,r,"second");return t+" ms"}(t):function(t){var e=Math.abs(t);if(e>=o)return Math.round(t/o)+"d";if(e>=i)return Math.round(t/i)+"h";if(e>=n)return Math.round(t/n)+"m";if(e>=r)return Math.round(t/r)+"s";return t+"ms"}(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,r){"use strict";var n=r(2),i=r(33).every;n({target:"Array",proto:!0,forced:r(36)("every")},{every:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},function(t,e,r){"use strict";var n=r(12),i=r(32),o=r(15),a=r(36),s=Math.min,u=[].lastIndexOf,c=!!u&&1/[1].lastIndexOf(1,-0)<0,f=a("lastIndexOf");t.exports=c||f?function(t){if(c)return u.apply(this,arguments)||0;var e=n(this),r=o(e.length),a=r-1;for(arguments.length>1&&(a=s(a,i(arguments[1]))),a<0&&(a=r+a);a>=0;a--)if(a in e&&e[a]===t)return a||0;return-1}:u},function(t,e,r){"use strict";var n=r(76),i=r(88),o=r(8),a=r(20),s=r(132),u=r(77),c=r(15),f=r(78),l=r(53),h=r(5),p=[].push,d=Math.min,v=!h((function(){return!RegExp(4294967295,"y")}));n("split",2,(function(t,e,r){var n;return n="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(t,r){var n=String(a(this)),o=void 0===r?4294967295:r>>>0;if(0===o)return[];if(void 0===t)return[n];if(!i(t))return e.call(n,t,o);for(var s,u,c,f=[],h=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),d=0,v=new RegExp(t.source,h+"g");(s=l.call(v,n))&&!((u=v.lastIndex)>d&&(f.push(n.slice(d,s.index)),s.length>1&&s.index<n.length&&p.apply(f,s.slice(1)),c=s[0].length,d=u,f.length>=o));)v.lastIndex===s.index&&v.lastIndex++;return d===n.length?!c&&v.test("")||f.push(""):f.push(n.slice(d)),f.length>o?f.slice(0,o):f}:"0".split(void 0,0).length?function(t,r){return void 0===t&&0===r?[]:e.call(this,t,r)}:e,[function(e,r){var i=a(this),o=null==e?void 0:e[t];return void 0!==o?o.call(e,i,r):n.call(String(i),e,r)},function(t,i){var a=r(n,t,this,i,n!==e);if(a.done)return a.value;var l=o(t),h=String(this),p=s(l,RegExp),g=l.unicode,y=(l.ignoreCase?"i":"")+(l.multiline?"m":"")+(l.unicode?"u":"")+(v?"y":"g"),b=new p(v?l:"^(?:"+l.source+")",y),_=void 0===i?4294967295:i>>>0;if(0===_)return[];if(0===h.length)return null===f(b,h)?[h]:[];for(var m=0,w=0,x=[];w<h.length;){b.lastIndex=v?w:0;var k,E=f(b,v?h:h.slice(w));if(null===E||(k=d(c(b.lastIndex+(v?0:w)),h.length))===m)w=u(h,w,g);else{if(x.push(h.slice(m,w)),x.length===_)return x;for(var S=1;S<=E.length-1;S++)if(x.push(E[S]),x.length===_)return x;w=m=k}}return x.push(h.slice(m)),x}]}),!v)},function(t,e,r){var n=r(4);t.exports=n.Promise},function(t,e,r){var n=r(17);t.exports=function(t,e,r){for(var i in e)n(t,i,e[i],r);return t}},function(t,e){t.exports=function(t,e,r){if(!(t instanceof e))throw TypeError("Incorrect "+(r?r+" ":"")+"invocation");return t}},function(t,e,r){var n=r(8),i=r(181),o=r(15),a=r(71),s=r(182),u=r(183),c=function(t,e){this.stopped=t,this.result=e};(t.exports=function(t,e,r,f,l){var h,p,d,v,g,y,b,_=a(e,r,f?2:1);if(l)h=t;else{if("function"!=typeof(p=s(t)))throw TypeError("Target is not iterable");if(i(p)){for(d=0,v=o(t.length);v>d;d++)if((g=f?_(n(b=t[d])[0],b[1]):_(t[d]))&&g instanceof c)return g;return new c(!1)}h=p.call(t)}for(y=h.next;!(b=y.call(h)).done;)if("object"==typeof(g=u(h,_,b.value,f))&&g&&g instanceof c)return g;return new c(!1)}).stop=function(t){return new c(!0,t)}},function(t,e,r){var n=r(3),i=r(34),o=n("iterator"),a=Array.prototype;t.exports=function(t){return void 0!==t&&(i.Array===t||a[o]===t)}},function(t,e,r){var n=r(118),i=r(34),o=r(3)("iterator");t.exports=function(t){if(null!=t)return t[o]||t["@@iterator"]||i[n(t)]}},function(t,e,r){var n=r(8);t.exports=function(t,e,r,i){try{return i?e(n(r)[0],r[1]):e(r)}catch(e){var o=t.return;throw void 0!==o&&n(o.call(t)),e}}},function(t,e,r){var n=r(3)("iterator"),i=!1;try{var o=0,a={next:function(){return{done:!!o++}},return:function(){i=!0}};a[n]=function(){return this},Array.from(a,(function(){throw 2}))}catch(t){}t.exports=function(t,e){if(!e&&!i)return!1;var r=!1;try{var o={};o[n]=function(){return{next:function(){return{done:r=!0}}}},t(o)}catch(t){}return r}},function(t,e,r){var n,i,o,a,s,u,c,f,l=r(4),h=r(22).f,p=r(19),d=r(133).set,v=r(134),g=l.MutationObserver||l.WebKitMutationObserver,y=l.process,b=l.Promise,_="process"==p(y),m=h(l,"queueMicrotask"),w=m&&m.value;w||(n=function(){var t,e;for(_&&(t=y.domain)&&t.exit();i;){e=i.fn,i=i.next;try{e()}catch(t){throw i?a():o=void 0,t}}o=void 0,t&&t.enter()},_?a=function(){y.nextTick(n)}:g&&!v?(s=!0,u=document.createTextNode(""),new g(n).observe(u,{characterData:!0}),a=function(){u.data=s=!s}):b&&b.resolve?(c=b.resolve(void 0),f=c.then,a=function(){f.call(c,n)}):a=function(){d.call(l,n)}),t.exports=w||function(t){var e={fn:t,next:void 0};o&&(o.next=e),i||(i=e,a()),o=e}},function(t,e,r){var n=r(8),i=r(10),o=r(135);t.exports=function(t,e){if(n(t),i(e)&&e.constructor===t)return e;var r=o.f(t);return(0,r.resolve)(e),r.promise}},function(t,e,r){var n=r(4);t.exports=function(t,e){var r=n.console;r&&r.error&&(1===arguments.length?r.error(t):r.error(t,e))}},function(t,e){t.exports=function(t){try{return{error:!1,value:t()}}catch(t){return{error:!0,value:t}}}},function(t,e,r){(function(t,e){!function(t,r){"use strict";if(!t.setImmediate){var n,i,o,a,s,u=1,c={},f=!1,l=t.document,h=Object.getPrototypeOf&&Object.getPrototypeOf(t);h=h&&h.setTimeout?h:t,"[object process]"==={}.toString.call(t.process)?n=function(t){e.nextTick((function(){d(t)}))}:!function(){if(t.postMessage&&!t.importScripts){var e=!0,r=t.onmessage;return t.onmessage=function(){e=!1},t.postMessage("","*"),t.onmessage=r,e}}()?t.MessageChannel?((o=new MessageChannel).port1.onmessage=function(t){d(t.data)},n=function(t){o.port2.postMessage(t)}):l&&"onreadystatechange"in l.createElement("script")?(i=l.documentElement,n=function(t){var e=l.createElement("script");e.onreadystatechange=function(){d(t),e.onreadystatechange=null,i.removeChild(e),e=null},i.appendChild(e)}):n=function(t){setTimeout(d,0,t)}:(a="setImmediate$"+Math.random()+"$",s=function(e){e.source===t&&"string"==typeof e.data&&0===e.data.indexOf(a)&&d(+e.data.slice(a.length))},t.addEventListener?t.addEventListener("message",s,!1):t.attachEvent("onmessage",s),n=function(e){t.postMessage(a+e,"*")}),h.setImmediate=function(t){"function"!=typeof t&&(t=new Function(""+t));for(var e=new Array(arguments.length-1),r=0;r<e.length;r++)e[r]=arguments[r+1];var i={callback:t,args:e};return c[u]=i,n(u),u++},h.clearImmediate=p}function p(t){delete c[t]}function d(t){if(f)setTimeout(d,0,t);else{var e=c[t];if(e){f=!0;try{!function(t){var e=t.callback,r=t.args;switch(r.length){case 0:e();break;case 1:e(r[0]);break;case 2:e(r[0],r[1]);break;case 3:e(r[0],r[1],r[2]);break;default:e.apply(void 0,r)}}(e)}finally{p(t),f=!1}}}}}("undefined"==typeof self?void 0===t?this:t:self)}).call(this,r(21),r(38))},function(t,e,r){"use strict";e.byteLength=function(t){var e=c(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function(t){var e,r,n=c(t),a=n[0],s=n[1],u=new o(function(t,e,r){return 3*(e+r)/4-r}(0,a,s)),f=0,l=s>0?a-4:a;for(r=0;r<l;r+=4)e=i[t.charCodeAt(r)]<<18|i[t.charCodeAt(r+1)]<<12|i[t.charCodeAt(r+2)]<<6|i[t.charCodeAt(r+3)],u[f++]=e>>16&255,u[f++]=e>>8&255,u[f++]=255&e;2===s&&(e=i[t.charCodeAt(r)]<<2|i[t.charCodeAt(r+1)]>>4,u[f++]=255&e);1===s&&(e=i[t.charCodeAt(r)]<<10|i[t.charCodeAt(r+1)]<<4|i[t.charCodeAt(r+2)]>>2,u[f++]=e>>8&255,u[f++]=255&e);return u},e.fromByteArray=function(t){for(var e,r=t.length,i=r%3,o=[],a=0,s=r-i;a<s;a+=16383)o.push(f(t,a,a+16383>s?s:a+16383));1===i?(e=t[r-1],o.push(n[e>>2]+n[e<<4&63]+"==")):2===i&&(e=(t[r-2]<<8)+t[r-1],o.push(n[e>>10]+n[e>>4&63]+n[e<<2&63]+"="));return o.join("")};for(var n=[],i=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,u=a.length;s<u;++s)n[s]=a[s],i[a.charCodeAt(s)]=s;function c(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function f(t,e,r){for(var i,o,a=[],s=e;s<r;s+=3)i=(t[s]<<16&16711680)+(t[s+1]<<8&65280)+(255&t[s+2]),a.push(n[(o=i)>>18&63]+n[o>>12&63]+n[o>>6&63]+n[63&o]);return a.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(t,e){e.read=function(t,e,r,n,i){var o,a,s=8*i-n-1,u=(1<<s)-1,c=u>>1,f=-7,l=r?i-1:0,h=r?-1:1,p=t[e+l];for(l+=h,o=p&(1<<-f)-1,p>>=-f,f+=s;f>0;o=256*o+t[e+l],l+=h,f-=8);for(a=o&(1<<-f)-1,o>>=-f,f+=n;f>0;a=256*a+t[e+l],l+=h,f-=8);if(0===o)o=1-c;else{if(o===u)return a?NaN:1/0*(p?-1:1);a+=Math.pow(2,n),o-=c}return(p?-1:1)*a*Math.pow(2,o-n)},e.write=function(t,e,r,n,i,o){var a,s,u,c=8*o-i-1,f=(1<<c)-1,l=f>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:o-1,d=n?1:-1,v=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,a=f):(a=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-a))<1&&(a--,u*=2),(e+=a+l>=1?h/u:h*Math.pow(2,1-l))*u>=2&&(a++,u/=2),a+l>=f?(s=0,a=f):a+l>=1?(s=(e*u-1)*Math.pow(2,i),a+=l):(s=e*Math.pow(2,l-1)*Math.pow(2,i),a=0));i>=8;t[r+p]=255&s,p+=d,s/=256,i-=8);for(a=a<<i|s,c+=i;c>0;t[r+p]=255&a,p+=d,a/=256,c-=8);t[r+p-d]|=128*v}},function(t,e){},function(t,e,r){"use strict";var n=r(56).Buffer,i=r(194);t.exports=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.head=null,this.tail=null,this.length=0}return t.prototype.push=function(t){var e={data:t,next:null};this.length>0?this.tail.next=e:this.head=e,this.tail=e,++this.length},t.prototype.unshift=function(t){var e={data:t,next:this.head};0===this.length&&(this.tail=e),this.head=e,++this.length},t.prototype.shift=function(){if(0!==this.length){var t=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,t}},t.prototype.clear=function(){this.head=this.tail=null,this.length=0},t.prototype.join=function(t){if(0===this.length)return"";for(var e=this.head,r=""+e.data;e=e.next;)r+=t+e.data;return r},t.prototype.concat=function(t){if(0===this.length)return n.alloc(0);if(1===this.length)return this.head.data;for(var e,r,i,o=n.allocUnsafe(t>>>0),a=this.head,s=0;a;)e=a.data,r=o,i=s,e.copy(r,i),s+=a.data.length,a=a.next;return o},t}(),i&&i.inspect&&i.inspect.custom&&(t.exports.prototype[i.inspect.custom]=function(){var t=i.inspect({length:this.length});return this.constructor.name+" "+t})},function(t,e){},function(t,e,r){(function(e){function r(t){try{if(!e.localStorage)return!1}catch(t){return!1}var r=e.localStorage[t];return null!=r&&"true"===String(r).toLowerCase()}t.exports=function(t,e){if(r("noDeprecation"))return t;var n=!1;return function(){if(!n){if(r("throwDeprecation"))throw new Error(e);r("traceDeprecation")?console.trace(e):console.warn(e),n=!0}return t.apply(this,arguments)}}}).call(this,r(21))},function(t,e,r){"use strict";t.exports=o;var n=r(142),i=r(39);function o(t){if(!(this instanceof o))return new o(t);n.call(this,t)}i.inherits=r(29),i.inherits(o,n),o.prototype._transform=function(t,e,r){r(null,t)}},function(t,e,r){t.exports=r(95)},function(t,e,r){t.exports=r(23)},function(t,e,r){t.exports=r(94).Transform},function(t,e,r){t.exports=r(94).PassThrough},function(t,e,r){"use strict";var n=r(2),i=r(60),o=r(12),a=r(36),s=[].join,u=i!=Object,c=a("join",",");n({target:"Array",proto:!0,forced:u||c},{join:function(t){return s.call(o(this),void 0===t?",":t)}})},function(t,e){t.exports=function(t){return-1!==Function.toString.call(t).indexOf("[native code]")}},function(t,e,r){var n=r(80);function i(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}function o(e,r,a){return i()?t.exports=o=Reflect.construct:t.exports=o=function(t,e,r){var i=[null];i.push.apply(i,e);var o=new(Function.bind.apply(t,i));return r&&n(o,r.prototype),o},o.apply(null,arguments)}t.exports=o},function(t,e,r){"use strict";var n=r(2),i=r(66).indexOf,o=r(36),a=[].indexOf,s=!!a&&1/[1].indexOf(1,-0)<0,u=o("indexOf");n({target:"Array",proto:!0,forced:s||u},{indexOf:function(t){return s?a.apply(this,arguments)||0:i(this,t,arguments.length>1?arguments[1]:void 0)}})},function(t,e,r){"use strict";r.r(e);r(98),r(149),r(150),r(51),r(52),r(35),r(74),r(75),r(79);var n=r(0),i=r.n(n),o=(r(28),r(1)),a=r.n(o),s=r(18),u=r.n(s),c=r(30),f=r.n(c),l=r(40),h=r.n(l),p=r(16),d=r.n(p),v=r(57),g=r.n(v),y=r(41),b=r.n(y),_=(r(81),r(84),r(85),r(86),r(37),r(87),r(157),r(158),r(159),r(161),r(162),r(124),r(163),r(165),r(126),r(129),r(89),r(90),r(42)),m=r.n(_),w=r(9),x=r.n(w),k=r(143),E=r.n(k),S=r(58),j=r.n(S),R=(r(174),r(130),r(131),r(176),function(t){for(;t.endsWith("/");)t=t.slice(0,-1);return t}),C=function(t){for(var e=t.split("/"),r=e[0],n=0,i=1;i<e.length-1;i++){n=i,""===e[i]&&(r+="/");break}return r=r+"/"+e[n+1]+"/"},I=function(t){return(t=R(t)).substring(0,t.lastIndexOf("/")+1)},O=function(t){return(t=R(t)).substr(t.lastIndexOf("/")+1)},T=function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return e.every((function(t){return t.endsWith("/")}))},P=function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return e.every((function(t){return!t.endsWith("/")}))},A={CONTAINER:\'<http://www.w3.org/ns/ldp#BasicContainer>; rel="type"\',RESOURCE:\'<http://www.w3.org/ns/ldp#Resource>; rel="type"\'},L=(r(91),r(96)),F=r.n(L),M=r(6);const{rdf:N,xsd:B}=M.a;var D,U,q=0;class G{constructor(t){this.id=t}get value(){return this.id}equals(t){return t instanceof G?this.id===t.id:!!t&&this.termType===t.termType&&this.value===t.value}toJSON(){return{termType:this.termType,value:this.value}}}class W extends G{get termType(){return"NamedNode"}}class z extends G{get termType(){return"Literal"}get value(){return this.id.substring(1,this.id.lastIndexOf(\'"\'))}get language(){var t=this.id,e=t.lastIndexOf(\'"\')+1;return e<t.length&&"@"===t[e++]?t.substr(e).toLowerCase():""}get datatype(){return new W(this.datatypeString)}get datatypeString(){var t,e=this.id,r=e.lastIndexOf(\'"\')+1;return r<e.length&&"^"===(t=e[r])?e.substr(r+2):"@"!==t?B.string:N.langString}equals(t){return t instanceof z?this.id===t.id:!!t&&!!t.datatype&&this.termType===t.termType&&this.value===t.value&&this.language===t.language&&this.datatype.value===t.datatype.value}toJSON(){return{termType:this.termType,value:this.value,language:this.language,datatype:{termType:"NamedNode",value:this.datatypeString}}}}class Y extends G{constructor(t){super("_:"+t)}get termType(){return"BlankNode"}get value(){return this.id.substr(2)}}class Q extends G{constructor(t){super("?"+t)}get termType(){return"Variable"}get value(){return this.id.substr(1)}}class $ extends G{constructor(){return super(""),U||this}get termType(){return"DefaultGraph"}equals(t){return this===t||!!t&&this.termType===t.termType}}U=new $;class H{constructor(t,e,r,n){this.subject=t,this.predicate=e,this.object=r,this.graph=n||U}toJSON(){return{subject:this.subject.toJSON(),predicate:this.predicate.toJSON(),object:this.object.toJSON(),graph:this.graph.toJSON()}}equals(t){return!!t&&this.subject.equals(t.subject)&&this.predicate.equals(t.predicate)&&this.object.equals(t.object)&&this.graph.equals(t.graph)}}var K=D={namedNode:function(t){return new W(t)},blankNode:function(t){t||(t="n3-"+q++);return new Y(t)},variable:function(t){return new Q(t)},literal:function(t,e){if("string"==typeof e)return new z(\'"\'+t+\'"@\'+e.toLowerCase());let r=e?e.value:"";""===r&&("boolean"==typeof t?r=B.boolean:"number"==typeof t&&(Number.isFinite(t)?r=Number.isInteger(t)?B.integer:B.double:(r=B.double,Number.isNaN(t)||(t=t>0?"INF":"-INF"))));return""===r||r===B.string?new z(\'"\'+t+\'"\'):new z(\'"\'+t+\'"^^\'+r)},defaultGraph:function(){return U},quad:V,triple:V,internal:{Term:G,NamedNode:W,BlankNode:Y,Variable:Q,Literal:z,DefaultGraph:$,Quad:H,Triple:H,fromId:function(t,e){if(e=e||D,!t)return e.defaultGraph();switch(t[0]){case"_":return e.blankNode(t.substr(2));case"?":return e.variable(t.substr(1));case\'"\':if(e===D)return new z(t);if(\'"\'===t[t.length-1])return e.literal(t.substr(1,t.length-2));var r=t.lastIndexOf(\'"\',t.length-1);return e.literal(t.substr(1,r-1),"@"===t[r+1]?t.substr(r+2):e.namedNode(t.substr(r+3)));default:return e.namedNode(t)}},toId:function(t){if("string"==typeof t)return t;if(t instanceof G)return t.id;if(!t)return U.id;switch(t.termType){case"NamedNode":return t.value;case"BlankNode":return"_:"+t.value;case"Variable":return"?"+t.value;case"DefaultGraph":return"";case"Literal":return\'"\'+t.value+\'"\'+(t.language?"@"+t.language:t.datatype&&t.datatype.value!==B.string?"^^"+t.datatype.value:"");default:throw new Error("Unexpected termType: "+t.termType)}}}};function V(t,e,r,n){return new H(t,e,r,n)}var Z=r(145),J=0,X=0;class tt{constructor(t){this._contextStack=[],this._graph=null,t=t||{},this._setBase(t.baseIRI),t.factory&&rt(this,t.factory);var e="string"==typeof t.format?t.format.match(/\\w*$/)[0].toLowerCase():"",r="turtle"===e,n="trig"===e,i=/triple/.test(e),o=/quad/.test(e),a=this._n3Mode=/n3/.test(e),s=i||o;(this._supportsNamedGraphs=!(r||a))||(this._readPredicateOrNamedGraph=this._readPredicate),this._supportsQuads=!(r||n||i||a),s&&(this._resolveRelativeIRI=function(t){return null}),this._blankNodePrefix="string"!=typeof t.blankNodePrefix?"":t.blankNodePrefix.replace(/^(?!_:)/,"_:"),this._lexer=t.lexer||new Z.a({lineMode:s,n3:a}),this._explicitQuantifiers=!!t.explicitQuantifiers}static _resetBlankNodeIds(){J=X=0}_blank(){return this._blankNode("b"+X++)}_setBase(t){if(t){var e=t.indexOf("#");e>=0&&(t=t.substr(0,e)),this._base=t,this._basePath=t.indexOf("/")<0?t:t.replace(/[^\\/?]*(?:\\?.*)?$/,""),t=t.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i),this._baseRoot=t[0],this._baseScheme=t[1]}else this._base="",this._basePath=""}_saveContext(t,e,r,n,i){var o=this._n3Mode;this._contextStack.push({subject:r,predicate:n,object:i,graph:e,type:t,inverse:!!o&&this._inversePredicate,blankPrefix:o?this._prefixes._:"",quantified:o?this._quantified:null}),o&&(this._inversePredicate=!1,this._prefixes._=this._graph?this._graph.id.substr(2)+".":".",this._quantified=Object.create(this._quantified))}_restoreContext(){var t=this._contextStack.pop(),e=this._n3Mode;this._subject=t.subject,this._predicate=t.predicate,this._object=t.object,this._graph=t.graph,e&&(this._inversePredicate=t.inverse,this._prefixes._=t.blankPrefix,this._quantified=t.quantified)}_readInTopContext(t){switch(t.type){case"eof":return null!==this._graph?this._error("Unclosed graph",t):(delete this._prefixes._,this._callback(null,null,this._prefixes));case"PREFIX":this._sparqlStyle=!0;case"@prefix":return this._readPrefix;case"BASE":this._sparqlStyle=!0;case"@base":return this._readBaseIRI;case"{":if(this._supportsNamedGraphs)return this._graph="",this._subject=null,this._readSubject;case"GRAPH":if(this._supportsNamedGraphs)return this._readNamedGraphLabel;default:return this._readSubject(t)}}_readEntity(t,e){var r;switch(t.type){case"IRI":case"typeIRI":var n=this._resolveIRI(t.value);if(null===n)return this._error("Invalid IRI",t);r=this._namedNode(n);break;case"type":case"prefixed":var i=this._prefixes[t.prefix];if(void 0===i)return this._error(\'Undefined prefix "\'+t.prefix+\':"\',t);r=this._namedNode(i+t.value);break;case"blank":r=this._blankNode(this._prefixes[t.prefix]+t.value);break;case"var":r=this._variable(t.value.substr(1));break;default:return this._error("Expected entity but got "+t.type,t)}return!e&&this._n3Mode&&r.id in this._quantified&&(r=this._quantified[r.id]),r}_readSubject(t){switch(this._predicate=null,t.type){case"[":return this._saveContext("blank",this._graph,this._subject=this._blank(),null,null),this._readBlankNodeHead;case"(":return this._saveContext("list",this._graph,this.RDF_NIL,null,null),this._subject=null,this._readListItem;case"{":return this._n3Mode?(this._saveContext("formula",this._graph,this._graph=this._blank(),null,null),this._readSubject):this._error("Unexpected graph",t);case"}":return this._readPunctuation(t);case"@forSome":return this._n3Mode?(this._subject=null,this._predicate=this.N3_FORSOME,this._quantifier=this._blankNode,this._readQuantifierList):this._error(\'Unexpected "@forSome"\',t);case"@forAll":return this._n3Mode?(this._subject=null,this._predicate=this.N3_FORALL,this._quantifier=this._variable,this._readQuantifierList):this._error(\'Unexpected "@forAll"\',t);default:if(void 0===(this._subject=this._readEntity(t)))return;if(this._n3Mode)return this._getPathReader(this._readPredicateOrNamedGraph)}return this._readPredicateOrNamedGraph}_readPredicate(t){var e=t.type;switch(e){case"inverse":this._inversePredicate=!0;case"abbreviation":this._predicate=this.ABBREVIATIONS[t.value];break;case".":case"]":case"}":return null===this._predicate?this._error("Unexpected "+e,t):(this._subject=null,"]"===e?this._readBlankNodeTail(t):this._readPunctuation(t));case";":return null!==this._predicate?this._readPredicate:this._error("Expected predicate but got ;",t);case"blank":if(!this._n3Mode)return this._error("Disallowed blank node as predicate",t);default:if(void 0===(this._predicate=this._readEntity(t)))return}return this._readObject}_readObject(t){switch(t.type){case"literal":if(0===t.prefix.length)return this._literalValue=t.value,this._readDataTypeOrLang;this._object=this._literal(t.value,this._namedNode(t.prefix));break;case"[":return this._saveContext("blank",this._graph,this._subject,this._predicate,this._subject=this._blank()),this._readBlankNodeHead;case"(":return this._saveContext("list",this._graph,this._subject,this._predicate,this.RDF_NIL),this._subject=null,this._readListItem;case"{":return this._n3Mode?(this._saveContext("formula",this._graph,this._subject,this._predicate,this._graph=this._blank()),this._readSubject):this._error("Unexpected graph",t);default:if(void 0===(this._object=this._readEntity(t)))return;if(this._n3Mode)return this._getPathReader(this._getContextEndReader())}return this._getContextEndReader()}_readPredicateOrNamedGraph(t){return"{"===t.type?this._readGraph(t):this._readPredicate(t)}_readGraph(t){return"{"!==t.type?this._error("Expected graph but got "+t.type,t):(this._graph=this._subject,this._subject=null,this._readSubject)}_readBlankNodeHead(t){return"]"===t.type?(this._subject=null,this._readBlankNodeTail(t)):(this._predicate=null,this._readPredicate(t))}_readBlankNodeTail(t){if("]"!==t.type)return this._readBlankNodePunctuation(t);null!==this._subject&&this._emit(this._subject,this._predicate,this._object,this._graph);var e=null===this._predicate;return this._restoreContext(),null===this._object?e?this._readPredicateOrNamedGraph:this._readPredicateAfterBlank:this._getContextEndReader()}_readPredicateAfterBlank(t){switch(t.type){case".":case"}":return this._subject=null,this._readPunctuation(t);default:return this._readPredicate(t)}}_readListItem(t){var e=null,r=null,n=this._subject,i=this._contextStack,o=i[i.length-1],a=this._readListItem;switch(t.type){case"[":this._saveContext("blank",this._graph,r=this._blank(),this.RDF_FIRST,this._subject=e=this._blank()),a=this._readBlankNodeHead;break;case"(":this._saveContext("list",this._graph,r=this._blank(),this.RDF_FIRST,this.RDF_NIL),this._subject=null;break;case")":if(this._restoreContext(),0!==i.length&&"list"===i[i.length-1].type&&this._emit(this._subject,this._predicate,this._object,this._graph),null===this._predicate){if(a=this._readPredicate,this._subject===this.RDF_NIL)return a}else if(a=this._getContextEndReader(),this._object===this.RDF_NIL)return a;r=this.RDF_NIL;break;case"literal":0===t.prefix.length?(this._literalValue=t.value,a=this._readListItemDataTypeOrLang):(e=this._literal(t.value,this._namedNode(t.prefix)),a=this._getContextEndReader());break;default:if(void 0===(e=this._readEntity(t)))return}if(null===r&&(this._subject=r=this._blank()),null===n?null===o.predicate?o.subject=r:o.object=r:this._emit(n,this.RDF_REST,r,this._graph),null!==e){if(this._n3Mode&&("IRI"===t.type||"prefixed"===t.type))return this._saveContext("item",this._graph,r,this.RDF_FIRST,e),this._subject=e,this._predicate=null,this._getPathReader(this._readListItem);this._emit(r,this.RDF_FIRST,e,this._graph)}return a}_readDataTypeOrLang(t){return this._completeLiteral(t,!1)}_readListItemDataTypeOrLang(t){return this._completeLiteral(t,!0)}_completeLiteral(t,e){switch(t.type){case"type":case"typeIRI":var r=this._readEntity(t);if(void 0===r)return;this._object=this._literal(this._literalValue,r),t=null;break;case"langcode":this._object=this._literal(this._literalValue,t.value),t=null;break;default:this._object=this._literal(this._literalValue)}return e&&this._emit(this._subject,this.RDF_FIRST,this._object,this._graph),null===t?this._getContextEndReader():(this._readCallback=this._getContextEndReader(),this._readCallback(t))}_readFormulaTail(t){return"}"!==t.type?this._readPunctuation(t):(null!==this._subject&&this._emit(this._subject,this._predicate,this._object,this._graph),this._restoreContext(),null===this._object?this._readPredicate:this._getContextEndReader())}_readPunctuation(t){var e,r=this._subject,n=this._graph,i=this._inversePredicate;switch(t.type){case"}":if(null===this._graph)return this._error("Unexpected graph closing",t);if(this._n3Mode)return this._readFormulaTail(t);this._graph=null;case".":this._subject=null,e=this._contextStack.length?this._readSubject:this._readInTopContext,i&&(this._inversePredicate=!1);break;case";":e=this._readPredicate;break;case",":e=this._readObject;break;default:if(this._supportsQuads&&null===this._graph&&void 0!==(n=this._readEntity(t))){e=this._readQuadPunctuation;break}return this._error(\'Expected punctuation to follow "\'+this._object.id+\'"\',t)}if(null!==r){var o=this._predicate,a=this._object;i?this._emit(a,o,r,n):this._emit(r,o,a,n)}return e}_readBlankNodePunctuation(t){var e;switch(t.type){case";":e=this._readPredicate;break;case",":e=this._readObject;break;default:return this._error(\'Expected punctuation to follow "\'+this._object.id+\'"\',t)}return this._emit(this._subject,this._predicate,this._object,this._graph),e}_readQuadPunctuation(t){return"."!==t.type?this._error("Expected dot to follow quad",t):this._readInTopContext}_readPrefix(t){return"prefix"!==t.type?this._error("Expected prefix to follow @prefix",t):(this._prefix=t.value,this._readPrefixIRI)}_readPrefixIRI(t){if("IRI"!==t.type)return this._error(\'Expected IRI to follow prefix "\'+this._prefix+\':"\',t);var e=this._readEntity(t);return this._prefixes[this._prefix]=e.value,this._prefixCallback(this._prefix,e),this._readDeclarationPunctuation}_readBaseIRI(t){var e="IRI"===t.type&&this._resolveIRI(t.value);return e?(this._setBase(e),this._readDeclarationPunctuation):this._error("Expected valid IRI to follow base declaration",t)}_readNamedGraphLabel(t){switch(t.type){case"IRI":case"blank":case"prefixed":return this._readSubject(t),this._readGraph;case"[":return this._readNamedGraphBlankLabel;default:return this._error("Invalid graph label",t)}}_readNamedGraphBlankLabel(t){return"]"!==t.type?this._error("Invalid graph label",t):(this._subject=this._blank(),this._readGraph)}_readDeclarationPunctuation(t){return this._sparqlStyle?(this._sparqlStyle=!1,this._readInTopContext(t)):"."!==t.type?this._error("Expected declaration to end with a dot",t):this._readInTopContext}_readQuantifierList(t){var e;switch(t.type){case"IRI":case"prefixed":if(void 0!==(e=this._readEntity(t,!0)))break;default:return this._error("Unexpected "+t.type,t)}return this._explicitQuantifiers?(null===this._subject?this._emit(this._graph||this.DEFAULTGRAPH,this._predicate,this._subject=this._blank(),this.QUANTIFIERS_GRAPH):this._emit(this._subject,this.RDF_REST,this._subject=this._blank(),this.QUANTIFIERS_GRAPH),this._emit(this._subject,this.RDF_FIRST,e,this.QUANTIFIERS_GRAPH)):this._quantified[e.id]=this._quantifier("b"+X++),this._readQuantifierPunctuation}_readQuantifierPunctuation(t){return","===t.type?this._readQuantifierList:(this._explicitQuantifiers&&(this._emit(this._subject,this.RDF_REST,this.RDF_NIL,this.QUANTIFIERS_GRAPH),this._subject=null),this._readCallback=this._getContextEndReader(),this._readCallback(t))}_getPathReader(t){return this._afterPath=t,this._readPath}_readPath(t){switch(t.type){case"!":return this._readForwardPath;case"^":return this._readBackwardPath;default:var e=this._contextStack,r=e.length&&e[e.length-1];if(r&&"item"===r.type){var n=this._subject;this._restoreContext(),this._emit(this._subject,this.RDF_FIRST,n,this._graph)}return this._afterPath(t)}}_readForwardPath(t){var e,r,n=this._blank();if(void 0!==(r=this._readEntity(t)))return null===this._predicate?(e=this._subject,this._subject=n):(e=this._object,this._object=n),this._emit(e,r,n,this._graph),this._readPath}_readBackwardPath(t){var e,r,n=this._blank();if(void 0!==(e=this._readEntity(t)))return null===this._predicate?(r=this._subject,this._subject=n):(r=this._object,this._object=n),this._emit(n,e,r,this._graph),this._readPath}_getContextEndReader(){var t=this._contextStack;if(!t.length)return this._readPunctuation;switch(t[t.length-1].type){case"blank":return this._readBlankNodeTail;case"list":return this._readListItem;case"formula":return this._readFormulaTail}}_emit(t,e,r,n){this._callback(null,this._quad(t,e,r,n||this.DEFAULTGRAPH))}_error(t,e){var r=new Error(t+" on line "+e.line+".");r.context={token:e,line:e.line,previousToken:this._lexer.previousToken},this._callback(r),this._callback=et}_resolveIRI(t){return/^[a-z][a-z0-9+.-]*:/i.test(t)?t:this._resolveRelativeIRI(t)}_resolveRelativeIRI(t){if(!t.length)return this._base;switch(t[0]){case"#":return this._base+t;case"?":return this._base.replace(/(?:\\?.*)?$/,t);case"/":return("/"===t[1]?this._baseScheme:this._baseRoot)+this._removeDotSegments(t);default:return/^[^/:]*:/.test(t)?null:this._removeDotSegments(this._basePath+t)}}_removeDotSegments(t){if(!/(^|\\/)\\.\\.?($|[/#?])/.test(t))return t;for(var e="",r=t.length,n=-1,i=-1,o=0,a="/";n<r;){switch(a){case":":if(i<0&&"/"===t[++n]&&"/"===t[++n])for(;(i=n+1)<r&&"/"!==t[i];)n=i;break;case"?":case"#":n=r;break;case"/":if("."===t[n+1])switch(a=t[1+ ++n]){case"/":e+=t.substring(o,n-1),o=n+1;break;case void 0:case"?":case"#":return e+t.substring(o,n)+t.substr(n+1);case".":if(void 0===(a=t[1+ ++n])||"/"===a||"?"===a||"#"===a){if((o=(e+=t.substring(o,n-2)).lastIndexOf("/"))>=i&&(e=e.substr(0,o)),"/"!==a)return e+"/"+t.substr(n+1);o=n+1}}}a=t[++n]}return e+t.substring(o)}parse(t,e,r){var n=this;if(this._readCallback=this._readInTopContext,this._sparqlStyle=!1,this._prefixes=Object.create(null),this._prefixes._=this._blankNodePrefix?this._blankNodePrefix.substr(2):"b"+J+++"_",this._prefixCallback=r||et,this._inversePredicate=!1,this._quantified=Object.create(null),!e){var i,o=[];if(this._callback=function(t,e){t?i=t:e&&o.push(e)},this._lexer.tokenize(t).every((function(t){return n._readCallback=n._readCallback(t)})),i)throw i;return o}this._callback=e,this._lexer.tokenize(t,(function(t,e){null!==t?(n._callback(t),n._callback=et):n._readCallback&&(n._readCallback=n._readCallback(e))}))}}function et(){}function rt(t,e){var r=e.namedNode;t._namedNode=r,t._blankNode=e.blankNode,t._literal=e.literal,t._variable=e.variable,t._quad=e.quad,t.DEFAULTGRAPH=e.defaultGraph(),t.RDF_FIRST=r(M.a.rdf.first),t.RDF_REST=r(M.a.rdf.rest),t.RDF_NIL=r(M.a.rdf.nil),t.N3_FORALL=r(M.a.r.forAll),t.N3_FORSOME=r(M.a.r.forSome),t.ABBREVIATIONS={a:r(M.a.rdf.type),"=":r(M.a.owl.sameAs),">":r(M.a.log.implies)},t.QUANTIFIERS_GRAPH=r("urn:n3:quantifiers")}rt(tt.prototype,K);var nt=r(146);const{toId:it,fromId:ot}=K.internal;class at{constructor(t,e){this._size=0,this._graphs=Object.create(null),this._id=0,this._ids=Object.create(null),this._ids["><"]=0,this._entities=Object.create(null),this._blankNodeIndex=0,e||!t||t[0]||(e=t,t=null),e=e||{},this._factory=e.factory||K,t&&this.addQuads(t)}get size(){var t=this._size;if(null!==t)return t;t=0;var e,r,n=this._graphs;for(var i in n)for(var o in e=n[i].subjects)for(var a in r=e[o])t+=Object.keys(r[a]).length;return this._size=t}_addToIndex(t,e,r,n){var i=t[e]||(t[e]={}),o=i[r]||(i[r]={}),a=n in o;return a||(o[n]=null),!a}_removeFromIndex(t,e,r,n){var i,o=t[e],a=o[r];for(i in delete a[n],a)return;for(i in delete o[r],o)return;delete t[e]}_findInIndex(t,e,r,n,i,o,a,s,u,c){var f,l,h,p=!e+!r+!n>1?Object.keys(this._ids):this._entities;for(var d in e&&((f=t,t={})[e]=f[e]),t){var v=p[d];if(l=t[d])for(var g in r&&((f=l,l={})[r]=f[r]),l){var y=p[g];if(h=l[g])for(var b=(n?n in h?[n]:[]:Object.keys(h)),_=0;_<b.length;_++){var m={subject:null,predicate:null,object:null};m[i]=ot(v,this._factory),m[o]=ot(y,this._factory),m[a]=ot(p[b[_]],this._factory);var w=this._factory.quad(m.subject,m.predicate,m.object,ot(s,this._factory));if(c)c.push(w);else if(u(w))return!0}}}return c}_loop(t,e){for(var r in t)e(r)}_loopByKey0(t,e,r){var n,i;if(n=t[e])for(i in n)r(i)}_loopByKey1(t,e,r){var n;for(n in t)t[n][e]&&r(n)}_loopBy2Keys(t,e,r,n){var i,o,a;if((i=t[e])&&(o=i[r]))for(a in o)n(a)}_countInIndex(t,e,r,n){var i,o,a,s=0;for(var u in e&&((i=t,t={})[e]=i[e]),t)if(o=t[u])for(var c in r&&((i=o,o={})[r]=i[r]),o)(a=o[c])&&(n?n in a&&s++:s+=Object.keys(a).length);return s}_getGraphs(t){if(!st(t))return this._graphs;var e={};return e[t]=this._graphs[t],e}_uniqueEntities(t){var e=Object.create(null),r=this._entities;return function(n){n in e||(e[n]=!0,t(ot(r[n])))}}addQuad(t,e,r,n){e||(n=t.graph,r=t.object,e=t.predicate,t=t.subject),t=it(t),e=it(e),r=it(r),n=it(n);var i=this._graphs[n];i||(i=this._graphs[n]={subjects:{},predicates:{},objects:{}},Object.freeze(i));var o=this._ids,a=this._entities;t=o[t]||(o[a[++this._id]=t]=this._id),e=o[e]||(o[a[++this._id]=e]=this._id),r=o[r]||(o[a[++this._id]=r]=this._id);var s=this._addToIndex(i.subjects,t,e,r);return this._addToIndex(i.predicates,e,r,t),this._addToIndex(i.objects,r,t,e),this._size=null,s}addQuads(t){for(var e=0;e<t.length;e++)this.addQuad(t[e])}import(t){var e=this;return t.on("data",(function(t){e.addQuad(t)})),t}removeQuad(t,e,r,n){e||(n=t.graph,r=t.object,e=t.predicate,t=t.subject),t=it(t),e=it(e),r=it(r),n=it(n);var i,o,a,s=this._ids,u=this._graphs;if(!((t=s[t])&&(e=s[e])&&(r=s[r])&&(i=u[n])&&(o=i.subjects[t])&&(a=o[e])&&r in a))return!1;for(t in this._removeFromIndex(i.subjects,t,e,r),this._removeFromIndex(i.predicates,e,r,t),this._removeFromIndex(i.objects,r,t,e),null!==this._size&&this._size--,i.subjects)return!0;return delete u[n],!0}removeQuads(t){for(var e=0;e<t.length;e++)this.removeQuad(t[e])}remove(t){var e=this;return t.on("data",(function(t){e.removeQuad(t)})),t}removeMatches(t,e,r,n){return this.remove(this.match(t,e,r,n))}deleteGraph(t){return this.removeMatches(null,null,null,t)}getQuads(t,e,r,n){t=t&&it(t),e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s,u=[],c=this._getGraphs(n),f=this._ids;if(st(t)&&!(o=f[t])||st(e)&&!(a=f[e])||st(r)&&!(s=f[r]))return u;for(var l in c)(i=c[l])&&(o?s?this._findInIndex(i.objects,s,o,a,"object","subject","predicate",l,null,u):this._findInIndex(i.subjects,o,a,null,"subject","predicate","object",l,null,u):a?this._findInIndex(i.predicates,a,s,null,"predicate","object","subject",l,null,u):s?this._findInIndex(i.objects,s,null,null,"object","subject","predicate",l,null,u):this._findInIndex(i.subjects,null,null,null,"subject","predicate","object",l,null,u));return u}match(t,e,r,n){var i=new nt.Readable({objectMode:!0});return i._read=()=>{for(var o of this.getQuads(t,e,r,n))i.push(o);i.push(null)},i}countQuads(t,e,r,n){t=t&&it(t),e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s,u=0,c=this._getGraphs(n),f=this._ids;if(st(t)&&!(o=f[t])||st(e)&&!(a=f[e])||st(r)&&!(s=f[r]))return 0;for(var l in c)(i=c[l])&&(u+=t?r?this._countInIndex(i.objects,s,o,a):this._countInIndex(i.subjects,o,a,s):e?this._countInIndex(i.predicates,a,s,o):this._countInIndex(i.objects,s,o,a));return u}forEach(t,e,r,n,i){this.some((function(e){return t(e),!1}),e,r,n,i)}every(t,e,r,n,i){var o=!1,a=!this.some((function(e){return o=!0,!t(e)}),e,r,n,i);return o&&a}some(t,e,r,n,i){e=e&&it(e),r=r&&it(r),n=n&&it(n),i=i&&it(i);var o,a,s,u,c=this._getGraphs(i),f=this._ids;if(st(e)&&!(a=f[e])||st(r)&&!(s=f[r])||st(n)&&!(u=f[n]))return!1;for(var l in c)if(o=c[l])if(a){if(u){if(this._findInIndex(o.objects,u,a,s,"object","subject","predicate",l,t,null))return!0}else if(this._findInIndex(o.subjects,a,s,null,"subject","predicate","object",l,t,null))return!0}else if(s){if(this._findInIndex(o.predicates,s,u,null,"predicate","object","subject",l,t,null))return!0}else if(u){if(this._findInIndex(o.objects,u,null,null,"object","subject","predicate",l,t,null))return!0}else if(this._findInIndex(o.subjects,null,null,null,"subject","predicate","object",l,t,null))return!0;return!1}getSubjects(t,e,r){var n=[];return this.forSubjects((function(t){n.push(t)}),t,e,r),n}forSubjects(t,e,r,n){e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s=this._ids,u=this._getGraphs(n);if(t=this._uniqueEntities(t),!(st(e)&&!(o=s[e])||st(r)&&!(a=s[r])))for(n in u)(i=u[n])&&(o?a?this._loopBy2Keys(i.predicates,o,a,t):this._loopByKey1(i.subjects,o,t):a?this._loopByKey0(i.objects,a,t):this._loop(i.subjects,t))}getPredicates(t,e,r){var n=[];return this.forPredicates((function(t){n.push(t)}),t,e,r),n}forPredicates(t,e,r,n){e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s=this._ids,u=this._getGraphs(n);if(t=this._uniqueEntities(t),!(st(e)&&!(o=s[e])||st(r)&&!(a=s[r])))for(n in u)(i=u[n])&&(o?a?this._loopBy2Keys(i.objects,a,o,t):this._loopByKey0(i.subjects,o,t):a?this._loopByKey1(i.predicates,a,t):this._loop(i.predicates,t))}getObjects(t,e,r){var n=[];return this.forObjects((function(t){n.push(t)}),t,e,r),n}forObjects(t,e,r,n){e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s=this._ids,u=this._getGraphs(n);if(t=this._uniqueEntities(t),!(st(e)&&!(o=s[e])||st(r)&&!(a=s[r])))for(n in u)(i=u[n])&&(o?a?this._loopBy2Keys(i.subjects,o,a,t):this._loopByKey1(i.objects,o,t):a?this._loopByKey0(i.predicates,a,t):this._loop(i.objects,t))}getGraphs(t,e,r){var n=[];return this.forGraphs((function(t){n.push(t)}),t,e,r),n}forGraphs(t,e,r,n){for(var i in this._graphs)this.some((function(e){return t(e.graph),!0}),e,r,n,i)}createBlankNode(t){var e,r;if(t)for(e=t="_:"+t,r=1;this._ids[e];)e=t+r++;else do{e="_:b"+this._blankNodeIndex++}while(this._ids[e]);return this._ids[e]=++this._id,this._entities[this._id]=e,this._factory.blankNode(e.substr(2))}extractLists({remove:t=!1,ignoreErrors:e=!1}={}){var r={},n=e?()=>!0:(t,e)=>{throw new Error(`${t.value} ${e}`)},i=this.getQuads(null,M.a.rdf.rest,M.a.rdf.nil,null),o=t?[...i]:[];return i.forEach(e=>{for(var i,a,s=[],u=!1,c=e.graph,f=e.subject;f&&!u;){var l,h,p=this.getQuads(null,null,f,null),d=this.getQuads(f,null,null,null),v=null,g=null,y=null;for(l=0;l<d.length&&!u;l++)(h=d[l]).graph.equals(c)?i?u=n(f,"has non-list arcs out"):h.predicate.value===M.a.rdf.first?v?u=n(f,"has multiple rdf:first arcs"):o.push(v=h):h.predicate.value===M.a.rdf.rest?g?u=n(f,"has multiple rdf:rest arcs"):o.push(g=h):p.length?u=n(f,"can\'t be subject and object"):(i=h,a="subject"):u=n(f,"not confined to single graph");for(l=0;l<p.length&&!u;++l)h=p[l],i?u=n(f,"can\'t have coreferences"):h.predicate.value===M.a.rdf.rest?y?u=n(f,"has incoming rdf:rest arcs"):y=h:(i=h,a="object");v?s.unshift(v.object):u=n(f,"has no list head"),f=y&&y.subject}u?t=!1:i&&(r[i[a].value]=s)}),t&&this.removeQuads(o),r}}function st(t){return"string"==typeof t||t instanceof String}var ut=r(144),ct=r.n(ut)()(),ft=K.namedNode,lt=K.literal,ht=function(){function t(e){u()(this,t),this._fetch=e,this.parser=new tt,this.store=new at,this.cache={},this.prefix={}}var e,r,n,o;return f()(t,[{key:"setPrefix",value:function(t,e){this.prefix[t]=e}},{key:"getPrefix",value:function(t){return this.prefix[t]}},{key:"query",value:(o=a()(i.a.mark((function t(e,r,n,o,a){var s,u,c=arguments;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(!(c.length>5&&void 0!==c[5]?c[5]:{useCache:!0}).useCache||!(e in this.cache)){t.next=3;break}return t.abrupt("return",this._queryCached(e,r,n,o,a));case 3:return t.next=5,this._fetch(e,{headers:{Accept:"text/turtle"}});case 5:return s=t.sent,t.next=8,s.text();case 8:return u=t.sent,t.abrupt("return",this.queryTurtle(e,u,r,n,o,a));case 10:case"end":return t.stop()}}),t,this)}))),function(t,e,r,n,i){return o.apply(this,arguments)})},{key:"queryTurtle",value:(n=a()(i.a.mark((function t(e,r,n,o,a,s){var u;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this._parse(r,e);case 2:return u=t.sent,this.cache[e]=u,t.abrupt("return",this._queryCached(e,n,o,a,s));case 5:case"end":return t.stop()}}),t,this)}))),function(t,e,r,i,o,a){return n.apply(this,arguments)})},{key:"_queryCached",value:(r=a()(i.a.mark((function t(e,r,n,o,a){var s,u=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return a||(a=ft(e)[a]=[r,n,o,a].map((function(t){if("object"===F()(t)&&t){if(t.id)return t;var r=Object.keys(t),n=t[r];return 1===r.length&&"thisDoc"===r[0]?ft(n?e+"#"+n:e):ct[r]?ft(ct[r](n)):u.prefix[r]?ft(u.prefix[r]+n):ft(r+n)}return t&&void 0!==t?lt(t):t}))),s=this.cache[e],t.abrupt("return",s.getQuads(a[0],a[1],a[2],a[3]));case 3:case"end":return t.stop()}}),t,this)}))),function(t,e,n,i,o){return r.apply(this,arguments)})},{key:"_parse",value:(e=a()(i.a.mark((function t(e,r){var n,o;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=[],o=new tt({baseIRI:r}),t.abrupt("return",new Promise((function(t,r){o.parse(e,(function(e,i,o){if(i&&n.push(i),e)return r(e);if(!i){var a=new at;a.addQuads(n),t(a)}}))})));case 3:case"end":return t.stop()}}),t)}))),function(t,r){return e.apply(this,arguments)})}]),t}(),pt=I,dt=O;function vt(t,e){var r={url:t};for(var n in e.forEach((function(t){var e=t.predicate.value.replace(/.*\\//,"").replace(/.*#/,""),n=t.object.value.match("http://www.w3.org/ns/iana/media-types/")?t.object.value.replace("http://www.w3.org/ns/iana/media-types/",""):t.object.value.replace(/.*\\//,"");e.match("type")||(n=n.replace(/.*#/,"")),"ldp#Resource"!==n&&"ldp#Container"!==n&&(r[e]=[].concat(x()(r[e]||[]),[n.replace("#Resource","")]))})),r)1===r[n].length&&(r[n]=r[n][0]);return void 0===r.type&&(r.type="application/octet-stream"),r.itemType=r.type.includes("ldp#BasicContainer")?"Container":"Resource",r.name=dt(t),r.parent=pt(t),r}function gt(t,e,r){var n={type:"folder"};return n.modified=t.modified,n.mtime=t.mtime,n.size=t.size,n.itemType=t.itemType,n.name=t.name,n.parent=t.parent,n.url=t.url,n.folders=e,n.files=r,n}var yt={parseFolderResponse:function(){var t=a()(i.a.mark((function t(e){var r,n,o,s,u,c,f,l,h=arguments;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return r=h.length>1&&void 0!==h[1]?h[1]:e.url,t.next=3,e.text();case 3:return n=t.sent,o=new ht,t.next=7,o.queryTurtle(r,n,{thisDoc:""});case 7:return s=t.sent,u=vt(r,s),t.next=11,o.queryTurtle(r,n,{thisDoc:""},{ldp:"contains"});case 11:return c=t.sent,f=[],l=[],t.next=16,Promise.all(c.map(function(){var t=a()(i.a.mark((function t(e){var n,a,s;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=e.object,t.next=3,o.query(r,n);case 3:a=t.sent,(s=vt(n.value,a)).itemType.includes("Container")?(s.type="folder",f.push(s)):l.push(s);case 6:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()));case 16:return t.abrupt("return",gt(u,f,l));case 17:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()},bt=(r(201),r(97)),_t=r.n(bt),mt=function(t){function e(t){var r,n;u()(this,e);for(var i=arguments.length,o=new Array(i>1?i-1:0),a=1;a<i;a++)o[a-1]=arguments[a];return(n=h()(this,(r=d()(e)).call.apply(r,[this].concat(o)))).name="SingleResponseError",o.length||(n.message="".concat(t.status," ").concat(t.url)),n.response=t,n.ok=!1,n.status=t.status,n.statusText=t.statusText,n.url=t.url,n}return b()(e,t),e}(_t()(Error)),wt=function(t){function e(t){var r,n,i=t.successful,o=void 0===i?[]:i,a=t.rejectedErrors,s=void 0===a?[]:a,c=t.errors,f=void 0===c?[]:c;u()(this,e);for(var l=arguments.length,p=new Array(l>1?l-1:0),v=1;v<l;v++)p[v-1]=arguments[v];return(n=h()(this,(r=d()(e)).call.apply(r,[this].concat(p)))).name="SFCFetchError",n.successful=o,n.rejected=s.map((function(t){return t.response})),n.rejectedErrors=s,n.errors=f,n.ok=!1,s.length?1!==s.length||f.length?(n.message="".concat(n.name," ").concat([].concat(x()(s),x()(f)).map((function(t){return t.message})).join("\\n")),n.status=-2,n.statusText=n.message):(n.message="".concat(n.name," ").concat(s[0].message),n.status=s[0].status,n.statusText=s[0].statusText):(n.message="".concat(n.name," ").concat(f.map((function(t){return t.message})).join("\\n")),n.status=-1,n.statusText=n.message),n.successful=o,n.rejected=s.map((function(t){return t.response})),n.rejectedErrors=s,n.errors=f,n}return b()(e,t),e}(_t()(Error)),xt={401:"Make sure that the user is properly logged in",403:"Make sure that the origin of your app is authorized for your pod",404:"The requested resource could not be found",409:"A conflict appeared. If you tried to delete a folder, make sure that it is empty",500:"An internal server error occured"};function kt(t){return Et.apply(this,arguments)}function Et(){return(Et=a()(i.a.mark((function t(e){var r;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return r=e.map((function(t){return t.then((function(t){return{status:"fulfilled",value:t}})).catch((function(t){return{status:"rejected",reason:t}}))})),t.abrupt("return",Promise.all(r));case 2:case"end":return t.stop()}}),t)})))).apply(this,arguments)}function St(){return(St=a()(i.a.mark((function t(e){var r,n,o,a,s,u,c,f;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,kt(e);case 2:if(n=t.sent,o=(r=[]).concat.apply(r,x()(n.filter((function(t){return"fulfilled"===t.status})).map((function(t){return t.value})))),!(a=n.filter((function(t){return"rejected"===t.status})).map((function(t){return t.reason}))).length){t.next=9;break}throw c=(s=[]).concat.apply(s,x()(a.map((function(t){return t.errors})))),f=(u=[]).concat.apply(u,x()(a.map((function(t){return t.rejectedErrors})))),new wt({successful:o,rejectedErrors:f,errors:c});case 9:return t.abrupt("return",o);case 10:case"end":return t.stop()}}),t)})))).apply(this,arguments)}var jt={FetchError:wt,SingleResponseError:mt,assertResponseOk:function(t){if(!t.ok){var e=t.status in xt?new mt(t,"".concat(t.status," ").concat(t.url," - ").concat(xt[t.status])):new mt(t);throw new wt({successful:[],rejectedErrors:[e]})}return t},composedFetch:function(t){return St.apply(this,arguments)},promisesSettled:kt,toFetchError:function(t){throw t instanceof wt?t:t instanceof mt?new wt({rejectedErrors:[t]}):t instanceof Error?new wt({errors:[t]}):t}};r(204);function Rt(t,e){var r={};return function(t){if(t){return t.match(/<[^>]*>\\s*(\\s*;\\s*[^()<>@,;:"/[\\]?={} \\t]+=(([^\\(\\)<>@,;:"\\/\\[\\]\\?={} \\t]+)|("[^"]*")))*(,|$)/g)}}(t).map((function(t){var e=t.substring(t.indexOf("<")+1,t.indexOf(">")),r=t.substring(t.indexOf(\'rel="\')+\'rel="\'.length,t.lastIndexOf(\'"\'));return["describedby"===r.toLowerCase()?"meta":r,e]})).filter((function(t){var e=m()(t,1)[0];return["meta","acl"].includes(e)})).forEach((function(t){var n=m()(t,2),i=n[0],o=n[1];r[i]=function(t,e){var r,n,i,o,a,s=e.indexOf("#");s>0&&(e=e.slice(0,s));if(0===t.length)return e;if(0===t.indexOf("#"))return e+t;if(t.indexOf(":")>=0)return t;if(r=e.indexOf(":"),0===e.length)return t;if(r<0)return t;if(n=e.slice(0,+r+1||9e9),0===t.indexOf("//"))return n+t;if(e.indexOf("//",r)===r+1){if((i=e.indexOf("/",r+3))<0)return e.length-r-3>0?e+"/"+t:n+t}else if((i=e.indexOf("/",r+1))<0)return e.length-r-1>0?e+"/"+t:n+t;if(0===t.indexOf("/"))return e.slice(0,i)+t;if(a=e.slice(i),(o=a.lastIndexOf("/"))<0)return n+t;o>=0&&o<a.length-1&&(a=a.slice(0,+o+1||9e9));a+=t;for(;a.match(/[^\\/]*\\/\\.\\.\\//);)a=a.replace(/[^\\/]*\\/\\.\\.\\//,"");return a=(a=a.replace(/\\.\\//g,"")).replace(/\\/\\.$/,"/"),e.slice(0,i)+a}(o,e)})),r}var Ct=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.url,r=t.headers.get("link");return null===r?{}:Rt(r,e)};function It(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Ot(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?It(Object(r),!0).forEach((function(e){E()(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):It(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}var Tt=j()("solid-file-client:fetch"),Pt=C,At=I,Lt=O,Ft=T,Mt=P,Nt=A,Bt=jt.FetchError,Dt=jt.assertResponseOk,Ut=jt.composedFetch,qt=jt.toFetchError,Gt=Ct,Wt=yt.parseFolderResponse,zt={REPLACE:"replace",KEEP_SOURCE:"keep_source",KEEP_TARGET:"keep_target"},Yt={EXCLUDE:"exclude",INCLUDE:"include",INCLUDE_POSSIBLE:"include_possible"},Qt="no_modify",$t="to_target",Ht="to_source",Kt={withAcl:!0,withMeta:!0,agent:Qt,merge:zt.REPLACE,createPath:!0},Vt={enableLogging:!1};function Zt(t){return Jt((function(e){return e.status===t}))}function Jt(t){return function(e){if(!t(e))throw qt(e);return e}}var Xt=function(t){function e(t,r){var n;return u()(this,e),(n=h()(this,d()(e).call(this,t.fetch.bind(t),r)))._auth=t,n}var r,n,o,s;return b()(e,t),f()(e,[{key:"readFile",value:(s=a()(i.a.mark((function t(e,r){var n,o;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.get(e,r);case 2:if(n=t.sent,!(o=n.headers.get("content-type"))||!o.match(/(image|audio|video)/)){t.next=6;break}return t.abrupt("return",n.blob());case 6:if(!n.text){t.next=8;break}return t.abrupt("return",n.text());case 8:return t.abrupt("return",n);case 9:case"end":return t.stop()}}),t,this)}))),function(t,e){return s.apply(this,arguments)})},{key:"readHead",value:(o=a()(i.a.mark((function t(r,n){var o,a,s,u,c,f,l,h;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,g()(d()(e.prototype),"head",this).call(this,r,n);case 2:for(o=t.sent,a="",s=!0,u=!1,c=void 0,t.prev=7,f=o.headers.entries()[Symbol.iterator]();!(s=(l=f.next()).done);s=!0)h=l.value,a+=h[0]+": "+h[1]+"\\n";t.next=15;break;case 11:t.prev=11,t.t0=t.catch(7),u=!0,c=t.t0;case 15:t.prev=15,t.prev=16,s||null==f.return||f.return();case 18:if(t.prev=18,!u){t.next=21;break}throw c;case 21:return t.finish(18);case 22:return t.finish(15);case 23:return t.abrupt("return",a);case 24:case"end":return t.stop()}}),t,this,[[7,11,15,23],[16,,18,22]])}))),function(t,e){return o.apply(this,arguments)})},{key:"deleteFile",value:(n=a()(i.a.mark((function t(r){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",g()(d()(e.prototype),"_deleteItemWithLinks",this).call(this,r));case 1:case"end":return t.stop()}}),t,this)}))),function(t){return n.apply(this,arguments)})},{key:"deleteFolder",value:(r=a()(i.a.mark((function t(r,n){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",g()(d()(e.prototype),"deleteFolderRecursively",this).call(this,r));case 1:case"end":return t.stop()}}),t,this)}))),function(t,e){return r.apply(this,arguments)})}]),e}(function(){function t(e,r){u()(this,t),r=Ot({},Vt,{},r),this._fetch=e,this.rdf=new ht(this.fetch.bind(this)),r.enableLogging&&("string"==typeof r.enableLogging?j.a.enable(r.enableLogging):j.a.enable("solid-file-client:*"))}var e,r,n,o,s,c,l,h,p,d,v,g,y,b,_,w,k;return f()(t,[{key:"fetch",value:function(t,e){return this._fetch(t,e).then((function(r){return Tt("".concat(r.status," - ").concat(e&&e.method," ").concat(t)),r})).then(Dt)}},{key:"get",value:function(t,e){return this.fetch(t,Ot({},e,{method:"GET"}))}},{key:"delete",value:function(t,e){return this.fetch(t,Ot({},e,{method:"DELETE"}))}},{key:"post",value:function(t,e){return this.fetch(t,Ot({},e,{method:"POST"}))}},{key:"put",value:function(t,e){return this.fetch(t,Ot({},e,{method:"PUT"}))}},{key:"patch",value:function(t,e){return this.fetch(t,Ot({},e,{method:"PATCH"}))}},{key:"head",value:function(t,e){return this.fetch(t,Ot({},e,{method:"HEAD"}))}},{key:"options",value:function(t,e){return this.fetch(t,Ot({},e,{method:"OPTIONS"}))}},{key:"itemExists",value:(k=a()(i.a.mark((function t(e){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",this.head(e).then((function(){return!0})).catch((function(t){return Zt(404)(t),!1})));case 1:case"end":return t.stop()}}),t,this)}))),function(t){return k.apply(this,arguments)})},{key:"postItem",value:(w=a()(i.a.mark((function t(e,r,n,o,a){var s,u;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(a=Ot({},{createPath:!0},{},a),s=At(e),!a.createPath){t.next=5;break}return t.next=5,this.createFolder(s);case 5:return u={headers:{link:o,slug:Lt(e),"Content-Type":n},body:r},t.abrupt("return",this.post(s,u));case 7:case"end":return t.stop()}}),t,this)}))),function(t,e,r,n,i){return w.apply(this,arguments)})},{key:"createFolder",value:(_=a()(i.a.mark((function t(e,r){var n;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return r=Ot({},{createPath:!0,merge:zt.KEEP_TARGET},{},r),t.prev=1,t.next=4,this.head(e);case 4:if(n=t.sent,r.merge===zt.REPLACE){t.next=7;break}return t.abrupt("return",n);case 7:return t.next=9,this.deleteFolderRecursively(e);case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),Zt(404)(t.t0);case 14:return t.abrupt("return",this.postItem(e,"","text/turtle",Nt.CONTAINER,r));case 15:case"end":return t.stop()}}),t,this,[[1,11]])}))),function(t,e){return _.apply(this,arguments)})},{key:"postFile",value:function(t,e,r,n){return this.postItem(t,e,r,Nt.RESOURCE,n)}},{key:"createFile",value:function(t,e,r,n){return this.putFile(t,e,r,n)}},{key:"putFile",value:(b=a()(i.a.mark((function t(e,r,n,o){var a;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(o=Ot({},Kt,{},o),t.t0=o.merge===zt.KEEP_TARGET,!t.t0){t.next=6;break}return t.next=5,this.itemExists(e);case 5:t.t0=t.sent;case 6:if(!t.t0){t.next=8;break}qt(new Error("File already existed: "+e));case 8:return a={headers:{link:Nt.RESOURCE,"Content-Type":n},body:r},t.abrupt("return",this.put(e,a));case 10:case"end":return t.stop()}}),t,this)}))),function(t,e,r,n){return b.apply(this,arguments)})},{key:"readFolder",value:(y=a()(i.a.mark((function t(e,r){var n,o,s,u=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return e=e.endsWith("/")?e:e+"/",r=Ot({links:Yt.EXCLUDE},r),t.next=4,this.get(e,{headers:{Accept:"text/turtle"}});case 4:return n=t.sent,t.next=7,Wt(n,e);case 7:if(o=t.sent,r.links!==Yt.INCLUDE_POSSIBLE&&r.links!==Yt.INCLUDE){t.next=12;break}return s=function(){var t=a()(i.a.mark((function t(e){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,u.getItemLinks(e.url,r);case 2:e.links=t.sent;case 3:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}(),t.next=12,Ut([s(o)].concat(x()(o.files.map(s))));case 12:return t.abrupt("return",o);case 13:case"end":return t.stop()}}),t,this)}))),function(t,e){return y.apply(this,arguments)})},{key:"getItemLinks",value:(g=a()(i.a.mark((function t(e){var r,n,o=arguments;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return(r=o.length>1&&void 0!==o[1]?o[1]:{links:Yt.INCLUDE_POSSIBLE}).links===Yt.EXCLUDE&&qt(new Error("Invalid option LINKS.EXCLUDE for getItemLinks")),t.next=4,this.head(e).then(Gt);case 4:if(n=t.sent,r.links!==Yt.INCLUDE){t.next=8;break}return t.next=8,this._removeInexistingLinks(n);case 8:return t.abrupt("return",n);case 9:case"end":return t.stop()}}),t,this)}))),function(t){return g.apply(this,arguments)})},{key:"_removeInexistingLinks",value:(v=a()(i.a.mark((function t(e){var r=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,Ut(Object.entries(e).map((function(t){var n=m()(t,2),i=n[0],o=n[1];return r.itemExists(o).catch(Zt(404)).then((function(t){t||delete e[i]}))})));case 2:case"end":return t.stop()}}),t)}))),function(t){return v.apply(this,arguments)})},{key:"copyFile",value:(d=a()(i.a.mark((function t(e,r,n){var o,a,s,u;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(n=Ot({},Kt,{},n),!e.endsWith("/")&&!r.endsWith("/")){t.next=3;break}throw qt(new Error("Folders are not allowed with copyFile. Found: ".concat(e," and ").concat(r)));case 3:if(!e.endsWith(".acl")&&!r.endsWith(".acl")){t.next=5;break}throw qt(new Error("Use copyAclFile for copying ACL files. Found: ".concat(e," and ").concat(r)));case 5:return t.next=7,this.get(e);case 7:return o=t.sent,t.next=10,o.blob();case 10:return a=t.sent,s=o.headers.get("content-type"),t.next=14,this.putFile(r,a,s,n);case 14:return u=t.sent,t.next=17,this.copyLinksForItem(e,r,n,o,u);case 17:return t.abrupt("return",u);case 18:case"end":return t.stop()}}),t,this)}))),function(t,e,r){return d.apply(this,arguments)})},{key:"_linkUrlsDefined",value:(p=a()(i.a.mark((function t(e,r){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if("string"==typeof e){t.next=4;break}return t.abrupt("return",!1);case 4:if(t.t0="string"!=typeof r,!t.t0){t.next=9;break}return t.next=8,this.itemExists(e);case 8:t.t0=t.sent;case 9:if(!t.t0){t.next=13;break}throw qt(new Error("Cannot copy link file because target location was not provided by the pod"));case 13:if("string"==typeof r){t.next=17;break}return t.abrupt("return",!1);case 17:return t.abrupt("return",!0);case 18:case"end":return t.stop()}}),t,this)}))),function(t,e){return p.apply(this,arguments)})},{key:"copyMetaFileForItem",value:(h=a()(i.a.mark((function t(e,r){var n,o,a,s,u,c=arguments;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=c.length>2&&void 0!==c[2]?c[2]:{},t.next=3,this.getItemLinks(e);case 3:return o=t.sent,a=o.meta,t.next=7,this.getItemLinks(r);case 7:return s=t.sent,u=s.meta,t.next=11,this._linkUrlsDefined(a,u);case 11:if(t.sent){t.next=13;break}return t.abrupt("return",void 0);case 13:return t.abrupt("return",this.copyFile(a,u,{withAcl:n.withAcl,withMeta:!1}));case 14:case"end":return t.stop()}}),t,this)}))),function(t,e){return h.apply(this,arguments)})},{key:"copyAclFileForItem",value:(l=a()(i.a.mark((function t(e,r,n){var o,a,s,u,c,f,l,h,p;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=Ot({},Kt,{},{agent:Qt},{},n),t.next=3,this.getItemLinks(e);case 3:return o=t.sent,a=o.acl,t.next=7,this.getItemLinks(r);case 7:return s=t.sent,u=s.acl,t.next=11,this._linkUrlsDefined(a,u);case 11:if(t.sent){t.next=13;break}return t.abrupt("return",void 0);case 13:return t.next=15,this.get(a);case 15:return c=t.sent,f=c.headers.get("Content-Type"),t.next=19,c.text();case 19:return l=t.sent,h=Lt(e),p=Ft(r)?"":Lt(r),l.includes(e)&&(l=l.replace(new RegExp("<"+e+">","g"),"<./"+p+">")),p!==h&&(l=l.replace(new RegExp(h+">","g"),p+">")),n.agent===$t&&(l=(l=l.replace(new RegExp("<"+Pt(e)+"profile/card#","g"),"</profile/card#")).replace(new RegExp("<"+Pt(e)+"profile/card#me>","g"),"</profile/card#me>")),n.agent===Ht&&(l=(l=l.replace(new RegExp("</profile/card#","g"),"<"+Pt(e)+"profile/card#")).replace(new RegExp("</profile/card#me>","g"),"<"+Pt(e)+"profile/card#me>")),t.abrupt("return",this.putFile(u,l,f,n));case 27:case"end":return t.stop()}}),t,this)}))),function(t,e,r){return l.apply(this,arguments)})},{key:"copyLinksForItem",value:(c=a()(i.a.mark((function t(e,r,n){var o;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(o=[],!n.withMeta){t.next=7;break}return t.t0=o,t.next=5,this.copyMetaFileForItem(e,r,n).catch(Zt(404));case 5:t.t1=t.sent,t.t0.push.call(t.t0,t.t1);case 7:if(!n.withAcl){t.next=13;break}return t.t2=o,t.next=11,this.copyAclFileForItem(e,r,n).catch(Zt(404));case 11:t.t3=t.sent,t.t2.push.call(t.t2,t.t3);case 13:return t.abrupt("return",o.filter((function(t){return t&&!(t instanceof Error)})));case 14:case"end":return t.stop()}}),t,this)}))),function(t,e,r){return c.apply(this,arguments)})},{key:"copyFolder",value:(s=a()(i.a.mark((function t(e,r,n){var o,a,s,u,c,f,l=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(n=Ot({},Kt,{},n),"string"==typeof e&&"string"==typeof r){t.next=3;break}throw qt(new Error("The from and to parameters of copyFolder must be strings. Found: ".concat(e," and ").concat(r)));case 3:if(e.endsWith("/")&&r.endsWith("/")){t.next=5;break}throw qt(new Error("Files are not allowed with copyFolder. Found: ".concat(e," and ").concat(r)));case 5:return t.next=7,this.readFolder(e);case 7:return a=t.sent,s=a.folders,u=a.files,t.next=12,this.createFolder(r,n);case 12:return c=t.sent,t.next=15,this.copyLinksForItem(e,r,n,void 0,c);case 15:return t.next=17,Ut([].concat(x()(s.map((function(t){var i=t.name;return l.copyFolder("".concat(e).concat(i,"/"),"".concat(r).concat(i,"/"),n)}))),x()(u.map((function(t){var i=t.name;return l.copyFile("".concat(e).concat(i),"".concat(r).concat(i),n).catch(Jt((function(t){return t.message.includes("already existed")})))}))))).then((function(t){return t.filter((function(t){return!(t instanceof Bt)}))}));case 17:return f=t.sent,t.abrupt("return",(o=[c]).concat.apply(o,x()(f)));case 19:case"end":return t.stop()}}),t,this)}))),function(t,e,r){return s.apply(this,arguments)})},{key:"copy",value:function(t,e,r){return Ft(t,e)?this.copyFolder(t,e,r):Mt(t,e)?this.copyFile(t,e,r):void qt(new Error("Cannot copy from a folder url to a file url or vice versa"))}},{key:"_deleteItemWithLinks",value:(o=a()(i.a.mark((function t(e){var r;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.getItemLinks(e,{links:Yt.INCLUDE});case 2:if(!(r=t.sent).meta){t.next=6;break}return t.next=6,this._deleteItemWithLinks(r.meta);case 6:if(!r.acl){t.next=9;break}return t.next=9,this.delete(r.acl);case 9:return t.abrupt("return",this.delete(e));case 10:case"end":return t.stop()}}),t,this)}))),function(t){return o.apply(this,arguments)})},{key:"deleteFolderContents",value:(n=a()(i.a.mark((function t(e){var r,n,o,a=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.readFolder(e);case 2:return r=t.sent,n=r.folders,o=r.files,t.abrupt("return",Ut([].concat(x()(n.map((function(t){var e=t.url;return a.deleteFolderRecursively(e)}))),x()(o.map((function(t){var e=t.url;return a._deleteItemWithLinks(e)}))))));case 6:case"end":return t.stop()}}),t,this)}))),function(t){return n.apply(this,arguments)})},{key:"deleteFolderRecursively",value:(r=a()(i.a.mark((function t(e){var r;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.deleteFolderContents(e);case 2:return r=t.sent,t.t0=r,t.next=6,this._deleteItemWithLinks(e);case 6:return t.t1=t.sent,t.t0.unshift.call(t.t0,t.t1),t.abrupt("return",r);case 9:case"end":return t.stop()}}),t,this)}))),function(t){return r.apply(this,arguments)})},{key:"move",value:(e=a()(i.a.mark((function t(e,r,n){var o;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.copy(e,r,n);case 2:if(o=t.sent,!Ft(e)){t.next=8;break}return t.next=6,this.deleteFolderRecursively(e);case 6:t.next=10;break;case 8:return t.next=10,this._deleteItemWithLinks(e);case 10:return t.abrupt("return",o);case 11:case"end":return t.stop()}}),t,this)}))),function(t,r,n){return e.apply(this,arguments)})},{key:"rename",value:function(t,e,r){var n=At(t)+e+(Ft(t)?"/":"");return this.move(t,n,r)}}]),t}()),te=jt.FetchError,ee=jt.SingleResponseError;Xt.FetchError=te,Xt.SingleResponseError=ee,Xt.LINKS=Yt,Xt.MERGE=zt;e.default=Xt}]).default}));\n//# sourceMappingURL=solid-file-client.bundle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29saWQtZmlsZS1jbGllbnQvZGlzdC93aW5kb3cvc29saWQtZmlsZS1jbGllbnQuYnVuZGxlLmpzPzdmZWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxLQUFpRCxvQkFBb0IsU0FBNkgsQ0FBQyxvQkFBb0IsbUJBQW1CLFNBQVMsY0FBYyw0QkFBNEIsWUFBWSxxQkFBcUIsMkRBQTJELHVDQUF1QyxxQ0FBcUMsb0JBQW9CLEVBQUUsaUJBQWlCLDRGQUE0RixlQUFlLHdDQUF3QyxTQUFTLEVBQUUsbUJBQW1CLDhCQUE4QixxREFBcUQsMEJBQTBCLDZDQUE2QyxzQkFBc0IsNkRBQTZELFlBQVksZUFBZSxTQUFTLGlCQUFpQixpQ0FBaUMsaUJBQWlCLFlBQVksVUFBVSxzQkFBc0IsbUJBQW1CLGlEQUFpRCxtQkFBbUIsa0JBQWtCLGdCQUFnQixlQUFlLDBCQUEwQixJQUFJLHdCQUF3QixTQUFTLGlCQUFpQix5Q0FBeUMsc0JBQXNCLGtCQUFrQix1QkFBdUIsa0NBQWtDLG1CQUFtQixjQUFjLHNCQUFzQixjQUFjLHVCQUF1QixVQUFVLEtBQUssaUJBQWlCLDhEQUE4RCx3QkFBd0IsNkNBQTZDLHVCQUF1QixXQUFXLHdCQUF3QixpR0FBaUcsK0JBQStCLE9BQU8saURBQWlELGlCQUFpQixzR0FBc0csc0JBQXNCLCtEQUErRCxpQkFBaUIsYUFBYSxrQkFBa0IsMkJBQTJCLDhLQUE4SyxtQkFBbUIsZUFBZSxzQkFBc0IsSUFBSSxZQUFZLFNBQVMsV0FBVyxpQkFBaUIsYUFBYSw4SEFBOEgsS0FBSyxLQUFLLGdHQUFnRyxNQUFNLGtGQUFrRixNQUFNLDhDQUE4QyxJQUFJLGtEQUFrRCxNQUFNLDBCQUEwQixpQkFBaUIsV0FBVyx5QkFBeUIsa0NBQWtDLE1BQU0sZUFBZSxVQUFVLElBQUksR0FBRyxpQkFBaUIsWUFBWSxzQkFBc0Isd0RBQXdELFVBQVUsaUJBQWlCLCtCQUErQixzQkFBc0Isd0JBQXdC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R0FBRywwRUFBMEUsbUNBQW1DLFVBQVUsb0JBQW9CLCtCQUErQixFQUFFLEVBQUUsaUNBQWlDLG9KQUFvSixFQUFFLGdFQUFnRSxNQUFNLDZCQUE2QixNQUFNLHVCQUF1Qiw0Q0FBNEMsaUJBQWlCLEVBQUUsNEJBQTRCLFNBQVMsTUFBTSxrREFBa0Qsa0JBQWtCLFNBQVMsTUFBTSxtQ0FBbUMsZ0RBQWdELG1DQUFtQyxVQUFVLGdCQUFnQiwrQkFBK0IsRUFBRSxFQUFFLGdFQUFnRSxpQkFBaUIsNkJBQTZCLE1BQU0sdUJBQXVCLDBDQUEwQyxtR0FBbUcsWUFBWSxvQ0FBb0MsMkJBQTJCLFlBQVksaUNBQWlDLE9BQU8sa0NBQWtDLFVBQVUsZ0JBQWdCLCtCQUErQixFQUFFLEVBQUUsbUVBQW1FLE1BQU0sNkJBQTZCLE1BQU0sdUJBQXVCLG9EQUFvRCxvRUFBb0UsNEVBQTRFLGtDQUFrQyxVQUFVLGdCQUFnQiwrQkFBK0IsRUFBRSxFQUFFLG9EQUFvRCxNQUFNLDZCQUE2QixNQUFNLHVCQUF1Qix3Q0FBd0MsMkJBQTJCLFNBQVMsTUFBTSxnREFBZ0QsaUJBQWlCLE1BQU0scURBQXFELG9DQUFvQyxtQ0FBbUMsVUFBVSxvQkFBb0IsK0JBQStCLEVBQUUsRUFBRSxtQ0FBbUMsNkJBQTZCLHlCQUF5QixLQUFLLCtDQUErQyxtRUFBbUUsYUFBYSxXQUFXO0FBQ2o5K0kiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlNvbGlkRmlsZUNsaWVudD1lKCk6dC5Tb2xpZEZpbGVDbGllbnQ9ZSgpfSh3aW5kb3csKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXt9O2Z1bmN0aW9uIHIobil7aWYoZVtuXSlyZXR1cm4gZVtuXS5leHBvcnRzO3ZhciBpPWVbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiB0W25dLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLHIpLGkubD0hMCxpLmV4cG9ydHN9cmV0dXJuIHIubT10LHIuYz1lLHIuZD1mdW5jdGlvbih0LGUsbil7ci5vKHQsZSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0Om59KX0sci5yPWZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHIudD1mdW5jdGlvbih0LGUpe2lmKDEmZSYmKHQ9cih0KSksOCZlKXJldHVybiB0O2lmKDQmZSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZlJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIGkgaW4gdClyLmQobixpLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfS5iaW5kKG51bGwsaSkpO3JldHVybiBufSxyLm49ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIHIuZChlLFwiYVwiLGUpLGV9LHIubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sci5wPVwiXCIscihyLnM9MjA1KX0oW2Z1bmN0aW9uKHQsZSxyKXt0LmV4cG9ydHM9cigyOCl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gcih0LGUscixuLGksbyxhKXt0cnl7dmFyIHM9dFtvXShhKSx1PXMudmFsdWV9Y2F0Y2godCl7cmV0dXJuIHZvaWQgcih0KX1zLmRvbmU/ZSh1KTpQcm9taXNlLnJlc29sdmUodSkudGhlbihuLGkpfXQuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10aGlzLG49YXJndW1lbnRzO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSxvKXt2YXIgYT10LmFwcGx5KGUsbik7ZnVuY3Rpb24gcyh0KXtyKGEsaSxvLHMsdSxcIm5leHRcIix0KX1mdW5jdGlvbiB1KHQpe3IoYSxpLG8scyx1LFwidGhyb3dcIix0KX1zKHZvaWQgMCl9KSl9fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCksaT1yKDIyKS5mLG89cigxNCksYT1yKDE3KSxzPXIoNjIpLHU9cigxMDEpLGM9cig2OCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIHIsZixsLGgscCxkPXQudGFyZ2V0LHY9dC5nbG9iYWwsZz10LnN0YXQ7aWYocj12P246Zz9uW2RdfHxzKGQse30pOihuW2RdfHx7fSkucHJvdG90eXBlKWZvcihmIGluIGUpe2lmKGg9ZVtmXSxsPXQubm9UYXJnZXRHZXQ/KHA9aShyLGYpKSYmcC52YWx1ZTpyW2ZdLCFjKHY/ZjpkKyhnP1wiLlwiOlwiI1wiKStmLHQuZm9yY2VkKSYmdm9pZCAwIT09bCl7aWYodHlwZW9mIGg9PXR5cGVvZiBsKWNvbnRpbnVlO3UoaCxsKX0odC5zaGFtfHxsJiZsLnNoYW0pJiZvKGgsXCJzaGFtXCIsITApLGEocixmLGgsdCl9fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCksaT1yKDY0KSxvPXIoMTMpLGE9cig2NSkscz1yKDY5KSx1PXIoMTA3KSxjPWkoXCJ3a3NcIiksZj1uLlN5bWJvbCxsPXU/ZjpmJiZmLndpdGhvdXRTZXR0ZXJ8fGE7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBvKGMsdCl8fChzJiZvKGYsdCk/Y1t0XT1mW3RdOmNbdF09bChcIlN5bWJvbC5cIit0KSksY1t0XX19LGZ1bmN0aW9uKHQsZSxyKXsoZnVuY3Rpb24oZSl7dmFyIHI9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuTWF0aD09TWF0aCYmdH07dC5leHBvcnRzPXIoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMmJmdsb2JhbFRoaXMpfHxyKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyl8fHIoXCJvYmplY3RcIj09dHlwZW9mIHNlbGYmJnNlbGYpfHxyKFwib2JqZWN0XCI9PXR5cGVvZiBlJiZlKXx8RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfSkuY2FsbCh0aGlzLHIoMjEpKX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhdCgpfWNhdGNoKHQpe3JldHVybiEwfX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIixpPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjXCIsbz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvMTAvc3dhcC9cIjtlLmE9e3hzZDp7ZGVjaW1hbDppK1wiZGVjaW1hbFwiLGJvb2xlYW46aStcImJvb2xlYW5cIixkb3VibGU6aStcImRvdWJsZVwiLGludGVnZXI6aStcImludGVnZXJcIixzdHJpbmc6aStcInN0cmluZ1wifSxyZGY6e3R5cGU6bitcInR5cGVcIixuaWw6bitcIm5pbFwiLGZpcnN0Om4rXCJmaXJzdFwiLHJlc3Q6bitcInJlc3RcIixsYW5nU3RyaW5nOm4rXCJsYW5nU3RyaW5nXCJ9LG93bDp7c2FtZUFzOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMi8wNy9vd2wjc2FtZUFzXCJ9LHI6e2ZvclNvbWU6bytcInJlaWZ5I2ZvclNvbWVcIixmb3JBbGw6bytcInJlaWZ5I2ZvckFsbFwifSxsb2c6e2ltcGxpZXM6bytcImxvZyNpbXBsaWVzXCJ9fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNSk7dC5leHBvcnRzPSFuKChmdW5jdGlvbigpe3JldHVybiA3IT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmF9KSl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoIW4odCkpdGhyb3cgVHlwZUVycm9yKFN0cmluZyh0KStcIiBpcyBub3QgYW4gb2JqZWN0XCIpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTY5KSxpPXIoMTcwKSxvPXIoMTcxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odCl8fGkodCl8fG8oKX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB0P251bGwhPT10OlwiZnVuY3Rpb25cIj09dHlwZW9mIHR9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig3KSxpPXIoOTkpLG89cig4KSxhPXIoNDMpLHM9T2JqZWN0LmRlZmluZVByb3BlcnR5O2UuZj1uP3M6ZnVuY3Rpb24odCxlLHIpe2lmKG8odCksZT1hKGUsITApLG8ociksaSl0cnl7cmV0dXJuIHModCxlLHIpfWNhdGNoKHQpe31pZihcImdldFwiaW4gcnx8XCJzZXRcImluIHIpdGhyb3cgVHlwZUVycm9yKFwiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuXCJ2YWx1ZVwiaW4gciYmKHRbZV09ci52YWx1ZSksdH19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDYwKSxpPXIoMjApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbihpKHQpKX19LGZ1bmN0aW9uKHQsZSl7dmFyIHI9e30uaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuY2FsbCh0LGUpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDExKSxvPXIoMzEpO3QuZXhwb3J0cz1uP2Z1bmN0aW9uKHQsZSxyKXtyZXR1cm4gaS5mKHQsZSxvKDEscikpfTpmdW5jdGlvbih0LGUscil7cmV0dXJuIHRbZV09cix0fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMzIpLGk9TWF0aC5taW47dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/aShuKHQpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIHIoZSl7cmV0dXJuIHQuZXhwb3J0cz1yPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9LHIoZSl9dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDQpLGk9cigxNCksbz1yKDEzKSxhPXIoNjIpLHM9cig2MyksdT1yKDI0KSxjPXUuZ2V0LGY9dS5lbmZvcmNlLGw9U3RyaW5nKFN0cmluZykuc3BsaXQoXCJTdHJpbmdcIik7KHQuZXhwb3J0cz1mdW5jdGlvbih0LGUscixzKXt2YXIgdT0hIXMmJiEhcy51bnNhZmUsYz0hIXMmJiEhcy5lbnVtZXJhYmxlLGg9ISFzJiYhIXMubm9UYXJnZXRHZXQ7XCJmdW5jdGlvblwiPT10eXBlb2YgciYmKFwic3RyaW5nXCIhPXR5cGVvZiBlfHxvKHIsXCJuYW1lXCIpfHxpKHIsXCJuYW1lXCIsZSksZihyKS5zb3VyY2U9bC5qb2luKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6XCJcIikpLHQhPT1uPyh1PyFoJiZ0W2VdJiYoYz0hMCk6ZGVsZXRlIHRbZV0sYz90W2VdPXI6aSh0LGUscikpOmM/dFtlXT1yOmEoZSxyKX0pKEZ1bmN0aW9uLnByb3RvdHlwZSxcInRvU3RyaW5nXCIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcyYmYyh0aGlzKS5zb3VyY2V8fHModGhpcyl9KSl9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX19LGZ1bmN0aW9uKHQsZSl7dmFyIHI9e30udG9TdHJpbmc7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiByLmNhbGwodCkuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihudWxsPT10KXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlKXt2YXIgcjtyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3I9cnx8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaCh0KXtcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiYocj13aW5kb3cpfXQuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig3KSxpPXIoNTkpLG89cigzMSksYT1yKDEyKSxzPXIoNDMpLHU9cigxMyksYz1yKDk5KSxmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPW4/ZjpmdW5jdGlvbih0LGUpe2lmKHQ9YSh0KSxlPXMoZSwhMCksYyl0cnl7cmV0dXJuIGYodCxlKX1jYXRjaCh0KXt9aWYodSh0LGUpKXJldHVybiBvKCFpLmYuY2FsbCh0LGUpLHRbZV0pfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNTUpLGk9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3ZhciBlPVtdO2Zvcih2YXIgciBpbiB0KWUucHVzaChyKTtyZXR1cm4gZX07dC5leHBvcnRzPWw7dmFyIG89cigzOSk7by5pbmhlcml0cz1yKDI5KTt2YXIgYT1yKDEzOCkscz1yKDk1KTtvLmluaGVyaXRzKGwsYSk7Zm9yKHZhciB1PWkocy5wcm90b3R5cGUpLGM9MDtjPHUubGVuZ3RoO2MrKyl7dmFyIGY9dVtjXTtsLnByb3RvdHlwZVtmXXx8KGwucHJvdG90eXBlW2ZdPXMucHJvdG90eXBlW2ZdKX1mdW5jdGlvbiBsKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGwpKXJldHVybiBuZXcgbCh0KTthLmNhbGwodGhpcyx0KSxzLmNhbGwodGhpcyx0KSx0JiYhMT09PXQucmVhZGFibGUmJih0aGlzLnJlYWRhYmxlPSExKSx0JiYhMT09PXQud3JpdGFibGUmJih0aGlzLndyaXRhYmxlPSExKSx0aGlzLmFsbG93SGFsZk9wZW49ITAsdCYmITE9PT10LmFsbG93SGFsZk9wZW4mJih0aGlzLmFsbG93SGFsZk9wZW49ITEpLHRoaXMub25jZShcImVuZFwiLGgpfWZ1bmN0aW9uIGgoKXt0aGlzLmFsbG93SGFsZk9wZW58fHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWR8fG4ubmV4dFRpY2socCx0aGlzKX1mdW5jdGlvbiBwKHQpe3QuZW5kKCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGwucHJvdG90eXBlLFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobC5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX3JlYWRhYmxlU3RhdGUmJnZvaWQgMCE9PXRoaXMuX3dyaXRhYmxlU3RhdGUmJih0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQpfSxzZXQ6ZnVuY3Rpb24odCl7dm9pZCAwIT09dGhpcy5fcmVhZGFibGVTdGF0ZSYmdm9pZCAwIT09dGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPXQsdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ9dCl9fSksbC5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24odCxlKXt0aGlzLnB1c2gobnVsbCksdGhpcy5lbmQoKSxuLm5leHRUaWNrKGUsdCl9fSxmdW5jdGlvbih0LGUscil7dmFyIG4saSxvLGE9cigxNDcpLHM9cig0KSx1PXIoMTApLGM9cigxNCksZj1yKDEzKSxsPXIoNDQpLGg9cig0NSkscD1zLldlYWtNYXA7aWYoYSl7dmFyIGQ9bmV3IHAsdj1kLmdldCxnPWQuaGFzLHk9ZC5zZXQ7bj1mdW5jdGlvbih0LGUpe3JldHVybiB5LmNhbGwoZCx0LGUpLGV9LGk9ZnVuY3Rpb24odCl7cmV0dXJuIHYuY2FsbChkLHQpfHx7fX0sbz1mdW5jdGlvbih0KXtyZXR1cm4gZy5jYWxsKGQsdCl9fWVsc2V7dmFyIGI9bChcInN0YXRlXCIpO2hbYl09ITAsbj1mdW5jdGlvbih0LGUpe3JldHVybiBjKHQsYixlKSxlfSxpPWZ1bmN0aW9uKHQpe3JldHVybiBmKHQsYik/dFtiXTp7fX0sbz1mdW5jdGlvbih0KXtyZXR1cm4gZih0LGIpfX10LmV4cG9ydHM9e3NldDpuLGdldDppLGhhczpvLGVuZm9yY2U6ZnVuY3Rpb24odCl7cmV0dXJuIG8odCk/aSh0KTpuKHQse30pfSxnZXR0ZXJGb3I6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciByO2lmKCF1KGUpfHwocj1pKGUpKS50eXBlIT09dCl0aHJvdyBUeXBlRXJyb3IoXCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsIFwiK3QrXCIgcmVxdWlyZWRcIik7cmV0dXJuIHJ9fX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPSExfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMDMpLGk9cig0KSxvPWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDp2b2lkIDB9O3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPDI/byhuW3RdKXx8byhpW3RdKTpuW3RdJiZuW3RdW2VdfHxpW3RdJiZpW3RdW2VdfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMjApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0KG4odCkpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPWZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO3ZhciBlPU9iamVjdC5wcm90b3R5cGUscj1lLmhhc093blByb3BlcnR5LG49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sP1N5bWJvbDp7fSxpPW4uaXRlcmF0b3J8fFwiQEBpdGVyYXRvclwiLG89bi5hc3luY0l0ZXJhdG9yfHxcIkBAYXN5bmNJdGVyYXRvclwiLGE9bi50b1N0cmluZ1RhZ3x8XCJAQHRvU3RyaW5nVGFnXCI7ZnVuY3Rpb24gcyh0LGUscixuKXt2YXIgaT1lJiZlLnByb3RvdHlwZSBpbnN0YW5jZW9mIGY/ZTpmLG89T2JqZWN0LmNyZWF0ZShpLnByb3RvdHlwZSksYT1uZXcgeChufHxbXSk7cmV0dXJuIG8uX2ludm9rZT1mdW5jdGlvbih0LGUscil7dmFyIG49XCJzdXNwZW5kZWRTdGFydFwiO3JldHVybiBmdW5jdGlvbihpLG8pe2lmKFwiZXhlY3V0aW5nXCI9PT1uKXRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7aWYoXCJjb21wbGV0ZWRcIj09PW4pe2lmKFwidGhyb3dcIj09PWkpdGhyb3cgbztyZXR1cm4gRSgpfWZvcihyLm1ldGhvZD1pLHIuYXJnPW87Oyl7dmFyIGE9ci5kZWxlZ2F0ZTtpZihhKXt2YXIgcz1fKGEscik7aWYocyl7aWYocz09PWMpY29udGludWU7cmV0dXJuIHN9fWlmKFwibmV4dFwiPT09ci5tZXRob2Qpci5zZW50PXIuX3NlbnQ9ci5hcmc7ZWxzZSBpZihcInRocm93XCI9PT1yLm1ldGhvZCl7aWYoXCJzdXNwZW5kZWRTdGFydFwiPT09bil0aHJvdyBuPVwiY29tcGxldGVkXCIsci5hcmc7ci5kaXNwYXRjaEV4Y2VwdGlvbihyLmFyZyl9ZWxzZVwicmV0dXJuXCI9PT1yLm1ldGhvZCYmci5hYnJ1cHQoXCJyZXR1cm5cIixyLmFyZyk7bj1cImV4ZWN1dGluZ1wiO3ZhciBmPXUodCxlLHIpO2lmKFwibm9ybWFsXCI9PT1mLnR5cGUpe2lmKG49ci5kb25lP1wiY29tcGxldGVkXCI6XCJzdXNwZW5kZWRZaWVsZFwiLGYuYXJnPT09Yyljb250aW51ZTtyZXR1cm57dmFsdWU6Zi5hcmcsZG9uZTpyLmRvbmV9fVwidGhyb3dcIj09PWYudHlwZSYmKG49XCJjb21wbGV0ZWRcIixyLm1ldGhvZD1cInRocm93XCIsci5hcmc9Zi5hcmcpfX19KHQscixhKSxvfWZ1bmN0aW9uIHUodCxlLHIpe3RyeXtyZXR1cm57dHlwZTpcIm5vcm1hbFwiLGFyZzp0LmNhbGwoZSxyKX19Y2F0Y2godCl7cmV0dXJue3R5cGU6XCJ0aHJvd1wiLGFyZzp0fX19dC53cmFwPXM7dmFyIGM9e307ZnVuY3Rpb24gZigpe31mdW5jdGlvbiBsKCl7fWZ1bmN0aW9uIGgoKXt9dmFyIHA9e307cFtpXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt2YXIgZD1PYmplY3QuZ2V0UHJvdG90eXBlT2Ysdj1kJiZkKGQoayhbXSkpKTt2JiZ2IT09ZSYmci5jYWxsKHYsaSkmJihwPXYpO3ZhciBnPWgucHJvdG90eXBlPWYucHJvdG90eXBlPU9iamVjdC5jcmVhdGUocCk7ZnVuY3Rpb24geSh0KXtbXCJuZXh0XCIsXCJ0aHJvd1wiLFwicmV0dXJuXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3RbZV09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2ludm9rZShlLHQpfX0pKX1mdW5jdGlvbiBiKHQpe3ZhciBlO3RoaXMuX2ludm9rZT1mdW5jdGlvbihuLGkpe2Z1bmN0aW9uIG8oKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsbyl7IWZ1bmN0aW9uIGUobixpLG8sYSl7dmFyIHM9dSh0W25dLHQsaSk7aWYoXCJ0aHJvd1wiIT09cy50eXBlKXt2YXIgYz1zLmFyZyxmPWMudmFsdWU7cmV0dXJuIGYmJlwib2JqZWN0XCI9PXR5cGVvZiBmJiZyLmNhbGwoZixcIl9fYXdhaXRcIik/UHJvbWlzZS5yZXNvbHZlKGYuX19hd2FpdCkudGhlbigoZnVuY3Rpb24odCl7ZShcIm5leHRcIix0LG8sYSl9KSwoZnVuY3Rpb24odCl7ZShcInRocm93XCIsdCxvLGEpfSkpOlByb21pc2UucmVzb2x2ZShmKS50aGVuKChmdW5jdGlvbih0KXtjLnZhbHVlPXQsbyhjKX0pLChmdW5jdGlvbih0KXtyZXR1cm4gZShcInRocm93XCIsdCxvLGEpfSkpfWEocy5hcmcpfShuLGksZSxvKX0pKX1yZXR1cm4gZT1lP2UudGhlbihvLG8pOm8oKX19ZnVuY3Rpb24gXyh0LGUpe3ZhciByPXQuaXRlcmF0b3JbZS5tZXRob2RdO2lmKHZvaWQgMD09PXIpe2lmKGUuZGVsZWdhdGU9bnVsbCxcInRocm93XCI9PT1lLm1ldGhvZCl7aWYodC5pdGVyYXRvci5yZXR1cm4mJihlLm1ldGhvZD1cInJldHVyblwiLGUuYXJnPXZvaWQgMCxfKHQsZSksXCJ0aHJvd1wiPT09ZS5tZXRob2QpKXJldHVybiBjO2UubWV0aG9kPVwidGhyb3dcIixlLmFyZz1uZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKX1yZXR1cm4gY312YXIgbj11KHIsdC5pdGVyYXRvcixlLmFyZyk7aWYoXCJ0aHJvd1wiPT09bi50eXBlKXJldHVybiBlLm1ldGhvZD1cInRocm93XCIsZS5hcmc9bi5hcmcsZS5kZWxlZ2F0ZT1udWxsLGM7dmFyIGk9bi5hcmc7cmV0dXJuIGk/aS5kb25lPyhlW3QucmVzdWx0TmFtZV09aS52YWx1ZSxlLm5leHQ9dC5uZXh0TG9jLFwicmV0dXJuXCIhPT1lLm1ldGhvZCYmKGUubWV0aG9kPVwibmV4dFwiLGUuYXJnPXZvaWQgMCksZS5kZWxlZ2F0ZT1udWxsLGMpOmk6KGUubWV0aG9kPVwidGhyb3dcIixlLmFyZz1uZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksZS5kZWxlZ2F0ZT1udWxsLGMpfWZ1bmN0aW9uIG0odCl7dmFyIGU9e3RyeUxvYzp0WzBdfTsxIGluIHQmJihlLmNhdGNoTG9jPXRbMV0pLDIgaW4gdCYmKGUuZmluYWxseUxvYz10WzJdLGUuYWZ0ZXJMb2M9dFszXSksdGhpcy50cnlFbnRyaWVzLnB1c2goZSl9ZnVuY3Rpb24gdyh0KXt2YXIgZT10LmNvbXBsZXRpb258fHt9O2UudHlwZT1cIm5vcm1hbFwiLGRlbGV0ZSBlLmFyZyx0LmNvbXBsZXRpb249ZX1mdW5jdGlvbiB4KHQpe3RoaXMudHJ5RW50cmllcz1be3RyeUxvYzpcInJvb3RcIn1dLHQuZm9yRWFjaChtLHRoaXMpLHRoaXMucmVzZXQoITApfWZ1bmN0aW9uIGsodCl7aWYodCl7dmFyIGU9dFtpXTtpZihlKXJldHVybiBlLmNhbGwodCk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5uZXh0KXJldHVybiB0O2lmKCFpc05hTih0Lmxlbmd0aCkpe3ZhciBuPS0xLG89ZnVuY3Rpb24gZSgpe2Zvcig7KytuPHQubGVuZ3RoOylpZihyLmNhbGwodCxuKSlyZXR1cm4gZS52YWx1ZT10W25dLGUuZG9uZT0hMSxlO3JldHVybiBlLnZhbHVlPXZvaWQgMCxlLmRvbmU9ITAsZX07cmV0dXJuIG8ubmV4dD1vfX1yZXR1cm57bmV4dDpFfX1mdW5jdGlvbiBFKCl7cmV0dXJue3ZhbHVlOnZvaWQgMCxkb25lOiEwfX1yZXR1cm4gbC5wcm90b3R5cGU9Zy5jb25zdHJ1Y3Rvcj1oLGguY29uc3RydWN0b3I9bCxoW2FdPWwuZGlzcGxheU5hbWU9XCJHZW5lcmF0b3JGdW5jdGlvblwiLHQuaXNHZW5lcmF0b3JGdW5jdGlvbj1mdW5jdGlvbih0KXt2YXIgZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZ0LmNvbnN0cnVjdG9yO3JldHVybiEhZSYmKGU9PT1sfHxcIkdlbmVyYXRvckZ1bmN0aW9uXCI9PT0oZS5kaXNwbGF5TmFtZXx8ZS5uYW1lKSl9LHQubWFyaz1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGgpOih0Ll9fcHJvdG9fXz1oLGEgaW4gdHx8KHRbYV09XCJHZW5lcmF0b3JGdW5jdGlvblwiKSksdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShnKSx0fSx0LmF3cmFwPWZ1bmN0aW9uKHQpe3JldHVybntfX2F3YWl0OnR9fSx5KGIucHJvdG90eXBlKSxiLnByb3RvdHlwZVtvXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSx0LkFzeW5jSXRlcmF0b3I9Yix0LmFzeW5jPWZ1bmN0aW9uKGUscixuLGkpe3ZhciBvPW5ldyBiKHMoZSxyLG4saSkpO3JldHVybiB0LmlzR2VuZXJhdG9yRnVuY3Rpb24ocik/bzpvLm5leHQoKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kb25lP3QudmFsdWU6by5uZXh0KCl9KSl9LHkoZyksZ1thXT1cIkdlbmVyYXRvclwiLGdbaV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sZy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBHZW5lcmF0b3JdXCJ9LHQua2V5cz1mdW5jdGlvbih0KXt2YXIgZT1bXTtmb3IodmFyIHIgaW4gdCllLnB1c2gocik7cmV0dXJuIGUucmV2ZXJzZSgpLGZ1bmN0aW9uIHIoKXtmb3IoO2UubGVuZ3RoOyl7dmFyIG49ZS5wb3AoKTtpZihuIGluIHQpcmV0dXJuIHIudmFsdWU9bixyLmRvbmU9ITEscn1yZXR1cm4gci5kb25lPSEwLHJ9fSx0LnZhbHVlcz1rLHgucHJvdG90eXBlPXtjb25zdHJ1Y3Rvcjp4LHJlc2V0OmZ1bmN0aW9uKHQpe2lmKHRoaXMucHJldj0wLHRoaXMubmV4dD0wLHRoaXMuc2VudD10aGlzLl9zZW50PXZvaWQgMCx0aGlzLmRvbmU9ITEsdGhpcy5kZWxlZ2F0ZT1udWxsLHRoaXMubWV0aG9kPVwibmV4dFwiLHRoaXMuYXJnPXZvaWQgMCx0aGlzLnRyeUVudHJpZXMuZm9yRWFjaCh3KSwhdClmb3IodmFyIGUgaW4gdGhpcylcInRcIj09PWUuY2hhckF0KDApJiZyLmNhbGwodGhpcyxlKSYmIWlzTmFOKCtlLnNsaWNlKDEpKSYmKHRoaXNbZV09dm9pZCAwKX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuZG9uZT0hMDt2YXIgdD10aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtpZihcInRocm93XCI9PT10LnR5cGUpdGhyb3cgdC5hcmc7cmV0dXJuIHRoaXMucnZhbH0sZGlzcGF0Y2hFeGNlcHRpb246ZnVuY3Rpb24odCl7aWYodGhpcy5kb25lKXRocm93IHQ7dmFyIGU9dGhpcztmdW5jdGlvbiBuKHIsbil7cmV0dXJuIGEudHlwZT1cInRocm93XCIsYS5hcmc9dCxlLm5leHQ9cixuJiYoZS5tZXRob2Q9XCJuZXh0XCIsZS5hcmc9dm9pZCAwKSwhIW59Zm9yKHZhciBpPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtpPj0wOy0taSl7dmFyIG89dGhpcy50cnlFbnRyaWVzW2ldLGE9by5jb21wbGV0aW9uO2lmKFwicm9vdFwiPT09by50cnlMb2MpcmV0dXJuIG4oXCJlbmRcIik7aWYoby50cnlMb2M8PXRoaXMucHJldil7dmFyIHM9ci5jYWxsKG8sXCJjYXRjaExvY1wiKSx1PXIuY2FsbChvLFwiZmluYWxseUxvY1wiKTtpZihzJiZ1KXtpZih0aGlzLnByZXY8by5jYXRjaExvYylyZXR1cm4gbihvLmNhdGNoTG9jLCEwKTtpZih0aGlzLnByZXY8by5maW5hbGx5TG9jKXJldHVybiBuKG8uZmluYWxseUxvYyl9ZWxzZSBpZihzKXtpZih0aGlzLnByZXY8by5jYXRjaExvYylyZXR1cm4gbihvLmNhdGNoTG9jLCEwKX1lbHNle2lmKCF1KXRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO2lmKHRoaXMucHJldjxvLmZpbmFsbHlMb2MpcmV0dXJuIG4oby5maW5hbGx5TG9jKX19fX0sYWJydXB0OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtuPj0wOy0tbil7dmFyIGk9dGhpcy50cnlFbnRyaWVzW25dO2lmKGkudHJ5TG9jPD10aGlzLnByZXYmJnIuY2FsbChpLFwiZmluYWxseUxvY1wiKSYmdGhpcy5wcmV2PGkuZmluYWxseUxvYyl7dmFyIG89aTticmVha319byYmKFwiYnJlYWtcIj09PXR8fFwiY29udGludWVcIj09PXQpJiZvLnRyeUxvYzw9ZSYmZTw9by5maW5hbGx5TG9jJiYobz1udWxsKTt2YXIgYT1vP28uY29tcGxldGlvbjp7fTtyZXR1cm4gYS50eXBlPXQsYS5hcmc9ZSxvPyh0aGlzLm1ldGhvZD1cIm5leHRcIix0aGlzLm5leHQ9by5maW5hbGx5TG9jLGMpOnRoaXMuY29tcGxldGUoYSl9LGNvbXBsZXRlOmZ1bmN0aW9uKHQsZSl7aWYoXCJ0aHJvd1wiPT09dC50eXBlKXRocm93IHQuYXJnO3JldHVyblwiYnJlYWtcIj09PXQudHlwZXx8XCJjb250aW51ZVwiPT09dC50eXBlP3RoaXMubmV4dD10LmFyZzpcInJldHVyblwiPT09dC50eXBlPyh0aGlzLnJ2YWw9dGhpcy5hcmc9dC5hcmcsdGhpcy5tZXRob2Q9XCJyZXR1cm5cIix0aGlzLm5leHQ9XCJlbmRcIik6XCJub3JtYWxcIj09PXQudHlwZSYmZSYmKHRoaXMubmV4dD1lKSxjfSxmaW5pc2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtlPj0wOy0tZSl7dmFyIHI9dGhpcy50cnlFbnRyaWVzW2VdO2lmKHIuZmluYWxseUxvYz09PXQpcmV0dXJuIHRoaXMuY29tcGxldGUoci5jb21wbGV0aW9uLHIuYWZ0ZXJMb2MpLHcociksY319LGNhdGNoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7ZT49MDstLWUpe3ZhciByPXRoaXMudHJ5RW50cmllc1tlXTtpZihyLnRyeUxvYz09PXQpe3ZhciBuPXIuY29tcGxldGlvbjtpZihcInRocm93XCI9PT1uLnR5cGUpe3ZhciBpPW4uYXJnO3cocil9cmV0dXJuIGl9fXRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKX0sZGVsZWdhdGVZaWVsZDpmdW5jdGlvbih0LGUscil7cmV0dXJuIHRoaXMuZGVsZWdhdGU9e2l0ZXJhdG9yOmsodCkscmVzdWx0TmFtZTplLG5leHRMb2M6cn0sXCJuZXh0XCI9PT10aGlzLm1ldGhvZCYmKHRoaXMuYXJnPXZvaWQgMCksY319LHR9KHQuZXhwb3J0cyk7dHJ5e3JlZ2VuZXJhdG9yUnVudGltZT1ufWNhdGNoKHQpe0Z1bmN0aW9uKFwiclwiLFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShuKX19LGZ1bmN0aW9uKHQsZSl7XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmNyZWF0ZT90LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt0LnN1cGVyXz1lLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pfTp0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt0LnN1cGVyXz1lO3ZhciByPWZ1bmN0aW9uKCl7fTtyLnByb3RvdHlwZT1lLnByb3RvdHlwZSx0LnByb3RvdHlwZT1uZXcgcix0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10fX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiByKHQsZSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPWVbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX10LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBlJiZyKHQucHJvdG90eXBlLGUpLG4mJnIodCxuKSx0fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19fSxmdW5jdGlvbih0LGUpe3ZhciByPU1hdGguY2VpbCxuPU1hdGguZmxvb3I7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpc05hTih0PSt0KT8wOih0PjA/bjpyKSh0KX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDcxKSxpPXIoNjApLG89cigyNyksYT1yKDE1KSxzPXIoMTEyKSx1PVtdLnB1c2gsYz1mdW5jdGlvbih0KXt2YXIgZT0xPT10LHI9Mj09dCxjPTM9PXQsZj00PT10LGw9Nj09dCxoPTU9PXR8fGw7cmV0dXJuIGZ1bmN0aW9uKHAsZCx2LGcpe2Zvcih2YXIgeSxiLF89byhwKSxtPWkoXyksdz1uKGQsdiwzKSx4PWEobS5sZW5ndGgpLGs9MCxFPWd8fHMsUz1lP0UocCx4KTpyP0UocCwwKTp2b2lkIDA7eD5rO2srKylpZigoaHx8ayBpbiBtKSYmKGI9dyh5PW1ba10sayxfKSx0KSlpZihlKVNba109YjtlbHNlIGlmKGIpc3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIHk7Y2FzZSA2OnJldHVybiBrO2Nhc2UgMjp1LmNhbGwoUyx5KX1lbHNlIGlmKGYpcmV0dXJuITE7cmV0dXJuIGw/LTE6Y3x8Zj9mOlN9fTt0LmV4cG9ydHM9e2ZvckVhY2g6YygwKSxtYXA6YygxKSxmaWx0ZXI6YygyKSxzb21lOmMoMyksZXZlcnk6Yyg0KSxmaW5kOmMoNSksZmluZEluZGV4OmMoNil9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz17fX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDUzKTtuKHt0YXJnZXQ6XCJSZWdFeHBcIixwcm90bzohMCxmb3JjZWQ6Ly4vLmV4ZWMhPT1pfSx7ZXhlYzppfSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDUpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByPVtdW3RdO3JldHVybiFyfHwhbigoZnVuY3Rpb24oKXtyLmNhbGwobnVsbCxlfHxmdW5jdGlvbigpe3Rocm93IDF9LDEpfSkpfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDMzKS5tYXAsbz1yKDUpLGE9cig1NCkoXCJtYXBcIikscz1hJiYhbygoZnVuY3Rpb24oKXtbXS5tYXAuY2FsbCh7bGVuZ3RoOi0xLDA6MX0sKGZ1bmN0aW9uKHQpe3Rocm93IHR9KSl9KSk7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IWF8fCFzfSx7bWFwOmZ1bmN0aW9uKHQpe3JldHVybiBpKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LGZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpPXQuZXhwb3J0cz17fTtmdW5jdGlvbiBvKCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBhKCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIHModCl7aWYocj09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQodCwwKTtpZigocj09PW98fCFyKSYmc2V0VGltZW91dClyZXR1cm4gcj1zZXRUaW1lb3V0LHNldFRpbWVvdXQodCwwKTt0cnl7cmV0dXJuIHIodCwwKX1jYXRjaChlKXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLHQsMCl9Y2F0Y2goZSl7cmV0dXJuIHIuY2FsbCh0aGlzLHQsMCl9fX0hZnVuY3Rpb24oKXt0cnl7cj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6b31jYXRjaCh0KXtyPW99dHJ5e249XCJmdW5jdGlvblwiPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDphfWNhdGNoKHQpe249YX19KCk7dmFyIHUsYz1bXSxmPSExLGw9LTE7ZnVuY3Rpb24gaCgpe2YmJnUmJihmPSExLHUubGVuZ3RoP2M9dS5jb25jYXQoYyk6bD0tMSxjLmxlbmd0aCYmcCgpKX1mdW5jdGlvbiBwKCl7aWYoIWYpe3ZhciB0PXMoaCk7Zj0hMDtmb3IodmFyIGU9Yy5sZW5ndGg7ZTspe2Zvcih1PWMsYz1bXTsrK2w8ZTspdSYmdVtsXS5ydW4oKTtsPS0xLGU9Yy5sZW5ndGh9dT1udWxsLGY9ITEsZnVuY3Rpb24odCl7aWYobj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KHQpO2lmKChuPT09YXx8IW4pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG49Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dCh0KTt0cnl7bih0KX1jYXRjaChlKXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLHQpfWNhdGNoKGUpe3JldHVybiBuLmNhbGwodGhpcyx0KX19fSh0KX19ZnVuY3Rpb24gZCh0LGUpe3RoaXMuZnVuPXQsdGhpcy5hcnJheT1lfWZ1bmN0aW9uIHYoKXt9aS5uZXh0VGljaz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllW3ItMV09YXJndW1lbnRzW3JdO2MucHVzaChuZXcgZCh0LGUpKSwxIT09Yy5sZW5ndGh8fGZ8fHMocCl9LGQucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LGkudGl0bGU9XCJicm93c2VyXCIsaS5icm93c2VyPSEwLGkuZW52PXt9LGkuYXJndj1bXSxpLnZlcnNpb249XCJcIixpLnZlcnNpb25zPXt9LGkub249dixpLmFkZExpc3RlbmVyPXYsaS5vbmNlPXYsaS5vZmY9dixpLnJlbW92ZUxpc3RlbmVyPXYsaS5yZW1vdmVBbGxMaXN0ZW5lcnM9dixpLmVtaXQ9dixpLnByZXBlbmRMaXN0ZW5lcj12LGkucHJlcGVuZE9uY2VMaXN0ZW5lcj12LGkubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybltdfSxpLmJpbmRpbmc9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9LGkuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9LGkuY2hkaXI9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfSxpLnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIodCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1lLmlzQXJyYXk9ZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmlzQXJyYXk/QXJyYXkuaXNBcnJheSh0KTpcIltvYmplY3QgQXJyYXldXCI9PT1yKHQpfSxlLmlzQm9vbGVhbj1mdW5jdGlvbih0KXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIHR9LGUuaXNOdWxsPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dH0sZS5pc051bGxPclVuZGVmaW5lZD1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dH0sZS5pc051bWJlcj1mdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdH0sZS5pc1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdH0sZS5pc1N5bWJvbD1mdW5jdGlvbih0KXtyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdH0sZS5pc1VuZGVmaW5lZD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dH0sZS5pc1JlZ0V4cD1mdW5jdGlvbih0KXtyZXR1cm5cIltvYmplY3QgUmVnRXhwXVwiPT09cih0KX0sZS5pc09iamVjdD1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXR9LGUuaXNEYXRlPWZ1bmN0aW9uKHQpe3JldHVyblwiW29iamVjdCBEYXRlXVwiPT09cih0KX0sZS5pc0Vycm9yPWZ1bmN0aW9uKHQpe3JldHVyblwiW29iamVjdCBFcnJvcl1cIj09PXIodCl8fHQgaW5zdGFuY2VvZiBFcnJvcn0sZS5pc0Z1bmN0aW9uPWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHR9LGUuaXNQcmltaXRpdmU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PT10fHxcImJvb2xlYW5cIj09dHlwZW9mIHR8fFwibnVtYmVyXCI9PXR5cGVvZiB0fHxcInN0cmluZ1wiPT10eXBlb2YgdHx8XCJzeW1ib2xcIj09dHlwZW9mIHR8fHZvaWQgMD09PXR9LGUuaXNCdWZmZXI9dC5pc0J1ZmZlcn0pLmNhbGwodGhpcyxyKDkyKS5CdWZmZXIpfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig5NiksaT1yKDE1NSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIWV8fFwib2JqZWN0XCIhPT1uKGUpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP2kodCk6ZX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDgwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJm4odCxlKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDE2NiksaT1yKDE2Nyksbz1yKDE2OCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4odCl8fGkodCxlKXx8bygpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTApO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKCFuKHQpKXJldHVybiB0O3ZhciByLGk7aWYoZSYmXCJmdW5jdGlvblwiPT10eXBlb2Yocj10LnRvU3RyaW5nKSYmIW4oaT1yLmNhbGwodCkpKXJldHVybiBpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mKHI9dC52YWx1ZU9mKSYmIW4oaT1yLmNhbGwodCkpKXJldHVybiBpO2lmKCFlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZihyPXQudG9TdHJpbmcpJiYhbihpPXIuY2FsbCh0KSkpcmV0dXJuIGk7dGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNjQpLGk9cig2NSksbz1uKFwia2V5c1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG9bdF18fChvW3RdPWkodCkpfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9e319LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEwNCksaT1yKDY3KS5jb25jYXQoXCJsZW5ndGhcIixcInByb3RvdHlwZVwiKTtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsaSl9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxOSk7dC5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHQpe3JldHVyblwiQXJyYXlcIj09bih0KX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEwNCksaT1yKDY3KTt0LmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsaSl9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMSkuZixpPXIoMTMpLG89cigzKShcInRvU3RyaW5nVGFnXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7dCYmIWkodD1yP3Q6dC5wcm90b3R5cGUsbykmJm4odCxvLHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZX0pfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKHQpK1wiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMTIpLGk9cigxMTMpLG89cigzNCksYT1yKDI0KSxzPXIoMTE0KSx1PWEuc2V0LGM9YS5nZXR0ZXJGb3IoXCJBcnJheSBJdGVyYXRvclwiKTt0LmV4cG9ydHM9cyhBcnJheSxcIkFycmF5XCIsKGZ1bmN0aW9uKHQsZSl7dSh0aGlzLHt0eXBlOlwiQXJyYXkgSXRlcmF0b3JcIix0YXJnZXQ6bih0KSxpbmRleDowLGtpbmQ6ZX0pfSksKGZ1bmN0aW9uKCl7dmFyIHQ9Yyh0aGlzKSxlPXQudGFyZ2V0LHI9dC5raW5kLG49dC5pbmRleCsrO3JldHVybiFlfHxuPj1lLmxlbmd0aD8odC50YXJnZXQ9dm9pZCAwLHt2YWx1ZTp2b2lkIDAsZG9uZTohMH0pOlwia2V5c1wiPT1yP3t2YWx1ZTpuLGRvbmU6ITF9OlwidmFsdWVzXCI9PXI/e3ZhbHVlOmVbbl0sZG9uZTohMX06e3ZhbHVlOltuLGVbbl1dLGRvbmU6ITF9fSksXCJ2YWx1ZXNcIiksby5Bcmd1bWVudHM9by5BcnJheSxpKFwia2V5c1wiKSxpKFwidmFsdWVzXCIpLGkoXCJlbnRyaWVzXCIpfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig3MiksaT1yKDE3KSxvPXIoMTU0KTtufHxpKE9iamVjdC5wcm90b3R5cGUsXCJ0b1N0cmluZ1wiLG8se3Vuc2FmZTohMH0pfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saSxvPXIoNzMpLGE9cigxMTkpLHM9UmVnRXhwLnByb3RvdHlwZS5leGVjLHU9U3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLGM9cyxmPShuPS9hLyxpPS9iKi9nLHMuY2FsbChuLFwiYVwiKSxzLmNhbGwoaSxcImFcIiksMCE9PW4ubGFzdEluZGV4fHwwIT09aS5sYXN0SW5kZXgpLGw9YS5VTlNVUFBPUlRFRF9ZfHxhLkJST0tFTl9DQVJFVCxoPXZvaWQgMCE9PS8oKT8/Ly5leGVjKFwiXCIpWzFdOyhmfHxofHxsKSYmKGM9ZnVuY3Rpb24odCl7dmFyIGUscixuLGksYT10aGlzLGM9bCYmYS5zdGlja3kscD1vLmNhbGwoYSksZD1hLnNvdXJjZSx2PTAsZz10O3JldHVybiBjJiYoLTE9PT0ocD1wLnJlcGxhY2UoXCJ5XCIsXCJcIikpLmluZGV4T2YoXCJnXCIpJiYocCs9XCJnXCIpLGc9U3RyaW5nKHQpLnNsaWNlKGEubGFzdEluZGV4KSxhLmxhc3RJbmRleD4wJiYoIWEubXVsdGlsaW5lfHxhLm11bHRpbGluZSYmXCJcXG5cIiE9PXRbYS5sYXN0SW5kZXgtMV0pJiYoZD1cIig/OiBcIitkK1wiKVwiLGc9XCIgXCIrZyx2KyspLHI9bmV3IFJlZ0V4cChcIl4oPzpcIitkK1wiKVwiLHApKSxoJiYocj1uZXcgUmVnRXhwKFwiXlwiK2QrXCIkKD8hXFxcXHMpXCIscCkpLGYmJihlPWEubGFzdEluZGV4KSxuPXMuY2FsbChjP3I6YSxnKSxjP24/KG4uaW5wdXQ9bi5pbnB1dC5zbGljZSh2KSxuWzBdPW5bMF0uc2xpY2Uodiksbi5pbmRleD1hLmxhc3RJbmRleCxhLmxhc3RJbmRleCs9blswXS5sZW5ndGgpOmEubGFzdEluZGV4PTA6ZiYmbiYmKGEubGFzdEluZGV4PWEuZ2xvYmFsP24uaW5kZXgrblswXS5sZW5ndGg6ZSksaCYmbiYmbi5sZW5ndGg+MSYmdS5jYWxsKG5bMF0sciwoZnVuY3Rpb24oKXtmb3IoaT0xO2k8YXJndW1lbnRzLmxlbmd0aC0yO2krKyl2b2lkIDA9PT1hcmd1bWVudHNbaV0mJihuW2ldPXZvaWQgMCl9KSksbn0pLHQuZXhwb3J0cz1jfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig1KSxpPXIoMyksbz1yKDgzKSxhPWkoXCJzcGVjaWVzXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbz49NTF8fCFuKChmdW5jdGlvbigpe3ZhciBlPVtdO3JldHVybihlLmNvbnN0cnVjdG9yPXt9KVthXT1mdW5jdGlvbigpe3JldHVybntmb286MX19LDEhPT1lW3RdKEJvb2xlYW4pLmZvb30pKX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24oZSl7IWUudmVyc2lvbnx8MD09PWUudmVyc2lvbi5pbmRleE9mKFwidjAuXCIpfHwwPT09ZS52ZXJzaW9uLmluZGV4T2YoXCJ2MS5cIikmJjAhPT1lLnZlcnNpb24uaW5kZXhPZihcInYxLjguXCIpP3QuZXhwb3J0cz17bmV4dFRpY2s6ZnVuY3Rpb24odCxyLG4saSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7dmFyIG8sYSxzPWFyZ3VtZW50cy5sZW5ndGg7c3dpdGNoKHMpe2Nhc2UgMDpjYXNlIDE6cmV0dXJuIGUubmV4dFRpY2sodCk7Y2FzZSAyOnJldHVybiBlLm5leHRUaWNrKChmdW5jdGlvbigpe3QuY2FsbChudWxsLHIpfSkpO2Nhc2UgMzpyZXR1cm4gZS5uZXh0VGljaygoZnVuY3Rpb24oKXt0LmNhbGwobnVsbCxyLG4pfSkpO2Nhc2UgNDpyZXR1cm4gZS5uZXh0VGljaygoZnVuY3Rpb24oKXt0LmNhbGwobnVsbCxyLG4saSl9KSk7ZGVmYXVsdDpmb3Iobz1uZXcgQXJyYXkocy0xKSxhPTA7YTxvLmxlbmd0aDspb1thKytdPWFyZ3VtZW50c1thXTtyZXR1cm4gZS5uZXh0VGljaygoZnVuY3Rpb24oKXt0LmFwcGx5KG51bGwsbyl9KSl9fX06dC5leHBvcnRzPWV9KS5jYWxsKHRoaXMscigzOCkpfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig5MiksaT1uLkJ1ZmZlcjtmdW5jdGlvbiBvKHQsZSl7Zm9yKHZhciByIGluIHQpZVtyXT10W3JdfWZ1bmN0aW9uIGEodCxlLHIpe3JldHVybiBpKHQsZSxyKX1pLmZyb20mJmkuYWxsb2MmJmkuYWxsb2NVbnNhZmUmJmkuYWxsb2NVbnNhZmVTbG93P3QuZXhwb3J0cz1uOihvKG4sZSksZS5CdWZmZXI9YSksbyhpLGEpLGEuZnJvbT1mdW5jdGlvbih0LGUscil7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyXCIpO3JldHVybiBpKHQsZSxyKX0sYS5hbGxvYz1mdW5jdGlvbih0LGUscil7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7dmFyIG49aSh0KTtyZXR1cm4gdm9pZCAwIT09ZT9cInN0cmluZ1wiPT10eXBlb2Ygcj9uLmZpbGwoZSxyKTpuLmZpbGwoZSk6bi5maWxsKDApLG59LGEuYWxsb2NVbnNhZmU9ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7cmV0dXJuIGkodCl9LGEuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO3JldHVybiBuLlNsb3dCdWZmZXIodCl9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxNTYpO2Z1bmN0aW9uIGkoZSxyLG8pe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmdldD90LmV4cG9ydHM9aT1SZWZsZWN0LmdldDp0LmV4cG9ydHM9aT1mdW5jdGlvbih0LGUscil7dmFyIGk9bih0LGUpO2lmKGkpe3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSxlKTtyZXR1cm4gby5nZXQ/by5nZXQuY2FsbChyKTpvLnZhbHVlfX0saShlLHIsb3x8ZSl9dC5leHBvcnRzPWl9LGZ1bmN0aW9uKHQsZSxyKXsoZnVuY3Rpb24obil7ZS5sb2c9ZnVuY3Rpb24oLi4udCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUubG9nJiZjb25zb2xlLmxvZyguLi50KX0sZS5mb3JtYXRBcmdzPWZ1bmN0aW9uKGUpe2lmKGVbMF09KHRoaXMudXNlQ29sb3JzP1wiJWNcIjpcIlwiKSt0aGlzLm5hbWVzcGFjZSsodGhpcy51c2VDb2xvcnM/XCIgJWNcIjpcIiBcIikrZVswXSsodGhpcy51c2VDb2xvcnM/XCIlYyBcIjpcIiBcIikrXCIrXCIrdC5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZiksIXRoaXMudXNlQ29sb3JzKXJldHVybjtjb25zdCByPVwiY29sb3I6IFwiK3RoaXMuY29sb3I7ZS5zcGxpY2UoMSwwLHIsXCJjb2xvcjogaW5oZXJpdFwiKTtsZXQgbj0wLGk9MDtlWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZyx0PT57XCIlJVwiIT09dCYmKG4rKyxcIiVjXCI9PT10JiYoaT1uKSl9KSxlLnNwbGljZShpLDAscil9LGUuc2F2ZT1mdW5jdGlvbih0KXt0cnl7dD9lLnN0b3JhZ2Uuc2V0SXRlbShcImRlYnVnXCIsdCk6ZS5zdG9yYWdlLnJlbW92ZUl0ZW0oXCJkZWJ1Z1wiKX1jYXRjaCh0KXt9fSxlLmxvYWQ9ZnVuY3Rpb24oKXtsZXQgdDt0cnl7dD1lLnN0b3JhZ2UuZ2V0SXRlbShcImRlYnVnXCIpfWNhdGNoKHQpe30hdCYmdm9pZCAwIT09biYmXCJlbnZcImluIG4mJih0PW4uZW52LkRFQlVHKTtyZXR1cm4gdH0sZS51c2VDb2xvcnM9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cucHJvY2VzcyYmKFwicmVuZGVyZXJcIj09PXdpbmRvdy5wcm9jZXNzLnR5cGV8fHdpbmRvdy5wcm9jZXNzLl9fbndqcykpcmV0dXJuITA7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLnVzZXJBZ2VudCYmbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKXJldHVybiExO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY29uc29sZSYmKHdpbmRvdy5jb25zb2xlLmZpcmVidWd8fHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiYmd2luZG93LmNvbnNvbGUudGFibGUpfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IudXNlckFnZW50JiZuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSYmcGFyc2VJbnQoUmVnRXhwLiQxLDEwKT49MzF8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci51c2VyQWdlbnQmJm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKX0sZS5zdG9yYWdlPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBsb2NhbFN0b3JhZ2V9Y2F0Y2godCl7fX0oKSxlLmNvbG9ycz1bXCIjMDAwMENDXCIsXCIjMDAwMEZGXCIsXCIjMDAzM0NDXCIsXCIjMDAzM0ZGXCIsXCIjMDA2NkNDXCIsXCIjMDA2NkZGXCIsXCIjMDA5OUNDXCIsXCIjMDA5OUZGXCIsXCIjMDBDQzAwXCIsXCIjMDBDQzMzXCIsXCIjMDBDQzY2XCIsXCIjMDBDQzk5XCIsXCIjMDBDQ0NDXCIsXCIjMDBDQ0ZGXCIsXCIjMzMwMENDXCIsXCIjMzMwMEZGXCIsXCIjMzMzM0NDXCIsXCIjMzMzM0ZGXCIsXCIjMzM2NkNDXCIsXCIjMzM2NkZGXCIsXCIjMzM5OUNDXCIsXCIjMzM5OUZGXCIsXCIjMzNDQzAwXCIsXCIjMzNDQzMzXCIsXCIjMzNDQzY2XCIsXCIjMzNDQzk5XCIsXCIjMzNDQ0NDXCIsXCIjMzNDQ0ZGXCIsXCIjNjYwMENDXCIsXCIjNjYwMEZGXCIsXCIjNjYzM0NDXCIsXCIjNjYzM0ZGXCIsXCIjNjZDQzAwXCIsXCIjNjZDQzMzXCIsXCIjOTkwMENDXCIsXCIjOTkwMEZGXCIsXCIjOTkzM0NDXCIsXCIjOTkzM0ZGXCIsXCIjOTlDQzAwXCIsXCIjOTlDQzMzXCIsXCIjQ0MwMDAwXCIsXCIjQ0MwMDMzXCIsXCIjQ0MwMDY2XCIsXCIjQ0MwMDk5XCIsXCIjQ0MwMENDXCIsXCIjQ0MwMEZGXCIsXCIjQ0MzMzAwXCIsXCIjQ0MzMzMzXCIsXCIjQ0MzMzY2XCIsXCIjQ0MzMzk5XCIsXCIjQ0MzM0NDXCIsXCIjQ0MzM0ZGXCIsXCIjQ0M2NjAwXCIsXCIjQ0M2NjMzXCIsXCIjQ0M5OTAwXCIsXCIjQ0M5OTMzXCIsXCIjQ0NDQzAwXCIsXCIjQ0NDQzMzXCIsXCIjRkYwMDAwXCIsXCIjRkYwMDMzXCIsXCIjRkYwMDY2XCIsXCIjRkYwMDk5XCIsXCIjRkYwMENDXCIsXCIjRkYwMEZGXCIsXCIjRkYzMzAwXCIsXCIjRkYzMzMzXCIsXCIjRkYzMzY2XCIsXCIjRkYzMzk5XCIsXCIjRkYzM0NDXCIsXCIjRkYzM0ZGXCIsXCIjRkY2NjAwXCIsXCIjRkY2NjMzXCIsXCIjRkY5OTAwXCIsXCIjRkY5OTMzXCIsXCIjRkZDQzAwXCIsXCIjRkZDQzMzXCJdLHQuZXhwb3J0cz1yKDE3MikoZSk7Y29uc3R7Zm9ybWF0dGVyczppfT10LmV4cG9ydHM7aS5qPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkodCl9Y2F0Y2godCl7cmV0dXJuXCJbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogXCIrdC5tZXNzYWdlfX19KS5jYWxsKHRoaXMscigzOCkpfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49e30ucHJvcGVydHlJc0VudW1lcmFibGUsaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLG89aSYmIW4uY2FsbCh7MToyfSwxKTtlLmY9bz9mdW5jdGlvbih0KXt2YXIgZT1pKHRoaXMsdCk7cmV0dXJuISFlJiZlLmVudW1lcmFibGV9Om59LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDUpLGk9cigxOSksbz1cIlwiLnNwbGl0O3QuZXhwb3J0cz1uKChmdW5jdGlvbigpe3JldHVybiFPYmplY3QoXCJ6XCIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApfSkpP2Z1bmN0aW9uKHQpe3JldHVyblwiU3RyaW5nXCI9PWkodCk/by5jYWxsKHQsXCJcIik6T2JqZWN0KHQpfTpPYmplY3R9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDQpLGk9cigxMCksbz1uLmRvY3VtZW50LGE9aShvKSYmaShvLmNyZWF0ZUVsZW1lbnQpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gYT9vLmNyZWF0ZUVsZW1lbnQodCk6e319fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig0KSxpPXIoMTQpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3RyeXtpKG4sdCxlKX1jYXRjaChyKXtuW3RdPWV9cmV0dXJuIGV9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMDApLGk9RnVuY3Rpb24udG9TdHJpbmc7XCJmdW5jdGlvblwiIT10eXBlb2Ygbi5pbnNwZWN0U291cmNlJiYobi5pbnNwZWN0U291cmNlPWZ1bmN0aW9uKHQpe3JldHVybiBpLmNhbGwodCl9KSx0LmV4cG9ydHM9bi5pbnNwZWN0U291cmNlfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyNSksaT1yKDEwMCk7KHQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBpW3RdfHwoaVt0XT12b2lkIDAhPT1lP2U6e30pfSkoXCJ2ZXJzaW9uc1wiLFtdKS5wdXNoKHt2ZXJzaW9uOlwiMy42LjFcIixtb2RlOm4/XCJwdXJlXCI6XCJnbG9iYWxcIixjb3B5cmlnaHQ6XCLCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpXCJ9KX0sZnVuY3Rpb24odCxlKXt2YXIgcj0wLG49TWF0aC5yYW5kb20oKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJTeW1ib2woXCIrU3RyaW5nKHZvaWQgMD09PXQ/XCJcIjp0KStcIilfXCIrKCsrcituKS50b1N0cmluZygzNil9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMiksaT1yKDE1KSxvPXIoMTA1KSxhPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIsYSl7dmFyIHMsdT1uKGUpLGM9aSh1Lmxlbmd0aCksZj1vKGEsYyk7aWYodCYmciE9cil7Zm9yKDtjPmY7KWlmKChzPXVbZisrXSkhPXMpcmV0dXJuITB9ZWxzZSBmb3IoO2M+ZjtmKyspaWYoKHR8fGYgaW4gdSkmJnVbZl09PT1yKXJldHVybiB0fHxmfHwwO3JldHVybiF0JiYtMX19O3QuZXhwb3J0cz17aW5jbHVkZXM6YSghMCksaW5kZXhPZjphKCExKX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPVtcImNvbnN0cnVjdG9yXCIsXCJoYXNPd25Qcm9wZXJ0eVwiLFwiaXNQcm90b3R5cGVPZlwiLFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcInRvTG9jYWxlU3RyaW5nXCIsXCJ0b1N0cmluZ1wiLFwidmFsdWVPZlwiXX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNSksaT0vI3xcXC5wcm90b3R5cGVcXC4vLG89ZnVuY3Rpb24odCxlKXt2YXIgcj1zW2EodCldO3JldHVybiByPT1jfHxyIT11JiYoXCJmdW5jdGlvblwiPT10eXBlb2YgZT9uKGUpOiEhZSl9LGE9by5ub3JtYWxpemU9ZnVuY3Rpb24odCl7cmV0dXJuIFN0cmluZyh0KS5yZXBsYWNlKGksXCIuXCIpLnRvTG93ZXJDYXNlKCl9LHM9by5kYXRhPXt9LHU9by5OQVRJVkU9XCJOXCIsYz1vLlBPTFlGSUxMPVwiUFwiO3QuZXhwb3J0cz1vfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig1KTt0LmV4cG9ydHM9ISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzJiYhbigoZnVuY3Rpb24oKXtyZXR1cm4hU3RyaW5nKFN5bWJvbCgpKX0pKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuLGk9cig4KSxvPXIoMTA4KSxhPXIoNjcpLHM9cig0NSksdT1yKDEwOSksYz1yKDYxKSxmPXIoNDQpLGw9ZihcIklFX1BST1RPXCIpLGg9ZnVuY3Rpb24oKXt9LHA9ZnVuY3Rpb24odCl7cmV0dXJuXCI8c2NyaXB0PlwiK3QrXCI8XFwvc2NyaXB0PlwifSxkPWZ1bmN0aW9uKCl7dHJ5e249ZG9jdW1lbnQuZG9tYWluJiZuZXcgQWN0aXZlWE9iamVjdChcImh0bWxmaWxlXCIpfWNhdGNoKHQpe312YXIgdCxlO2Q9bj9mdW5jdGlvbih0KXt0LndyaXRlKHAoXCJcIikpLHQuY2xvc2UoKTt2YXIgZT10LnBhcmVudFdpbmRvdy5PYmplY3Q7cmV0dXJuIHQ9bnVsbCxlfShuKTooKGU9YyhcImlmcmFtZVwiKSkuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix1LmFwcGVuZENoaWxkKGUpLGUuc3JjPVN0cmluZyhcImphdmFzY3JpcHQ6XCIpLCh0PWUuY29udGVudFdpbmRvdy5kb2N1bWVudCkub3BlbigpLHQud3JpdGUocChcImRvY3VtZW50LkY9T2JqZWN0XCIpKSx0LmNsb3NlKCksdC5GKTtmb3IodmFyIHI9YS5sZW5ndGg7ci0tOylkZWxldGUgZC5wcm90b3R5cGVbYVtyXV07cmV0dXJuIGQoKX07c1tsXT0hMCx0LmV4cG9ydHM9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24odCxlKXt2YXIgcjtyZXR1cm4gbnVsbCE9PXQ/KGgucHJvdG90eXBlPWkodCkscj1uZXcgaCxoLnByb3RvdHlwZT1udWxsLHJbbF09dCk6cj1kKCksdm9pZCAwPT09ZT9yOm8ocixlKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDUwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIpe2lmKG4odCksdm9pZCAwPT09ZSlyZXR1cm4gdDtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmNhbGwoZSl9O2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIHQuY2FsbChlLHIpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHIsbil7cmV0dXJuIHQuY2FsbChlLHIsbil9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24ocixuLGkpe3JldHVybiB0LmNhbGwoZSxyLG4saSl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19fSxmdW5jdGlvbih0LGUscil7dmFyIG49e307bltyKDMpKFwidG9TdHJpbmdUYWdcIildPVwielwiLHQuZXhwb3J0cz1cIltvYmplY3Qgel1cIj09PVN0cmluZyhuKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoOCk7dC5leHBvcnRzPWZ1bmN0aW9uKCl7dmFyIHQ9bih0aGlzKSxlPVwiXCI7cmV0dXJuIHQuZ2xvYmFsJiYoZSs9XCJnXCIpLHQuaWdub3JlQ2FzZSYmKGUrPVwiaVwiKSx0Lm11bHRpbGluZSYmKGUrPVwibVwiKSx0LmRvdEFsbCYmKGUrPVwic1wiKSx0LnVuaWNvZGUmJihlKz1cInVcIiksdC5zdGlja3kmJihlKz1cInlcIiksZX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDEyMCkuY2hhckF0LGk9cigyNCksbz1yKDExNCksYT1pLnNldCxzPWkuZ2V0dGVyRm9yKFwiU3RyaW5nIEl0ZXJhdG9yXCIpO28oU3RyaW5nLFwiU3RyaW5nXCIsKGZ1bmN0aW9uKHQpe2EodGhpcyx7dHlwZTpcIlN0cmluZyBJdGVyYXRvclwiLHN0cmluZzpTdHJpbmcodCksaW5kZXg6MH0pfSksKGZ1bmN0aW9uKCl7dmFyIHQsZT1zKHRoaXMpLHI9ZS5zdHJpbmcsaT1lLmluZGV4O3JldHVybiBpPj1yLmxlbmd0aD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9Oih0PW4ocixpKSxlLmluZGV4Kz10Lmxlbmd0aCx7dmFsdWU6dCxkb25lOiExfSl9KSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDc2KSxpPXIoOCksbz1yKDE1KSxhPXIoMjApLHM9cig3NyksdT1yKDc4KTtuKFwibWF0Y2hcIiwxLChmdW5jdGlvbih0LGUscil7cmV0dXJuW2Z1bmN0aW9uKGUpe3ZhciByPWEodGhpcyksbj1udWxsPT1lP3ZvaWQgMDplW3RdO3JldHVybiB2b2lkIDAhPT1uP24uY2FsbChlLHIpOm5ldyBSZWdFeHAoZSlbdF0oU3RyaW5nKHIpKX0sZnVuY3Rpb24odCl7dmFyIG49cihlLHQsdGhpcyk7aWYobi5kb25lKXJldHVybiBuLnZhbHVlO3ZhciBhPWkodCksYz1TdHJpbmcodGhpcyk7aWYoIWEuZ2xvYmFsKXJldHVybiB1KGEsYyk7dmFyIGY9YS51bmljb2RlO2EubGFzdEluZGV4PTA7Zm9yKHZhciBsLGg9W10scD0wO251bGwhPT0obD11KGEsYykpOyl7dmFyIGQ9U3RyaW5nKGxbMF0pO2hbcF09ZCxcIlwiPT09ZCYmKGEubGFzdEluZGV4PXMoYyxvKGEubGFzdEluZGV4KSxmKSkscCsrfXJldHVybiAwPT09cD9udWxsOmh9XX0pKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMTcpLGk9cig1KSxvPXIoMyksYT1yKDUzKSxzPXIoMTQpLHU9byhcInNwZWNpZXNcIiksYz0haSgoZnVuY3Rpb24oKXt2YXIgdD0vLi87cmV0dXJuIHQuZXhlYz1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0Lmdyb3Vwcz17YTpcIjdcIn0sdH0sXCI3XCIhPT1cIlwiLnJlcGxhY2UodCxcIiQ8YT5cIil9KSksZj1cIiQwXCI9PT1cImFcIi5yZXBsYWNlKC8uLyxcIiQwXCIpLGw9IWkoKGZ1bmN0aW9uKCl7dmFyIHQ9Lyg/OikvLGU9dC5leGVjO3QuZXhlYz1mdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIHI9XCJhYlwiLnNwbGl0KHQpO3JldHVybiAyIT09ci5sZW5ndGh8fFwiYVwiIT09clswXXx8XCJiXCIhPT1yWzFdfSkpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscixoKXt2YXIgcD1vKHQpLGQ9IWkoKGZ1bmN0aW9uKCl7dmFyIGU9e307cmV0dXJuIGVbcF09ZnVuY3Rpb24oKXtyZXR1cm4gN30sNyE9XCJcIlt0XShlKX0pKSx2PWQmJiFpKChmdW5jdGlvbigpe3ZhciBlPSExLHI9L2EvO3JldHVyblwic3BsaXRcIj09PXQmJigocj17fSkuY29uc3RydWN0b3I9e30sci5jb25zdHJ1Y3Rvclt1XT1mdW5jdGlvbigpe3JldHVybiByfSxyLmZsYWdzPVwiXCIscltwXT0vLi9bcF0pLHIuZXhlYz1mdW5jdGlvbigpe3JldHVybiBlPSEwLG51bGx9LHJbcF0oXCJcIiksIWV9KSk7aWYoIWR8fCF2fHxcInJlcGxhY2VcIj09PXQmJighY3x8IWYpfHxcInNwbGl0XCI9PT10JiYhbCl7dmFyIGc9Ly4vW3BdLHk9cihwLFwiXCJbdF0sKGZ1bmN0aW9uKHQsZSxyLG4saSl7cmV0dXJuIGUuZXhlYz09PWE/ZCYmIWk/e2RvbmU6ITAsdmFsdWU6Zy5jYWxsKGUscixuKX06e2RvbmU6ITAsdmFsdWU6dC5jYWxsKHIsZSxuKX06e2RvbmU6ITF9fSkse1JFUExBQ0VfS0VFUFNfJDA6Zn0pLGI9eVswXSxfPXlbMV07bihTdHJpbmcucHJvdG90eXBlLHQsYiksbihSZWdFeHAucHJvdG90eXBlLHAsMj09ZT9mdW5jdGlvbih0LGUpe3JldHVybiBfLmNhbGwodCx0aGlzLGUpfTpmdW5jdGlvbih0KXtyZXR1cm4gXy5jYWxsKHQsdGhpcyl9KX1oJiZzKFJlZ0V4cC5wcm90b3R5cGVbcF0sXCJzaGFtXCIsITApfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMTIwKS5jaGFyQXQ7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gZSsocj9uKHQsZSkubGVuZ3RoOjEpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTkpLGk9cig1Myk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5leGVjO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHIpe3ZhciBvPXIuY2FsbCh0LGUpO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBvKXRocm93IFR5cGVFcnJvcihcIlJlZ0V4cCBleGVjIG1ldGhvZCByZXR1cm5lZCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBPYmplY3Qgb3IgbnVsbFwiKTtyZXR1cm4gb31pZihcIlJlZ0V4cFwiIT09bih0KSl0aHJvdyBUeXBlRXJyb3IoXCJSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyXCIpO3JldHVybiBpLmNhbGwodCxlKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDQpLGk9cigxMjEpLG89cig1MSksYT1yKDE0KSxzPXIoMyksdT1zKFwiaXRlcmF0b3JcIiksYz1zKFwidG9TdHJpbmdUYWdcIiksZj1vLnZhbHVlcztmb3IodmFyIGwgaW4gaSl7dmFyIGg9bltsXSxwPWgmJmgucHJvdG90eXBlO2lmKHApe2lmKHBbdV0hPT1mKXRyeXthKHAsdSxmKX1jYXRjaCh0KXtwW3VdPWZ9aWYocFtjXXx8YShwLGMsbCksaVtsXSlmb3IodmFyIGQgaW4gbylpZihwW2RdIT09b1tkXSl0cnl7YShwLGQsb1tkXSl9Y2F0Y2godCl7cFtkXT1vW2RdfX19fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIHIoZSxuKXtyZXR1cm4gdC5leHBvcnRzPXI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9LHIoZSxuKX10LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDUpLG89cig0NyksYT1yKDEwKSxzPXIoMjcpLHU9cigxNSksYz1yKDgyKSxmPXIoMTEyKSxsPXIoNTQpLGg9cigzKSxwPXIoODMpLGQ9aChcImlzQ29uY2F0U3ByZWFkYWJsZVwiKSx2PXA+PTUxfHwhaSgoZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdFtkXT0hMSx0LmNvbmNhdCgpWzBdIT09dH0pKSxnPWwoXCJjb25jYXRcIikseT1mdW5jdGlvbih0KXtpZighYSh0KSlyZXR1cm4hMTt2YXIgZT10W2RdO3JldHVybiB2b2lkIDAhPT1lPyEhZTpvKHQpfTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohdnx8IWd9LHtjb25jYXQ6ZnVuY3Rpb24odCl7dmFyIGUscixuLGksbyxhPXModGhpcyksbD1mKGEsMCksaD0wO2ZvcihlPS0xLG49YXJndW1lbnRzLmxlbmd0aDtlPG47ZSsrKWlmKG89LTE9PT1lP2E6YXJndW1lbnRzW2VdLHkobykpe2lmKGgrKGk9dShvLmxlbmd0aCkpPjkwMDcxOTkyNTQ3NDA5OTEpdGhyb3cgVHlwZUVycm9yKFwiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkXCIpO2ZvcihyPTA7cjxpO3IrKyxoKyspciBpbiBvJiZjKGwsaCxvW3JdKX1lbHNle2lmKGg+PTkwMDcxOTkyNTQ3NDA5OTEpdGhyb3cgVHlwZUVycm9yKFwiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkXCIpO2MobCxoKyssbyl9cmV0dXJuIGwubGVuZ3RoPWgsbH19KX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNDMpLGk9cigxMSksbz1yKDMxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIpe3ZhciBhPW4oZSk7YSBpbiB0P2kuZih0LGEsbygwLHIpKTp0W2FdPXJ9fSxmdW5jdGlvbih0LGUscil7dmFyIG4saSxvPXIoNCksYT1yKDEyMikscz1vLnByb2Nlc3MsdT1zJiZzLnZlcnNpb25zLGM9dSYmdS52ODtjP2k9KG49Yy5zcGxpdChcIi5cIikpWzBdK25bMV06YSYmKCEobj1hLm1hdGNoKC9FZGdlXFwvKFxcZCspLykpfHxuWzFdPj03NCkmJihuPWEubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pKSYmKGk9blsxXSksdC5leHBvcnRzPWkmJitpfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigyKSxpPXIoMzMpLmZpbHRlcixvPXIoNSksYT1yKDU0KShcImZpbHRlclwiKSxzPWEmJiFvKChmdW5jdGlvbigpe1tdLmZpbHRlci5jYWxsKHtsZW5ndGg6LTEsMDoxfSwoZnVuY3Rpb24odCl7dGhyb3cgdH0pKX0pKTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohYXx8IXN9LHtmaWx0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIGkodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDEyMyk7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6W10uZm9yRWFjaCE9aX0se2ZvckVhY2g6aX0pfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigyKSxpPXIoNjYpLmluY2x1ZGVzLG89cigxMTMpO24oe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITB9LHtpbmNsdWRlczpmdW5jdGlvbih0KXtyZXR1cm4gaSh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLG8oXCJpbmNsdWRlc1wiKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDExKS5mLG89RnVuY3Rpb24ucHJvdG90eXBlLGE9by50b1N0cmluZyxzPS9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztuJiYhKFwibmFtZVwiaW4gbykmJmkobyxcIm5hbWVcIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3RyeXtyZXR1cm4gYS5jYWxsKHRoaXMpLm1hdGNoKHMpWzFdfWNhdGNoKHQpe3JldHVyblwiXCJ9fX0pfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMCksaT1yKDE5KSxvPXIoMykoXCJtYXRjaFwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIG4odCkmJih2b2lkIDAhPT0oZT10W29dKT8hIWU6XCJSZWdFeHBcIj09aSh0KSl9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig3NiksaT1yKDgpLG89cigyNyksYT1yKDE1KSxzPXIoMzIpLHU9cigyMCksYz1yKDc3KSxmPXIoNzgpLGw9TWF0aC5tYXgsaD1NYXRoLm1pbixwPU1hdGguZmxvb3IsZD0vXFwkKFskJidgXXxcXGRcXGQ/fDxbXj5dKj4pL2csdj0vXFwkKFskJidgXXxcXGRcXGQ/KS9nO24oXCJyZXBsYWNlXCIsMiwoZnVuY3Rpb24odCxlLHIsbil7cmV0dXJuW2Z1bmN0aW9uKHIsbil7dmFyIGk9dSh0aGlzKSxvPW51bGw9PXI/dm9pZCAwOnJbdF07cmV0dXJuIHZvaWQgMCE9PW8/by5jYWxsKHIsaSxuKTplLmNhbGwoU3RyaW5nKGkpLHIsbil9LGZ1bmN0aW9uKHQsbyl7aWYobi5SRVBMQUNFX0tFRVBTXyQwfHxcInN0cmluZ1wiPT10eXBlb2YgbyYmLTE9PT1vLmluZGV4T2YoXCIkMFwiKSl7dmFyIHU9cihlLHQsdGhpcyxvKTtpZih1LmRvbmUpcmV0dXJuIHUudmFsdWV9dmFyIHA9aSh0KSxkPVN0cmluZyh0aGlzKSx2PVwiZnVuY3Rpb25cIj09dHlwZW9mIG87dnx8KG89U3RyaW5nKG8pKTt2YXIgeT1wLmdsb2JhbDtpZih5KXt2YXIgYj1wLnVuaWNvZGU7cC5sYXN0SW5kZXg9MH1mb3IodmFyIF89W107Oyl7dmFyIG09ZihwLGQpO2lmKG51bGw9PT1tKWJyZWFrO2lmKF8ucHVzaChtKSwheSlicmVhaztcIlwiPT09U3RyaW5nKG1bMF0pJiYocC5sYXN0SW5kZXg9YyhkLGEocC5sYXN0SW5kZXgpLGIpKX1mb3IodmFyIHcseD1cIlwiLGs9MCxFPTA7RTxfLmxlbmd0aDtFKyspe209X1tFXTtmb3IodmFyIFM9U3RyaW5nKG1bMF0pLGo9bChoKHMobS5pbmRleCksZC5sZW5ndGgpLDApLFI9W10sQz0xO0M8bS5sZW5ndGg7QysrKVIucHVzaCh2b2lkIDA9PT0odz1tW0NdKT93OlN0cmluZyh3KSk7dmFyIEk9bS5ncm91cHM7aWYodil7dmFyIE89W1NdLmNvbmNhdChSLGosZCk7dm9pZCAwIT09SSYmTy5wdXNoKEkpO3ZhciBUPVN0cmluZyhvLmFwcGx5KHZvaWQgMCxPKSl9ZWxzZSBUPWcoUyxkLGosUixJLG8pO2o+PWsmJih4Kz1kLnNsaWNlKGssaikrVCxrPWorUy5sZW5ndGgpfXJldHVybiB4K2Quc2xpY2Uoayl9XTtmdW5jdGlvbiBnKHQscixuLGksYSxzKXt2YXIgdT1uK3QubGVuZ3RoLGM9aS5sZW5ndGgsZj12O3JldHVybiB2b2lkIDAhPT1hJiYoYT1vKGEpLGY9ZCksZS5jYWxsKHMsZiwoZnVuY3Rpb24oZSxvKXt2YXIgcztzd2l0Y2goby5jaGFyQXQoMCkpe2Nhc2VcIiRcIjpyZXR1cm5cIiRcIjtjYXNlXCImXCI6cmV0dXJuIHQ7Y2FzZVwiYFwiOnJldHVybiByLnNsaWNlKDAsbik7Y2FzZVwiJ1wiOnJldHVybiByLnNsaWNlKHUpO2Nhc2VcIjxcIjpzPWFbby5zbGljZSgxLC0xKV07YnJlYWs7ZGVmYXVsdDp2YXIgZj0rbztpZigwPT09ZilyZXR1cm4gZTtpZihmPmMpe3ZhciBsPXAoZi8xMCk7cmV0dXJuIDA9PT1sP2U6bDw9Yz92b2lkIDA9PT1pW2wtMV0/by5jaGFyQXQoMSk6aVtsLTFdK28uY2hhckF0KDEpOmV9cz1pW2YtMV19cmV0dXJuIHZvaWQgMD09PXM/XCJcIjpzfSkpfX0pKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCksaT1yKDEyMSksbz1yKDEyMyksYT1yKDE0KTtmb3IodmFyIHMgaW4gaSl7dmFyIHU9bltzXSxjPXUmJnUucHJvdG90eXBlO2lmKGMmJmMuZm9yRWFjaCE9PW8pdHJ5e2EoYyxcImZvckVhY2hcIixvKX1jYXRjaCh0KXtjLmZvckVhY2g9b319fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saSxvLGEscz1yKDIpLHU9cigyNSksYz1yKDQpLGY9cigyNiksbD1yKDE3NyksaD1yKDE3KSxwPXIoMTc4KSxkPXIoNDkpLHY9cigxMjUpLGc9cigxMCkseT1yKDUwKSxiPXIoMTc5KSxfPXIoMTkpLG09cig2Myksdz1yKDE4MCkseD1yKDE4NCksaz1yKDEzMiksRT1yKDEzMykuc2V0LFM9cigxODUpLGo9cigxODYpLFI9cigxODcpLEM9cigxMzUpLEk9cigxODgpLE89cigyNCksVD1yKDY4KSxQPXIoMyksQT1yKDgzKSxMPVAoXCJzcGVjaWVzXCIpLEY9XCJQcm9taXNlXCIsTT1PLmdldCxOPU8uc2V0LEI9Ty5nZXR0ZXJGb3IoRiksRD1sLFU9Yy5UeXBlRXJyb3IscT1jLmRvY3VtZW50LEc9Yy5wcm9jZXNzLFc9ZihcImZldGNoXCIpLHo9Qy5mLFk9eixRPVwicHJvY2Vzc1wiPT1fKEcpLCQ9ISEocSYmcS5jcmVhdGVFdmVudCYmYy5kaXNwYXRjaEV2ZW50KSxIPVQoRiwoZnVuY3Rpb24oKXtpZighKG0oRCkhPT1TdHJpbmcoRCkpKXtpZig2Nj09PUEpcmV0dXJuITA7aWYoIVEmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudClyZXR1cm4hMH1pZih1JiYhRC5wcm90b3R5cGUuZmluYWxseSlyZXR1cm4hMDtpZihBPj01MSYmL25hdGl2ZSBjb2RlLy50ZXN0KEQpKXJldHVybiExO3ZhciB0PUQucmVzb2x2ZSgxKSxlPWZ1bmN0aW9uKHQpe3QoKGZ1bmN0aW9uKCl7fSksKGZ1bmN0aW9uKCl7fSkpfTtyZXR1cm4odC5jb25zdHJ1Y3Rvcj17fSlbTF09ZSwhKHQudGhlbigoZnVuY3Rpb24oKXt9KSlpbnN0YW5jZW9mIGUpfSkpLEs9SHx8IXgoKGZ1bmN0aW9uKHQpe0QuYWxsKHQpLmNhdGNoKChmdW5jdGlvbigpe30pKX0pKSxWPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiEoIWcodCl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mKGU9dC50aGVuKSkmJmV9LFo9ZnVuY3Rpb24odCxlLHIpe2lmKCFlLm5vdGlmaWVkKXtlLm5vdGlmaWVkPSEwO3ZhciBuPWUucmVhY3Rpb25zO1MoKGZ1bmN0aW9uKCl7Zm9yKHZhciBpPWUudmFsdWUsbz0xPT1lLnN0YXRlLGE9MDtuLmxlbmd0aD5hOyl7dmFyIHMsdSxjLGY9blthKytdLGw9bz9mLm9rOmYuZmFpbCxoPWYucmVzb2x2ZSxwPWYucmVqZWN0LGQ9Zi5kb21haW47dHJ5e2w/KG98fCgyPT09ZS5yZWplY3Rpb24mJmV0KHQsZSksZS5yZWplY3Rpb249MSksITA9PT1sP3M9aTooZCYmZC5lbnRlcigpLHM9bChpKSxkJiYoZC5leGl0KCksYz0hMCkpLHM9PT1mLnByb21pc2U/cChVKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk6KHU9VihzKSk/dS5jYWxsKHMsaCxwKTpoKHMpKTpwKGkpfWNhdGNoKHQpe2QmJiFjJiZkLmV4aXQoKSxwKHQpfX1lLnJlYWN0aW9ucz1bXSxlLm5vdGlmaWVkPSExLHImJiFlLnJlamVjdGlvbiYmWCh0LGUpfSkpfX0sSj1mdW5jdGlvbih0LGUscil7dmFyIG4saTskPygobj1xLmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpLnByb21pc2U9ZSxuLnJlYXNvbj1yLG4uaW5pdEV2ZW50KHQsITEsITApLGMuZGlzcGF0Y2hFdmVudChuKSk6bj17cHJvbWlzZTplLHJlYXNvbjpyfSwoaT1jW1wib25cIit0XSk/aShuKTpcInVuaGFuZGxlZHJlamVjdGlvblwiPT09dCYmUihcIlVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvblwiLHIpfSxYPWZ1bmN0aW9uKHQsZSl7RS5jYWxsKGMsKGZ1bmN0aW9uKCl7dmFyIHIsbj1lLnZhbHVlO2lmKHR0KGUpJiYocj1JKChmdW5jdGlvbigpe1E/Ry5lbWl0KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsbix0KTpKKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsdCxuKX0pKSxlLnJlamVjdGlvbj1RfHx0dChlKT8yOjEsci5lcnJvcikpdGhyb3cgci52YWx1ZX0pKX0sdHQ9ZnVuY3Rpb24odCl7cmV0dXJuIDEhPT10LnJlamVjdGlvbiYmIXQucGFyZW50fSxldD1mdW5jdGlvbih0LGUpe0UuY2FsbChjLChmdW5jdGlvbigpe1E/Ry5lbWl0KFwicmVqZWN0aW9uSGFuZGxlZFwiLHQpOkooXCJyZWplY3Rpb25oYW5kbGVkXCIsdCxlLnZhbHVlKX0pKX0scnQ9ZnVuY3Rpb24odCxlLHIsbil7cmV0dXJuIGZ1bmN0aW9uKGkpe3QoZSxyLGksbil9fSxudD1mdW5jdGlvbih0LGUscixuKXtlLmRvbmV8fChlLmRvbmU9ITAsbiYmKGU9biksZS52YWx1ZT1yLGUuc3RhdGU9MixaKHQsZSwhMCkpfSxpdD1mdW5jdGlvbih0LGUscixuKXtpZighZS5kb25lKXtlLmRvbmU9ITAsbiYmKGU9bik7dHJ5e2lmKHQ9PT1yKXRocm93IFUoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTt2YXIgaT1WKHIpO2k/UygoZnVuY3Rpb24oKXt2YXIgbj17ZG9uZTohMX07dHJ5e2kuY2FsbChyLHJ0KGl0LHQsbixlKSxydChudCx0LG4sZSkpfWNhdGNoKHIpe250KHQsbixyLGUpfX0pKTooZS52YWx1ZT1yLGUuc3RhdGU9MSxaKHQsZSwhMSkpfWNhdGNoKHIpe250KHQse2RvbmU6ITF9LHIsZSl9fX07SCYmKEQ9ZnVuY3Rpb24odCl7Yih0aGlzLEQsRikseSh0KSxuLmNhbGwodGhpcyk7dmFyIGU9TSh0aGlzKTt0cnl7dChydChpdCx0aGlzLGUpLHJ0KG50LHRoaXMsZSkpfWNhdGNoKHQpe250KHRoaXMsZSx0KX19LChuPWZ1bmN0aW9uKHQpe04odGhpcyx7dHlwZTpGLGRvbmU6ITEsbm90aWZpZWQ6ITEscGFyZW50OiExLHJlYWN0aW9uczpbXSxyZWplY3Rpb246ITEsc3RhdGU6MCx2YWx1ZTp2b2lkIDB9KX0pLnByb3RvdHlwZT1wKEQucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHQsZSl7dmFyIHI9Qih0aGlzKSxuPXooayh0aGlzLEQpKTtyZXR1cm4gbi5vaz1cImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHx0LG4uZmFpbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLG4uZG9tYWluPVE/Ry5kb21haW46dm9pZCAwLHIucGFyZW50PSEwLHIucmVhY3Rpb25zLnB1c2gobiksMCE9ci5zdGF0ZSYmWih0aGlzLHIsITEpLG4ucHJvbWlzZX0sY2F0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsdCl9fSksaT1mdW5jdGlvbigpe3ZhciB0PW5ldyBuLGU9TSh0KTt0aGlzLnByb21pc2U9dCx0aGlzLnJlc29sdmU9cnQoaXQsdCxlKSx0aGlzLnJlamVjdD1ydChudCx0LGUpfSxDLmY9ej1mdW5jdGlvbih0KXtyZXR1cm4gdD09PUR8fHQ9PT1vP25ldyBpKHQpOlkodCl9LHV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGx8fChhPWwucHJvdG90eXBlLnRoZW4saChsLnByb3RvdHlwZSxcInRoZW5cIiwoZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzO3JldHVybiBuZXcgRCgoZnVuY3Rpb24odCxlKXthLmNhbGwocix0LGUpfSkpLnRoZW4odCxlKX0pLHt1bnNhZmU6ITB9KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBXJiZzKHtnbG9iYWw6ITAsZW51bWVyYWJsZTohMCxmb3JjZWQ6ITB9LHtmZXRjaDpmdW5jdGlvbih0KXtyZXR1cm4gaihELFcuYXBwbHkoYyxhcmd1bWVudHMpKX19KSkpLHMoe2dsb2JhbDohMCx3cmFwOiEwLGZvcmNlZDpIfSx7UHJvbWlzZTpEfSksZChELEYsITEsITApLHYoRiksbz1mKEYpLHMoe3RhcmdldDpGLHN0YXQ6ITAsZm9yY2VkOkh9LHtyZWplY3Q6ZnVuY3Rpb24odCl7dmFyIGU9eih0aGlzKTtyZXR1cm4gZS5yZWplY3QuY2FsbCh2b2lkIDAsdCksZS5wcm9taXNlfX0pLHMoe3RhcmdldDpGLHN0YXQ6ITAsZm9yY2VkOnV8fEh9LHtyZXNvbHZlOmZ1bmN0aW9uKHQpe3JldHVybiBqKHUmJnRoaXM9PT1vP0Q6dGhpcyx0KX19KSxzKHt0YXJnZXQ6RixzdGF0OiEwLGZvcmNlZDpLfSx7YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj16KGUpLG49ci5yZXNvbHZlLGk9ci5yZWplY3Qsbz1JKChmdW5jdGlvbigpe3ZhciByPXkoZS5yZXNvbHZlKSxvPVtdLGE9MCxzPTE7dyh0LChmdW5jdGlvbih0KXt2YXIgdT1hKyssYz0hMTtvLnB1c2godm9pZCAwKSxzKyssci5jYWxsKGUsdCkudGhlbigoZnVuY3Rpb24odCl7Y3x8KGM9ITAsb1t1XT10LC0tc3x8bihvKSl9KSxpKX0pKSwtLXN8fG4obyl9KSk7cmV0dXJuIG8uZXJyb3ImJmkoby52YWx1ZSksci5wcm9taXNlfSxyYWNlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj16KGUpLG49ci5yZWplY3QsaT1JKChmdW5jdGlvbigpe3ZhciBpPXkoZS5yZXNvbHZlKTt3KHQsKGZ1bmN0aW9uKHQpe2kuY2FsbChlLHQpLnRoZW4oci5yZXNvbHZlLG4pfSkpfSkpO3JldHVybiBpLmVycm9yJiZuKGkudmFsdWUpLHIucHJvbWlzZX19KX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbih0KXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG52YXIgbj1yKDE5MCksaT1yKDE5MSksbz1yKDEzNyk7ZnVuY3Rpb24gYSgpe3JldHVybiB1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/MjE0NzQ4MzY0NzoxMDczNzQxODIzfWZ1bmN0aW9uIHModCxlKXtpZihhKCk8ZSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoXCIpO3JldHVybiB1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHQ9bmV3IFVpbnQ4QXJyYXkoZSkpLl9fcHJvdG9fXz11LnByb3RvdHlwZToobnVsbD09PXQmJih0PW5ldyB1KGUpKSx0Lmxlbmd0aD1lKSx0fWZ1bmN0aW9uIHUodCxlLHIpe2lmKCEodS5UWVBFRF9BUlJBWV9TVVBQT1JUfHx0aGlzIGluc3RhbmNlb2YgdSkpcmV0dXJuIG5ldyB1KHQsZSxyKTtpZihcIm51bWJlclwiPT10eXBlb2YgdCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmdcIik7cmV0dXJuIGwodGhpcyx0KX1yZXR1cm4gYyh0aGlzLHQsZSxyKX1mdW5jdGlvbiBjKHQsZSxyLG4pe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP2Z1bmN0aW9uKHQsZSxyLG4pe2lmKGUuYnl0ZUxlbmd0aCxyPDB8fGUuYnl0ZUxlbmd0aDxyKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihlLmJ5dGVMZW5ndGg8cisobnx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInbGVuZ3RoJyBpcyBvdXQgb2YgYm91bmRzXCIpO2U9dm9pZCAwPT09ciYmdm9pZCAwPT09bj9uZXcgVWludDhBcnJheShlKTp2b2lkIDA9PT1uP25ldyBVaW50OEFycmF5KGUscik6bmV3IFVpbnQ4QXJyYXkoZSxyLG4pO3UuVFlQRURfQVJSQVlfU1VQUE9SVD8odD1lKS5fX3Byb3RvX189dS5wcm90b3R5cGU6dD1oKHQsZSk7cmV0dXJuIHR9KHQsZSxyLG4pOlwic3RyaW5nXCI9PXR5cGVvZiBlP2Z1bmN0aW9uKHQsZSxyKXtcInN0cmluZ1wiPT10eXBlb2YgciYmXCJcIiE9PXJ8fChyPVwidXRmOFwiKTtpZighdS5pc0VuY29kaW5nKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7dmFyIG49MHxkKGUsciksaT0odD1zKHQsbikpLndyaXRlKGUscik7aSE9PW4mJih0PXQuc2xpY2UoMCxpKSk7cmV0dXJuIHR9KHQsZSxyKTpmdW5jdGlvbih0LGUpe2lmKHUuaXNCdWZmZXIoZSkpe3ZhciByPTB8cChlLmxlbmd0aCk7cmV0dXJuIDA9PT0odD1zKHQscikpLmxlbmd0aHx8ZS5jb3B5KHQsMCwwLHIpLHR9aWYoZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxcImxlbmd0aFwiaW4gZSlyZXR1cm5cIm51bWJlclwiIT10eXBlb2YgZS5sZW5ndGh8fChuPWUubGVuZ3RoKSE9bj9zKHQsMCk6aCh0LGUpO2lmKFwiQnVmZmVyXCI9PT1lLnR5cGUmJm8oZS5kYXRhKSlyZXR1cm4gaCh0LGUuZGF0YSl9dmFyIG47dGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC5cIil9KHQsZSl9ZnVuY3Rpb24gZih0KXtpZihcIm51bWJlclwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyk7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpfWZ1bmN0aW9uIGwodCxlKXtpZihmKGUpLHQ9cyh0LGU8MD8wOjB8cChlKSksIXUuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IodmFyIHI9MDtyPGU7KytyKXRbcl09MDtyZXR1cm4gdH1mdW5jdGlvbiBoKHQsZSl7dmFyIHI9ZS5sZW5ndGg8MD8wOjB8cChlLmxlbmd0aCk7dD1zKHQscik7Zm9yKHZhciBuPTA7bjxyO24rPTEpdFtuXT0yNTUmZVtuXTtyZXR1cm4gdH1mdW5jdGlvbiBwKHQpe2lmKHQ+PWEoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIithKCkudG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpO3JldHVybiAwfHR9ZnVuY3Rpb24gZCh0LGUpe2lmKHUuaXNCdWZmZXIodCkpcmV0dXJuIHQubGVuZ3RoO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3JiYoQXJyYXlCdWZmZXIuaXNWaWV3KHQpfHx0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKXJldHVybiB0LmJ5dGVMZW5ndGg7XCJzdHJpbmdcIiE9dHlwZW9mIHQmJih0PVwiXCIrdCk7dmFyIHI9dC5sZW5ndGg7aWYoMD09PXIpcmV0dXJuIDA7Zm9yKHZhciBuPSExOzspc3dpdGNoKGUpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHI7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZSB2b2lkIDA6cmV0dXJuIFUodCkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiAyKnI7Y2FzZVwiaGV4XCI6cmV0dXJuIHI+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBxKHQpLmxlbmd0aDtkZWZhdWx0OmlmKG4pcmV0dXJuIFUodCkubGVuZ3RoO2U9KFwiXCIrZSkudG9Mb3dlckNhc2UoKSxuPSEwfX1mdW5jdGlvbiB2KHQsZSxyKXt2YXIgbj0hMTtpZigodm9pZCAwPT09ZXx8ZTwwKSYmKGU9MCksZT50aGlzLmxlbmd0aClyZXR1cm5cIlwiO2lmKCh2b2lkIDA9PT1yfHxyPnRoaXMubGVuZ3RoKSYmKHI9dGhpcy5sZW5ndGgpLHI8PTApcmV0dXJuXCJcIjtpZigocj4+Pj0wKTw9KGU+Pj49MCkpcmV0dXJuXCJcIjtmb3IodHx8KHQ9XCJ1dGY4XCIpOzspc3dpdGNoKHQpe2Nhc2VcImhleFwiOnJldHVybiBJKHRoaXMsZSxyKTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gaih0aGlzLGUscik7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gUih0aGlzLGUscik7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIEModGhpcyxlLHIpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBTKHRoaXMsZSxyKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gTyh0aGlzLGUscik7ZGVmYXVsdDppZihuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIit0KTt0PSh0K1wiXCIpLnRvTG93ZXJDYXNlKCksbj0hMH19ZnVuY3Rpb24gZyh0LGUscil7dmFyIG49dFtlXTt0W2VdPXRbcl0sdFtyXT1ufWZ1bmN0aW9uIHkodCxlLHIsbixpKXtpZigwPT09dC5sZW5ndGgpcmV0dXJuLTE7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHI/KG49cixyPTApOnI+MjE0NzQ4MzY0Nz9yPTIxNDc0ODM2NDc6cjwtMjE0NzQ4MzY0OCYmKHI9LTIxNDc0ODM2NDgpLHI9K3IsaXNOYU4ocikmJihyPWk/MDp0Lmxlbmd0aC0xKSxyPDAmJihyPXQubGVuZ3RoK3IpLHI+PXQubGVuZ3RoKXtpZihpKXJldHVybi0xO3I9dC5sZW5ndGgtMX1lbHNlIGlmKHI8MCl7aWYoIWkpcmV0dXJuLTE7cj0wfWlmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT11LmZyb20oZSxuKSksdS5pc0J1ZmZlcihlKSlyZXR1cm4gMD09PWUubGVuZ3RoPy0xOmIodCxlLHIsbixpKTtpZihcIm51bWJlclwiPT10eXBlb2YgZSlyZXR1cm4gZSY9MjU1LHUuVFlQRURfQVJSQVlfU1VQUE9SVCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj9pP1VpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0LGUscik6VWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbCh0LGUscik6Yih0LFtlXSxyLG4saSk7dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBiKHQsZSxyLG4saSl7dmFyIG8sYT0xLHM9dC5sZW5ndGgsdT1lLmxlbmd0aDtpZih2b2lkIDAhPT1uJiYoXCJ1Y3MyXCI9PT0obj1TdHJpbmcobikudG9Mb3dlckNhc2UoKSl8fFwidWNzLTJcIj09PW58fFwidXRmMTZsZVwiPT09bnx8XCJ1dGYtMTZsZVwiPT09bikpe2lmKHQubGVuZ3RoPDJ8fGUubGVuZ3RoPDIpcmV0dXJuLTE7YT0yLHMvPTIsdS89MixyLz0yfWZ1bmN0aW9uIGModCxlKXtyZXR1cm4gMT09PWE/dFtlXTp0LnJlYWRVSW50MTZCRShlKmEpfWlmKGkpe3ZhciBmPS0xO2ZvcihvPXI7bzxzO28rKylpZihjKHQsbyk9PT1jKGUsLTE9PT1mPzA6by1mKSl7aWYoLTE9PT1mJiYoZj1vKSxvLWYrMT09PXUpcmV0dXJuIGYqYX1lbHNlLTEhPT1mJiYoby09by1mKSxmPS0xfWVsc2UgZm9yKHIrdT5zJiYocj1zLXUpLG89cjtvPj0wO28tLSl7Zm9yKHZhciBsPSEwLGg9MDtoPHU7aCsrKWlmKGModCxvK2gpIT09YyhlLGgpKXtsPSExO2JyZWFrfWlmKGwpcmV0dXJuIG99cmV0dXJuLTF9ZnVuY3Rpb24gXyh0LGUscixuKXtyPU51bWJlcihyKXx8MDt2YXIgaT10Lmxlbmd0aC1yO24/KG49TnVtYmVyKG4pKT5pJiYobj1pKTpuPWk7dmFyIG89ZS5sZW5ndGg7aWYobyUyIT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmdcIik7bj5vLzImJihuPW8vMik7Zm9yKHZhciBhPTA7YTxuOysrYSl7dmFyIHM9cGFyc2VJbnQoZS5zdWJzdHIoMiphLDIpLDE2KTtpZihpc05hTihzKSlyZXR1cm4gYTt0W3IrYV09c31yZXR1cm4gYX1mdW5jdGlvbiBtKHQsZSxyLG4pe3JldHVybiBHKFUoZSx0Lmxlbmd0aC1yKSx0LHIsbil9ZnVuY3Rpb24gdyh0LGUscixuKXtyZXR1cm4gRyhmdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0wO3I8dC5sZW5ndGg7KytyKWUucHVzaCgyNTUmdC5jaGFyQ29kZUF0KHIpKTtyZXR1cm4gZX0oZSksdCxyLG4pfWZ1bmN0aW9uIHgodCxlLHIsbil7cmV0dXJuIHcodCxlLHIsbil9ZnVuY3Rpb24gayh0LGUscixuKXtyZXR1cm4gRyhxKGUpLHQscixuKX1mdW5jdGlvbiBFKHQsZSxyLG4pe3JldHVybiBHKGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByLG4saSxvPVtdLGE9MDthPHQubGVuZ3RoJiYhKChlLT0yKTwwKTsrK2Epcj10LmNoYXJDb2RlQXQoYSksbj1yPj44LGk9ciUyNTYsby5wdXNoKGkpLG8ucHVzaChuKTtyZXR1cm4gb30oZSx0Lmxlbmd0aC1yKSx0LHIsbil9ZnVuY3Rpb24gUyh0LGUscil7cmV0dXJuIDA9PT1lJiZyPT09dC5sZW5ndGg/bi5mcm9tQnl0ZUFycmF5KHQpOm4uZnJvbUJ5dGVBcnJheSh0LnNsaWNlKGUscikpfWZ1bmN0aW9uIGoodCxlLHIpe3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBuPVtdLGk9ZTtpPHI7KXt2YXIgbyxhLHMsdSxjPXRbaV0sZj1udWxsLGw9Yz4yMzk/NDpjPjIyMz8zOmM+MTkxPzI6MTtpZihpK2w8PXIpc3dpdGNoKGwpe2Nhc2UgMTpjPDEyOCYmKGY9Yyk7YnJlYWs7Y2FzZSAyOjEyOD09KDE5MiYobz10W2krMV0pKSYmKHU9KDMxJmMpPDw2fDYzJm8pPjEyNyYmKGY9dSk7YnJlYWs7Y2FzZSAzOm89dFtpKzFdLGE9dFtpKzJdLDEyOD09KDE5MiZvKSYmMTI4PT0oMTkyJmEpJiYodT0oMTUmYyk8PDEyfCg2MyZvKTw8Nnw2MyZhKT4yMDQ3JiYodTw1NTI5Nnx8dT41NzM0MykmJihmPXUpO2JyZWFrO2Nhc2UgNDpvPXRbaSsxXSxhPXRbaSsyXSxzPXRbaSszXSwxMjg9PSgxOTImbykmJjEyOD09KDE5MiZhKSYmMTI4PT0oMTkyJnMpJiYodT0oMTUmYyk8PDE4fCg2MyZvKTw8MTJ8KDYzJmEpPDw2fDYzJnMpPjY1NTM1JiZ1PDExMTQxMTImJihmPXUpfW51bGw9PT1mPyhmPTY1NTMzLGw9MSk6Zj42NTUzNSYmKGYtPTY1NTM2LG4ucHVzaChmPj4+MTAmMTAyM3w1NTI5NiksZj01NjMyMHwxMDIzJmYpLG4ucHVzaChmKSxpKz1sfXJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPD00MDk2KXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx0KTt2YXIgcj1cIlwiLG49MDtmb3IoO248ZTspcis9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsdC5zbGljZShuLG4rPTQwOTYpKTtyZXR1cm4gcn0obil9ZS5CdWZmZXI9dSxlLlNsb3dCdWZmZXI9ZnVuY3Rpb24odCl7K3QhPXQmJih0PTApO3JldHVybiB1LmFsbG9jKCt0KX0sZS5JTlNQRUNUX01BWF9CWVRFUz01MCx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ9dm9pZCAwIT09dC5UWVBFRF9BUlJBWV9TVVBQT1JUP3QuVFlQRURfQVJSQVlfU1VQUE9SVDpmdW5jdGlvbigpe3RyeXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4gdC5fX3Byb3RvX189e19fcHJvdG9fXzpVaW50OEFycmF5LnByb3RvdHlwZSxmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fSw0Mj09PXQuZm9vKCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuc3ViYXJyYXkmJjA9PT10LnN1YmFycmF5KDEsMSkuYnl0ZUxlbmd0aH1jYXRjaCh0KXtyZXR1cm4hMX19KCksZS5rTWF4TGVuZ3RoPWEoKSx1LnBvb2xTaXplPTgxOTIsdS5fYXVnbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX189dS5wcm90b3R5cGUsdH0sdS5mcm9tPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gYyhudWxsLHQsZSxyKX0sdS5UWVBFRF9BUlJBWV9TVVBQT1JUJiYodS5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlLHUuX19wcm90b19fPVVpbnQ4QXJyYXksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnNwZWNpZXMmJnVbU3ltYm9sLnNwZWNpZXNdPT09dSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsU3ltYm9sLnNwZWNpZXMse3ZhbHVlOm51bGwsY29uZmlndXJhYmxlOiEwfSkpLHUuYWxsb2M9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBmdW5jdGlvbih0LGUscixuKXtyZXR1cm4gZihlKSxlPD0wP3ModCxlKTp2b2lkIDAhPT1yP1wic3RyaW5nXCI9PXR5cGVvZiBuP3ModCxlKS5maWxsKHIsbik6cyh0LGUpLmZpbGwocik6cyh0LGUpfShudWxsLHQsZSxyKX0sdS5hbGxvY1Vuc2FmZT1mdW5jdGlvbih0KXtyZXR1cm4gbChudWxsLHQpfSx1LmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbih0KXtyZXR1cm4gbChudWxsLHQpfSx1LmlzQnVmZmVyPWZ1bmN0aW9uKHQpe3JldHVybiEobnVsbD09dHx8IXQuX2lzQnVmZmVyKX0sdS5jb21wYXJlPWZ1bmN0aW9uKHQsZSl7aWYoIXUuaXNCdWZmZXIodCl8fCF1LmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzXCIpO2lmKHQ9PT1lKXJldHVybiAwO2Zvcih2YXIgcj10Lmxlbmd0aCxuPWUubGVuZ3RoLGk9MCxvPU1hdGgubWluKHIsbik7aTxvOysraSlpZih0W2ldIT09ZVtpXSl7cj10W2ldLG49ZVtpXTticmVha31yZXR1cm4gcjxuPy0xOm48cj8xOjB9LHUuaXNFbmNvZGluZz1mdW5jdGlvbih0KXtzd2l0Y2goU3RyaW5nKHQpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19LHUuY29uY2F0PWZ1bmN0aW9uKHQsZSl7aWYoIW8odCkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7aWYoMD09PXQubGVuZ3RoKXJldHVybiB1LmFsbG9jKDApO3ZhciByO2lmKHZvaWQgMD09PWUpZm9yKGU9MCxyPTA7cjx0Lmxlbmd0aDsrK3IpZSs9dFtyXS5sZW5ndGg7dmFyIG49dS5hbGxvY1Vuc2FmZShlKSxpPTA7Zm9yKHI9MDtyPHQubGVuZ3RoOysrcil7dmFyIGE9dFtyXTtpZighdS5pc0J1ZmZlcihhKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTthLmNvcHkobixpKSxpKz1hLmxlbmd0aH1yZXR1cm4gbn0sdS5ieXRlTGVuZ3RoPWQsdS5wcm90b3R5cGUuX2lzQnVmZmVyPSEwLHUucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoO2lmKHQlMiE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpO2Zvcih2YXIgZT0wO2U8dDtlKz0yKWcodGhpcyxlLGUrMSk7cmV0dXJuIHRoaXN9LHUucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoO2lmKHQlNCE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpO2Zvcih2YXIgZT0wO2U8dDtlKz00KWcodGhpcyxlLGUrMyksZyh0aGlzLGUrMSxlKzIpO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxlbmd0aDtpZih0JTghPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtmb3IodmFyIGU9MDtlPHQ7ZSs9OClnKHRoaXMsZSxlKzcpLGcodGhpcyxlKzEsZSs2KSxnKHRoaXMsZSsyLGUrNSksZyh0aGlzLGUrMyxlKzQpO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciB0PTB8dGhpcy5sZW5ndGg7cmV0dXJuIDA9PT10P1wiXCI6MD09PWFyZ3VtZW50cy5sZW5ndGg/aih0aGlzLDAsdCk6di5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHUucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbih0KXtpZighdS5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gdGhpcz09PXR8fDA9PT11LmNvbXBhcmUodGhpcyx0KX0sdS5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciB0PVwiXCIscj1lLklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiB0aGlzLmxlbmd0aD4wJiYodD10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCxyKS5tYXRjaCgvLnsyfS9nKS5qb2luKFwiIFwiKSx0aGlzLmxlbmd0aD5yJiYodCs9XCIgLi4uIFwiKSksXCI8QnVmZmVyIFwiK3QrXCI+XCJ9LHUucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24odCxlLHIsbixpKXtpZighdS5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1yJiYocj10P3QubGVuZ3RoOjApLHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PWkmJihpPXRoaXMubGVuZ3RoKSxlPDB8fHI+dC5sZW5ndGh8fG48MHx8aT50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtpZihuPj1pJiZlPj1yKXJldHVybiAwO2lmKG4+PWkpcmV0dXJuLTE7aWYoZT49cilyZXR1cm4gMTtpZih0aGlzPT09dClyZXR1cm4gMDtmb3IodmFyIG89KGk+Pj49MCktKG4+Pj49MCksYT0ocj4+Pj0wKS0oZT4+Pj0wKSxzPU1hdGgubWluKG8sYSksYz10aGlzLnNsaWNlKG4saSksZj10LnNsaWNlKGUsciksbD0wO2w8czsrK2wpaWYoY1tsXSE9PWZbbF0pe289Y1tsXSxhPWZbbF07YnJlYWt9cmV0dXJuIG88YT8tMTphPG8/MTowfSx1LnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbih0LGUscil7cmV0dXJuLTEhPT10aGlzLmluZGV4T2YodCxlLHIpfSx1LnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4geSh0aGlzLHQsZSxyLCEwKX0sdS5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB5KHRoaXMsdCxlLHIsITEpfSx1LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUscixuKXtpZih2b2lkIDA9PT1lKW49XCJ1dGY4XCIscj10aGlzLmxlbmd0aCxlPTA7ZWxzZSBpZih2b2lkIDA9PT1yJiZcInN0cmluZ1wiPT10eXBlb2YgZSluPWUscj10aGlzLmxlbmd0aCxlPTA7ZWxzZXtpZighaXNGaW5pdGUoZSkpdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7ZXw9MCxpc0Zpbml0ZShyKT8ocnw9MCx2b2lkIDA9PT1uJiYobj1cInV0ZjhcIikpOihuPXIscj12b2lkIDApfXZhciBpPXRoaXMubGVuZ3RoLWU7aWYoKHZvaWQgMD09PXJ8fHI+aSkmJihyPWkpLHQubGVuZ3RoPjAmJihyPDB8fGU8MCl8fGU+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKTtufHwobj1cInV0ZjhcIik7Zm9yKHZhciBvPSExOzspc3dpdGNoKG4pe2Nhc2VcImhleFwiOnJldHVybiBfKHRoaXMsdCxlLHIpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBtKHRoaXMsdCxlLHIpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIHcodGhpcyx0LGUscik7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHgodGhpcyx0LGUscik7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGsodGhpcyx0LGUscik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIEUodGhpcyx0LGUscik7ZGVmYXVsdDppZihvKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIituKTtuPShcIlwiK24pLnRvTG93ZXJDYXNlKCksbz0hMH19LHUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBSKHQsZSxyKXt2YXIgbj1cIlwiO3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBpPWU7aTxyOysraSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyZ0W2ldKTtyZXR1cm4gbn1mdW5jdGlvbiBDKHQsZSxyKXt2YXIgbj1cIlwiO3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBpPWU7aTxyOysraSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbaV0pO3JldHVybiBufWZ1bmN0aW9uIEkodCxlLHIpe3ZhciBuPXQubGVuZ3RoOyghZXx8ZTwwKSYmKGU9MCksKCFyfHxyPDB8fHI+bikmJihyPW4pO2Zvcih2YXIgaT1cIlwiLG89ZTtvPHI7KytvKWkrPUQodFtvXSk7cmV0dXJuIGl9ZnVuY3Rpb24gTyh0LGUscil7Zm9yKHZhciBuPXQuc2xpY2UoZSxyKSxpPVwiXCIsbz0wO288bi5sZW5ndGg7bys9MilpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG5bb10rMjU2Km5bbysxXSk7cmV0dXJuIGl9ZnVuY3Rpb24gVCh0LGUscil7aWYodCUxIT0wfHx0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYodCtlPnIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfWZ1bmN0aW9uIFAodCxlLHIsbixpLG8pe2lmKCF1LmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKGU+aXx8ZTxvKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHIrbj50Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiBBKHQsZSxyLG4pe2U8MCYmKGU9NjU1MzUrZSsxKTtmb3IodmFyIGk9MCxvPU1hdGgubWluKHQubGVuZ3RoLXIsMik7aTxvOysraSl0W3IraV09KGUmMjU1PDw4KihuP2k6MS1pKSk+Pj44KihuP2k6MS1pKX1mdW5jdGlvbiBMKHQsZSxyLG4pe2U8MCYmKGU9NDI5NDk2NzI5NStlKzEpO2Zvcih2YXIgaT0wLG89TWF0aC5taW4odC5sZW5ndGgtciw0KTtpPG87KytpKXRbcitpXT1lPj4+OCoobj9pOjMtaSkmMjU1fWZ1bmN0aW9uIEYodCxlLHIsbixpLG8pe2lmKHIrbj50Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihyPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gTSh0LGUscixuLG8pe3JldHVybiBvfHxGKHQsMCxyLDQpLGkud3JpdGUodCxlLHIsbiwyMyw0KSxyKzR9ZnVuY3Rpb24gTih0LGUscixuLG8pe3JldHVybiBvfHxGKHQsMCxyLDgpLGkud3JpdGUodCxlLHIsbiw1Miw4KSxyKzh9dS5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlKXt2YXIgcixuPXRoaXMubGVuZ3RoO2lmKCh0PX5+dCk8MD8odCs9bik8MCYmKHQ9MCk6dD5uJiYodD1uKSwoZT12b2lkIDA9PT1lP246fn5lKTwwPyhlKz1uKTwwJiYoZT0wKTplPm4mJihlPW4pLGU8dCYmKGU9dCksdS5UWVBFRF9BUlJBWV9TVVBQT1JUKShyPXRoaXMuc3ViYXJyYXkodCxlKSkuX19wcm90b19fPXUucHJvdG90eXBlO2Vsc2V7dmFyIGk9ZS10O3I9bmV3IHUoaSx2b2lkIDApO2Zvcih2YXIgbz0wO288aTsrK28pcltvXT10aGlzW28rdF19cmV0dXJuIHJ9LHUucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24odCxlLHIpe3R8PTAsZXw9MCxyfHxUKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBuPXRoaXNbdF0saT0xLG89MDsrK288ZSYmKGkqPTI1Nik7KW4rPXRoaXNbdCtvXSppO3JldHVybiBufSx1LnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKHQsZSxyKXt0fD0wLGV8PTAscnx8VCh0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10aGlzW3QrLS1lXSxpPTE7ZT4wJiYoaSo9MjU2KTspbis9dGhpc1t0Ky0tZV0qaTtyZXR1cm4gbn0sdS5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCwxLHRoaXMubGVuZ3RoKSx0aGlzW3RdfSx1LnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF18dGhpc1t0KzFdPDw4fSx1LnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF08PDh8dGhpc1t0KzFdfSx1LnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDQsdGhpcy5sZW5ndGgpLCh0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2KSsxNjc3NzIxNip0aGlzW3QrM119LHUucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxUKHQsNCx0aGlzLmxlbmd0aCksMTY3NzcyMTYqdGhpc1t0XSsodGhpc1t0KzFdPDwxNnx0aGlzW3QrMl08PDh8dGhpc1t0KzNdKX0sdS5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uKHQsZSxyKXt0fD0wLGV8PTAscnx8VCh0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10aGlzW3RdLGk9MSxvPTA7KytvPGUmJihpKj0yNTYpOyluKz10aGlzW3Qrb10qaTtyZXR1cm4gbj49KGkqPTEyOCkmJihuLT1NYXRoLnBvdygyLDgqZSkpLG59LHUucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbih0LGUscil7dHw9MCxlfD0wLHJ8fFQodCxlLHRoaXMubGVuZ3RoKTtmb3IodmFyIG49ZSxpPTEsbz10aGlzW3QrLS1uXTtuPjAmJihpKj0yNTYpOylvKz10aGlzW3QrLS1uXSppO3JldHVybiBvPj0oaSo9MTI4KSYmKG8tPU1hdGgucG93KDIsOCplKSksb30sdS5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW3RdPy0xKigyNTUtdGhpc1t0XSsxKTp0aGlzW3RdfSx1LnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbih0LGUpe2V8fFQodCwyLHRoaXMubGVuZ3RoKTt2YXIgcj10aGlzW3RdfHRoaXNbdCsxXTw8ODtyZXR1cm4gMzI3Njgmcj80Mjk0OTAxNzYwfHI6cn0sdS5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24odCxlKXtlfHxUKHQsMix0aGlzLmxlbmd0aCk7dmFyIHI9dGhpc1t0KzFdfHRoaXNbdF08PDg7cmV0dXJuIDMyNzY4JnI/NDI5NDkwMTc2MHxyOnJ9LHUucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2fHRoaXNbdCszXTw8MjR9LHUucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdPDwyNHx0aGlzW3QrMV08PDE2fHRoaXNbdCsyXTw8OHx0aGlzW3QrM119LHUucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCw0LHRoaXMubGVuZ3RoKSxpLnJlYWQodGhpcyx0LCEwLDIzLDQpfSx1LnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxUKHQsNCx0aGlzLmxlbmd0aCksaS5yZWFkKHRoaXMsdCwhMSwyMyw0KX0sdS5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCw4LHRoaXMubGVuZ3RoKSxpLnJlYWQodGhpcyx0LCEwLDUyLDgpfSx1LnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDgsdGhpcy5sZW5ndGgpLGkucmVhZCh0aGlzLHQsITEsNTIsOCl9LHUucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uKHQsZSxyLG4peyh0PSt0LGV8PTAscnw9MCxuKXx8UCh0aGlzLHQsZSxyLE1hdGgucG93KDIsOCpyKS0xLDApO3ZhciBpPTEsbz0wO2Zvcih0aGlzW2VdPTI1NSZ0OysrbzxyJiYoaSo9MjU2KTspdGhpc1tlK29dPXQvaSYyNTU7cmV0dXJuIGUrcn0sdS5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24odCxlLHIsbil7KHQ9K3QsZXw9MCxyfD0wLG4pfHxQKHRoaXMsdCxlLHIsTWF0aC5wb3coMiw4KnIpLTEsMCk7dmFyIGk9ci0xLG89MTtmb3IodGhpc1tlK2ldPTI1NSZ0Oy0taT49MCYmKG8qPTI1Nik7KXRoaXNbZStpXT10L28mMjU1O3JldHVybiBlK3J9LHUucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8UCh0aGlzLHQsZSwxLDI1NSwwKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlR8fCh0PU1hdGguZmxvb3IodCkpLHRoaXNbZV09MjU1JnQsZSsxfSx1LnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fFAodGhpcyx0LGUsMiw2NTUzNSwwKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44KTpBKHRoaXMsdCxlLCEwKSxlKzJ9LHUucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8UCh0aGlzLHQsZSwyLDY1NTM1LDApLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+OCx0aGlzW2UrMV09MjU1JnQpOkEodGhpcyx0LGUsITEpLGUrMn0sdS5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxQKHRoaXMsdCxlLDQsNDI5NDk2NzI5NSwwKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZSszXT10Pj4+MjQsdGhpc1tlKzJdPXQ+Pj4xNix0aGlzW2UrMV09dD4+PjgsdGhpc1tlXT0yNTUmdCk6TCh0aGlzLHQsZSwhMCksZSs0fSx1LnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fFAodGhpcyx0LGUsNCw0Mjk0OTY3Mjk1LDApLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+MjQsdGhpc1tlKzFdPXQ+Pj4xNix0aGlzW2UrMl09dD4+PjgsdGhpc1tlKzNdPTI1NSZ0KTpMKHRoaXMsdCxlLCExKSxlKzR9LHUucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24odCxlLHIsbil7aWYodD0rdCxlfD0wLCFuKXt2YXIgaT1NYXRoLnBvdygyLDgqci0xKTtQKHRoaXMsdCxlLHIsaS0xLC1pKX12YXIgbz0wLGE9MSxzPTA7Zm9yKHRoaXNbZV09MjU1JnQ7KytvPHImJihhKj0yNTYpOyl0PDAmJjA9PT1zJiYwIT09dGhpc1tlK28tMV0mJihzPTEpLHRoaXNbZStvXT0odC9hPj4wKS1zJjI1NTtyZXR1cm4gZStyfSx1LnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uKHQsZSxyLG4pe2lmKHQ9K3QsZXw9MCwhbil7dmFyIGk9TWF0aC5wb3coMiw4KnItMSk7UCh0aGlzLHQsZSxyLGktMSwtaSl9dmFyIG89ci0xLGE9MSxzPTA7Zm9yKHRoaXNbZStvXT0yNTUmdDstLW8+PTAmJihhKj0yNTYpOyl0PDAmJjA9PT1zJiYwIT09dGhpc1tlK28rMV0mJihzPTEpLHRoaXNbZStvXT0odC9hPj4wKS1zJjI1NTtyZXR1cm4gZStyfSx1LnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8UCh0aGlzLHQsZSwxLDEyNywtMTI4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlR8fCh0PU1hdGguZmxvb3IodCkpLHQ8MCYmKHQ9MjU1K3QrMSksdGhpc1tlXT0yNTUmdCxlKzF9LHUucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxQKHRoaXMsdCxlLDIsMzI3NjcsLTMyNzY4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44KTpBKHRoaXMsdCxlLCEwKSxlKzJ9LHUucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxQKHRoaXMsdCxlLDIsMzI3NjcsLTMyNzY4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09dD4+PjgsdGhpc1tlKzFdPTI1NSZ0KTpBKHRoaXMsdCxlLCExKSxlKzJ9LHUucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxQKHRoaXMsdCxlLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksdS5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW2VdPTI1NSZ0LHRoaXNbZSsxXT10Pj4+OCx0aGlzW2UrMl09dD4+PjE2LHRoaXNbZSszXT10Pj4+MjQpOkwodGhpcyx0LGUsITApLGUrNH0sdS5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fFAodGhpcyx0LGUsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSx0PDAmJih0PTQyOTQ5NjcyOTUrdCsxKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09dD4+PjI0LHRoaXNbZSsxXT10Pj4+MTYsdGhpc1tlKzJdPXQ+Pj44LHRoaXNbZSszXT0yNTUmdCk6TCh0aGlzLHQsZSwhMSksZSs0fSx1LnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBNKHRoaXMsdCxlLCEwLHIpfSx1LnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBNKHRoaXMsdCxlLCExLHIpfSx1LnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gTih0aGlzLHQsZSwhMCxyKX0sdS5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIE4odGhpcyx0LGUsITEscil9LHUucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24odCxlLHIsbil7aWYocnx8KHI9MCksbnx8MD09PW58fChuPXRoaXMubGVuZ3RoKSxlPj10Lmxlbmd0aCYmKGU9dC5sZW5ndGgpLGV8fChlPTApLG4+MCYmbjxyJiYobj1yKSxuPT09cilyZXR1cm4gMDtpZigwPT09dC5sZW5ndGh8fDA9PT10aGlzLmxlbmd0aClyZXR1cm4gMDtpZihlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKHI8MHx8cj49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO24+dGhpcy5sZW5ndGgmJihuPXRoaXMubGVuZ3RoKSx0Lmxlbmd0aC1lPG4tciYmKG49dC5sZW5ndGgtZStyKTt2YXIgaSxvPW4tcjtpZih0aGlzPT09dCYmcjxlJiZlPG4pZm9yKGk9by0xO2k+PTA7LS1pKXRbaStlXT10aGlzW2krcl07ZWxzZSBpZihvPDFlM3x8IXUuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IoaT0wO2k8bzsrK2kpdFtpK2VdPXRoaXNbaStyXTtlbHNlIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHQsdGhpcy5zdWJhcnJheShyLHIrbyksZSk7cmV0dXJuIG99LHUucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLHIsbil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlPyhuPWUsZT0wLHI9dGhpcy5sZW5ndGgpOlwic3RyaW5nXCI9PXR5cGVvZiByJiYobj1yLHI9dGhpcy5sZW5ndGgpLDE9PT10Lmxlbmd0aCl7dmFyIGk9dC5jaGFyQ29kZUF0KDApO2k8MjU2JiYodD1pKX1pZih2b2lkIDAhPT1uJiZcInN0cmluZ1wiIT10eXBlb2Ygbil0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihcInN0cmluZ1wiPT10eXBlb2YgbiYmIXUuaXNFbmNvZGluZyhuKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrbil9ZWxzZVwibnVtYmVyXCI9PXR5cGVvZiB0JiYodCY9MjU1KTtpZihlPDB8fHRoaXMubGVuZ3RoPGV8fHRoaXMubGVuZ3RoPHIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIik7aWYocjw9ZSlyZXR1cm4gdGhpczt2YXIgbztpZihlPj4+PTAscj12b2lkIDA9PT1yP3RoaXMubGVuZ3RoOnI+Pj4wLHR8fCh0PTApLFwibnVtYmVyXCI9PXR5cGVvZiB0KWZvcihvPWU7bzxyOysrbyl0aGlzW29dPXQ7ZWxzZXt2YXIgYT11LmlzQnVmZmVyKHQpP3Q6VShuZXcgdSh0LG4pLnRvU3RyaW5nKCkpLHM9YS5sZW5ndGg7Zm9yKG89MDtvPHItZTsrK28pdGhpc1tvK2VdPWFbbyVzXX1yZXR1cm4gdGhpc307dmFyIEI9L1teK1xcLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIEQodCl7cmV0dXJuIHQ8MTY/XCIwXCIrdC50b1N0cmluZygxNik6dC50b1N0cmluZygxNil9ZnVuY3Rpb24gVSh0LGUpe3ZhciByO2U9ZXx8MS8wO2Zvcih2YXIgbj10Lmxlbmd0aCxpPW51bGwsbz1bXSxhPTA7YTxuOysrYSl7aWYoKHI9dC5jaGFyQ29kZUF0KGEpKT41NTI5NSYmcjw1NzM0NCl7aWYoIWkpe2lmKHI+NTYzMTkpeyhlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1pZihhKzE9PT1uKXsoZS09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9aT1yO2NvbnRpbnVlfWlmKHI8NTYzMjApeyhlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KSxpPXI7Y29udGludWV9cj02NTUzNisoaS01NTI5Njw8MTB8ci01NjMyMCl9ZWxzZSBpJiYoZS09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSk7aWYoaT1udWxsLHI8MTI4KXtpZigoZS09MSk8MClicmVhaztvLnB1c2gocil9ZWxzZSBpZihyPDIwNDgpe2lmKChlLT0yKTwwKWJyZWFrO28ucHVzaChyPj42fDE5Miw2MyZyfDEyOCl9ZWxzZSBpZihyPDY1NTM2KXtpZigoZS09Myk8MClicmVhaztvLnB1c2gocj4+MTJ8MjI0LHI+PjYmNjN8MTI4LDYzJnJ8MTI4KX1lbHNle2lmKCEocjwxMTE0MTEyKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIik7aWYoKGUtPTQpPDApYnJlYWs7by5wdXNoKHI+PjE4fDI0MCxyPj4xMiY2M3wxMjgscj4+NiY2M3wxMjgsNjMmcnwxMjgpfX1yZXR1cm4gb31mdW5jdGlvbiBxKHQpe3JldHVybiBuLnRvQnl0ZUFycmF5KGZ1bmN0aW9uKHQpe2lmKCh0PWZ1bmN0aW9uKHQpe3JldHVybiB0LnRyaW0/dC50cmltKCk6dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfSh0KS5yZXBsYWNlKEIsXCJcIikpLmxlbmd0aDwyKXJldHVyblwiXCI7Zm9yKDt0Lmxlbmd0aCU0IT0wOyl0Kz1cIj1cIjtyZXR1cm4gdH0odCkpfWZ1bmN0aW9uIEcodCxlLHIsbil7Zm9yKHZhciBpPTA7aTxuJiYhKGkrcj49ZS5sZW5ndGh8fGk+PXQubGVuZ3RoKTsrK2kpZVtpK3JdPXRbaV07cmV0dXJuIGl9fSkuY2FsbCh0aGlzLHIoMjEpKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9XCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3Q/UmVmbGVjdDpudWxsLG89aSYmXCJmdW5jdGlvblwiPT10eXBlb2YgaS5hcHBseT9pLmFwcGx5OmZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodCxlLHIpfTtuPWkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGkub3duS2V5cz9pLm93bktleXM6T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scz9mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCkpfTpmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCl9O3ZhciBhPU51bWJlci5pc05hTnx8ZnVuY3Rpb24odCl7cmV0dXJuIHQhPXR9O2Z1bmN0aW9uIHMoKXtzLmluaXQuY2FsbCh0aGlzKX10LmV4cG9ydHM9cyxzLkV2ZW50RW1pdHRlcj1zLHMucHJvdG90eXBlLl9ldmVudHM9dm9pZCAwLHMucHJvdG90eXBlLl9ldmVudHNDb3VudD0wLHMucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnM9dm9pZCAwO3ZhciB1PTEwO2Z1bmN0aW9uIGModCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiB0KX1mdW5jdGlvbiBmKHQpe3JldHVybiB2b2lkIDA9PT10Ll9tYXhMaXN0ZW5lcnM/cy5kZWZhdWx0TWF4TGlzdGVuZXJzOnQuX21heExpc3RlbmVyc31mdW5jdGlvbiBsKHQsZSxyLG4pe3ZhciBpLG8sYSxzO2lmKGMociksdm9pZCAwPT09KG89dC5fZXZlbnRzKT8obz10Ll9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0Ll9ldmVudHNDb3VudD0wKToodm9pZCAwIT09by5uZXdMaXN0ZW5lciYmKHQuZW1pdChcIm5ld0xpc3RlbmVyXCIsZSxyLmxpc3RlbmVyP3IubGlzdGVuZXI6ciksbz10Ll9ldmVudHMpLGE9b1tlXSksdm9pZCAwPT09YSlhPW9bZV09ciwrK3QuX2V2ZW50c0NvdW50O2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgYT9hPW9bZV09bj9bcixhXTpbYSxyXTpuP2EudW5zaGlmdChyKTphLnB1c2gociksKGk9Zih0KSk+MCYmYS5sZW5ndGg+aSYmIWEud2FybmVkKXthLndhcm5lZD0hMDt2YXIgdT1uZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiK2EubGVuZ3RoK1wiIFwiK1N0cmluZyhlKStcIiBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0XCIpO3UubmFtZT1cIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZ1wiLHUuZW1pdHRlcj10LHUudHlwZT1lLHUuY291bnQ9YS5sZW5ndGgscz11LGNvbnNvbGUmJmNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKHMpfXJldHVybiB0fWZ1bmN0aW9uIGgoKXtpZighdGhpcy5maXJlZClyZXR1cm4gdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLHRoaXMud3JhcEZuKSx0aGlzLmZpcmVkPSEwLDA9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk6dGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCxhcmd1bWVudHMpfWZ1bmN0aW9uIHAodCxlLHIpe3ZhciBuPXtmaXJlZDohMSx3cmFwRm46dm9pZCAwLHRhcmdldDp0LHR5cGU6ZSxsaXN0ZW5lcjpyfSxpPWguYmluZChuKTtyZXR1cm4gaS5saXN0ZW5lcj1yLG4ud3JhcEZuPWksaX1mdW5jdGlvbiBkKHQsZSxyKXt2YXIgbj10Ll9ldmVudHM7aWYodm9pZCAwPT09bilyZXR1cm5bXTt2YXIgaT1uW2VdO3JldHVybiB2b2lkIDA9PT1pP1tdOlwiZnVuY3Rpb25cIj09dHlwZW9mIGk/cj9baS5saXN0ZW5lcnx8aV06W2ldOnI/ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKWVbcl09dFtyXS5saXN0ZW5lcnx8dFtyXTtyZXR1cm4gZX0oaSk6ZyhpLGkubGVuZ3RoKX1mdW5jdGlvbiB2KHQpe3ZhciBlPXRoaXMuX2V2ZW50cztpZih2b2lkIDAhPT1lKXt2YXIgcj1lW3RdO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHIpcmV0dXJuIDE7aWYodm9pZCAwIT09cilyZXR1cm4gci5sZW5ndGh9cmV0dXJuIDB9ZnVuY3Rpb24gZyh0LGUpe2Zvcih2YXIgcj1uZXcgQXJyYXkoZSksbj0wO248ZTsrK24pcltuXT10W25dO3JldHVybiByfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLFwiZGVmYXVsdE1heExpc3RlbmVyc1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1fSxzZXQ6ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHR8fHQ8MHx8YSh0KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcrdCtcIi5cIik7dT10fX0pLHMuaW5pdD1mdW5jdGlvbigpe3ZvaWQgMCE9PXRoaXMuX2V2ZW50cyYmdGhpcy5fZXZlbnRzIT09T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHN8fCh0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKSx0aGlzLl9tYXhMaXN0ZW5lcnM9dGhpcy5fbWF4TGlzdGVuZXJzfHx2b2lkIDB9LHMucHJvdG90eXBlLnNldE1heExpc3RlbmVycz1mdW5jdGlvbih0KXtpZihcIm51bWJlclwiIT10eXBlb2YgdHx8dDwwfHxhKHQpKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyt0K1wiLlwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPXQsdGhpc30scy5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIGYodGhpcyl9LHMucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKWUucHVzaChhcmd1bWVudHNbcl0pO3ZhciBuPVwiZXJyb3JcIj09PXQsaT10aGlzLl9ldmVudHM7aWYodm9pZCAwIT09aSluPW4mJnZvaWQgMD09PWkuZXJyb3I7ZWxzZSBpZighbilyZXR1cm4hMTtpZihuKXt2YXIgYTtpZihlLmxlbmd0aD4wJiYoYT1lWzBdKSxhIGluc3RhbmNlb2YgRXJyb3IpdGhyb3cgYTt2YXIgcz1uZXcgRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3IuXCIrKGE/XCIgKFwiK2EubWVzc2FnZStcIilcIjpcIlwiKSk7dGhyb3cgcy5jb250ZXh0PWEsc312YXIgdT1pW3RdO2lmKHZvaWQgMD09PXUpcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdSlvKHUsdGhpcyxlKTtlbHNle3ZhciBjPXUubGVuZ3RoLGY9Zyh1LGMpO2ZvcihyPTA7cjxjOysrcilvKGZbcl0sdGhpcyxlKX1yZXR1cm4hMH0scy5wcm90b3R5cGUuYWRkTGlzdGVuZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbCh0aGlzLHQsZSwhMSl9LHMucHJvdG90eXBlLm9uPXMucHJvdG90eXBlLmFkZExpc3RlbmVyLHMucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3JldHVybiBsKHRoaXMsdCxlLCEwKX0scy5wcm90b3R5cGUub25jZT1mdW5jdGlvbih0LGUpe3JldHVybiBjKGUpLHRoaXMub24odCxwKHRoaXMsdCxlKSksdGhpc30scy5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3JldHVybiBjKGUpLHRoaXMucHJlcGVuZExpc3RlbmVyKHQscCh0aGlzLHQsZSkpLHRoaXN9LHMucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLG8sYTtpZihjKGUpLHZvaWQgMD09PShuPXRoaXMuX2V2ZW50cykpcmV0dXJuIHRoaXM7aWYodm9pZCAwPT09KHI9blt0XSkpcmV0dXJuIHRoaXM7aWYocj09PWV8fHIubGlzdGVuZXI9PT1lKTA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6KGRlbGV0ZSBuW3RdLG4ucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsdCxyLmxpc3RlbmVyfHxlKSk7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXtmb3IoaT0tMSxvPXIubGVuZ3RoLTE7bz49MDtvLS0paWYocltvXT09PWV8fHJbb10ubGlzdGVuZXI9PT1lKXthPXJbb10ubGlzdGVuZXIsaT1vO2JyZWFrfWlmKGk8MClyZXR1cm4gdGhpczswPT09aT9yLnNoaWZ0KCk6ZnVuY3Rpb24odCxlKXtmb3IoO2UrMTx0Lmxlbmd0aDtlKyspdFtlXT10W2UrMV07dC5wb3AoKX0ocixpKSwxPT09ci5sZW5ndGgmJihuW3RdPXJbMF0pLHZvaWQgMCE9PW4ucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsdCxhfHxlKX1yZXR1cm4gdGhpc30scy5wcm90b3R5cGUub2ZmPXMucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLHMucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbih0KXt2YXIgZSxyLG47aWYodm9pZCAwPT09KHI9dGhpcy5fZXZlbnRzKSlyZXR1cm4gdGhpcztpZih2b2lkIDA9PT1yLnJlbW92ZUxpc3RlbmVyKXJldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCk6dm9pZCAwIT09clt0XSYmKDA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6ZGVsZXRlIHJbdF0pLHRoaXM7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpLG89T2JqZWN0LmtleXMocik7Zm9yKG49MDtuPG8ubGVuZ3RoOysrbilcInJlbW92ZUxpc3RlbmVyXCIhPT0oaT1vW25dKSYmdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoaSk7cmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIiksdGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCx0aGlzfWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mKGU9clt0XSkpdGhpcy5yZW1vdmVMaXN0ZW5lcih0LGUpO2Vsc2UgaWYodm9pZCAwIT09ZSlmb3Iobj1lLmxlbmd0aC0xO24+PTA7bi0tKXRoaXMucmVtb3ZlTGlzdGVuZXIodCxlW25dKTtyZXR1cm4gdGhpc30scy5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybiBkKHRoaXMsdCwhMCl9LHMucHJvdG90eXBlLnJhd0xpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4gZCh0aGlzLHQsITEpfSxzLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lmxpc3RlbmVyQ291bnQ/dC5saXN0ZW5lckNvdW50KGUpOnYuY2FsbCh0LGUpfSxzLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PXYscy5wcm90b3R5cGUuZXZlbnROYW1lcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ldmVudHNDb3VudD4wP24odGhpcy5fZXZlbnRzKTpbXX19LGZ1bmN0aW9uKHQsZSxyKXsoZT10LmV4cG9ydHM9cigxMzgpKS5TdHJlYW09ZSxlLlJlYWRhYmxlPWUsZS5Xcml0YWJsZT1yKDk1KSxlLkR1cGxleD1yKDIzKSxlLlRyYW5zZm9ybT1yKDE0MiksZS5QYXNzVGhyb3VnaD1yKDE5Nil9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24oZSxuLGkpe3ZhciBvPXIoNTUpO2Z1bmN0aW9uIGEodCl7dmFyIGU9dGhpczt0aGlzLm5leHQ9bnVsbCx0aGlzLmVudHJ5PW51bGwsdGhpcy5maW5pc2g9ZnVuY3Rpb24oKXshZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQuZW50cnk7dC5lbnRyeT1udWxsO2Zvcig7bjspe3ZhciBpPW4uY2FsbGJhY2s7ZS5wZW5kaW5nY2ItLSxpKHIpLG49bi5uZXh0fWUuY29ya2VkUmVxdWVzdHNGcmVlP2UuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQ9dDplLmNvcmtlZFJlcXVlc3RzRnJlZT10fShlLHQpfX10LmV4cG9ydHM9Yjt2YXIgcyx1PSFlLmJyb3dzZXImJltcInYwLjEwXCIsXCJ2MC45LlwiXS5pbmRleE9mKGUudmVyc2lvbi5zbGljZSgwLDUpKT4tMT9uOm8ubmV4dFRpY2s7Yi5Xcml0YWJsZVN0YXRlPXk7dmFyIGM9cigzOSk7Yy5pbmhlcml0cz1yKDI5KTt2YXIgZj17ZGVwcmVjYXRlOnIoMTk1KX0sbD1yKDEzOSksaD1yKDU2KS5CdWZmZXIscD1pLlVpbnQ4QXJyYXl8fGZ1bmN0aW9uKCl7fTt2YXIgZCx2PXIoMTQwKTtmdW5jdGlvbiBnKCl7fWZ1bmN0aW9uIHkodCxlKXtzPXN8fHIoMjMpLHQ9dHx8e307dmFyIG49ZSBpbnN0YW5jZW9mIHM7dGhpcy5vYmplY3RNb2RlPSEhdC5vYmplY3RNb2RlLG4mJih0aGlzLm9iamVjdE1vZGU9dGhpcy5vYmplY3RNb2RlfHwhIXQud3JpdGFibGVPYmplY3RNb2RlKTt2YXIgaT10LmhpZ2hXYXRlck1hcmssYz10LndyaXRhYmxlSGlnaFdhdGVyTWFyayxmPXRoaXMub2JqZWN0TW9kZT8xNjoxNjM4NDt0aGlzLmhpZ2hXYXRlck1hcms9aXx8MD09PWk/aTpuJiYoY3x8MD09PWMpP2M6Zix0aGlzLmhpZ2hXYXRlck1hcms9TWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspLHRoaXMuZmluYWxDYWxsZWQ9ITEsdGhpcy5uZWVkRHJhaW49ITEsdGhpcy5lbmRpbmc9ITEsdGhpcy5lbmRlZD0hMSx0aGlzLmZpbmlzaGVkPSExLHRoaXMuZGVzdHJveWVkPSExO3ZhciBsPSExPT09dC5kZWNvZGVTdHJpbmdzO3RoaXMuZGVjb2RlU3RyaW5ncz0hbCx0aGlzLmRlZmF1bHRFbmNvZGluZz10LmRlZmF1bHRFbmNvZGluZ3x8XCJ1dGY4XCIsdGhpcy5sZW5ndGg9MCx0aGlzLndyaXRpbmc9ITEsdGhpcy5jb3JrZWQ9MCx0aGlzLnN5bmM9ITAsdGhpcy5idWZmZXJQcm9jZXNzaW5nPSExLHRoaXMub253cml0ZT1mdW5jdGlvbih0KXshZnVuY3Rpb24odCxlKXt2YXIgcj10Ll93cml0YWJsZVN0YXRlLG49ci5zeW5jLGk9ci53cml0ZWNiO2lmKGZ1bmN0aW9uKHQpe3Qud3JpdGluZz0hMSx0LndyaXRlY2I9bnVsbCx0Lmxlbmd0aC09dC53cml0ZWxlbix0LndyaXRlbGVuPTB9KHIpLGUpIWZ1bmN0aW9uKHQsZSxyLG4saSl7LS1lLnBlbmRpbmdjYixyPyhvLm5leHRUaWNrKGksbiksby5uZXh0VGljayhFLHQsZSksdC5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ9ITAsdC5lbWl0KFwiZXJyb3JcIixuKSk6KGkobiksdC5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ9ITAsdC5lbWl0KFwiZXJyb3JcIixuKSxFKHQsZSkpfSh0LHIsbixlLGkpO2Vsc2V7dmFyIGE9eChyKTthfHxyLmNvcmtlZHx8ci5idWZmZXJQcm9jZXNzaW5nfHwhci5idWZmZXJlZFJlcXVlc3R8fHcodCxyKSxuP3UobSx0LHIsYSxpKTptKHQscixhLGkpfX0oZSx0KX0sdGhpcy53cml0ZWNiPW51bGwsdGhpcy53cml0ZWxlbj0wLHRoaXMuYnVmZmVyZWRSZXF1ZXN0PW51bGwsdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGwsdGhpcy5wZW5kaW5nY2I9MCx0aGlzLnByZWZpbmlzaGVkPSExLHRoaXMuZXJyb3JFbWl0dGVkPSExLHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQ9MCx0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZT1uZXcgYSh0aGlzKX1mdW5jdGlvbiBiKHQpe2lmKHM9c3x8cigyMyksIShkLmNhbGwoYix0aGlzKXx8dGhpcyBpbnN0YW5jZW9mIHMpKXJldHVybiBuZXcgYih0KTt0aGlzLl93cml0YWJsZVN0YXRlPW5ldyB5KHQsdGhpcyksdGhpcy53cml0YWJsZT0hMCx0JiYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC53cml0ZSYmKHRoaXMuX3dyaXRlPXQud3JpdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQud3JpdGV2JiYodGhpcy5fd3JpdGV2PXQud3JpdGV2KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmRlc3Ryb3kmJih0aGlzLl9kZXN0cm95PXQuZGVzdHJveSksXCJmdW5jdGlvblwiPT10eXBlb2YgdC5maW5hbCYmKHRoaXMuX2ZpbmFsPXQuZmluYWwpKSxsLmNhbGwodGhpcyl9ZnVuY3Rpb24gXyh0LGUscixuLGksbyxhKXtlLndyaXRlbGVuPW4sZS53cml0ZWNiPWEsZS53cml0aW5nPSEwLGUuc3luYz0hMCxyP3QuX3dyaXRldihpLGUub253cml0ZSk6dC5fd3JpdGUoaSxvLGUub253cml0ZSksZS5zeW5jPSExfWZ1bmN0aW9uIG0odCxlLHIsbil7cnx8ZnVuY3Rpb24odCxlKXswPT09ZS5sZW5ndGgmJmUubmVlZERyYWluJiYoZS5uZWVkRHJhaW49ITEsdC5lbWl0KFwiZHJhaW5cIikpfSh0LGUpLGUucGVuZGluZ2NiLS0sbigpLEUodCxlKX1mdW5jdGlvbiB3KHQsZSl7ZS5idWZmZXJQcm9jZXNzaW5nPSEwO3ZhciByPWUuYnVmZmVyZWRSZXF1ZXN0O2lmKHQuX3dyaXRldiYmciYmci5uZXh0KXt2YXIgbj1lLmJ1ZmZlcmVkUmVxdWVzdENvdW50LGk9bmV3IEFycmF5KG4pLG89ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7by5lbnRyeT1yO2Zvcih2YXIgcz0wLHU9ITA7cjspaVtzXT1yLHIuaXNCdWZ8fCh1PSExKSxyPXIubmV4dCxzKz0xO2kuYWxsQnVmZmVycz11LF8odCxlLCEwLGUubGVuZ3RoLGksXCJcIixvLmZpbmlzaCksZS5wZW5kaW5nY2IrKyxlLmxhc3RCdWZmZXJlZFJlcXVlc3Q9bnVsbCxvLm5leHQ/KGUuY29ya2VkUmVxdWVzdHNGcmVlPW8ubmV4dCxvLm5leHQ9bnVsbCk6ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU9bmV3IGEoZSksZS5idWZmZXJlZFJlcXVlc3RDb3VudD0wfWVsc2V7Zm9yKDtyOyl7dmFyIGM9ci5jaHVuayxmPXIuZW5jb2RpbmcsbD1yLmNhbGxiYWNrO2lmKF8odCxlLCExLGUub2JqZWN0TW9kZT8xOmMubGVuZ3RoLGMsZixsKSxyPXIubmV4dCxlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS0sZS53cml0aW5nKWJyZWFrfW51bGw9PT1yJiYoZS5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGwpfWUuYnVmZmVyZWRSZXF1ZXN0PXIsZS5idWZmZXJQcm9jZXNzaW5nPSExfWZ1bmN0aW9uIHgodCl7cmV0dXJuIHQuZW5kaW5nJiYwPT09dC5sZW5ndGgmJm51bGw9PT10LmJ1ZmZlcmVkUmVxdWVzdCYmIXQuZmluaXNoZWQmJiF0LndyaXRpbmd9ZnVuY3Rpb24gayh0LGUpe3QuX2ZpbmFsKChmdW5jdGlvbihyKXtlLnBlbmRpbmdjYi0tLHImJnQuZW1pdChcImVycm9yXCIsciksZS5wcmVmaW5pc2hlZD0hMCx0LmVtaXQoXCJwcmVmaW5pc2hcIiksRSh0LGUpfSkpfWZ1bmN0aW9uIEUodCxlKXt2YXIgcj14KGUpO3JldHVybiByJiYoIWZ1bmN0aW9uKHQsZSl7ZS5wcmVmaW5pc2hlZHx8ZS5maW5hbENhbGxlZHx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuX2ZpbmFsPyhlLnBlbmRpbmdjYisrLGUuZmluYWxDYWxsZWQ9ITAsby5uZXh0VGljayhrLHQsZSkpOihlLnByZWZpbmlzaGVkPSEwLHQuZW1pdChcInByZWZpbmlzaFwiKSkpfSh0LGUpLDA9PT1lLnBlbmRpbmdjYiYmKGUuZmluaXNoZWQ9ITAsdC5lbWl0KFwiZmluaXNoXCIpKSkscn1jLmluaGVyaXRzKGIsbCkseS5wcm90b3R5cGUuZ2V0QnVmZmVyPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuYnVmZmVyZWRSZXF1ZXN0LGU9W107dDspZS5wdXNoKHQpLHQ9dC5uZXh0O3JldHVybiBlfSxmdW5jdGlvbigpe3RyeXtPYmplY3QuZGVmaW5lUHJvcGVydHkoeS5wcm90b3R5cGUsXCJidWZmZXJcIix7Z2V0OmYuZGVwcmVjYXRlKChmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEJ1ZmZlcigpfSksXCJfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciBpbnN0ZWFkLlwiLFwiREVQMDAwM1wiKX0pfWNhdGNoKHQpe319KCksXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaGFzSW5zdGFuY2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdPyhkPUZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuISFkLmNhbGwodGhpcyx0KXx8dGhpcz09PWImJih0JiZ0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgeSl9fSkpOmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzfSxiLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKCl7dGhpcy5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlXCIpKX0sYi5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGk9dGhpcy5fd3JpdGFibGVTdGF0ZSxhPSExLHM9IWkub2JqZWN0TW9kZSYmKG49dCxoLmlzQnVmZmVyKG4pfHxuIGluc3RhbmNlb2YgcCk7cmV0dXJuIHMmJiFoLmlzQnVmZmVyKHQpJiYodD1mdW5jdGlvbih0KXtyZXR1cm4gaC5mcm9tKHQpfSh0KSksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKHI9ZSxlPW51bGwpLHM/ZT1cImJ1ZmZlclwiOmV8fChlPWkuZGVmYXVsdEVuY29kaW5nKSxcImZ1bmN0aW9uXCIhPXR5cGVvZiByJiYocj1nKSxpLmVuZGVkP2Z1bmN0aW9uKHQsZSl7dmFyIHI9bmV3IEVycm9yKFwid3JpdGUgYWZ0ZXIgZW5kXCIpO3QuZW1pdChcImVycm9yXCIsciksby5uZXh0VGljayhlLHIpfSh0aGlzLHIpOihzfHxmdW5jdGlvbih0LGUscixuKXt2YXIgaT0hMCxhPSExO3JldHVybiBudWxsPT09cj9hPW5ldyBUeXBlRXJyb3IoXCJNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbVwiKTpcInN0cmluZ1wiPT10eXBlb2Ygcnx8dm9pZCAwPT09cnx8ZS5vYmplY3RNb2RlfHwoYT1uZXcgVHlwZUVycm9yKFwiSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVua1wiKSksYSYmKHQuZW1pdChcImVycm9yXCIsYSksby5uZXh0VGljayhuLGEpLGk9ITEpLGl9KHRoaXMsaSx0LHIpKSYmKGkucGVuZGluZ2NiKyssYT1mdW5jdGlvbih0LGUscixuLGksbyl7aWYoIXIpe3ZhciBhPWZ1bmN0aW9uKHQsZSxyKXt0Lm9iamVjdE1vZGV8fCExPT09dC5kZWNvZGVTdHJpbmdzfHxcInN0cmluZ1wiIT10eXBlb2YgZXx8KGU9aC5mcm9tKGUscikpO3JldHVybiBlfShlLG4saSk7biE9PWEmJihyPSEwLGk9XCJidWZmZXJcIixuPWEpfXZhciBzPWUub2JqZWN0TW9kZT8xOm4ubGVuZ3RoO2UubGVuZ3RoKz1zO3ZhciB1PWUubGVuZ3RoPGUuaGlnaFdhdGVyTWFyazt1fHwoZS5uZWVkRHJhaW49ITApO2lmKGUud3JpdGluZ3x8ZS5jb3JrZWQpe3ZhciBjPWUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtlLmxhc3RCdWZmZXJlZFJlcXVlc3Q9e2NodW5rOm4sZW5jb2Rpbmc6aSxpc0J1ZjpyLGNhbGxiYWNrOm8sbmV4dDpudWxsfSxjP2MubmV4dD1lLmxhc3RCdWZmZXJlZFJlcXVlc3Q6ZS5idWZmZXJlZFJlcXVlc3Q9ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0LGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQrPTF9ZWxzZSBfKHQsZSwhMSxzLG4saSxvKTtyZXR1cm4gdX0odGhpcyxpLHMsdCxlLHIpKSxhfSxiLnByb3RvdHlwZS5jb3JrPWZ1bmN0aW9uKCl7dGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrK30sYi5wcm90b3R5cGUudW5jb3JrPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fd3JpdGFibGVTdGF0ZTt0LmNvcmtlZCYmKHQuY29ya2VkLS0sdC53cml0aW5nfHx0LmNvcmtlZHx8dC5maW5pc2hlZHx8dC5idWZmZXJQcm9jZXNzaW5nfHwhdC5idWZmZXJlZFJlcXVlc3R8fHcodGhpcyx0KSl9LGIucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZz1mdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9dC50b0xvd2VyQ2FzZSgpKSwhKFtcImhleFwiLFwidXRmOFwiLFwidXRmLThcIixcImFzY2lpXCIsXCJiaW5hcnlcIixcImJhc2U2NFwiLFwidWNzMlwiLFwidWNzLTJcIixcInV0ZjE2bGVcIixcInV0Zi0xNmxlXCIsXCJyYXdcIl0uaW5kZXhPZigodCtcIlwiKS50b0xvd2VyQ2FzZSgpKT4tMSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3QpO3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZz10LHRoaXN9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcIndyaXRhYmxlSGlnaFdhdGVyTWFya1wiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcmt9fSksYi5wcm90b3R5cGUuX3dyaXRlPWZ1bmN0aW9uKHQsZSxyKXtyKG5ldyBFcnJvcihcIl93cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZFwiKSl9LGIucHJvdG90eXBlLl93cml0ZXY9bnVsbCxiLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXRoaXMuX3dyaXRhYmxlU3RhdGU7XCJmdW5jdGlvblwiPT10eXBlb2YgdD8ocj10LHQ9bnVsbCxlPW51bGwpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihyPWUsZT1udWxsKSxudWxsIT10JiZ0aGlzLndyaXRlKHQsZSksbi5jb3JrZWQmJihuLmNvcmtlZD0xLHRoaXMudW5jb3JrKCkpLG4uZW5kaW5nfHxuLmZpbmlzaGVkfHxmdW5jdGlvbih0LGUscil7ZS5lbmRpbmc9ITAsRSh0LGUpLHImJihlLmZpbmlzaGVkP28ubmV4dFRpY2socik6dC5vbmNlKFwiZmluaXNoXCIscikpO2UuZW5kZWQ9ITAsdC53cml0YWJsZT0hMX0odGhpcyxuLHIpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX3dyaXRhYmxlU3RhdGUmJnRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPXQpfX0pLGIucHJvdG90eXBlLmRlc3Ryb3k9di5kZXN0cm95LGIucHJvdG90eXBlLl91bmRlc3Ryb3k9di51bmRlc3Ryb3ksYi5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24odCxlKXt0aGlzLmVuZCgpLGUodCl9fSkuY2FsbCh0aGlzLHIoMzgpLHIoMTM2KS5zZXRJbW1lZGlhdGUscigyMSkpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIHIoZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP3QuZXhwb3J0cz1yPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06dC5leHBvcnRzPXI9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0scihlKX10LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTYpLGk9cig4MCksbz1yKDIwMiksYT1yKDIwMyk7ZnVuY3Rpb24gcyhlKXt2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXA/bmV3IE1hcDp2b2lkIDA7cmV0dXJuIHQuZXhwb3J0cz1zPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10fHwhbyh0KSlyZXR1cm4gdDtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtpZih2b2lkIDAhPT1yKXtpZihyLmhhcyh0KSlyZXR1cm4gci5nZXQodCk7ci5zZXQodCxlKX1mdW5jdGlvbiBlKCl7cmV0dXJuIGEodCxhcmd1bWVudHMsbih0aGlzKS5jb25zdHJ1Y3Rvcil9cmV0dXJuIGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGkoZSx0KX0scyhlKX10LmV4cG9ydHM9c30sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDQpLG89cigyNiksYT1yKDI1KSxzPXIoNyksdT1yKDY5KSxjPXIoMTA3KSxmPXIoNSksbD1yKDEzKSxoPXIoNDcpLHA9cigxMCksZD1yKDgpLHY9cigyNyksZz1yKDEyKSx5PXIoNDMpLGI9cigzMSksXz1yKDcwKSxtPXIoNDgpLHc9cig0NikseD1yKDE0OCksaz1yKDEwNiksRT1yKDIyKSxTPXIoMTEpLGo9cig1OSksUj1yKDE0KSxDPXIoMTcpLEk9cig2NCksTz1yKDQ0KSxUPXIoNDUpLFA9cig2NSksQT1yKDMpLEw9cigxMTApLEY9cigxMTEpLE09cig0OSksTj1yKDI0KSxCPXIoMzMpLmZvckVhY2gsRD1PKFwiaGlkZGVuXCIpLFU9QShcInRvUHJpbWl0aXZlXCIpLHE9Ti5zZXQsRz1OLmdldHRlckZvcihcIlN5bWJvbFwiKSxXPU9iamVjdC5wcm90b3R5cGUsej1pLlN5bWJvbCxZPW8oXCJKU09OXCIsXCJzdHJpbmdpZnlcIiksUT1FLmYsJD1TLmYsSD14LmYsSz1qLmYsVj1JKFwic3ltYm9sc1wiKSxaPUkoXCJvcC1zeW1ib2xzXCIpLEo9SShcInN0cmluZy10by1zeW1ib2wtcmVnaXN0cnlcIiksWD1JKFwic3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeVwiKSx0dD1JKFwid2tzXCIpLGV0PWkuUU9iamVjdCxydD0hZXR8fCFldC5wcm90b3R5cGV8fCFldC5wcm90b3R5cGUuZmluZENoaWxkLG50PXMmJmYoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPV8oJCh7fSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuICQodGhpcyxcImFcIix7dmFsdWU6N30pLmF9fSkpLmF9KSk/ZnVuY3Rpb24odCxlLHIpe3ZhciBuPVEoVyxlKTtuJiZkZWxldGUgV1tlXSwkKHQsZSxyKSxuJiZ0IT09VyYmJChXLGUsbil9OiQsaXQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1WW3RdPV8oei5wcm90b3R5cGUpO3JldHVybiBxKHIse3R5cGU6XCJTeW1ib2xcIix0YWc6dCxkZXNjcmlwdGlvbjplfSksc3x8KHIuZGVzY3JpcHRpb249ZSkscn0sb3Q9Yz9mdW5jdGlvbih0KXtyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdCh0KWluc3RhbmNlb2Ygen0sYXQ9ZnVuY3Rpb24odCxlLHIpe3Q9PT1XJiZhdChaLGUsciksZCh0KTt2YXIgbj15KGUsITApO3JldHVybiBkKHIpLGwoVixuKT8oci5lbnVtZXJhYmxlPyhsKHQsRCkmJnRbRF1bbl0mJih0W0RdW25dPSExKSxyPV8ocix7ZW51bWVyYWJsZTpiKDAsITEpfSkpOihsKHQsRCl8fCQodCxELGIoMSx7fSkpLHRbRF1bbl09ITApLG50KHQsbixyKSk6JCh0LG4scil9LHN0PWZ1bmN0aW9uKHQsZSl7ZCh0KTt2YXIgcj1nKGUpLG49bShyKS5jb25jYXQobHQocikpO3JldHVybiBCKG4sKGZ1bmN0aW9uKGUpe3MmJiF1dC5jYWxsKHIsZSl8fGF0KHQsZSxyW2VdKX0pKSx0fSx1dD1mdW5jdGlvbih0KXt2YXIgZT15KHQsITApLHI9Sy5jYWxsKHRoaXMsZSk7cmV0dXJuISh0aGlzPT09VyYmbChWLGUpJiYhbChaLGUpKSYmKCEocnx8IWwodGhpcyxlKXx8IWwoVixlKXx8bCh0aGlzLEQpJiZ0aGlzW0RdW2VdKXx8cil9LGN0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9Zyh0KSxuPXkoZSwhMCk7aWYociE9PVd8fCFsKFYsbil8fGwoWixuKSl7dmFyIGk9UShyLG4pO3JldHVybiFpfHwhbChWLG4pfHxsKHIsRCkmJnJbRF1bbl18fChpLmVudW1lcmFibGU9ITApLGl9fSxmdD1mdW5jdGlvbih0KXt2YXIgZT1IKGcodCkpLHI9W107cmV0dXJuIEIoZSwoZnVuY3Rpb24odCl7bChWLHQpfHxsKFQsdCl8fHIucHVzaCh0KX0pKSxyfSxsdD1mdW5jdGlvbih0KXt2YXIgZT10PT09VyxyPUgoZT9aOmcodCkpLG49W107cmV0dXJuIEIociwoZnVuY3Rpb24odCl7IWwoVix0KXx8ZSYmIWwoVyx0KXx8bi5wdXNoKFZbdF0pfSkpLG59Oyh1fHwoQygoej1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiB6KXRocm93IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTt2YXIgdD1hcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/U3RyaW5nKGFyZ3VtZW50c1swXSk6dm9pZCAwLGU9UCh0KSxyPWZ1bmN0aW9uKHQpe3RoaXM9PT1XJiZyLmNhbGwoWix0KSxsKHRoaXMsRCkmJmwodGhpc1tEXSxlKSYmKHRoaXNbRF1bZV09ITEpLG50KHRoaXMsZSxiKDEsdCkpfTtyZXR1cm4gcyYmcnQmJm50KFcsZSx7Y29uZmlndXJhYmxlOiEwLHNldDpyfSksaXQoZSx0KX0pLnByb3RvdHlwZSxcInRvU3RyaW5nXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEcodGhpcykudGFnfSkpLEMoeixcIndpdGhvdXRTZXR0ZXJcIiwoZnVuY3Rpb24odCl7cmV0dXJuIGl0KFAodCksdCl9KSksai5mPXV0LFMuZj1hdCxFLmY9Y3Qsdy5mPXguZj1mdCxrLmY9bHQsTC5mPWZ1bmN0aW9uKHQpe3JldHVybiBpdChBKHQpLHQpfSxzJiYoJCh6LnByb3RvdHlwZSxcImRlc2NyaXB0aW9uXCIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRyh0aGlzKS5kZXNjcmlwdGlvbn19KSxhfHxDKFcsXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLHV0LHt1bnNhZmU6ITB9KSkpLG4oe2dsb2JhbDohMCx3cmFwOiEwLGZvcmNlZDohdSxzaGFtOiF1fSx7U3ltYm9sOnp9KSxCKG0odHQpLChmdW5jdGlvbih0KXtGKHQpfSkpLG4oe3RhcmdldDpcIlN5bWJvbFwiLHN0YXQ6ITAsZm9yY2VkOiF1fSx7Zm9yOmZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZyh0KTtpZihsKEosZSkpcmV0dXJuIEpbZV07dmFyIHI9eihlKTtyZXR1cm4gSltlXT1yLFhbcl09ZSxyfSxrZXlGb3I6ZnVuY3Rpb24odCl7aWYoIW90KHQpKXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhIHN5bWJvbFwiKTtpZihsKFgsdCkpcmV0dXJuIFhbdF19LHVzZVNldHRlcjpmdW5jdGlvbigpe3J0PSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXtydD0hMX19KSxuKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDohdSxzaGFtOiFzfSx7Y3JlYXRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWU/Xyh0KTpzdChfKHQpLGUpfSxkZWZpbmVQcm9wZXJ0eTphdCxkZWZpbmVQcm9wZXJ0aWVzOnN0LGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpjdH0pLG4oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiF1fSx7Z2V0T3duUHJvcGVydHlOYW1lczpmdCxnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6bHR9KSxuKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpmKChmdW5jdGlvbigpe2suZigxKX0pKX0se2dldE93blByb3BlcnR5U3ltYm9sczpmdW5jdGlvbih0KXtyZXR1cm4gay5mKHYodCkpfX0pLFkpJiZuKHt0YXJnZXQ6XCJKU09OXCIsc3RhdDohMCxmb3JjZWQ6IXV8fGYoKGZ1bmN0aW9uKCl7dmFyIHQ9eigpO3JldHVyblwiW251bGxdXCIhPVkoW3RdKXx8XCJ7fVwiIT1ZKHthOnR9KXx8XCJ7fVwiIT1ZKE9iamVjdCh0KSl9KSl9LHtzdHJpbmdpZnk6ZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgbixpPVt0XSxvPTE7YXJndW1lbnRzLmxlbmd0aD5vOylpLnB1c2goYXJndW1lbnRzW28rK10pO2lmKG49ZSwocChlKXx8dm9pZCAwIT09dCkmJiFvdCh0KSlyZXR1cm4gaChlKXx8KGU9ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYoZT1uLmNhbGwodGhpcyx0LGUpKSwhb3QoZSkpcmV0dXJuIGV9KSxpWzFdPWUsWS5hcHBseShudWxsLGkpfX0pO3oucHJvdG90eXBlW1VdfHxSKHoucHJvdG90eXBlLFUsei5wcm90b3R5cGUudmFsdWVPZiksTSh6LFwiU3ltYm9sXCIpLFRbRF09ITB9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDcpLGk9cig1KSxvPXIoNjEpO3QuZXhwb3J0cz0hbiYmIWkoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eShvKFwiZGl2XCIpLFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSkpfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig0KSxpPXIoNjIpLG89bltcIl9fY29yZS1qc19zaGFyZWRfX1wiXXx8aShcIl9fY29yZS1qc19zaGFyZWRfX1wiLHt9KTt0LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTMpLGk9cigxMDIpLG89cigyMiksYT1yKDExKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9aShlKSxzPWEuZix1PW8uZixjPTA7YzxyLmxlbmd0aDtjKyspe3ZhciBmPXJbY107bih0LGYpfHxzKHQsZix1KGUsZikpfX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDI2KSxpPXIoNDYpLG89cigxMDYpLGE9cig4KTt0LmV4cG9ydHM9bihcIlJlZmxlY3RcIixcIm93bktleXNcIil8fGZ1bmN0aW9uKHQpe3ZhciBlPWkuZihhKHQpKSxyPW8uZjtyZXR1cm4gcj9lLmNvbmNhdChyKHQpKTplfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCk7dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEzKSxpPXIoMTIpLG89cig2NikuaW5kZXhPZixhPXIoNDUpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByLHM9aSh0KSx1PTAsYz1bXTtmb3IociBpbiBzKSFuKGEscikmJm4ocyxyKSYmYy5wdXNoKHIpO2Zvcig7ZS5sZW5ndGg+dTspbihzLHI9ZVt1KytdKSYmKH5vKGMscil8fGMucHVzaChyKSk7cmV0dXJuIGN9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigzMiksaT1NYXRoLm1heCxvPU1hdGgubWluO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByPW4odCk7cmV0dXJuIHI8MD9pKHIrZSwwKTpvKHIsZSl9fSxmdW5jdGlvbih0LGUpe2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig2OSk7dC5leHBvcnRzPW4mJiFTeW1ib2wuc2hhbSYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcn0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDExKSxvPXIoOCksYT1yKDQ4KTt0LmV4cG9ydHM9bj9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbih0LGUpe28odCk7Zm9yKHZhciByLG49YShlKSxzPW4ubGVuZ3RoLHU9MDtzPnU7KWkuZih0LHI9blt1KytdLGVbcl0pO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMjYpO3QuZXhwb3J0cz1uKFwiZG9jdW1lbnRcIixcImRvY3VtZW50RWxlbWVudFwiKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMyk7ZS5mPW59LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEwMyksaT1yKDEzKSxvPXIoMTEwKSxhPXIoMTEpLmY7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPW4uU3ltYm9sfHwobi5TeW1ib2w9e30pO2koZSx0KXx8YShlLHQse3ZhbHVlOm8uZih0KX0pfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTApLGk9cig0Nyksbz1yKDMpKFwic3BlY2llc1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgcjtyZXR1cm4gaSh0KSYmKFwiZnVuY3Rpb25cIiE9dHlwZW9mKHI9dC5jb25zdHJ1Y3Rvcil8fHIhPT1BcnJheSYmIWkoci5wcm90b3R5cGUpP24ocikmJm51bGw9PT0ocj1yW29dKSYmKHI9dm9pZCAwKTpyPXZvaWQgMCksbmV3KHZvaWQgMD09PXI/QXJyYXk6cikoMD09PWU/MDplKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDMpLGk9cig3MCksbz1yKDExKSxhPW4oXCJ1bnNjb3BhYmxlc1wiKSxzPUFycmF5LnByb3RvdHlwZTtudWxsPT1zW2FdJiZvLmYocyxhLHtjb25maWd1cmFibGU6ITAsdmFsdWU6aShudWxsKX0pLHQuZXhwb3J0cz1mdW5jdGlvbih0KXtzW2FdW3RdPSEwfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDE1MSksbz1yKDExNiksYT1yKDExNykscz1yKDQ5KSx1PXIoMTQpLGM9cigxNyksZj1yKDMpLGw9cigyNSksaD1yKDM0KSxwPXIoMTE1KSxkPXAuSXRlcmF0b3JQcm90b3R5cGUsdj1wLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMsZz1mKFwiaXRlcmF0b3JcIikseT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIsZixwLGIsXyl7aShyLGUsZik7dmFyIG0sdyx4LGs9ZnVuY3Rpb24odCl7aWYodD09PXAmJkMpcmV0dXJuIEM7aWYoIXYmJnQgaW4gailyZXR1cm4galt0XTtzd2l0Y2godCl7Y2FzZVwia2V5c1wiOmNhc2VcInZhbHVlc1wiOmNhc2VcImVudHJpZXNcIjpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIodGhpcyx0KX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyByKHRoaXMpfX0sRT1lK1wiIEl0ZXJhdG9yXCIsUz0hMSxqPXQucHJvdG90eXBlLFI9altnXXx8altcIkBAaXRlcmF0b3JcIl18fHAmJmpbcF0sQz0hdiYmUnx8ayhwKSxJPVwiQXJyYXlcIj09ZSYmai5lbnRyaWVzfHxSO2lmKEkmJihtPW8oSS5jYWxsKG5ldyB0KSksZCE9PU9iamVjdC5wcm90b3R5cGUmJm0ubmV4dCYmKGx8fG8obSk9PT1kfHwoYT9hKG0sZCk6XCJmdW5jdGlvblwiIT10eXBlb2YgbVtnXSYmdShtLGcseSkpLHMobSxFLCEwLCEwKSxsJiYoaFtFXT15KSkpLFwidmFsdWVzXCI9PXAmJlImJlwidmFsdWVzXCIhPT1SLm5hbWUmJihTPSEwLEM9ZnVuY3Rpb24oKXtyZXR1cm4gUi5jYWxsKHRoaXMpfSksbCYmIV98fGpbZ109PT1DfHx1KGosZyxDKSxoW2VdPUMscClpZih3PXt2YWx1ZXM6ayhcInZhbHVlc1wiKSxrZXlzOmI/QzprKFwia2V5c1wiKSxlbnRyaWVzOmsoXCJlbnRyaWVzXCIpfSxfKWZvcih4IGluIHcpKHZ8fFN8fCEoeCBpbiBqKSkmJmMoaix4LHdbeF0pO2Vsc2Ugbih7dGFyZ2V0OmUscHJvdG86ITAsZm9yY2VkOnZ8fFN9LHcpO3JldHVybiB3fX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGksbyxhPXIoMTE2KSxzPXIoMTQpLHU9cigxMyksYz1yKDMpLGY9cigyNSksbD1jKFwiaXRlcmF0b3JcIiksaD0hMTtbXS5rZXlzJiYoXCJuZXh0XCJpbihvPVtdLmtleXMoKSk/KGk9YShhKG8pKSkhPT1PYmplY3QucHJvdG90eXBlJiYobj1pKTpoPSEwKSxudWxsPT1uJiYobj17fSksZnx8dShuLGwpfHxzKG4sbCwoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSx0LmV4cG9ydHM9e0l0ZXJhdG9yUHJvdG90eXBlOm4sQlVHR1lfU0FGQVJJX0lURVJBVE9SUzpofX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTMpLGk9cigyNyksbz1yKDQ0KSxhPXIoMTUyKSxzPW8oXCJJRV9QUk9UT1wiKSx1PU9iamVjdC5wcm90b3R5cGU7dC5leHBvcnRzPWE/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0PWkodCksbih0LHMpP3Rbc106XCJmdW5jdGlvblwiPT10eXBlb2YgdC5jb25zdHJ1Y3RvciYmdCBpbnN0YW5jZW9mIHQuY29uc3RydWN0b3I/dC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6dCBpbnN0YW5jZW9mIE9iamVjdD91Om51bGx9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig4KSxpPXIoMTUzKTt0LmV4cG9ydHM9T2JqZWN0LnNldFByb3RvdHlwZU9mfHwoXCJfX3Byb3RvX19cImlue30/ZnVuY3Rpb24oKXt2YXIgdCxlPSExLHI9e307dHJ5eyh0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSxcIl9fcHJvdG9fX1wiKS5zZXQpLmNhbGwocixbXSksZT1yIGluc3RhbmNlb2YgQXJyYXl9Y2F0Y2godCl7fXJldHVybiBmdW5jdGlvbihyLG8pe3JldHVybiBuKHIpLGkobyksZT90LmNhbGwocixvKTpyLl9fcHJvdG9fXz1vLHJ9fSgpOnZvaWQgMCl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDcyKSxpPXIoMTkpLG89cigzKShcInRvU3RyaW5nVGFnXCIpLGE9XCJBcmd1bWVudHNcIj09aShmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpO3QuZXhwb3J0cz1uP2k6ZnVuY3Rpb24odCl7dmFyIGUscixuO3JldHVybiB2b2lkIDA9PT10P1wiVW5kZWZpbmVkXCI6bnVsbD09PXQ/XCJOdWxsXCI6XCJzdHJpbmdcIj09dHlwZW9mKHI9ZnVuY3Rpb24odCxlKXt0cnl7cmV0dXJuIHRbZV19Y2F0Y2godCl7fX0oZT1PYmplY3QodCksbykpP3I6YT9pKGUpOlwiT2JqZWN0XCI9PShuPWkoZSkpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNhbGxlZT9cIkFyZ3VtZW50c1wiOm59fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig1KTtmdW5jdGlvbiBpKHQsZSl7cmV0dXJuIFJlZ0V4cCh0LGUpfWUuVU5TVVBQT1JURURfWT1uKChmdW5jdGlvbigpe3ZhciB0PWkoXCJhXCIsXCJ5XCIpO3JldHVybiB0Lmxhc3RJbmRleD0yLG51bGwhPXQuZXhlYyhcImFiY2RcIil9KSksZS5CUk9LRU5fQ0FSRVQ9bigoZnVuY3Rpb24oKXt2YXIgdD1pKFwiXnJcIixcImd5XCIpO3JldHVybiB0Lmxhc3RJbmRleD0yLG51bGwhPXQuZXhlYyhcInN0clwiKX0pKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMzIpLGk9cigyMCksbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyKXt2YXIgbyxhLHM9U3RyaW5nKGkoZSkpLHU9bihyKSxjPXMubGVuZ3RoO3JldHVybiB1PDB8fHU+PWM/dD9cIlwiOnZvaWQgMDoobz1zLmNoYXJDb2RlQXQodSkpPDU1Mjk2fHxvPjU2MzE5fHx1KzE9PT1jfHwoYT1zLmNoYXJDb2RlQXQodSsxKSk8NTYzMjB8fGE+NTczNDM/dD9zLmNoYXJBdCh1KTpvOnQ/cy5zbGljZSh1LHUrMik6YS01NjMyMCsoby01NTI5Njw8MTApKzY1NTM2fX07dC5leHBvcnRzPXtjb2RlQXQ6byghMSksY2hhckF0Om8oITApfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9e0NTU1J1bGVMaXN0OjAsQ1NTU3R5bGVEZWNsYXJhdGlvbjowLENTU1ZhbHVlTGlzdDowLENsaWVudFJlY3RMaXN0OjAsRE9NUmVjdExpc3Q6MCxET01TdHJpbmdMaXN0OjAsRE9NVG9rZW5MaXN0OjEsRGF0YVRyYW5zZmVySXRlbUxpc3Q6MCxGaWxlTGlzdDowLEhUTUxBbGxDb2xsZWN0aW9uOjAsSFRNTENvbGxlY3Rpb246MCxIVE1MRm9ybUVsZW1lbnQ6MCxIVE1MU2VsZWN0RWxlbWVudDowLE1lZGlhTGlzdDowLE1pbWVUeXBlQXJyYXk6MCxOYW1lZE5vZGVNYXA6MCxOb2RlTGlzdDoxLFBhaW50UmVxdWVzdExpc3Q6MCxQbHVnaW46MCxQbHVnaW5BcnJheTowLFNWR0xlbmd0aExpc3Q6MCxTVkdOdW1iZXJMaXN0OjAsU1ZHUGF0aFNlZ0xpc3Q6MCxTVkdQb2ludExpc3Q6MCxTVkdTdHJpbmdMaXN0OjAsU1ZHVHJhbnNmb3JtTGlzdDowLFNvdXJjZUJ1ZmZlckxpc3Q6MCxTdHlsZVNoZWV0TGlzdDowLFRleHRUcmFja0N1ZUxpc3Q6MCxUZXh0VHJhY2tMaXN0OjAsVG91Y2hMaXN0OjB9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyNik7dC5leHBvcnRzPW4oXCJuYXZpZ2F0b3JcIixcInVzZXJBZ2VudFwiKXx8XCJcIn0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMzMpLmZvckVhY2gsaT1yKDM2KTt0LmV4cG9ydHM9aShcImZvckVhY2hcIik/ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX06W10uZm9yRWFjaH0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMiksaT1yKDI3KSxvPXIoNDgpO24oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOnIoNSkoKGZ1bmN0aW9uKCl7bygxKX0pKX0se2tleXM6ZnVuY3Rpb24odCl7cmV0dXJuIG8oaSh0KSl9fSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDI2KSxpPXIoMTEpLG89cigzKSxhPXIoNykscz1vKFwic3BlY2llc1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9bih0KSxyPWkuZjthJiZlJiYhZVtzXSYmcihlLHMse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbixpPXIoMiksbz1yKDIyKS5mLGE9cigxNSkscz1yKDEyNyksdT1yKDIwKSxjPXIoMTI4KSxmPXIoMjUpLGw9XCJcIi5lbmRzV2l0aCxoPU1hdGgubWluLHA9YyhcImVuZHNXaXRoXCIpO2koe3RhcmdldDpcIlN0cmluZ1wiLHByb3RvOiEwLGZvcmNlZDohIShmfHxwfHwobj1vKFN0cmluZy5wcm90b3R5cGUsXCJlbmRzV2l0aFwiKSwhbnx8bi53cml0YWJsZSkpJiYhcH0se2VuZHNXaXRoOmZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZyh1KHRoaXMpKTtzKHQpO3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLG49YShlLmxlbmd0aCksaT12b2lkIDA9PT1yP246aChhKHIpLG4pLG89U3RyaW5nKHQpO3JldHVybiBsP2wuY2FsbChlLG8saSk6ZS5zbGljZShpLW8ubGVuZ3RoLGkpPT09b319KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoODgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihuKHQpKXRocm93IFR5cGVFcnJvcihcIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9uc1wiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDMpKFwibWF0Y2hcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPS8uLzt0cnl7XCIvLi9cIlt0XShlKX1jYXRjaChyKXt0cnl7cmV0dXJuIGVbbl09ITEsXCIvLi9cIlt0XShlKX1jYXRjaCh0KXt9fXJldHVybiExfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDEyNyksbz1yKDIwKTtuKHt0YXJnZXQ6XCJTdHJpbmdcIixwcm90bzohMCxmb3JjZWQ6IXIoMTI4KShcImluY2x1ZGVzXCIpfSx7aW5jbHVkZXM6ZnVuY3Rpb24odCl7cmV0dXJuISF+U3RyaW5nKG8odGhpcykpLmluZGV4T2YoaSh0KSxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDIpLGk9cigxNzUpO24oe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOmkhPT1bXS5sYXN0SW5kZXhPZn0se2xhc3RJbmRleE9mOml9KX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDEwKSxvPXIoNDcpLGE9cigxMDUpLHM9cigxNSksdT1yKDEyKSxjPXIoODIpLGY9cig1NCksbD1yKDMpKFwic3BlY2llc1wiKSxoPVtdLnNsaWNlLHA9TWF0aC5tYXg7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IWYoXCJzbGljZVwiKX0se3NsaWNlOmZ1bmN0aW9uKHQsZSl7dmFyIHIsbixmLGQ9dSh0aGlzKSx2PXMoZC5sZW5ndGgpLGc9YSh0LHYpLHk9YSh2b2lkIDA9PT1lP3Y6ZSx2KTtpZihvKGQpJiYoXCJmdW5jdGlvblwiIT10eXBlb2Yocj1kLmNvbnN0cnVjdG9yKXx8ciE9PUFycmF5JiYhbyhyLnByb3RvdHlwZSk/aShyKSYmbnVsbD09PShyPXJbbF0pJiYocj12b2lkIDApOnI9dm9pZCAwLHI9PT1BcnJheXx8dm9pZCAwPT09cikpcmV0dXJuIGguY2FsbChkLGcseSk7Zm9yKG49bmV3KHZvaWQgMD09PXI/QXJyYXk6cikocCh5LWcsMCkpLGY9MDtnPHk7ZysrLGYrKylnIGluIGQmJmMobixmLGRbZ10pO3JldHVybiBuLmxlbmd0aD1mLG59fSl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDgpLGk9cig1MCksbz1yKDMpKFwic3BlY2llc1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgcixhPW4odCkuY29uc3RydWN0b3I7cmV0dXJuIHZvaWQgMD09PWF8fG51bGw9PShyPW4oYSlbb10pP2U6aShyKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpLG8sYT1yKDQpLHM9cig1KSx1PXIoMTkpLGM9cig3MSksZj1yKDEwOSksbD1yKDYxKSxoPXIoMTM0KSxwPWEubG9jYXRpb24sZD1hLnNldEltbWVkaWF0ZSx2PWEuY2xlYXJJbW1lZGlhdGUsZz1hLnByb2Nlc3MseT1hLk1lc3NhZ2VDaGFubmVsLGI9YS5EaXNwYXRjaCxfPTAsbT17fSx3PWZ1bmN0aW9uKHQpe2lmKG0uaGFzT3duUHJvcGVydHkodCkpe3ZhciBlPW1bdF07ZGVsZXRlIG1bdF0sZSgpfX0seD1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt3KHQpfX0saz1mdW5jdGlvbih0KXt3KHQuZGF0YSl9LEU9ZnVuY3Rpb24odCl7YS5wb3N0TWVzc2FnZSh0K1wiXCIscC5wcm90b2NvbCtcIi8vXCIrcC5ob3N0KX07ZCYmdnx8KGQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLHI9MTthcmd1bWVudHMubGVuZ3RoPnI7KWUucHVzaChhcmd1bWVudHNbcisrXSk7cmV0dXJuIG1bKytfXT1mdW5jdGlvbigpeyhcImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6RnVuY3Rpb24odCkpLmFwcGx5KHZvaWQgMCxlKX0sbihfKSxffSx2PWZ1bmN0aW9uKHQpe2RlbGV0ZSBtW3RdfSxcInByb2Nlc3NcIj09dShnKT9uPWZ1bmN0aW9uKHQpe2cubmV4dFRpY2soeCh0KSl9OmImJmIubm93P249ZnVuY3Rpb24odCl7Yi5ub3coeCh0KSl9OnkmJiFoPyhvPShpPW5ldyB5KS5wb3J0MixpLnBvcnQxLm9ubWVzc2FnZT1rLG49YyhvLnBvc3RNZXNzYWdlLG8sMSkpOiFhLmFkZEV2ZW50TGlzdGVuZXJ8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHBvc3RNZXNzYWdlfHxhLmltcG9ydFNjcmlwdHN8fHMoRSk/bj1cIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gbChcInNjcmlwdFwiKT9mdW5jdGlvbih0KXtmLmFwcGVuZENoaWxkKGwoXCJzY3JpcHRcIikpLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2YucmVtb3ZlQ2hpbGQodGhpcyksdyh0KX19OmZ1bmN0aW9uKHQpe3NldFRpbWVvdXQoeCh0KSwwKX06KG49RSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsaywhMSkpKSx0LmV4cG9ydHM9e3NldDpkLGNsZWFyOnZ9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMjIpO3QuZXhwb3J0cz0vKGlwaG9uZXxpcG9kfGlwYWQpLiphcHBsZXdlYmtpdC9pLnRlc3Qobil9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDUwKSxpPWZ1bmN0aW9uKHQpe3ZhciBlLHI7dGhpcy5wcm9taXNlPW5ldyB0KChmdW5jdGlvbih0LG4pe2lmKHZvaWQgMCE9PWV8fHZvaWQgMCE9PXIpdGhyb3cgVHlwZUVycm9yKFwiQmFkIFByb21pc2UgY29uc3RydWN0b3JcIik7ZT10LHI9bn0pKSx0aGlzLnJlc29sdmU9bihlKSx0aGlzLnJlamVjdD1uKHIpfTt0LmV4cG9ydHMuZj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkodCl9fSxmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHQpe3ZhciBuPXZvaWQgMCE9PXQmJnR8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmfHx3aW5kb3csaT1GdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7ZnVuY3Rpb24gbyh0LGUpe3RoaXMuX2lkPXQsdGhpcy5fY2xlYXJGbj1lfWUuc2V0VGltZW91dD1mdW5jdGlvbigpe3JldHVybiBuZXcgbyhpLmNhbGwoc2V0VGltZW91dCxuLGFyZ3VtZW50cyksY2xlYXJUaW1lb3V0KX0sZS5zZXRJbnRlcnZhbD1mdW5jdGlvbigpe3JldHVybiBuZXcgbyhpLmNhbGwoc2V0SW50ZXJ2YWwsbixhcmd1bWVudHMpLGNsZWFySW50ZXJ2YWwpfSxlLmNsZWFyVGltZW91dD1lLmNsZWFySW50ZXJ2YWw9ZnVuY3Rpb24odCl7dCYmdC5jbG9zZSgpfSxvLnByb3RvdHlwZS51bnJlZj1vLnByb3RvdHlwZS5yZWY9ZnVuY3Rpb24oKXt9LG8ucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5fY2xlYXJGbi5jYWxsKG4sdGhpcy5faWQpfSxlLmVucm9sbD1mdW5jdGlvbih0LGUpe2NsZWFyVGltZW91dCh0Ll9pZGxlVGltZW91dElkKSx0Ll9pZGxlVGltZW91dD1lfSxlLnVuZW5yb2xsPWZ1bmN0aW9uKHQpe2NsZWFyVGltZW91dCh0Ll9pZGxlVGltZW91dElkKSx0Ll9pZGxlVGltZW91dD0tMX0sZS5fdW5yZWZBY3RpdmU9ZS5hY3RpdmU9ZnVuY3Rpb24odCl7Y2xlYXJUaW1lb3V0KHQuX2lkbGVUaW1lb3V0SWQpO3ZhciBlPXQuX2lkbGVUaW1lb3V0O2U+PTAmJih0Ll9pZGxlVGltZW91dElkPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dC5fb25UaW1lb3V0JiZ0Ll9vblRpbWVvdXQoKX0pLGUpKX0scigxODkpLGUuc2V0SW1tZWRpYXRlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLnNldEltbWVkaWF0ZXx8dm9pZCAwIT09dCYmdC5zZXRJbW1lZGlhdGV8fHRoaXMmJnRoaXMuc2V0SW1tZWRpYXRlLGUuY2xlYXJJbW1lZGlhdGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGYuY2xlYXJJbW1lZGlhdGV8fHZvaWQgMCE9PXQmJnQuY2xlYXJJbW1lZGlhdGV8fHRoaXMmJnRoaXMuY2xlYXJJbW1lZGlhdGV9KS5jYWxsKHRoaXMscigyMSkpfSxmdW5jdGlvbih0LGUpe3ZhciByPXt9LnRvU3RyaW5nO3QuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PXIuY2FsbCh0KX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24oZSxuKXt2YXIgaT1yKDU1KTt0LmV4cG9ydHM9Xzt2YXIgbyxhPXIoMTM3KTtfLlJlYWRhYmxlU3RhdGU9YjtyKDkzKS5FdmVudEVtaXR0ZXI7dmFyIHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5saXN0ZW5lcnMoZSkubGVuZ3RofSx1PXIoMTM5KSxjPXIoNTYpLkJ1ZmZlcixmPWUuVWludDhBcnJheXx8ZnVuY3Rpb24oKXt9O3ZhciBsPXIoMzkpO2wuaW5oZXJpdHM9cigyOSk7dmFyIGg9cigxOTIpLHA9dm9pZCAwO3A9aCYmaC5kZWJ1Z2xvZz9oLmRlYnVnbG9nKFwic3RyZWFtXCIpOmZ1bmN0aW9uKCl7fTt2YXIgZCx2PXIoMTkzKSxnPXIoMTQwKTtsLmluaGVyaXRzKF8sdSk7dmFyIHk9W1wiZXJyb3JcIixcImNsb3NlXCIsXCJkZXN0cm95XCIsXCJwYXVzZVwiLFwicmVzdW1lXCJdO2Z1bmN0aW9uIGIodCxlKXt0PXR8fHt9O3ZhciBuPWUgaW5zdGFuY2VvZihvPW98fHIoMjMpKTt0aGlzLm9iamVjdE1vZGU9ISF0Lm9iamVjdE1vZGUsbiYmKHRoaXMub2JqZWN0TW9kZT10aGlzLm9iamVjdE1vZGV8fCEhdC5yZWFkYWJsZU9iamVjdE1vZGUpO3ZhciBpPXQuaGlnaFdhdGVyTWFyayxhPXQucmVhZGFibGVIaWdoV2F0ZXJNYXJrLHM9dGhpcy5vYmplY3RNb2RlPzE2OjE2Mzg0O3RoaXMuaGlnaFdhdGVyTWFyaz1pfHwwPT09aT9pOm4mJihhfHwwPT09YSk/YTpzLHRoaXMuaGlnaFdhdGVyTWFyaz1NYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayksdGhpcy5idWZmZXI9bmV3IHYsdGhpcy5sZW5ndGg9MCx0aGlzLnBpcGVzPW51bGwsdGhpcy5waXBlc0NvdW50PTAsdGhpcy5mbG93aW5nPW51bGwsdGhpcy5lbmRlZD0hMSx0aGlzLmVuZEVtaXR0ZWQ9ITEsdGhpcy5yZWFkaW5nPSExLHRoaXMuc3luYz0hMCx0aGlzLm5lZWRSZWFkYWJsZT0hMSx0aGlzLmVtaXR0ZWRSZWFkYWJsZT0hMSx0aGlzLnJlYWRhYmxlTGlzdGVuaW5nPSExLHRoaXMucmVzdW1lU2NoZWR1bGVkPSExLHRoaXMuZGVzdHJveWVkPSExLHRoaXMuZGVmYXVsdEVuY29kaW5nPXQuZGVmYXVsdEVuY29kaW5nfHxcInV0ZjhcIix0aGlzLmF3YWl0RHJhaW49MCx0aGlzLnJlYWRpbmdNb3JlPSExLHRoaXMuZGVjb2Rlcj1udWxsLHRoaXMuZW5jb2Rpbmc9bnVsbCx0LmVuY29kaW5nJiYoZHx8KGQ9cigxNDEpLlN0cmluZ0RlY29kZXIpLHRoaXMuZGVjb2Rlcj1uZXcgZCh0LmVuY29kaW5nKSx0aGlzLmVuY29kaW5nPXQuZW5jb2RpbmcpfWZ1bmN0aW9uIF8odCl7aWYobz1vfHxyKDIzKSwhKHRoaXMgaW5zdGFuY2VvZiBfKSlyZXR1cm4gbmV3IF8odCk7dGhpcy5fcmVhZGFibGVTdGF0ZT1uZXcgYih0LHRoaXMpLHRoaXMucmVhZGFibGU9ITAsdCYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQucmVhZCYmKHRoaXMuX3JlYWQ9dC5yZWFkKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmRlc3Ryb3kmJih0aGlzLl9kZXN0cm95PXQuZGVzdHJveSkpLHUuY2FsbCh0aGlzKX1mdW5jdGlvbiBtKHQsZSxyLG4saSl7dmFyIG8sYT10Ll9yZWFkYWJsZVN0YXRlO251bGw9PT1lPyhhLnJlYWRpbmc9ITEsZnVuY3Rpb24odCxlKXtpZihlLmVuZGVkKXJldHVybjtpZihlLmRlY29kZXIpe3ZhciByPWUuZGVjb2Rlci5lbmQoKTtyJiZyLmxlbmd0aCYmKGUuYnVmZmVyLnB1c2gociksZS5sZW5ndGgrPWUub2JqZWN0TW9kZT8xOnIubGVuZ3RoKX1lLmVuZGVkPSEwLGsodCl9KHQsYSkpOihpfHwobz1mdW5jdGlvbih0LGUpe3ZhciByO249ZSxjLmlzQnVmZmVyKG4pfHxuIGluc3RhbmNlb2YgZnx8XCJzdHJpbmdcIj09dHlwZW9mIGV8fHZvaWQgMD09PWV8fHQub2JqZWN0TW9kZXx8KHI9bmV3IFR5cGVFcnJvcihcIkludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmtcIikpO3ZhciBuO3JldHVybiByfShhLGUpKSxvP3QuZW1pdChcImVycm9yXCIsbyk6YS5vYmplY3RNb2RlfHxlJiZlLmxlbmd0aD4wPyhcInN0cmluZ1wiPT10eXBlb2YgZXx8YS5vYmplY3RNb2RlfHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk9PT1jLnByb3RvdHlwZXx8KGU9ZnVuY3Rpb24odCl7cmV0dXJuIGMuZnJvbSh0KX0oZSkpLG4/YS5lbmRFbWl0dGVkP3QuZW1pdChcImVycm9yXCIsbmV3IEVycm9yKFwic3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnRcIikpOncodCxhLGUsITApOmEuZW5kZWQ/dC5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRlwiKSk6KGEucmVhZGluZz0hMSxhLmRlY29kZXImJiFyPyhlPWEuZGVjb2Rlci53cml0ZShlKSxhLm9iamVjdE1vZGV8fDAhPT1lLmxlbmd0aD93KHQsYSxlLCExKTpTKHQsYSkpOncodCxhLGUsITEpKSk6bnx8KGEucmVhZGluZz0hMSkpO3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4hdC5lbmRlZCYmKHQubmVlZFJlYWRhYmxlfHx0Lmxlbmd0aDx0LmhpZ2hXYXRlck1hcmt8fDA9PT10Lmxlbmd0aCl9KGEpfWZ1bmN0aW9uIHcodCxlLHIsbil7ZS5mbG93aW5nJiYwPT09ZS5sZW5ndGgmJiFlLnN5bmM/KHQuZW1pdChcImRhdGFcIixyKSx0LnJlYWQoMCkpOihlLmxlbmd0aCs9ZS5vYmplY3RNb2RlPzE6ci5sZW5ndGgsbj9lLmJ1ZmZlci51bnNoaWZ0KHIpOmUuYnVmZmVyLnB1c2gociksZS5uZWVkUmVhZGFibGUmJmsodCkpLFModCxlKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoXy5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fcmVhZGFibGVTdGF0ZSYmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPXQpfX0pLF8ucHJvdG90eXBlLmRlc3Ryb3k9Zy5kZXN0cm95LF8ucHJvdG90eXBlLl91bmRlc3Ryb3k9Zy51bmRlc3Ryb3ksXy5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24odCxlKXt0aGlzLnB1c2gobnVsbCksZSh0KX0sXy5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0LGUpe3ZhciByLG49dGhpcy5fcmVhZGFibGVTdGF0ZTtyZXR1cm4gbi5vYmplY3RNb2RlP3I9ITA6XCJzdHJpbmdcIj09dHlwZW9mIHQmJigoZT1lfHxuLmRlZmF1bHRFbmNvZGluZykhPT1uLmVuY29kaW5nJiYodD1jLmZyb20odCxlKSxlPVwiXCIpLHI9ITApLG0odGhpcyx0LGUsITEscil9LF8ucHJvdG90eXBlLnVuc2hpZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIG0odGhpcyx0LG51bGwsITAsITEpfSxfLnByb3RvdHlwZS5pc1BhdXNlZD1mdW5jdGlvbigpe3JldHVybiExPT09dGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nfSxfLnByb3RvdHlwZS5zZXRFbmNvZGluZz1mdW5jdGlvbih0KXtyZXR1cm4gZHx8KGQ9cigxNDEpLlN0cmluZ0RlY29kZXIpLHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlcj1uZXcgZCh0KSx0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nPXQsdGhpc307ZnVuY3Rpb24geCh0LGUpe3JldHVybiB0PD0wfHwwPT09ZS5sZW5ndGgmJmUuZW5kZWQ/MDplLm9iamVjdE1vZGU/MTp0IT10P2UuZmxvd2luZyYmZS5sZW5ndGg/ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDplLmxlbmd0aDoodD5lLmhpZ2hXYXRlck1hcmsmJihlLmhpZ2hXYXRlck1hcms9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+PTgzODg2MDg/dD04Mzg4NjA4Oih0LS0sdHw9dD4+PjEsdHw9dD4+PjIsdHw9dD4+PjQsdHw9dD4+PjgsdHw9dD4+PjE2LHQrKyksdH0odCkpLHQ8PWUubGVuZ3RoP3Q6ZS5lbmRlZD9lLmxlbmd0aDooZS5uZWVkUmVhZGFibGU9ITAsMCkpfWZ1bmN0aW9uIGsodCl7dmFyIGU9dC5fcmVhZGFibGVTdGF0ZTtlLm5lZWRSZWFkYWJsZT0hMSxlLmVtaXR0ZWRSZWFkYWJsZXx8KHAoXCJlbWl0UmVhZGFibGVcIixlLmZsb3dpbmcpLGUuZW1pdHRlZFJlYWRhYmxlPSEwLGUuc3luYz9pLm5leHRUaWNrKEUsdCk6RSh0KSl9ZnVuY3Rpb24gRSh0KXtwKFwiZW1pdCByZWFkYWJsZVwiKSx0LmVtaXQoXCJyZWFkYWJsZVwiKSxJKHQpfWZ1bmN0aW9uIFModCxlKXtlLnJlYWRpbmdNb3JlfHwoZS5yZWFkaW5nTW9yZT0hMCxpLm5leHRUaWNrKGosdCxlKSl9ZnVuY3Rpb24gaih0LGUpe2Zvcih2YXIgcj1lLmxlbmd0aDshZS5yZWFkaW5nJiYhZS5mbG93aW5nJiYhZS5lbmRlZCYmZS5sZW5ndGg8ZS5oaWdoV2F0ZXJNYXJrJiYocChcIm1heWJlUmVhZE1vcmUgcmVhZCAwXCIpLHQucmVhZCgwKSxyIT09ZS5sZW5ndGgpOylyPWUubGVuZ3RoO2UucmVhZGluZ01vcmU9ITF9ZnVuY3Rpb24gUih0KXtwKFwicmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwXCIpLHQucmVhZCgwKX1mdW5jdGlvbiBDKHQsZSl7ZS5yZWFkaW5nfHwocChcInJlc3VtZSByZWFkIDBcIiksdC5yZWFkKDApKSxlLnJlc3VtZVNjaGVkdWxlZD0hMSxlLmF3YWl0RHJhaW49MCx0LmVtaXQoXCJyZXN1bWVcIiksSSh0KSxlLmZsb3dpbmcmJiFlLnJlYWRpbmcmJnQucmVhZCgwKX1mdW5jdGlvbiBJKHQpe3ZhciBlPXQuX3JlYWRhYmxlU3RhdGU7Zm9yKHAoXCJmbG93XCIsZS5mbG93aW5nKTtlLmZsb3dpbmcmJm51bGwhPT10LnJlYWQoKTspO31mdW5jdGlvbiBPKHQsZSl7cmV0dXJuIDA9PT1lLmxlbmd0aD9udWxsOihlLm9iamVjdE1vZGU/cj1lLmJ1ZmZlci5zaGlmdCgpOiF0fHx0Pj1lLmxlbmd0aD8ocj1lLmRlY29kZXI/ZS5idWZmZXIuam9pbihcIlwiKToxPT09ZS5idWZmZXIubGVuZ3RoP2UuYnVmZmVyLmhlYWQuZGF0YTplLmJ1ZmZlci5jb25jYXQoZS5sZW5ndGgpLGUuYnVmZmVyLmNsZWFyKCkpOnI9ZnVuY3Rpb24odCxlLHIpe3ZhciBuO3Q8ZS5oZWFkLmRhdGEubGVuZ3RoPyhuPWUuaGVhZC5kYXRhLnNsaWNlKDAsdCksZS5oZWFkLmRhdGE9ZS5oZWFkLmRhdGEuc2xpY2UodCkpOm49dD09PWUuaGVhZC5kYXRhLmxlbmd0aD9lLnNoaWZ0KCk6cj9mdW5jdGlvbih0LGUpe3ZhciByPWUuaGVhZCxuPTEsaT1yLmRhdGE7dC09aS5sZW5ndGg7Zm9yKDtyPXIubmV4dDspe3ZhciBvPXIuZGF0YSxhPXQ+by5sZW5ndGg/by5sZW5ndGg6dDtpZihhPT09by5sZW5ndGg/aSs9bzppKz1vLnNsaWNlKDAsdCksMD09PSh0LT1hKSl7YT09PW8ubGVuZ3RoPygrK24sci5uZXh0P2UuaGVhZD1yLm5leHQ6ZS5oZWFkPWUudGFpbD1udWxsKTooZS5oZWFkPXIsci5kYXRhPW8uc2xpY2UoYSkpO2JyZWFrfSsrbn1yZXR1cm4gZS5sZW5ndGgtPW4saX0odCxlKTpmdW5jdGlvbih0LGUpe3ZhciByPWMuYWxsb2NVbnNhZmUodCksbj1lLmhlYWQsaT0xO24uZGF0YS5jb3B5KHIpLHQtPW4uZGF0YS5sZW5ndGg7Zm9yKDtuPW4ubmV4dDspe3ZhciBvPW4uZGF0YSxhPXQ+by5sZW5ndGg/by5sZW5ndGg6dDtpZihvLmNvcHkocixyLmxlbmd0aC10LDAsYSksMD09PSh0LT1hKSl7YT09PW8ubGVuZ3RoPygrK2ksbi5uZXh0P2UuaGVhZD1uLm5leHQ6ZS5oZWFkPWUudGFpbD1udWxsKTooZS5oZWFkPW4sbi5kYXRhPW8uc2xpY2UoYSkpO2JyZWFrfSsraX1yZXR1cm4gZS5sZW5ndGgtPWkscn0odCxlKTtyZXR1cm4gbn0odCxlLmJ1ZmZlcixlLmRlY29kZXIpLHIpO3ZhciByfWZ1bmN0aW9uIFQodCl7dmFyIGU9dC5fcmVhZGFibGVTdGF0ZTtpZihlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtlLmVuZEVtaXR0ZWR8fChlLmVuZGVkPSEwLGkubmV4dFRpY2soUCxlLHQpKX1mdW5jdGlvbiBQKHQsZSl7dC5lbmRFbWl0dGVkfHwwIT09dC5sZW5ndGh8fCh0LmVuZEVtaXR0ZWQ9ITAsZS5yZWFkYWJsZT0hMSxlLmVtaXQoXCJlbmRcIikpfWZ1bmN0aW9uIEEodCxlKXtmb3IodmFyIHI9MCxuPXQubGVuZ3RoO3I8bjtyKyspaWYodFtyXT09PWUpcmV0dXJuIHI7cmV0dXJuLTF9Xy5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtwKFwicmVhZFwiLHQpLHQ9cGFyc2VJbnQodCwxMCk7dmFyIGU9dGhpcy5fcmVhZGFibGVTdGF0ZSxyPXQ7aWYoMCE9PXQmJihlLmVtaXR0ZWRSZWFkYWJsZT0hMSksMD09PXQmJmUubmVlZFJlYWRhYmxlJiYoZS5sZW5ndGg+PWUuaGlnaFdhdGVyTWFya3x8ZS5lbmRlZCkpcmV0dXJuIHAoXCJyZWFkOiBlbWl0UmVhZGFibGVcIixlLmxlbmd0aCxlLmVuZGVkKSwwPT09ZS5sZW5ndGgmJmUuZW5kZWQ/VCh0aGlzKTprKHRoaXMpLG51bGw7aWYoMD09PSh0PXgodCxlKSkmJmUuZW5kZWQpcmV0dXJuIDA9PT1lLmxlbmd0aCYmVCh0aGlzKSxudWxsO3ZhciBuLGk9ZS5uZWVkUmVhZGFibGU7cmV0dXJuIHAoXCJuZWVkIHJlYWRhYmxlXCIsaSksKDA9PT1lLmxlbmd0aHx8ZS5sZW5ndGgtdDxlLmhpZ2hXYXRlck1hcmspJiZwKFwibGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmtcIixpPSEwKSxlLmVuZGVkfHxlLnJlYWRpbmc/cChcInJlYWRpbmcgb3IgZW5kZWRcIixpPSExKTppJiYocChcImRvIHJlYWRcIiksZS5yZWFkaW5nPSEwLGUuc3luYz0hMCwwPT09ZS5sZW5ndGgmJihlLm5lZWRSZWFkYWJsZT0hMCksdGhpcy5fcmVhZChlLmhpZ2hXYXRlck1hcmspLGUuc3luYz0hMSxlLnJlYWRpbmd8fCh0PXgocixlKSkpLG51bGw9PT0obj10PjA/Tyh0LGUpOm51bGwpPyhlLm5lZWRSZWFkYWJsZT0hMCx0PTApOmUubGVuZ3RoLT10LDA9PT1lLmxlbmd0aCYmKGUuZW5kZWR8fChlLm5lZWRSZWFkYWJsZT0hMCksciE9PXQmJmUuZW5kZWQmJlQodGhpcykpLG51bGwhPT1uJiZ0aGlzLmVtaXQoXCJkYXRhXCIsbiksbn0sXy5wcm90b3R5cGUuX3JlYWQ9ZnVuY3Rpb24odCl7dGhpcy5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZFwiKSl9LF8ucHJvdG90eXBlLnBpcGU9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLG89dGhpcy5fcmVhZGFibGVTdGF0ZTtzd2l0Y2goby5waXBlc0NvdW50KXtjYXNlIDA6by5waXBlcz10O2JyZWFrO2Nhc2UgMTpvLnBpcGVzPVtvLnBpcGVzLHRdO2JyZWFrO2RlZmF1bHQ6by5waXBlcy5wdXNoKHQpfW8ucGlwZXNDb3VudCs9MSxwKFwicGlwZSBjb3VudD0lZCBvcHRzPSVqXCIsby5waXBlc0NvdW50LGUpO3ZhciB1PSghZXx8ITEhPT1lLmVuZCkmJnQhPT1uLnN0ZG91dCYmdCE9PW4uc3RkZXJyP2Y6XztmdW5jdGlvbiBjKGUsbil7cChcIm9udW5waXBlXCIpLGU9PT1yJiZuJiYhMT09PW4uaGFzVW5waXBlZCYmKG4uaGFzVW5waXBlZD0hMCxwKFwiY2xlYW51cFwiKSx0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIix5KSx0LnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsYiksdC5yZW1vdmVMaXN0ZW5lcihcImRyYWluXCIsbCksdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsZyksdC5yZW1vdmVMaXN0ZW5lcihcInVucGlwZVwiLGMpLHIucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixmKSxyLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsXyksci5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIix2KSxoPSEwLCFvLmF3YWl0RHJhaW58fHQuX3dyaXRhYmxlU3RhdGUmJiF0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbnx8bCgpKX1mdW5jdGlvbiBmKCl7cChcIm9uZW5kXCIpLHQuZW5kKCl9by5lbmRFbWl0dGVkP2kubmV4dFRpY2sodSk6ci5vbmNlKFwiZW5kXCIsdSksdC5vbihcInVucGlwZVwiLGMpO3ZhciBsPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQuX3JlYWRhYmxlU3RhdGU7cChcInBpcGVPbkRyYWluXCIsZS5hd2FpdERyYWluKSxlLmF3YWl0RHJhaW4mJmUuYXdhaXREcmFpbi0tLDA9PT1lLmF3YWl0RHJhaW4mJnModCxcImRhdGFcIikmJihlLmZsb3dpbmc9ITAsSSh0KSl9fShyKTt0Lm9uKFwiZHJhaW5cIixsKTt2YXIgaD0hMTt2YXIgZD0hMTtmdW5jdGlvbiB2KGUpe3AoXCJvbmRhdGFcIiksZD0hMSwhMSE9PXQud3JpdGUoZSl8fGR8fCgoMT09PW8ucGlwZXNDb3VudCYmby5waXBlcz09PXR8fG8ucGlwZXNDb3VudD4xJiYtMSE9PUEoby5waXBlcyx0KSkmJiFoJiYocChcImZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZVwiLHIuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbiksci5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKyssZD0hMCksci5wYXVzZSgpKX1mdW5jdGlvbiBnKGUpe3AoXCJvbmVycm9yXCIsZSksXygpLHQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLGcpLDA9PT1zKHQsXCJlcnJvclwiKSYmdC5lbWl0KFwiZXJyb3JcIixlKX1mdW5jdGlvbiB5KCl7dC5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLGIpLF8oKX1mdW5jdGlvbiBiKCl7cChcIm9uZmluaXNoXCIpLHQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLHkpLF8oKX1mdW5jdGlvbiBfKCl7cChcInVucGlwZVwiKSxyLnVucGlwZSh0KX1yZXR1cm4gci5vbihcImRhdGFcIix2KSxmdW5jdGlvbih0LGUscil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5wcmVwZW5kTGlzdGVuZXIpcmV0dXJuIHQucHJlcGVuZExpc3RlbmVyKGUscik7dC5fZXZlbnRzJiZ0Ll9ldmVudHNbZV0/YSh0Ll9ldmVudHNbZV0pP3QuX2V2ZW50c1tlXS51bnNoaWZ0KHIpOnQuX2V2ZW50c1tlXT1bcix0Ll9ldmVudHNbZV1dOnQub24oZSxyKX0odCxcImVycm9yXCIsZyksdC5vbmNlKFwiY2xvc2VcIix5KSx0Lm9uY2UoXCJmaW5pc2hcIixiKSx0LmVtaXQoXCJwaXBlXCIsciksby5mbG93aW5nfHwocChcInBpcGUgcmVzdW1lXCIpLHIucmVzdW1lKCkpLHR9LF8ucHJvdG90eXBlLnVucGlwZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9yZWFkYWJsZVN0YXRlLHI9e2hhc1VucGlwZWQ6ITF9O2lmKDA9PT1lLnBpcGVzQ291bnQpcmV0dXJuIHRoaXM7aWYoMT09PWUucGlwZXNDb3VudClyZXR1cm4gdCYmdCE9PWUucGlwZXN8fCh0fHwodD1lLnBpcGVzKSxlLnBpcGVzPW51bGwsZS5waXBlc0NvdW50PTAsZS5mbG93aW5nPSExLHQmJnQuZW1pdChcInVucGlwZVwiLHRoaXMscikpLHRoaXM7aWYoIXQpe3ZhciBuPWUucGlwZXMsaT1lLnBpcGVzQ291bnQ7ZS5waXBlcz1udWxsLGUucGlwZXNDb3VudD0wLGUuZmxvd2luZz0hMTtmb3IodmFyIG89MDtvPGk7bysrKW5bb10uZW1pdChcInVucGlwZVwiLHRoaXMscik7cmV0dXJuIHRoaXN9dmFyIGE9QShlLnBpcGVzLHQpO3JldHVybi0xPT09YXx8KGUucGlwZXMuc3BsaWNlKGEsMSksZS5waXBlc0NvdW50LT0xLDE9PT1lLnBpcGVzQ291bnQmJihlLnBpcGVzPWUucGlwZXNbMF0pLHQuZW1pdChcInVucGlwZVwiLHRoaXMscikpLHRoaXN9LF8ucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dS5wcm90b3R5cGUub24uY2FsbCh0aGlzLHQsZSk7aWYoXCJkYXRhXCI9PT10KSExIT09dGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nJiZ0aGlzLnJlc3VtZSgpO2Vsc2UgaWYoXCJyZWFkYWJsZVwiPT09dCl7dmFyIG49dGhpcy5fcmVhZGFibGVTdGF0ZTtuLmVuZEVtaXR0ZWR8fG4ucmVhZGFibGVMaXN0ZW5pbmd8fChuLnJlYWRhYmxlTGlzdGVuaW5nPW4ubmVlZFJlYWRhYmxlPSEwLG4uZW1pdHRlZFJlYWRhYmxlPSExLG4ucmVhZGluZz9uLmxlbmd0aCYmayh0aGlzKTppLm5leHRUaWNrKFIsdGhpcykpfXJldHVybiByfSxfLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1fLnByb3RvdHlwZS5vbixfLnByb3RvdHlwZS5yZXN1bWU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9yZWFkYWJsZVN0YXRlO3JldHVybiB0LmZsb3dpbmd8fChwKFwicmVzdW1lXCIpLHQuZmxvd2luZz0hMCxmdW5jdGlvbih0LGUpe2UucmVzdW1lU2NoZWR1bGVkfHwoZS5yZXN1bWVTY2hlZHVsZWQ9ITAsaS5uZXh0VGljayhDLHQsZSkpfSh0aGlzLHQpKSx0aGlzfSxfLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbigpe3JldHVybiBwKFwiY2FsbCBwYXVzZSBmbG93aW5nPSVqXCIsdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSwhMSE9PXRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyYmKHAoXCJwYXVzZVwiKSx0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc9ITEsdGhpcy5lbWl0KFwicGF1c2VcIikpLHRoaXN9LF8ucHJvdG90eXBlLndyYXA9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXMuX3JlYWRhYmxlU3RhdGUsbj0hMTtmb3IodmFyIGkgaW4gdC5vbihcImVuZFwiLChmdW5jdGlvbigpe2lmKHAoXCJ3cmFwcGVkIGVuZFwiKSxyLmRlY29kZXImJiFyLmVuZGVkKXt2YXIgdD1yLmRlY29kZXIuZW5kKCk7dCYmdC5sZW5ndGgmJmUucHVzaCh0KX1lLnB1c2gobnVsbCl9KSksdC5vbihcImRhdGFcIiwoZnVuY3Rpb24oaSl7KHAoXCJ3cmFwcGVkIGRhdGFcIiksci5kZWNvZGVyJiYoaT1yLmRlY29kZXIud3JpdGUoaSkpLHIub2JqZWN0TW9kZSYmbnVsbD09aSl8fChyLm9iamVjdE1vZGV8fGkmJmkubGVuZ3RoKSYmKGUucHVzaChpKXx8KG49ITAsdC5wYXVzZSgpKSl9KSksdCl2b2lkIDA9PT10aGlzW2ldJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0W2ldJiYodGhpc1tpXT1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdFtlXS5hcHBseSh0LGFyZ3VtZW50cyl9fShpKSk7Zm9yKHZhciBvPTA7bzx5Lmxlbmd0aDtvKyspdC5vbih5W29dLHRoaXMuZW1pdC5iaW5kKHRoaXMseVtvXSkpO3JldHVybiB0aGlzLl9yZWFkPWZ1bmN0aW9uKGUpe3AoXCJ3cmFwcGVkIF9yZWFkXCIsZSksbiYmKG49ITEsdC5yZXN1bWUoKSl9LHRoaXN9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLnByb3RvdHlwZSxcInJlYWRhYmxlSGlnaFdhdGVyTWFya1wiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmt9fSksXy5fZnJvbUxpc3Q9T30pLmNhbGwodGhpcyxyKDIxKSxyKDM4KSl9LGZ1bmN0aW9uKHQsZSxyKXt0LmV4cG9ydHM9cig5MykuRXZlbnRFbWl0dGVyfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig1NSk7ZnVuY3Rpb24gaSh0LGUpe3QuZW1pdChcImVycm9yXCIsZSl9dC5leHBvcnRzPXtkZXN0cm95OmZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcyxvPXRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkLGE9dGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7cmV0dXJuIG98fGE/KGU/ZSh0KTohdHx8dGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWR8fG4ubmV4dFRpY2soaSx0aGlzLHQpLHRoaXMpOih0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ITApLHRoaXMuX3dyaXRhYmxlU3RhdGUmJih0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD0hMCksdGhpcy5fZGVzdHJveSh0fHxudWxsLChmdW5jdGlvbih0KXshZSYmdD8obi5uZXh0VGljayhpLHIsdCksci5fd3JpdGFibGVTdGF0ZSYmKHIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSEwKSk6ZSYmZSh0KX0pKSx0aGlzKX0sdW5kZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5fcmVhZGFibGVTdGF0ZSYmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPSExLHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZz0hMSx0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkPSExLHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZD0hMSksdGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPSExLHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQ9ITEsdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmc9ITEsdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZD0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD0hMSl9fX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNTYpLkJ1ZmZlcixpPW4uaXNFbmNvZGluZ3x8ZnVuY3Rpb24odCl7c3dpdGNoKCh0PVwiXCIrdCkmJnQudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpjYXNlXCJyYXdcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX07ZnVuY3Rpb24gbyh0KXt2YXIgZTtzd2l0Y2godGhpcy5lbmNvZGluZz1mdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbih0KXtpZighdClyZXR1cm5cInV0ZjhcIjtmb3IodmFyIGU7Oylzd2l0Y2godCl7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuXCJ1dGY4XCI7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuXCJ1dGYxNmxlXCI7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuXCJsYXRpbjFcIjtjYXNlXCJiYXNlNjRcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImhleFwiOnJldHVybiB0O2RlZmF1bHQ6aWYoZSlyZXR1cm47dD0oXCJcIit0KS50b0xvd2VyQ2FzZSgpLGU9ITB9fSh0KTtpZihcInN0cmluZ1wiIT10eXBlb2YgZSYmKG4uaXNFbmNvZGluZz09PWl8fCFpKHQpKSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIit0KTtyZXR1cm4gZXx8dH0odCksdGhpcy5lbmNvZGluZyl7Y2FzZVwidXRmMTZsZVwiOnRoaXMudGV4dD11LHRoaXMuZW5kPWMsZT00O2JyZWFrO2Nhc2VcInV0ZjhcIjp0aGlzLmZpbGxMYXN0PXMsZT00O2JyZWFrO2Nhc2VcImJhc2U2NFwiOnRoaXMudGV4dD1mLHRoaXMuZW5kPWwsZT0zO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIHRoaXMud3JpdGU9aCx2b2lkKHRoaXMuZW5kPXApfXRoaXMubGFzdE5lZWQ9MCx0aGlzLmxhc3RUb3RhbD0wLHRoaXMubGFzdENoYXI9bi5hbGxvY1Vuc2FmZShlKX1mdW5jdGlvbiBhKHQpe3JldHVybiB0PD0xMjc/MDp0Pj41PT02PzI6dD4+ND09MTQ/Mzp0Pj4zPT0zMD80OnQ+PjY9PTI/LTE6LTJ9ZnVuY3Rpb24gcyh0KXt2YXIgZT10aGlzLmxhc3RUb3RhbC10aGlzLmxhc3ROZWVkLHI9ZnVuY3Rpb24odCxlLHIpe2lmKDEyOCE9KDE5MiZlWzBdKSlyZXR1cm4gdC5sYXN0TmVlZD0wLFwi77+9XCI7aWYodC5sYXN0TmVlZD4xJiZlLmxlbmd0aD4xKXtpZigxMjghPSgxOTImZVsxXSkpcmV0dXJuIHQubGFzdE5lZWQ9MSxcIu+/vVwiO2lmKHQubGFzdE5lZWQ+MiYmZS5sZW5ndGg+MiYmMTI4IT0oMTkyJmVbMl0pKXJldHVybiB0Lmxhc3ROZWVkPTIsXCLvv71cIn19KHRoaXMsdCk7cmV0dXJuIHZvaWQgMCE9PXI/cjp0aGlzLmxhc3ROZWVkPD10Lmxlbmd0aD8odC5jb3B5KHRoaXMubGFzdENoYXIsZSwwLHRoaXMubGFzdE5lZWQpLHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywwLHRoaXMubGFzdFRvdGFsKSk6KHQuY29weSh0aGlzLmxhc3RDaGFyLGUsMCx0Lmxlbmd0aCksdm9pZCh0aGlzLmxhc3ROZWVkLT10Lmxlbmd0aCkpfWZ1bmN0aW9uIHUodCxlKXtpZigodC5sZW5ndGgtZSklMj09MCl7dmFyIHI9dC50b1N0cmluZyhcInV0ZjE2bGVcIixlKTtpZihyKXt2YXIgbj1yLmNoYXJDb2RlQXQoci5sZW5ndGgtMSk7aWYobj49NTUyOTYmJm48PTU2MzE5KXJldHVybiB0aGlzLmxhc3ROZWVkPTIsdGhpcy5sYXN0VG90YWw9NCx0aGlzLmxhc3RDaGFyWzBdPXRbdC5sZW5ndGgtMl0sdGhpcy5sYXN0Q2hhclsxXT10W3QubGVuZ3RoLTFdLHIuc2xpY2UoMCwtMSl9cmV0dXJuIHJ9cmV0dXJuIHRoaXMubGFzdE5lZWQ9MSx0aGlzLmxhc3RUb3RhbD0yLHRoaXMubGFzdENoYXJbMF09dFt0Lmxlbmd0aC0xXSx0LnRvU3RyaW5nKFwidXRmMTZsZVwiLGUsdC5sZW5ndGgtMSl9ZnVuY3Rpb24gYyh0KXt2YXIgZT10JiZ0Lmxlbmd0aD90aGlzLndyaXRlKHQpOlwiXCI7aWYodGhpcy5sYXN0TmVlZCl7dmFyIHI9dGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZDtyZXR1cm4gZSt0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKFwidXRmMTZsZVwiLDAscil9cmV0dXJuIGV9ZnVuY3Rpb24gZih0LGUpe3ZhciByPSh0Lmxlbmd0aC1lKSUzO3JldHVybiAwPT09cj90LnRvU3RyaW5nKFwiYmFzZTY0XCIsZSk6KHRoaXMubGFzdE5lZWQ9My1yLHRoaXMubGFzdFRvdGFsPTMsMT09PXI/dGhpcy5sYXN0Q2hhclswXT10W3QubGVuZ3RoLTFdOih0aGlzLmxhc3RDaGFyWzBdPXRbdC5sZW5ndGgtMl0sdGhpcy5sYXN0Q2hhclsxXT10W3QubGVuZ3RoLTFdKSx0LnRvU3RyaW5nKFwiYmFzZTY0XCIsZSx0Lmxlbmd0aC1yKSl9ZnVuY3Rpb24gbCh0KXt2YXIgZT10JiZ0Lmxlbmd0aD90aGlzLndyaXRlKHQpOlwiXCI7cmV0dXJuIHRoaXMubGFzdE5lZWQ/ZSt0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKFwiYmFzZTY0XCIsMCwzLXRoaXMubGFzdE5lZWQpOmV9ZnVuY3Rpb24gaCh0KXtyZXR1cm4gdC50b1N0cmluZyh0aGlzLmVuY29kaW5nKX1mdW5jdGlvbiBwKHQpe3JldHVybiB0JiZ0Lmxlbmd0aD90aGlzLndyaXRlKHQpOlwiXCJ9ZS5TdHJpbmdEZWNvZGVyPW8sby5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCl7aWYoMD09PXQubGVuZ3RoKXJldHVyblwiXCI7dmFyIGUscjtpZih0aGlzLmxhc3ROZWVkKXtpZih2b2lkIDA9PT0oZT10aGlzLmZpbGxMYXN0KHQpKSlyZXR1cm5cIlwiO3I9dGhpcy5sYXN0TmVlZCx0aGlzLmxhc3ROZWVkPTB9ZWxzZSByPTA7cmV0dXJuIHI8dC5sZW5ndGg/ZT9lK3RoaXMudGV4dCh0LHIpOnRoaXMudGV4dCh0LHIpOmV8fFwiXCJ9LG8ucHJvdG90eXBlLmVuZD1mdW5jdGlvbih0KXt2YXIgZT10JiZ0Lmxlbmd0aD90aGlzLndyaXRlKHQpOlwiXCI7cmV0dXJuIHRoaXMubGFzdE5lZWQ/ZStcIu+/vVwiOmV9LG8ucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1mdW5jdGlvbih0LGUscil7dmFyIG49ZS5sZW5ndGgtMTtpZihuPHIpcmV0dXJuIDA7dmFyIGk9YShlW25dKTtpZihpPj0wKXJldHVybiBpPjAmJih0Lmxhc3ROZWVkPWktMSksaTtpZigtLW48cnx8LTI9PT1pKXJldHVybiAwO2lmKChpPWEoZVtuXSkpPj0wKXJldHVybiBpPjAmJih0Lmxhc3ROZWVkPWktMiksaTtpZigtLW48cnx8LTI9PT1pKXJldHVybiAwO2lmKChpPWEoZVtuXSkpPj0wKXJldHVybiBpPjAmJigyPT09aT9pPTA6dC5sYXN0TmVlZD1pLTMpLGk7cmV0dXJuIDB9KHRoaXMsdCxlKTtpZighdGhpcy5sYXN0TmVlZClyZXR1cm4gdC50b1N0cmluZyhcInV0ZjhcIixlKTt0aGlzLmxhc3RUb3RhbD1yO3ZhciBuPXQubGVuZ3RoLShyLXRoaXMubGFzdE5lZWQpO3JldHVybiB0LmNvcHkodGhpcy5sYXN0Q2hhciwwLG4pLHQudG9TdHJpbmcoXCJ1dGY4XCIsZSxuKX0sby5wcm90b3R5cGUuZmlsbExhc3Q9ZnVuY3Rpb24odCl7aWYodGhpcy5sYXN0TmVlZDw9dC5sZW5ndGgpcmV0dXJuIHQuY29weSh0aGlzLmxhc3RDaGFyLHRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQsMCx0aGlzLmxhc3ROZWVkKSx0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsMCx0aGlzLmxhc3RUb3RhbCk7dC5jb3B5KHRoaXMubGFzdENoYXIsdGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZCwwLHQubGVuZ3RoKSx0aGlzLmxhc3ROZWVkLT10Lmxlbmd0aH19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9YTt2YXIgbj1yKDIzKSxpPXIoMzkpO2Z1bmN0aW9uIG8odCxlKXt2YXIgcj10aGlzLl90cmFuc2Zvcm1TdGF0ZTtyLnRyYW5zZm9ybWluZz0hMTt2YXIgbj1yLndyaXRlY2I7aWYoIW4pcmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsbmV3IEVycm9yKFwid3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzXCIpKTtyLndyaXRlY2h1bms9bnVsbCxyLndyaXRlY2I9bnVsbCxudWxsIT1lJiZ0aGlzLnB1c2goZSksbih0KTt2YXIgaT10aGlzLl9yZWFkYWJsZVN0YXRlO2kucmVhZGluZz0hMSwoaS5uZWVkUmVhZGFibGV8fGkubGVuZ3RoPGkuaGlnaFdhdGVyTWFyaykmJnRoaXMuX3JlYWQoaS5oaWdoV2F0ZXJNYXJrKX1mdW5jdGlvbiBhKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGEpKXJldHVybiBuZXcgYSh0KTtuLmNhbGwodGhpcyx0KSx0aGlzLl90cmFuc2Zvcm1TdGF0ZT17YWZ0ZXJUcmFuc2Zvcm06by5iaW5kKHRoaXMpLG5lZWRUcmFuc2Zvcm06ITEsdHJhbnNmb3JtaW5nOiExLHdyaXRlY2I6bnVsbCx3cml0ZWNodW5rOm51bGwsd3JpdGVlbmNvZGluZzpudWxsfSx0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZT0hMCx0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmM9ITEsdCYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudHJhbnNmb3JtJiYodGhpcy5fdHJhbnNmb3JtPXQudHJhbnNmb3JtKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmZsdXNoJiYodGhpcy5fZmx1c2g9dC5mbHVzaCkpLHRoaXMub24oXCJwcmVmaW5pc2hcIixzKX1mdW5jdGlvbiBzKCl7dmFyIHQ9dGhpcztcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLl9mbHVzaD90aGlzLl9mbHVzaCgoZnVuY3Rpb24oZSxyKXt1KHQsZSxyKX0pKTp1KHRoaXMsbnVsbCxudWxsKX1mdW5jdGlvbiB1KHQsZSxyKXtpZihlKXJldHVybiB0LmVtaXQoXCJlcnJvclwiLGUpO2lmKG51bGwhPXImJnQucHVzaChyKSx0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDBcIik7aWYodC5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKXRocm93IG5ldyBFcnJvcihcIkNhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmdcIik7cmV0dXJuIHQucHVzaChudWxsKX1pLmluaGVyaXRzPXIoMjkpLGkuaW5oZXJpdHMoYSxuKSxhLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm09ITEsbi5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsdCxlKX0sYS5wcm90b3R5cGUuX3RyYW5zZm9ybT1mdW5jdGlvbih0LGUscil7dGhyb3cgbmV3IEVycm9yKFwiX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX0sYS5wcm90b3R5cGUuX3dyaXRlPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj10aGlzLl90cmFuc2Zvcm1TdGF0ZTtpZihuLndyaXRlY2I9cixuLndyaXRlY2h1bms9dCxuLndyaXRlZW5jb2Rpbmc9ZSwhbi50cmFuc2Zvcm1pbmcpe3ZhciBpPXRoaXMuX3JlYWRhYmxlU3RhdGU7KG4ubmVlZFRyYW5zZm9ybXx8aS5uZWVkUmVhZGFibGV8fGkubGVuZ3RoPGkuaGlnaFdhdGVyTWFyaykmJnRoaXMuX3JlYWQoaS5oaWdoV2F0ZXJNYXJrKX19LGEucHJvdG90eXBlLl9yZWFkPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3RyYW5zZm9ybVN0YXRlO251bGwhPT1lLndyaXRlY2h1bmsmJmUud3JpdGVjYiYmIWUudHJhbnNmb3JtaW5nPyhlLnRyYW5zZm9ybWluZz0hMCx0aGlzLl90cmFuc2Zvcm0oZS53cml0ZWNodW5rLGUud3JpdGVlbmNvZGluZyxlLmFmdGVyVHJhbnNmb3JtKSk6ZS5uZWVkVHJhbnNmb3JtPSEwfSxhLnByb3RvdHlwZS5fZGVzdHJveT1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXM7bi5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLHQsKGZ1bmN0aW9uKHQpe2UodCksci5lbWl0KFwiY2xvc2VcIil9KSl9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1yLHR9fSxmdW5jdGlvbih0LGUpe2NvbnN0IHI9e2FjbDpcImh0dHA6Ly93d3cudzMub3JnL25zL2F1dGgvYWNsI1wiLGFyZzpcImh0dHA6Ly93d3cudzMub3JnL25zL3BpbS9hcmcjXCIsY2FsOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMi8xMi9jYWwvaWNhbCNcIixjb250YWN0OlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC8xMC9zd2FwL3BpbS9jb250YWN0I1wiLGRjOlwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cIixkY3Q6XCJodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvXCIsZG9hcDpcImh0dHA6Ly91c2VmdWxpbmMuY29tL25zL2RvYXAjXCIsZm9hZjpcImh0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvXCIsaHR0cDpcImh0dHA6Ly93d3cudzMub3JnLzIwMDcvb250L2h0dHAjXCIsaHR0cGg6XCJodHRwOi8vd3d3LnczLm9yZy8yMDA3L29udC9odHRwaCNcIixpY2FsVFo6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAyLzEyL2NhbC9pY2FsdHpkI1wiLGxkcDpcImh0dHA6Ly93d3cudzMub3JnL25zL2xkcCNcIixsaW5rOlwiaHR0cDovL3d3dy53My5vcmcvMjAwNy9vbnQvbGluayNcIixsb2c6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzEwL3N3YXAvbG9nI1wiLG1lZXRpbmc6XCJodHRwOi8vd3d3LnczLm9yZy9ucy9waW0vbWVldGluZyNcIixtbzpcImh0dHA6Ly9wdXJsLm9yZy9vbnRvbG9neS9tby9cIixvd2w6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAyLzA3L293bCNcIixwYWQ6XCJodHRwOi8vd3d3LnczLm9yZy9ucy9waW0vcGFkI1wiLHBhdGNoOlwiaHR0cDovL3d3dy53My5vcmcvbnMvcGltL3BhdGNoI1wiLHF1OlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC8xMC9zd2FwL3BpbS9xaWYjXCIsdHJpcDpcImh0dHA6Ly93d3cudzMub3JnL25zL3BpbS90cmlwI1wiLHJkZjpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIixyZGZzOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC8wMS9yZGYtc2NoZW1hI1wiLHJzczpcImh0dHA6Ly9wdXJsLm9yZy9yc3MvMS4wL1wiLHNjaGVkOlwiaHR0cDovL3d3dy53My5vcmcvbnMvcGltL3NjaGVkdWxlI1wiLHNjaGVtYTpcImh0dHA6L3NjaGVtYS5vcmcvXCIsc2lvYzpcImh0dHA6Ly9yZGZzLm9yZy9zaW9jL25zI1wiLHNvbGlkOlwiaHR0cDovL3d3dy53My5vcmcvbnMvc29saWQvdGVybXMjXCIsc3BhY2U6XCJodHRwOi8vd3d3LnczLm9yZy9ucy9waW0vc3BhY2UjXCIsc3RhdDpcImh0dHA6Ly93d3cudzMub3JnL25zL3Bvc2l4L3N0YXQjXCIsdGFiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwNy9vbnQvbGluayNcIix0YWJvbnQ6XCJodHRwOi8vd3d3LnczLm9yZy8yMDA3L29udC9saW5rI1wiLHVpOlwiaHR0cDovL3d3dy53My5vcmcvbnMvdWkjXCIsdmNhcmQ6XCJodHRwOi8vd3d3LnczLm9yZy8yMDA2L3ZjYXJkL25zI1wiLHdmOlwiaHR0cDovL3d3dy53My5vcmcvMjAwNS8wMS93Zi9mbG93I1wiLHhzZDpcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI1wifTt0LmV4cG9ydHM9ZnVuY3Rpb24odD17bmFtZWROb2RlOnQ9PnR9KXtjb25zdCBlPXt9O2Zvcihjb25zdCBuIGluIHIpe2NvbnN0IGk9cltuXTtlW25dPWZ1bmN0aW9uKGU9XCJcIil7cmV0dXJuIHQubmFtZWROb2RlKGkrZSl9fXJldHVybiBlfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbih0LG4pe3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBofSkpO3ZhciBpPXIoNik7Y29uc3R7eHNkOm99PWkuYSx7ZnJvbUNoYXJDb2RlOmF9PVN0cmluZzt2YXIgcz0vXFxcXHUoW2EtZkEtRjAtOV17NH0pfFxcXFxVKFthLWZBLUYwLTldezh9KXxcXFxcW3VVXXxcXFxcKC4pL2csdT17XCJcXFxcXCI6XCJcXFxcXCIsXCInXCI6XCInXCIsJ1wiJzonXCInLG46XCJcXG5cIixyOlwiXFxyXCIsdDpcIlxcdFwiLGY6XCJcXGZcIixiOlwiXFxiXCIsXzpcIl9cIixcIn5cIjpcIn5cIixcIi5cIjpcIi5cIixcIi1cIjpcIi1cIixcIiFcIjpcIiFcIiwkOlwiJFwiLFwiJlwiOlwiJlwiLFwiKFwiOlwiKFwiLFwiKVwiOlwiKVwiLFwiKlwiOlwiKlwiLFwiK1wiOlwiK1wiLFwiLFwiOlwiLFwiLFwiO1wiOlwiO1wiLFwiPVwiOlwiPVwiLFwiL1wiOlwiL1wiLFwiP1wiOlwiP1wiLFwiI1wiOlwiI1wiLFwiQFwiOlwiQFwiLFwiJVwiOlwiJVwifSxjPS9bXFx4MDAtXFx4MjA8PlxcXFxcIlxce1xcfVxcfFxcXlxcYF0vLGY9e19pcmk6ITAsX3VuZXNjYXBlZElyaTohMCxfc2ltcGxlUXVvdGVkU3RyaW5nOiEwLF9sYW5nY29kZTohMCxfYmxhbms6ITAsX25ld2xpbmU6ITAsX2NvbW1lbnQ6ITAsX3doaXRlc3BhY2U6ITAsX2VuZE9mRmlsZTohMH0sbD0vJDBeLztjbGFzcyBoe2NvbnN0cnVjdG9yKHQpe2lmKHRoaXMuX2lyaT0vXjwoKD86W14gPD57fVxcXFxdfFxcXFxbdVVdKSspPlsgXFx0XSovLHRoaXMuX3VuZXNjYXBlZElyaT0vXjwoW15cXHgwMC1cXHgyMDw+XFxcXFwiXFx7XFx9XFx8XFxeXFxgXSopPlsgXFx0XSovLHRoaXMuX3NpbXBsZVF1b3RlZFN0cmluZz0vXlwiKFteXCJcXFxcXFxyXFxuXSopXCIoPz1bXlwiXSkvLHRoaXMuX3NpbXBsZUFwb3N0cm9waGVTdHJpbmc9L14nKFteJ1xcXFxcXHJcXG5dKiknKD89W14nXSkvLHRoaXMuX2xhbmdjb2RlPS9eQChbYS16XSsoPzotW2EtejAtOV0rKSopKD89W15hLXowLTlcXC1dKS9pLHRoaXMuX3ByZWZpeD0vXigoPzpbQS1aYS16XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkoPzpcXC4/W1xcLTAtOUEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKT86KD89WyNcXHM8XSkvLHRoaXMuX3ByZWZpeGVkPS9eKCg/OltBLVphLXpcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSg/OlxcLj9bXFwtMC05QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSopPzooKD86KD86WzAtOkEtWl9hLXpcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdfCVbMC05YS1mQS1GXXsyfXxcXFxcWyEjLVxcLzs9P1xcLUBffl0pKD86KD86W1xcLlxcLTAtOkEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXXwlWzAtOWEtZkEtRl17Mn18XFxcXFshIy1cXC87PT9cXC1AX35dKSooPzpbXFwtMC06QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdfCVbMC05YS1mQS1GXXsyfXxcXFxcWyEjLVxcLzs9P1xcLUBffl0pKT8pPykoPzpbIFxcdF0rfCg/PVxcLj9bLDshXFxeXFxzIygpXFxbXFxdXFx7XFx9XCInPF0pKS8sdGhpcy5fdmFyaWFibGU9L15cXD8oPzooPzpbQS1aX2EtelxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmZmXFx1MDM3MC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl0pKD86W1xcLTAtOkEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKSg/PVsuLDshXFxeXFxzIygpXFxbXFxdXFx7XFx9XCInPF0pLyx0aGlzLl9ibGFuaz0vXl86KCg/OlswLTlBLVpfYS16XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkoPzpcXC4/W1xcLTAtOUEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKSg/OlsgXFx0XSt8KD89XFwuP1ssOzpcXHMjKClcXFtcXF1cXHtcXH1cIic8XSkpLyx0aGlzLl9udW1iZXI9L15bXFwtK10/KD86XFxkK1xcLj9cXGQqKFtlRV0oPzpbXFwtXFwrXSk/XFxkKyl8XFxkKlxcLj9cXGQrKSg/PVxcLj9bLDs6XFxzIygpXFxbXFxdXFx7XFx9XCInPF0pLyx0aGlzLl9ib29sZWFuPS9eKD86dHJ1ZXxmYWxzZSkoPz1bLiw7XFxzIygpXFxbXFxdXFx7XFx9XCInPF0pLyx0aGlzLl9rZXl3b3JkPS9eQFthLXpdKyg/PVtcXHMjPDpdKS9pLHRoaXMuX3NwYXJxbEtleXdvcmQ9L14oPzpQUkVGSVh8QkFTRXxHUkFQSCkoPz1bXFxzIzxdKS9pLHRoaXMuX3Nob3J0UHJlZGljYXRlcz0vXmEoPz1bXFxzKClcXFtcXF1cXHtcXH1cIic8XSkvLHRoaXMuX25ld2xpbmU9L15bIFxcdF0qKD86I1teXFxuXFxyXSopPyg/OlxcclxcbnxcXG58XFxyKVsgXFx0XSovLHRoaXMuX2NvbW1lbnQ9LyMoW15cXG5cXHJdKikvLHRoaXMuX3doaXRlc3BhY2U9L15bIFxcdF0rLyx0aGlzLl9lbmRPZkZpbGU9L14oPzojW15cXG5cXHJdKik/JC8sdD10fHx7fSx0aGlzLl9saW5lTW9kZT0hIXQubGluZU1vZGUpZm9yKHZhciBlIGluIHRoaXMuX24zTW9kZT0hMSx0aGlzKSEoZSBpbiBmKSYmdGhpc1tlXWluc3RhbmNlb2YgUmVnRXhwJiYodGhpc1tlXT1sKTtlbHNlIHRoaXMuX24zTW9kZT0hMSE9PXQubjM7dGhpcy5fY29tbWVudHM9ISF0LmNvbW1lbnRzLHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zPTB9X3Rva2VuaXplVG9FbmQodCxlKXtmb3IodmFyIHI9dGhpcy5faW5wdXQsbj10aGlzLl9jb21tZW50czs7KXtmb3IodmFyIGksYTtpPXRoaXMuX25ld2xpbmUuZXhlYyhyKTspbiYmKGE9dGhpcy5fY29tbWVudC5leGVjKGlbMF0pKSYmdChudWxsLHtsaW5lOnRoaXMuX2xpbmUsdHlwZTpcImNvbW1lbnRcIix2YWx1ZTphWzFdLHByZWZpeDpcIlwifSkscj1yLnN1YnN0cihpWzBdLmxlbmd0aCxyLmxlbmd0aCksdGhpcy5fbGluZSsrO2lmKCFpJiYoaT10aGlzLl93aGl0ZXNwYWNlLmV4ZWMocikpJiYocj1yLnN1YnN0cihpWzBdLmxlbmd0aCxyLmxlbmd0aCkpLHRoaXMuX2VuZE9mRmlsZS50ZXN0KHIpKXJldHVybiBlJiYobiYmKGE9dGhpcy5fY29tbWVudC5leGVjKHIpKSYmdChudWxsLHtsaW5lOnRoaXMuX2xpbmUsdHlwZTpcImNvbW1lbnRcIix2YWx1ZTphWzFdLHByZWZpeDpcIlwifSksdChyPW51bGwse2xpbmU6dGhpcy5fbGluZSx0eXBlOlwiZW9mXCIsdmFsdWU6XCJcIixwcmVmaXg6XCJcIn0pKSx0aGlzLl9pbnB1dD1yO3ZhciBzPXRoaXMuX2xpbmUsdT1cIlwiLGY9XCJcIixsPVwiXCIsaD1yWzBdLHA9bnVsbCxkPTAsdj0hMTtzd2l0Y2goaCl7Y2FzZVwiXlwiOmlmKHIubGVuZ3RoPDMpYnJlYWs7aWYoXCJeXCIhPT1yWzFdKXt0aGlzLl9uM01vZGUmJihkPTEsdT1cIl5cIik7YnJlYWt9aWYodGhpcy5fcHJldmlvdXNNYXJrZXI9XCJeXlwiLFwiPFwiIT09KHI9ci5zdWJzdHIoMikpWzBdKXt2PSEwO2JyZWFrfWNhc2VcIjxcIjppZihwPXRoaXMuX3VuZXNjYXBlZElyaS5leGVjKHIpKXU9XCJJUklcIixmPXBbMV07ZWxzZSBpZihwPXRoaXMuX2lyaS5leGVjKHIpKXtpZihudWxsPT09KGY9dGhpcy5fdW5lc2NhcGUocFsxXSkpfHxjLnRlc3QoZikpcmV0dXJuIHkodGhpcyk7dT1cIklSSVwifWVsc2UgdGhpcy5fbjNNb2RlJiZyLmxlbmd0aD4xJiZcIj1cIj09PXJbMV0mJih1PVwiaW52ZXJzZVwiLGQ9MixmPVwiPlwiKTticmVhaztjYXNlXCJfXCI6KChwPXRoaXMuX2JsYW5rLmV4ZWMocikpfHxlJiYocD10aGlzLl9ibGFuay5leGVjKHIrXCIgXCIpKSkmJih1PVwiYmxhbmtcIixsPVwiX1wiLGY9cFsxXSk7YnJlYWs7Y2FzZSdcIic6aWYocD10aGlzLl9zaW1wbGVRdW90ZWRTdHJpbmcuZXhlYyhyKSlmPXBbMV07ZWxzZSBpZigoe3ZhbHVlOmYsbWF0Y2hMZW5ndGg6ZH09dGhpcy5fcGFyc2VMaXRlcmFsKHIpKSxudWxsPT09ZilyZXR1cm4geSh0aGlzKTtudWxsPT09cCYmMD09PWR8fCh1PVwibGl0ZXJhbFwiLHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zPTApO2JyZWFrO2Nhc2VcIidcIjppZighdGhpcy5fbGluZU1vZGUpe2lmKHA9dGhpcy5fc2ltcGxlQXBvc3Ryb3BoZVN0cmluZy5leGVjKHIpKWY9cFsxXTtlbHNlIGlmKCh7dmFsdWU6ZixtYXRjaExlbmd0aDpkfT10aGlzLl9wYXJzZUxpdGVyYWwocikpLG51bGw9PT1mKXJldHVybiB5KHRoaXMpO251bGw9PT1wJiYwPT09ZHx8KHU9XCJsaXRlcmFsXCIsdGhpcy5fbGl0ZXJhbENsb3NpbmdQb3M9MCl9YnJlYWs7Y2FzZVwiP1wiOnRoaXMuX24zTW9kZSYmKHA9dGhpcy5fdmFyaWFibGUuZXhlYyhyKSkmJih1PVwidmFyXCIsZj1wWzBdKTticmVhaztjYXNlXCJAXCI6XCJsaXRlcmFsXCI9PT10aGlzLl9wcmV2aW91c01hcmtlciYmKHA9dGhpcy5fbGFuZ2NvZGUuZXhlYyhyKSk/KHU9XCJsYW5nY29kZVwiLGY9cFsxXSk6KHA9dGhpcy5fa2V5d29yZC5leGVjKHIpKSYmKHU9cFswXSk7YnJlYWs7Y2FzZVwiLlwiOmlmKDE9PT1yLmxlbmd0aD9lOnJbMV08XCIwXCJ8fHJbMV0+XCI5XCIpe3U9XCIuXCIsZD0xO2JyZWFrfWNhc2VcIjBcIjpjYXNlXCIxXCI6Y2FzZVwiMlwiOmNhc2VcIjNcIjpjYXNlXCI0XCI6Y2FzZVwiNVwiOmNhc2VcIjZcIjpjYXNlXCI3XCI6Y2FzZVwiOFwiOmNhc2VcIjlcIjpjYXNlXCIrXCI6Y2FzZVwiLVwiOihwPXRoaXMuX251bWJlci5leGVjKHIpfHxlJiYocD10aGlzLl9udW1iZXIuZXhlYyhyK1wiIFwiKSkpJiYodT1cImxpdGVyYWxcIixmPXBbMF0sbD1wWzFdP28uZG91YmxlOi9eWytcXC1dP1xcZCskLy50ZXN0KHBbMF0pP28uaW50ZWdlcjpvLmRlY2ltYWwpO2JyZWFrO2Nhc2VcIkJcIjpjYXNlXCJiXCI6Y2FzZVwicFwiOmNhc2VcIlBcIjpjYXNlXCJHXCI6Y2FzZVwiZ1wiOihwPXRoaXMuX3NwYXJxbEtleXdvcmQuZXhlYyhyKSk/dT1wWzBdLnRvVXBwZXJDYXNlKCk6dj0hMDticmVhaztjYXNlXCJmXCI6Y2FzZVwidFwiOihwPXRoaXMuX2Jvb2xlYW4uZXhlYyhyKSk/KHU9XCJsaXRlcmFsXCIsZj1wWzBdLGw9by5ib29sZWFuKTp2PSEwO2JyZWFrO2Nhc2VcImFcIjoocD10aGlzLl9zaG9ydFByZWRpY2F0ZXMuZXhlYyhyKSk/KHU9XCJhYmJyZXZpYXRpb25cIixmPVwiYVwiKTp2PSEwO2JyZWFrO2Nhc2VcIj1cIjp0aGlzLl9uM01vZGUmJnIubGVuZ3RoPjEmJih1PVwiYWJicmV2aWF0aW9uXCIsXCI+XCIhPT1yWzFdPyhkPTEsZj1cIj1cIik6KGQ9MixmPVwiPlwiKSk7YnJlYWs7Y2FzZVwiIVwiOmlmKCF0aGlzLl9uM01vZGUpYnJlYWs7Y2FzZVwiLFwiOmNhc2VcIjtcIjpjYXNlXCJbXCI6Y2FzZVwiXVwiOmNhc2VcIihcIjpjYXNlXCIpXCI6Y2FzZVwie1wiOmNhc2VcIn1cIjp0aGlzLl9saW5lTW9kZXx8KGQ9MSx1PWgpO2JyZWFrO2RlZmF1bHQ6dj0hMH1pZih2JiYoXCJAcHJlZml4XCIhPT10aGlzLl9wcmV2aW91c01hcmtlciYmXCJQUkVGSVhcIiE9PXRoaXMuX3ByZXZpb3VzTWFya2VyfHwhKHA9dGhpcy5fcHJlZml4LmV4ZWMocikpPygocD10aGlzLl9wcmVmaXhlZC5leGVjKHIpKXx8ZSYmKHA9dGhpcy5fcHJlZml4ZWQuZXhlYyhyK1wiIFwiKSkpJiYodT1cInByZWZpeGVkXCIsbD1wWzFdfHxcIlwiLGY9dGhpcy5fdW5lc2NhcGUocFsyXSkpOih1PVwicHJlZml4XCIsZj1wWzFdfHxcIlwiKSksXCJeXlwiPT09dGhpcy5fcHJldmlvdXNNYXJrZXIpc3dpdGNoKHUpe2Nhc2VcInByZWZpeGVkXCI6dT1cInR5cGVcIjticmVhaztjYXNlXCJJUklcIjp1PVwidHlwZUlSSVwiO2JyZWFrO2RlZmF1bHQ6dT1cIlwifWlmKCF1KXJldHVybiBlfHwhL14nJyd8XlwiXCJcIi8udGVzdChyKSYmL1xcbnxcXHIvLnRlc3Qocik/eSh0aGlzKTp0aGlzLl9pbnB1dD1yO3ZhciBnPXtsaW5lOnMsdHlwZTp1LHZhbHVlOmYscHJlZml4Omx9O3QobnVsbCxnKSx0aGlzLnByZXZpb3VzVG9rZW49Zyx0aGlzLl9wcmV2aW91c01hcmtlcj11LHI9ci5zdWJzdHIoZHx8cFswXS5sZW5ndGgsci5sZW5ndGgpfWZ1bmN0aW9uIHkoZSl7dChlLl9zeW50YXhFcnJvcigvXlxcUyovLmV4ZWMocilbMF0pKX19X3VuZXNjYXBlKHQpe3RyeXtyZXR1cm4gdC5yZXBsYWNlKHMsKGZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBpO2lmKGUpe2lmKGk9cGFyc2VJbnQoZSwxNiksaXNOYU4oaSkpdGhyb3cgbmV3IEVycm9yO3JldHVybiBhKGkpfWlmKHIpe2lmKGk9cGFyc2VJbnQociwxNiksaXNOYU4oaSkpdGhyb3cgbmV3IEVycm9yO3JldHVybiBpPD02NTUzNT9hKGkpOmEoNTUyOTYrKGktPTY1NTM2KS8xMDI0LDU2MzIwKygxMDIzJmkpKX12YXIgbz11W25dO2lmKCFvKXRocm93IG5ldyBFcnJvcjtyZXR1cm4gb30pKX1jYXRjaCh0KXtyZXR1cm4gbnVsbH19X3BhcnNlTGl0ZXJhbCh0KXtpZih0Lmxlbmd0aD49Myl7Y29uc3QgZT10Lm1hdGNoKC9eKD86XCJcIlwifFwifCcnJ3wnfCkvKVswXSxyPWUubGVuZ3RoO2xldCBuPU1hdGgubWF4KHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zLHIpO2Zvcig7KG49dC5pbmRleE9mKGUsbikpPjA7KXtsZXQgZT0wO2Zvcig7XCJcXFxcXCI9PT10W24tZS0xXTspZSsrO2lmKGUlMj09MCl7Y29uc3QgZT10LnN1YnN0cmluZyhyLG4pLGk9ZS5zcGxpdCgvXFxyXFxufFxccnxcXG4vKS5sZW5ndGgtMSxvPW4rcjtpZigxPT09ciYmMCE9PWl8fDM9PT1yJiZ0aGlzLl9saW5lTW9kZSlicmVhaztyZXR1cm4gdGhpcy5fbGluZSs9aSx7dmFsdWU6dGhpcy5fdW5lc2NhcGUoZSksbWF0Y2hMZW5ndGg6b319bisrfXRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zPXQubGVuZ3RoLXIrMX1yZXR1cm57dmFsdWU6XCJcIixtYXRjaExlbmd0aDowfX1fc3ludGF4RXJyb3IodCl7dGhpcy5faW5wdXQ9bnVsbDt2YXIgZT1uZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgXCInK3QrJ1wiIG9uIGxpbmUgJyt0aGlzLl9saW5lK1wiLlwiKTtyZXR1cm4gZS5jb250ZXh0PXt0b2tlbjp2b2lkIDAsbGluZTp0aGlzLl9saW5lLHByZXZpb3VzVG9rZW46dGhpcy5wcmV2aW91c1Rva2VufSxlfXRva2VuaXplKGUscil7dmFyIGk9dGhpcztpZih0aGlzLl9saW5lPTEsXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKHRoaXMuX2lucHV0PWUsXCJmdW5jdGlvblwiIT10eXBlb2Ygcil7dmFyIG8sYT1bXTtpZih0aGlzLl90b2tlbml6ZVRvRW5kKChmdW5jdGlvbih0LGUpe3Q/bz10OmEucHVzaChlKX0pLCEwKSxvKXRocm93IG87cmV0dXJuIGF9dCgoZnVuY3Rpb24oKXtpLl90b2tlbml6ZVRvRW5kKHIsITApfSkpfWVsc2UgdGhpcy5faW5wdXQ9XCJcIix0aGlzLl9wZW5kaW5nQnVmZmVyPW51bGwsXCJmdW5jdGlvblwiPT10eXBlb2YgZS5zZXRFbmNvZGluZyYmZS5zZXRFbmNvZGluZyhcInV0ZjhcIiksZS5vbihcImRhdGFcIiwoZnVuY3Rpb24odCl7bnVsbCE9PWkuX2lucHV0JiYwIT09dC5sZW5ndGgmJihpLl9wZW5kaW5nQnVmZmVyJiYodD1uLmNvbmNhdChbaS5fcGVuZGluZ0J1ZmZlcix0XSksaS5fcGVuZGluZ0J1ZmZlcj1udWxsKSwxMjgmdFt0Lmxlbmd0aC0xXT9pLl9wZW5kaW5nQnVmZmVyPXQ6KGkuX2lucHV0Kz10LGkuX3Rva2VuaXplVG9FbmQociwhMSkpKX0pKSxlLm9uKFwiZW5kXCIsKGZ1bmN0aW9uKCl7bnVsbCE9PWkuX2lucHV0JiZpLl90b2tlbml6ZVRvRW5kKHIsITApfSkpLGUub24oXCJlcnJvclwiLHIpfX19KS5jYWxsKHRoaXMscigxMzYpLnNldEltbWVkaWF0ZSxyKDkyKS5CdWZmZXIpfSxmdW5jdGlvbih0LGUscil7dC5leHBvcnRzPWk7dmFyIG49cig5MykuRXZlbnRFbWl0dGVyO2Z1bmN0aW9uIGkoKXtuLmNhbGwodGhpcyl9cigyOSkoaSxuKSxpLlJlYWRhYmxlPXIoOTQpLGkuV3JpdGFibGU9cigxOTcpLGkuRHVwbGV4PXIoMTk4KSxpLlRyYW5zZm9ybT1yKDE5OSksaS5QYXNzVGhyb3VnaD1yKDIwMCksaS5TdHJlYW09aSxpLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcztmdW5jdGlvbiBpKGUpe3Qud3JpdGFibGUmJiExPT09dC53cml0ZShlKSYmci5wYXVzZSYmci5wYXVzZSgpfWZ1bmN0aW9uIG8oKXtyLnJlYWRhYmxlJiZyLnJlc3VtZSYmci5yZXN1bWUoKX1yLm9uKFwiZGF0YVwiLGkpLHQub24oXCJkcmFpblwiLG8pLHQuX2lzU3RkaW98fGUmJiExPT09ZS5lbmR8fChyLm9uKFwiZW5kXCIscyksci5vbihcImNsb3NlXCIsdSkpO3ZhciBhPSExO2Z1bmN0aW9uIHMoKXthfHwoYT0hMCx0LmVuZCgpKX1mdW5jdGlvbiB1KCl7YXx8KGE9ITAsXCJmdW5jdGlvblwiPT10eXBlb2YgdC5kZXN0cm95JiZ0LmRlc3Ryb3koKSl9ZnVuY3Rpb24gYyh0KXtpZihmKCksMD09PW4ubGlzdGVuZXJDb3VudCh0aGlzLFwiZXJyb3JcIikpdGhyb3cgdH1mdW5jdGlvbiBmKCl7ci5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIixpKSx0LnJlbW92ZUxpc3RlbmVyKFwiZHJhaW5cIixvKSxyLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIscyksci5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsdSksci5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsYyksdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsYyksci5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLGYpLHIucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGYpLHQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGYpfXJldHVybiByLm9uKFwiZXJyb3JcIixjKSx0Lm9uKFwiZXJyb3JcIixjKSxyLm9uKFwiZW5kXCIsZiksci5vbihcImNsb3NlXCIsZiksdC5vbihcImNsb3NlXCIsZiksdC5lbWl0KFwicGlwZVwiLHIpLHR9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig0KSxpPXIoNjMpLG89bi5XZWFrTWFwO3QuZXhwb3J0cz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBvJiYvbmF0aXZlIGNvZGUvLnRlc3QoaShvKSl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEyKSxpPXIoNDYpLmYsbz17fS50b1N0cmluZyxhPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXTt0LmV4cG9ydHMuZj1mdW5jdGlvbih0KXtyZXR1cm4gYSYmXCJbb2JqZWN0IFdpbmRvd11cIj09by5jYWxsKHQpP2Z1bmN0aW9uKHQpe3RyeXtyZXR1cm4gaSh0KX1jYXRjaCh0KXtyZXR1cm4gYS5zbGljZSgpfX0odCk6aShuKHQpKX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDIpLGk9cig3KSxvPXIoNCksYT1yKDEzKSxzPXIoMTApLHU9cigxMSkuZixjPXIoMTAxKSxmPW8uU3ltYm9sO2lmKGkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGYmJighKFwiZGVzY3JpcHRpb25cImluIGYucHJvdG90eXBlKXx8dm9pZCAwIT09ZigpLmRlc2NyaXB0aW9uKSl7dmFyIGw9e30saD1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg8MXx8dm9pZCAwPT09YXJndW1lbnRzWzBdP3ZvaWQgMDpTdHJpbmcoYXJndW1lbnRzWzBdKSxlPXRoaXMgaW5zdGFuY2VvZiBoP25ldyBmKHQpOnZvaWQgMD09PXQ/ZigpOmYodCk7cmV0dXJuXCJcIj09PXQmJihsW2VdPSEwKSxlfTtjKGgsZik7dmFyIHA9aC5wcm90b3R5cGU9Zi5wcm90b3R5cGU7cC5jb25zdHJ1Y3Rvcj1oO3ZhciBkPXAudG9TdHJpbmcsdj1cIlN5bWJvbCh0ZXN0KVwiPT1TdHJpbmcoZihcInRlc3RcIikpLGc9L15TeW1ib2xcXCgoLiopXFwpW14pXSskLzt1KHAsXCJkZXNjcmlwdGlvblwiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9cyh0aGlzKT90aGlzLnZhbHVlT2YoKTp0aGlzLGU9ZC5jYWxsKHQpO2lmKGEobCx0KSlyZXR1cm5cIlwiO3ZhciByPXY/ZS5zbGljZSg3LC0xKTplLnJlcGxhY2UoZyxcIiQxXCIpO3JldHVyblwiXCI9PT1yP3ZvaWQgMDpyfX0pLG4oe2dsb2JhbDohMCxmb3JjZWQ6ITB9LHtTeW1ib2w6aH0pfX0sZnVuY3Rpb24odCxlLHIpe3IoMTExKShcIml0ZXJhdG9yXCIpfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigxMTUpLkl0ZXJhdG9yUHJvdG90eXBlLGk9cig3MCksbz1yKDMxKSxhPXIoNDkpLHM9cigzNCksdT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIpe3ZhciBjPWUrXCIgSXRlcmF0b3JcIjtyZXR1cm4gdC5wcm90b3R5cGU9aShuLHtuZXh0Om8oMSxyKX0pLGEodCxjLCExLCEwKSxzW2NdPXUsdH19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDUpO3QuZXhwb3J0cz0hbigoZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1udWxsLE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgdCkhPT10LnByb3RvdHlwZX0pKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZighbih0KSYmbnVsbCE9PXQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiK1N0cmluZyh0KStcIiBhcyBhIHByb3RvdHlwZVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDcyKSxpPXIoMTE4KTt0LmV4cG9ydHM9bj97fS50b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBcIitpKHRoaXMpK1wiXVwifX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxNik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7Zm9yKDshT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkmJm51bGwhPT0odD1uKHQpKTspO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMiksaT1yKDcpO24oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFpLHNoYW06IWl9LHtkZWZpbmVQcm9wZXJ0aWVzOnIoMTA4KX0pfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyKSxpPXIoNyk7bih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6IWksc2hhbTohaX0se2RlZmluZVByb3BlcnR5OnIoMTEpLmZ9KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMiksaT1yKDE2MCkuZW50cmllcztuKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwfSx7ZW50cmllczpmdW5jdGlvbih0KXtyZXR1cm4gaSh0KX19KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDQ4KSxvPXIoMTIpLGE9cig1OSkuZixzPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHIscz1vKGUpLHU9aShzKSxjPXUubGVuZ3RoLGY9MCxsPVtdO2M+Zjspcj11W2YrK10sbiYmIWEuY2FsbChzLHIpfHxsLnB1c2godD9bcixzW3JdXTpzW3JdKTtyZXR1cm4gbH19O3QuZXhwb3J0cz17ZW50cmllczpzKCEwKSx2YWx1ZXM6cyghMSl9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyKSxpPXIoNSksbz1yKDEyKSxhPXIoMjIpLmYscz1yKDcpLHU9aSgoZnVuY3Rpb24oKXthKDEpfSkpO24oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFzfHx1LHNoYW06IXN9LHtnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gYShvKHQpLGUpfX0pfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyKSxpPXIoNyksbz1yKDEwMiksYT1yKDEyKSxzPXIoMjIpLHU9cig4Mik7bih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxzaGFtOiFpfSx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczpmdW5jdGlvbih0KXtmb3IodmFyIGUscixuPWEodCksaT1zLmYsYz1vKG4pLGY9e30sbD0wO2MubGVuZ3RoPmw7KXZvaWQgMCE9PShyPWkobixlPWNbbCsrXSkpJiZ1KGYsZSxyKTtyZXR1cm4gZn19KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDQpLG89cig2OCksYT1yKDE2NCkscz1yKDExKS5mLHU9cig0NikuZixjPXIoODgpLGY9cig3MyksbD1yKDExOSksaD1yKDE3KSxwPXIoNSksZD1yKDI0KS5zZXQsdj1yKDEyNSksZz1yKDMpKFwibWF0Y2hcIikseT1pLlJlZ0V4cCxiPXkucHJvdG90eXBlLF89L2EvZyxtPS9hL2csdz1uZXcgeShfKSE9PV8seD1sLlVOU1VQUE9SVEVEX1k7aWYobiYmbyhcIlJlZ0V4cFwiLCF3fHx4fHxwKChmdW5jdGlvbigpe3JldHVybiBtW2ddPSExLHkoXykhPV98fHkobSk9PW18fFwiL2EvaVwiIT15KF8sXCJpXCIpfSkpKSl7Zm9yKHZhciBrPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbj10aGlzIGluc3RhbmNlb2YgayxpPWModCksbz12b2lkIDA9PT1lO2lmKCFuJiZpJiZ0LmNvbnN0cnVjdG9yPT09ayYmbylyZXR1cm4gdDt3P2kmJiFvJiYodD10LnNvdXJjZSk6dCBpbnN0YW5jZW9mIGsmJihvJiYoZT1mLmNhbGwodCkpLHQ9dC5zb3VyY2UpLHgmJihyPSEhZSYmZS5pbmRleE9mKFwieVwiKT4tMSkmJihlPWUucmVwbGFjZSgveS9nLFwiXCIpKTt2YXIgcz1hKHc/bmV3IHkodCxlKTp5KHQsZSksbj90aGlzOmIsayk7cmV0dXJuIHgmJnImJmQocyx7c3RpY2t5OnJ9KSxzfSxFPWZ1bmN0aW9uKHQpe3QgaW4ga3x8cyhrLHQse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4geVt0XX0sc2V0OmZ1bmN0aW9uKGUpe3lbdF09ZX19KX0sUz11KHkpLGo9MDtTLmxlbmd0aD5qOylFKFNbaisrXSk7Yi5jb25zdHJ1Y3Rvcj1rLGsucHJvdG90eXBlPWIsaChpLFwiUmVnRXhwXCIsayl9dihcIlJlZ0V4cFwiKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTApLGk9cigxMTcpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7dmFyIG8sYTtyZXR1cm4gaSYmXCJmdW5jdGlvblwiPT10eXBlb2Yobz1lLmNvbnN0cnVjdG9yKSYmbyE9PXImJm4oYT1vLnByb3RvdHlwZSkmJmEhPT1yLnByb3RvdHlwZSYmaSh0LGEpLHR9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigxNyksaT1yKDgpLG89cig1KSxhPXIoNzMpLHM9UmVnRXhwLnByb3RvdHlwZSx1PXMudG9TdHJpbmcsYz1vKChmdW5jdGlvbigpe3JldHVyblwiL2EvYlwiIT11LmNhbGwoe3NvdXJjZTpcImFcIixmbGFnczpcImJcIn0pfSkpLGY9XCJ0b1N0cmluZ1wiIT11Lm5hbWU7KGN8fGYpJiZuKFJlZ0V4cC5wcm90b3R5cGUsXCJ0b1N0cmluZ1wiLChmdW5jdGlvbigpe3ZhciB0PWkodGhpcyksZT1TdHJpbmcodC5zb3VyY2UpLHI9dC5mbGFncztyZXR1cm5cIi9cIitlK1wiL1wiK1N0cmluZyh2b2lkIDA9PT1yJiZ0IGluc3RhbmNlb2YgUmVnRXhwJiYhKFwiZmxhZ3NcImluIHMpP2EuY2FsbCh0KTpyKX0pLHt1bnNhZmU6ITB9KX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSl7dmFyIHI9W10sbj0hMCxpPSExLG89dm9pZCAwO3RyeXtmb3IodmFyIGEscz10W1N5bWJvbC5pdGVyYXRvcl0oKTshKG49KGE9cy5uZXh0KCkpLmRvbmUpJiYoci5wdXNoKGEudmFsdWUpLCFlfHxyLmxlbmd0aCE9PWUpO249ITApO31jYXRjaCh0KXtpPSEwLG89dH1maW5hbGx5e3RyeXtufHxudWxsPT1zLnJldHVybnx8cy5yZXR1cm4oKX1maW5hbGx5e2lmKGkpdGhyb3cgb319cmV0dXJuIHJ9fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpe2Zvcih2YXIgZT0wLHI9bmV3IEFycmF5KHQubGVuZ3RoKTtlPHQubGVuZ3RoO2UrKylyW2VdPXRbZV07cmV0dXJuIHJ9fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSlyZXR1cm4gQXJyYXkuZnJvbSh0KX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0sZnVuY3Rpb24odCxlLHIpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe2xldCBlPTA7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspZT0oZTw8NSktZSt0LmNoYXJDb2RlQXQociksZXw9MDtyZXR1cm4gbi5jb2xvcnNbTWF0aC5hYnMoZSklbi5jb2xvcnMubGVuZ3RoXX1mdW5jdGlvbiBuKHQpe2xldCByO2Z1bmN0aW9uIGEoLi4udCl7aWYoIWEuZW5hYmxlZClyZXR1cm47Y29uc3QgZT1hLGk9TnVtYmVyKG5ldyBEYXRlKSxvPWktKHJ8fGkpO2UuZGlmZj1vLGUucHJldj1yLGUuY3Vycj1pLHI9aSx0WzBdPW4uY29lcmNlKHRbMF0pLFwic3RyaW5nXCIhPXR5cGVvZiB0WzBdJiZ0LnVuc2hpZnQoXCIlT1wiKTtsZXQgcz0wO3RbMF09dFswXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywocixpKT0+e2lmKFwiJSVcIj09PXIpcmV0dXJuIHI7cysrO2NvbnN0IG89bi5mb3JtYXR0ZXJzW2ldO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG8pe2NvbnN0IG49dFtzXTtyPW8uY2FsbChlLG4pLHQuc3BsaWNlKHMsMSkscy0tfXJldHVybiByfSksbi5mb3JtYXRBcmdzLmNhbGwoZSx0KSwoZS5sb2d8fG4ubG9nKS5hcHBseShlLHQpfXJldHVybiBhLm5hbWVzcGFjZT10LGEuZW5hYmxlZD1uLmVuYWJsZWQodCksYS51c2VDb2xvcnM9bi51c2VDb2xvcnMoKSxhLmNvbG9yPWUodCksYS5kZXN0cm95PWksYS5leHRlbmQ9byxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmluaXQmJm4uaW5pdChhKSxuLmluc3RhbmNlcy5wdXNoKGEpLGF9ZnVuY3Rpb24gaSgpe2NvbnN0IHQ9bi5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtyZXR1cm4tMSE9PXQmJihuLmluc3RhbmNlcy5zcGxpY2UodCwxKSwhMCl9ZnVuY3Rpb24gbyh0LGUpe2NvbnN0IHI9bih0aGlzLm5hbWVzcGFjZSsodm9pZCAwPT09ZT9cIjpcIjplKSt0KTtyZXR1cm4gci5sb2c9dGhpcy5sb2cscn1mdW5jdGlvbiBhKHQpe3JldHVybiB0LnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIsdC50b1N0cmluZygpLmxlbmd0aC0yKS5yZXBsYWNlKC9cXC5cXCpcXD8kLyxcIipcIil9cmV0dXJuIG4uZGVidWc9bixuLmRlZmF1bHQ9bixuLmNvZXJjZT1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgRXJyb3IpcmV0dXJuIHQuc3RhY2t8fHQubWVzc2FnZTtyZXR1cm4gdH0sbi5kaXNhYmxlPWZ1bmN0aW9uKCl7Y29uc3QgdD1bLi4ubi5uYW1lcy5tYXAoYSksLi4ubi5za2lwcy5tYXAoYSkubWFwKHQ9PlwiLVwiK3QpXS5qb2luKFwiLFwiKTtyZXR1cm4gbi5lbmFibGUoXCJcIiksdH0sbi5lbmFibGU9ZnVuY3Rpb24odCl7bGV0IGU7bi5zYXZlKHQpLG4ubmFtZXM9W10sbi5za2lwcz1bXTtjb25zdCByPShcInN0cmluZ1wiPT10eXBlb2YgdD90OlwiXCIpLnNwbGl0KC9bXFxzLF0rLyksaT1yLmxlbmd0aDtmb3IoZT0wO2U8aTtlKyspcltlXSYmKFwiLVwiPT09KHQ9cltlXS5yZXBsYWNlKC9cXCovZyxcIi4qP1wiKSlbMF0/bi5za2lwcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrdC5zdWJzdHIoMSkrXCIkXCIpKTpuLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIit0K1wiJFwiKSkpO2ZvcihlPTA7ZTxuLmluc3RhbmNlcy5sZW5ndGg7ZSsrKXtjb25zdCB0PW4uaW5zdGFuY2VzW2VdO3QuZW5hYmxlZD1uLmVuYWJsZWQodC5uYW1lc3BhY2UpfX0sbi5lbmFibGVkPWZ1bmN0aW9uKHQpe2lmKFwiKlwiPT09dFt0Lmxlbmd0aC0xXSlyZXR1cm4hMDtsZXQgZSxyO2ZvcihlPTAscj1uLnNraXBzLmxlbmd0aDtlPHI7ZSsrKWlmKG4uc2tpcHNbZV0udGVzdCh0KSlyZXR1cm4hMTtmb3IoZT0wLHI9bi5uYW1lcy5sZW5ndGg7ZTxyO2UrKylpZihuLm5hbWVzW2VdLnRlc3QodCkpcmV0dXJuITA7cmV0dXJuITF9LG4uaHVtYW5pemU9cigxNzMpLE9iamVjdC5rZXlzKHQpLmZvckVhY2goZT0+e25bZV09dFtlXX0pLG4uaW5zdGFuY2VzPVtdLG4ubmFtZXM9W10sbi5za2lwcz1bXSxuLmZvcm1hdHRlcnM9e30sbi5zZWxlY3RDb2xvcj1lLG4uZW5hYmxlKG4ubG9hZCgpKSxufX0sZnVuY3Rpb24odCxlKXt2YXIgcj0xZTMsbj02ZTQsaT02MCpuLG89MjQqaTtmdW5jdGlvbiBhKHQsZSxyLG4pe3ZhciBpPWU+PTEuNSpyO3JldHVybiBNYXRoLnJvdW5kKHQvcikrXCIgXCIrbisoaT9cInNcIjpcIlwiKX10LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtlPWV8fHt9O3ZhciBzPXR5cGVvZiB0O2lmKFwic3RyaW5nXCI9PT1zJiZ0Lmxlbmd0aD4wKXJldHVybiBmdW5jdGlvbih0KXtpZigodD1TdHJpbmcodCkpLmxlbmd0aD4xMDApcmV0dXJuO3ZhciBlPS9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyh0KTtpZighZSlyZXR1cm47dmFyIGE9cGFyc2VGbG9hdChlWzFdKTtzd2l0Y2goKGVbMl18fFwibXNcIikudG9Mb3dlckNhc2UoKSl7Y2FzZVwieWVhcnNcIjpjYXNlXCJ5ZWFyXCI6Y2FzZVwieXJzXCI6Y2FzZVwieXJcIjpjYXNlXCJ5XCI6cmV0dXJuIDMxNTU3NmU1KmE7Y2FzZVwid2Vla3NcIjpjYXNlXCJ3ZWVrXCI6Y2FzZVwid1wiOnJldHVybiA2MDQ4ZTUqYTtjYXNlXCJkYXlzXCI6Y2FzZVwiZGF5XCI6Y2FzZVwiZFwiOnJldHVybiBhKm87Y2FzZVwiaG91cnNcIjpjYXNlXCJob3VyXCI6Y2FzZVwiaHJzXCI6Y2FzZVwiaHJcIjpjYXNlXCJoXCI6cmV0dXJuIGEqaTtjYXNlXCJtaW51dGVzXCI6Y2FzZVwibWludXRlXCI6Y2FzZVwibWluc1wiOmNhc2VcIm1pblwiOmNhc2VcIm1cIjpyZXR1cm4gYSpuO2Nhc2VcInNlY29uZHNcIjpjYXNlXCJzZWNvbmRcIjpjYXNlXCJzZWNzXCI6Y2FzZVwic2VjXCI6Y2FzZVwic1wiOnJldHVybiBhKnI7Y2FzZVwibWlsbGlzZWNvbmRzXCI6Y2FzZVwibWlsbGlzZWNvbmRcIjpjYXNlXCJtc2Vjc1wiOmNhc2VcIm1zZWNcIjpjYXNlXCJtc1wiOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJufX0odCk7aWYoXCJudW1iZXJcIj09PXMmJmlzRmluaXRlKHQpKXJldHVybiBlLmxvbmc/ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5hYnModCk7aWYoZT49bylyZXR1cm4gYSh0LGUsbyxcImRheVwiKTtpZihlPj1pKXJldHVybiBhKHQsZSxpLFwiaG91clwiKTtpZihlPj1uKXJldHVybiBhKHQsZSxuLFwibWludXRlXCIpO2lmKGU+PXIpcmV0dXJuIGEodCxlLHIsXCJzZWNvbmRcIik7cmV0dXJuIHQrXCIgbXNcIn0odCk6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5hYnModCk7aWYoZT49bylyZXR1cm4gTWF0aC5yb3VuZCh0L28pK1wiZFwiO2lmKGU+PWkpcmV0dXJuIE1hdGgucm91bmQodC9pKStcImhcIjtpZihlPj1uKXJldHVybiBNYXRoLnJvdW5kKHQvbikrXCJtXCI7aWYoZT49cilyZXR1cm4gTWF0aC5yb3VuZCh0L3IpK1wic1wiO3JldHVybiB0K1wibXNcIn0odCk7dGhyb3cgbmV3IEVycm9yKFwidmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD1cIitKU09OLnN0cmluZ2lmeSh0KSl9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigyKSxpPXIoMzMpLmV2ZXJ5O24oe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOnIoMzYpKFwiZXZlcnlcIil9LHtldmVyeTpmdW5jdGlvbih0KXtyZXR1cm4gaSh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigxMiksaT1yKDMyKSxvPXIoMTUpLGE9cigzNikscz1NYXRoLm1pbix1PVtdLmxhc3RJbmRleE9mLGM9ISF1JiYxL1sxXS5sYXN0SW5kZXhPZigxLC0wKTwwLGY9YShcImxhc3RJbmRleE9mXCIpO3QuZXhwb3J0cz1jfHxmP2Z1bmN0aW9uKHQpe2lmKGMpcmV0dXJuIHUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHwwO3ZhciBlPW4odGhpcykscj1vKGUubGVuZ3RoKSxhPXItMTtmb3IoYXJndW1lbnRzLmxlbmd0aD4xJiYoYT1zKGEsaShhcmd1bWVudHNbMV0pKSksYTwwJiYoYT1yK2EpO2E+PTA7YS0tKWlmKGEgaW4gZSYmZVthXT09PXQpcmV0dXJuIGF8fDA7cmV0dXJuLTF9OnV9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDc2KSxpPXIoODgpLG89cig4KSxhPXIoMjApLHM9cigxMzIpLHU9cig3NyksYz1yKDE1KSxmPXIoNzgpLGw9cig1MyksaD1yKDUpLHA9W10ucHVzaCxkPU1hdGgubWluLHY9IWgoKGZ1bmN0aW9uKCl7cmV0dXJuIVJlZ0V4cCg0Mjk0OTY3Mjk1LFwieVwiKX0pKTtuKFwic3BsaXRcIiwyLChmdW5jdGlvbih0LGUscil7dmFyIG47cmV0dXJuIG49XCJjXCI9PVwiYWJiY1wiLnNwbGl0KC8oYikqLylbMV18fDQhPVwidGVzdFwiLnNwbGl0KC8oPzopLywtMSkubGVuZ3RofHwyIT1cImFiXCIuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGh8fDQhPVwiLlwiLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aHx8XCIuXCIuc3BsaXQoLygpKCkvKS5sZW5ndGg+MXx8XCJcIi5zcGxpdCgvLj8vKS5sZW5ndGg/ZnVuY3Rpb24odCxyKXt2YXIgbj1TdHJpbmcoYSh0aGlzKSksbz12b2lkIDA9PT1yPzQyOTQ5NjcyOTU6cj4+PjA7aWYoMD09PW8pcmV0dXJuW107aWYodm9pZCAwPT09dClyZXR1cm5bbl07aWYoIWkodCkpcmV0dXJuIGUuY2FsbChuLHQsbyk7Zm9yKHZhciBzLHUsYyxmPVtdLGg9KHQuaWdub3JlQ2FzZT9cImlcIjpcIlwiKSsodC5tdWx0aWxpbmU/XCJtXCI6XCJcIikrKHQudW5pY29kZT9cInVcIjpcIlwiKSsodC5zdGlja3k/XCJ5XCI6XCJcIiksZD0wLHY9bmV3IFJlZ0V4cCh0LnNvdXJjZSxoK1wiZ1wiKTsocz1sLmNhbGwodixuKSkmJiEoKHU9di5sYXN0SW5kZXgpPmQmJihmLnB1c2gobi5zbGljZShkLHMuaW5kZXgpKSxzLmxlbmd0aD4xJiZzLmluZGV4PG4ubGVuZ3RoJiZwLmFwcGx5KGYscy5zbGljZSgxKSksYz1zWzBdLmxlbmd0aCxkPXUsZi5sZW5ndGg+PW8pKTspdi5sYXN0SW5kZXg9PT1zLmluZGV4JiZ2Lmxhc3RJbmRleCsrO3JldHVybiBkPT09bi5sZW5ndGg/IWMmJnYudGVzdChcIlwiKXx8Zi5wdXNoKFwiXCIpOmYucHVzaChuLnNsaWNlKGQpKSxmLmxlbmd0aD5vP2Yuc2xpY2UoMCxvKTpmfTpcIjBcIi5zcGxpdCh2b2lkIDAsMCkubGVuZ3RoP2Z1bmN0aW9uKHQscil7cmV0dXJuIHZvaWQgMD09PXQmJjA9PT1yP1tdOmUuY2FsbCh0aGlzLHQscil9OmUsW2Z1bmN0aW9uKGUscil7dmFyIGk9YSh0aGlzKSxvPW51bGw9PWU/dm9pZCAwOmVbdF07cmV0dXJuIHZvaWQgMCE9PW8/by5jYWxsKGUsaSxyKTpuLmNhbGwoU3RyaW5nKGkpLGUscil9LGZ1bmN0aW9uKHQsaSl7dmFyIGE9cihuLHQsdGhpcyxpLG4hPT1lKTtpZihhLmRvbmUpcmV0dXJuIGEudmFsdWU7dmFyIGw9byh0KSxoPVN0cmluZyh0aGlzKSxwPXMobCxSZWdFeHApLGc9bC51bmljb2RlLHk9KGwuaWdub3JlQ2FzZT9cImlcIjpcIlwiKSsobC5tdWx0aWxpbmU/XCJtXCI6XCJcIikrKGwudW5pY29kZT9cInVcIjpcIlwiKSsodj9cInlcIjpcImdcIiksYj1uZXcgcCh2P2w6XCJeKD86XCIrbC5zb3VyY2UrXCIpXCIseSksXz12b2lkIDA9PT1pPzQyOTQ5NjcyOTU6aT4+PjA7aWYoMD09PV8pcmV0dXJuW107aWYoMD09PWgubGVuZ3RoKXJldHVybiBudWxsPT09ZihiLGgpP1toXTpbXTtmb3IodmFyIG09MCx3PTAseD1bXTt3PGgubGVuZ3RoOyl7Yi5sYXN0SW5kZXg9dj93OjA7dmFyIGssRT1mKGIsdj9oOmguc2xpY2UodykpO2lmKG51bGw9PT1FfHwoaz1kKGMoYi5sYXN0SW5kZXgrKHY/MDp3KSksaC5sZW5ndGgpKT09PW0pdz11KGgsdyxnKTtlbHNle2lmKHgucHVzaChoLnNsaWNlKG0sdykpLHgubGVuZ3RoPT09XylyZXR1cm4geDtmb3IodmFyIFM9MTtTPD1FLmxlbmd0aC0xO1MrKylpZih4LnB1c2goRVtTXSkseC5sZW5ndGg9PT1fKXJldHVybiB4O3c9bT1rfX1yZXR1cm4geC5wdXNoKGguc2xpY2UobSkpLHh9XX0pLCF2KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCk7dC5leHBvcnRzPW4uUHJvbWlzZX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTcpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7Zm9yKHZhciBpIGluIGUpbih0LGksZVtpXSxyKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxyKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBUeXBlRXJyb3IoXCJJbmNvcnJlY3QgXCIrKHI/citcIiBcIjpcIlwiKStcImludm9jYXRpb25cIik7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig4KSxpPXIoMTgxKSxvPXIoMTUpLGE9cig3MSkscz1yKDE4MiksdT1yKDE4MyksYz1mdW5jdGlvbih0LGUpe3RoaXMuc3RvcHBlZD10LHRoaXMucmVzdWx0PWV9Oyh0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIsZixsKXt2YXIgaCxwLGQsdixnLHksYixfPWEoZSxyLGY/MjoxKTtpZihsKWg9dDtlbHNle2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mKHA9cyh0KSkpdGhyb3cgVHlwZUVycm9yKFwiVGFyZ2V0IGlzIG5vdCBpdGVyYWJsZVwiKTtpZihpKHApKXtmb3IoZD0wLHY9byh0Lmxlbmd0aCk7dj5kO2QrKylpZigoZz1mP18obihiPXRbZF0pWzBdLGJbMV0pOl8odFtkXSkpJiZnIGluc3RhbmNlb2YgYylyZXR1cm4gZztyZXR1cm4gbmV3IGMoITEpfWg9cC5jYWxsKHQpfWZvcih5PWgubmV4dDshKGI9eS5jYWxsKGgpKS5kb25lOylpZihcIm9iamVjdFwiPT10eXBlb2YoZz11KGgsXyxiLnZhbHVlLGYpKSYmZyYmZyBpbnN0YW5jZW9mIGMpcmV0dXJuIGc7cmV0dXJuIG5ldyBjKCExKX0pLnN0b3A9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBjKCEwLHQpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMyksaT1yKDM0KSxvPW4oXCJpdGVyYXRvclwiKSxhPUFycmF5LnByb3RvdHlwZTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQmJihpLkFycmF5PT09dHx8YVtvXT09PXQpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTE4KSxpPXIoMzQpLG89cigzKShcIml0ZXJhdG9yXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihudWxsIT10KXJldHVybiB0W29dfHx0W1wiQEBpdGVyYXRvclwiXXx8aVtuKHQpXX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDgpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscixpKXt0cnl7cmV0dXJuIGk/ZShuKHIpWzBdLHJbMV0pOmUocil9Y2F0Y2goZSl7dmFyIG89dC5yZXR1cm47dGhyb3cgdm9pZCAwIT09byYmbihvLmNhbGwodCkpLGV9fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMykoXCJpdGVyYXRvclwiKSxpPSExO3RyeXt2YXIgbz0wLGE9e25leHQ6ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTohIW8rK319LHJldHVybjpmdW5jdGlvbigpe2k9ITB9fTthW25dPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LEFycmF5LmZyb20oYSwoZnVuY3Rpb24oKXt0aHJvdyAyfSkpfWNhdGNoKHQpe310LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZighZSYmIWkpcmV0dXJuITE7dmFyIHI9ITE7dHJ5e3ZhciBvPXt9O29bbl09ZnVuY3Rpb24oKXtyZXR1cm57bmV4dDpmdW5jdGlvbigpe3JldHVybntkb25lOnI9ITB9fX19LHQobyl9Y2F0Y2godCl7fXJldHVybiByfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuLGksbyxhLHMsdSxjLGYsbD1yKDQpLGg9cigyMikuZixwPXIoMTkpLGQ9cigxMzMpLnNldCx2PXIoMTM0KSxnPWwuTXV0YXRpb25PYnNlcnZlcnx8bC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLHk9bC5wcm9jZXNzLGI9bC5Qcm9taXNlLF89XCJwcm9jZXNzXCI9PXAoeSksbT1oKGwsXCJxdWV1ZU1pY3JvdGFza1wiKSx3PW0mJm0udmFsdWU7d3x8KG49ZnVuY3Rpb24oKXt2YXIgdCxlO2ZvcihfJiYodD15LmRvbWFpbikmJnQuZXhpdCgpO2k7KXtlPWkuZm4saT1pLm5leHQ7dHJ5e2UoKX1jYXRjaCh0KXt0aHJvdyBpP2EoKTpvPXZvaWQgMCx0fX1vPXZvaWQgMCx0JiZ0LmVudGVyKCl9LF8/YT1mdW5jdGlvbigpe3kubmV4dFRpY2sobil9OmcmJiF2PyhzPSEwLHU9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIiksbmV3IGcobikub2JzZXJ2ZSh1LHtjaGFyYWN0ZXJEYXRhOiEwfSksYT1mdW5jdGlvbigpe3UuZGF0YT1zPSFzfSk6YiYmYi5yZXNvbHZlPyhjPWIucmVzb2x2ZSh2b2lkIDApLGY9Yy50aGVuLGE9ZnVuY3Rpb24oKXtmLmNhbGwoYyxuKX0pOmE9ZnVuY3Rpb24oKXtkLmNhbGwobCxuKX0pLHQuZXhwb3J0cz13fHxmdW5jdGlvbih0KXt2YXIgZT17Zm46dCxuZXh0OnZvaWQgMH07byYmKG8ubmV4dD1lKSxpfHwoaT1lLGEoKSksbz1lfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoOCksaT1yKDEwKSxvPXIoMTM1KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZihuKHQpLGkoZSkmJmUuY29uc3RydWN0b3I9PT10KXJldHVybiBlO3ZhciByPW8uZih0KTtyZXR1cm4oMCxyLnJlc29sdmUpKGUpLHIucHJvbWlzZX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDQpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByPW4uY29uc29sZTtyJiZyLmVycm9yJiYoMT09PWFyZ3VtZW50cy5sZW5ndGg/ci5lcnJvcih0KTpyLmVycm9yKHQsZSkpfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybntlcnJvcjohMSx2YWx1ZTp0KCl9fWNhdGNoKHQpe3JldHVybntlcnJvcjohMCx2YWx1ZTp0fX19fSxmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHQsZSl7IWZ1bmN0aW9uKHQscil7XCJ1c2Ugc3RyaWN0XCI7aWYoIXQuc2V0SW1tZWRpYXRlKXt2YXIgbixpLG8sYSxzLHU9MSxjPXt9LGY9ITEsbD10LmRvY3VtZW50LGg9T2JqZWN0LmdldFByb3RvdHlwZU9mJiZPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7aD1oJiZoLnNldFRpbWVvdXQ/aDp0LFwiW29iamVjdCBwcm9jZXNzXVwiPT09e30udG9TdHJpbmcuY2FsbCh0LnByb2Nlc3MpP249ZnVuY3Rpb24odCl7ZS5uZXh0VGljaygoZnVuY3Rpb24oKXtkKHQpfSkpfTohZnVuY3Rpb24oKXtpZih0LnBvc3RNZXNzYWdlJiYhdC5pbXBvcnRTY3JpcHRzKXt2YXIgZT0hMCxyPXQub25tZXNzYWdlO3JldHVybiB0Lm9ubWVzc2FnZT1mdW5jdGlvbigpe2U9ITF9LHQucG9zdE1lc3NhZ2UoXCJcIixcIipcIiksdC5vbm1lc3NhZ2U9cixlfX0oKT90Lk1lc3NhZ2VDaGFubmVsPygobz1uZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbih0KXtkKHQuZGF0YSl9LG49ZnVuY3Rpb24odCl7by5wb3J0Mi5wb3N0TWVzc2FnZSh0KX0pOmwmJlwib25yZWFkeXN0YXRlY2hhbmdlXCJpbiBsLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik/KGk9bC5kb2N1bWVudEVsZW1lbnQsbj1mdW5jdGlvbih0KXt2YXIgZT1sLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7ZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtkKHQpLGUub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsaS5yZW1vdmVDaGlsZChlKSxlPW51bGx9LGkuYXBwZW5kQ2hpbGQoZSl9KTpuPWZ1bmN0aW9uKHQpe3NldFRpbWVvdXQoZCwwLHQpfTooYT1cInNldEltbWVkaWF0ZSRcIitNYXRoLnJhbmRvbSgpK1wiJFwiLHM9ZnVuY3Rpb24oZSl7ZS5zb3VyY2U9PT10JiZcInN0cmluZ1wiPT10eXBlb2YgZS5kYXRhJiYwPT09ZS5kYXRhLmluZGV4T2YoYSkmJmQoK2UuZGF0YS5zbGljZShhLmxlbmd0aCkpfSx0LmFkZEV2ZW50TGlzdGVuZXI/dC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHMsITEpOnQuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIixzKSxuPWZ1bmN0aW9uKGUpe3QucG9zdE1lc3NhZ2UoYStlLFwiKlwiKX0pLGguc2V0SW1tZWRpYXRlPWZ1bmN0aW9uKHQpe1wiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJih0PW5ldyBGdW5jdGlvbihcIlwiK3QpKTtmb3IodmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSkscj0wO3I8ZS5sZW5ndGg7cisrKWVbcl09YXJndW1lbnRzW3IrMV07dmFyIGk9e2NhbGxiYWNrOnQsYXJnczplfTtyZXR1cm4gY1t1XT1pLG4odSksdSsrfSxoLmNsZWFySW1tZWRpYXRlPXB9ZnVuY3Rpb24gcCh0KXtkZWxldGUgY1t0XX1mdW5jdGlvbiBkKHQpe2lmKGYpc2V0VGltZW91dChkLDAsdCk7ZWxzZXt2YXIgZT1jW3RdO2lmKGUpe2Y9ITA7dHJ5eyFmdW5jdGlvbih0KXt2YXIgZT10LmNhbGxiYWNrLHI9dC5hcmdzO3N3aXRjaChyLmxlbmd0aCl7Y2FzZSAwOmUoKTticmVhaztjYXNlIDE6ZShyWzBdKTticmVhaztjYXNlIDI6ZShyWzBdLHJbMV0pO2JyZWFrO2Nhc2UgMzplKHJbMF0sclsxXSxyWzJdKTticmVhaztkZWZhdWx0OmUuYXBwbHkodm9pZCAwLHIpfX0oZSl9ZmluYWxseXtwKHQpLGY9ITF9fX19fShcInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj92b2lkIDA9PT10P3RoaXM6dDpzZWxmKX0pLmNhbGwodGhpcyxyKDIxKSxyKDM4KSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtlLmJ5dGVMZW5ndGg9ZnVuY3Rpb24odCl7dmFyIGU9Yyh0KSxyPWVbMF0sbj1lWzFdO3JldHVybiAzKihyK24pLzQtbn0sZS50b0J5dGVBcnJheT1mdW5jdGlvbih0KXt2YXIgZSxyLG49Yyh0KSxhPW5bMF0scz1uWzFdLHU9bmV3IG8oZnVuY3Rpb24odCxlLHIpe3JldHVybiAzKihlK3IpLzQtcn0oMCxhLHMpKSxmPTAsbD1zPjA/YS00OmE7Zm9yKHI9MDtyPGw7cis9NCllPWlbdC5jaGFyQ29kZUF0KHIpXTw8MTh8aVt0LmNoYXJDb2RlQXQocisxKV08PDEyfGlbdC5jaGFyQ29kZUF0KHIrMildPDw2fGlbdC5jaGFyQ29kZUF0KHIrMyldLHVbZisrXT1lPj4xNiYyNTUsdVtmKytdPWU+PjgmMjU1LHVbZisrXT0yNTUmZTsyPT09cyYmKGU9aVt0LmNoYXJDb2RlQXQocildPDwyfGlbdC5jaGFyQ29kZUF0KHIrMSldPj40LHVbZisrXT0yNTUmZSk7MT09PXMmJihlPWlbdC5jaGFyQ29kZUF0KHIpXTw8MTB8aVt0LmNoYXJDb2RlQXQocisxKV08PDR8aVt0LmNoYXJDb2RlQXQocisyKV0+PjIsdVtmKytdPWU+PjgmMjU1LHVbZisrXT0yNTUmZSk7cmV0dXJuIHV9LGUuZnJvbUJ5dGVBcnJheT1mdW5jdGlvbih0KXtmb3IodmFyIGUscj10Lmxlbmd0aCxpPXIlMyxvPVtdLGE9MCxzPXItaTthPHM7YSs9MTYzODMpby5wdXNoKGYodCxhLGErMTYzODM+cz9zOmErMTYzODMpKTsxPT09aT8oZT10W3ItMV0sby5wdXNoKG5bZT4+Ml0rbltlPDw0JjYzXStcIj09XCIpKToyPT09aSYmKGU9KHRbci0yXTw8OCkrdFtyLTFdLG8ucHVzaChuW2U+PjEwXStuW2U+PjQmNjNdK25bZTw8MiY2M10rXCI9XCIpKTtyZXR1cm4gby5qb2luKFwiXCIpfTtmb3IodmFyIG49W10saT1bXSxvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5P1VpbnQ4QXJyYXk6QXJyYXksYT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIixzPTAsdT1hLmxlbmd0aDtzPHU7KytzKW5bc109YVtzXSxpW2EuY2hhckNvZGVBdChzKV09cztmdW5jdGlvbiBjKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGUlND4wKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIik7dmFyIHI9dC5pbmRleE9mKFwiPVwiKTtyZXR1cm4tMT09PXImJihyPWUpLFtyLHI9PT1lPzA6NC1yJTRdfWZ1bmN0aW9uIGYodCxlLHIpe2Zvcih2YXIgaSxvLGE9W10scz1lO3M8cjtzKz0zKWk9KHRbc108PDE2JjE2NzExNjgwKSsodFtzKzFdPDw4JjY1MjgwKSsoMjU1JnRbcysyXSksYS5wdXNoKG5bKG89aSk+PjE4JjYzXStuW28+PjEyJjYzXStuW28+PjYmNjNdK25bNjMmb10pO3JldHVybiBhLmpvaW4oXCJcIil9aVtcIi1cIi5jaGFyQ29kZUF0KDApXT02MixpW1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzfSxmdW5jdGlvbih0LGUpe2UucmVhZD1mdW5jdGlvbih0LGUscixuLGkpe3ZhciBvLGEscz04Kmktbi0xLHU9KDE8PHMpLTEsYz11Pj4xLGY9LTcsbD1yP2ktMTowLGg9cj8tMToxLHA9dFtlK2xdO2ZvcihsKz1oLG89cCYoMTw8LWYpLTEscD4+PS1mLGYrPXM7Zj4wO289MjU2Km8rdFtlK2xdLGwrPWgsZi09OCk7Zm9yKGE9byYoMTw8LWYpLTEsbz4+PS1mLGYrPW47Zj4wO2E9MjU2KmErdFtlK2xdLGwrPWgsZi09OCk7aWYoMD09PW8pbz0xLWM7ZWxzZXtpZihvPT09dSlyZXR1cm4gYT9OYU46MS8wKihwPy0xOjEpO2ErPU1hdGgucG93KDIsbiksby09Y31yZXR1cm4ocD8tMToxKSphKk1hdGgucG93KDIsby1uKX0sZS53cml0ZT1mdW5jdGlvbih0LGUscixuLGksbyl7dmFyIGEscyx1LGM9OCpvLWktMSxmPSgxPDxjKS0xLGw9Zj4+MSxoPTIzPT09aT9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjAscD1uPzA6by0xLGQ9bj8xOi0xLHY9ZTwwfHwwPT09ZSYmMS9lPDA/MTowO2ZvcihlPU1hdGguYWJzKGUpLGlzTmFOKGUpfHxlPT09MS8wPyhzPWlzTmFOKGUpPzE6MCxhPWYpOihhPU1hdGguZmxvb3IoTWF0aC5sb2coZSkvTWF0aC5MTjIpLGUqKHU9TWF0aC5wb3coMiwtYSkpPDEmJihhLS0sdSo9MiksKGUrPWErbD49MT9oL3U6aCpNYXRoLnBvdygyLDEtbCkpKnU+PTImJihhKyssdS89MiksYStsPj1mPyhzPTAsYT1mKTphK2w+PTE/KHM9KGUqdS0xKSpNYXRoLnBvdygyLGkpLGErPWwpOihzPWUqTWF0aC5wb3coMixsLTEpKk1hdGgucG93KDIsaSksYT0wKSk7aT49ODt0W3IrcF09MjU1JnMscCs9ZCxzLz0yNTYsaS09OCk7Zm9yKGE9YTw8aXxzLGMrPWk7Yz4wO3RbcitwXT0yNTUmYSxwKz1kLGEvPTI1NixjLT04KTt0W3IrcC1kXXw9MTI4KnZ9fSxmdW5jdGlvbih0LGUpe30sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNTYpLkJ1ZmZlcixpPXIoMTk0KTt0LmV4cG9ydHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyx0KSx0aGlzLmhlYWQ9bnVsbCx0aGlzLnRhaWw9bnVsbCx0aGlzLmxlbmd0aD0wfXJldHVybiB0LnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQpe3ZhciBlPXtkYXRhOnQsbmV4dDpudWxsfTt0aGlzLmxlbmd0aD4wP3RoaXMudGFpbC5uZXh0PWU6dGhpcy5oZWFkPWUsdGhpcy50YWlsPWUsKyt0aGlzLmxlbmd0aH0sdC5wcm90b3R5cGUudW5zaGlmdD1mdW5jdGlvbih0KXt2YXIgZT17ZGF0YTp0LG5leHQ6dGhpcy5oZWFkfTswPT09dGhpcy5sZW5ndGgmJih0aGlzLnRhaWw9ZSksdGhpcy5oZWFkPWUsKyt0aGlzLmxlbmd0aH0sdC5wcm90b3R5cGUuc2hpZnQ9ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5sZW5ndGgpe3ZhciB0PXRoaXMuaGVhZC5kYXRhO3JldHVybiAxPT09dGhpcy5sZW5ndGg/dGhpcy5oZWFkPXRoaXMudGFpbD1udWxsOnRoaXMuaGVhZD10aGlzLmhlYWQubmV4dCwtLXRoaXMubGVuZ3RoLHR9fSx0LnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuaGVhZD10aGlzLnRhaWw9bnVsbCx0aGlzLmxlbmd0aD0wfSx0LnByb3RvdHlwZS5qb2luPWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLmxlbmd0aClyZXR1cm5cIlwiO2Zvcih2YXIgZT10aGlzLmhlYWQscj1cIlwiK2UuZGF0YTtlPWUubmV4dDspcis9dCtlLmRhdGE7cmV0dXJuIHJ9LHQucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbih0KXtpZigwPT09dGhpcy5sZW5ndGgpcmV0dXJuIG4uYWxsb2MoMCk7aWYoMT09PXRoaXMubGVuZ3RoKXJldHVybiB0aGlzLmhlYWQuZGF0YTtmb3IodmFyIGUscixpLG89bi5hbGxvY1Vuc2FmZSh0Pj4+MCksYT10aGlzLmhlYWQscz0wO2E7KWU9YS5kYXRhLHI9byxpPXMsZS5jb3B5KHIsaSkscys9YS5kYXRhLmxlbmd0aCxhPWEubmV4dDtyZXR1cm4gb30sdH0oKSxpJiZpLmluc3BlY3QmJmkuaW5zcGVjdC5jdXN0b20mJih0LmV4cG9ydHMucHJvdG90eXBlW2kuaW5zcGVjdC5jdXN0b21dPWZ1bmN0aW9uKCl7dmFyIHQ9aS5pbnNwZWN0KHtsZW5ndGg6dGhpcy5sZW5ndGh9KTtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lK1wiIFwiK3R9KX0sZnVuY3Rpb24odCxlKXt9LGZ1bmN0aW9uKHQsZSxyKXsoZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcih0KXt0cnl7aWYoIWUubG9jYWxTdG9yYWdlKXJldHVybiExfWNhdGNoKHQpe3JldHVybiExfXZhciByPWUubG9jYWxTdG9yYWdlW3RdO3JldHVybiBudWxsIT1yJiZcInRydWVcIj09PVN0cmluZyhyKS50b0xvd2VyQ2FzZSgpfXQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKHIoXCJub0RlcHJlY2F0aW9uXCIpKXJldHVybiB0O3ZhciBuPSExO3JldHVybiBmdW5jdGlvbigpe2lmKCFuKXtpZihyKFwidGhyb3dEZXByZWNhdGlvblwiKSl0aHJvdyBuZXcgRXJyb3IoZSk7cihcInRyYWNlRGVwcmVjYXRpb25cIik/Y29uc29sZS50cmFjZShlKTpjb25zb2xlLndhcm4oZSksbj0hMH1yZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fX0pLmNhbGwodGhpcyxyKDIxKSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9bzt2YXIgbj1yKDE0MiksaT1yKDM5KTtmdW5jdGlvbiBvKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG8pKXJldHVybiBuZXcgbyh0KTtuLmNhbGwodGhpcyx0KX1pLmluaGVyaXRzPXIoMjkpLGkuaW5oZXJpdHMobyxuKSxvLnByb3RvdHlwZS5fdHJhbnNmb3JtPWZ1bmN0aW9uKHQsZSxyKXtyKG51bGwsdCl9fSxmdW5jdGlvbih0LGUscil7dC5leHBvcnRzPXIoOTUpfSxmdW5jdGlvbih0LGUscil7dC5leHBvcnRzPXIoMjMpfSxmdW5jdGlvbih0LGUscil7dC5leHBvcnRzPXIoOTQpLlRyYW5zZm9ybX0sZnVuY3Rpb24odCxlLHIpe3QuZXhwb3J0cz1yKDk0KS5QYXNzVGhyb3VnaH0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDYwKSxvPXIoMTIpLGE9cigzNikscz1bXS5qb2luLHU9aSE9T2JqZWN0LGM9YShcImpvaW5cIixcIixcIik7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6dXx8Y30se2pvaW46ZnVuY3Rpb24odCl7cmV0dXJuIHMuY2FsbChvKHRoaXMpLHZvaWQgMD09PXQ/XCIsXCI6dCl9fSl9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybi0xIT09RnVuY3Rpb24udG9TdHJpbmcuY2FsbCh0KS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDgwKTtmdW5jdGlvbiBpKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIG8oZSxyLGEpe3JldHVybiBpKCk/dC5leHBvcnRzPW89UmVmbGVjdC5jb25zdHJ1Y3Q6dC5leHBvcnRzPW89ZnVuY3Rpb24odCxlLHIpe3ZhciBpPVtudWxsXTtpLnB1c2guYXBwbHkoaSxlKTt2YXIgbz1uZXcoRnVuY3Rpb24uYmluZC5hcHBseSh0LGkpKTtyZXR1cm4gciYmbihvLHIucHJvdG90eXBlKSxvfSxvLmFwcGx5KG51bGwsYXJndW1lbnRzKX10LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDY2KS5pbmRleE9mLG89cigzNiksYT1bXS5pbmRleE9mLHM9ISFhJiYxL1sxXS5pbmRleE9mKDEsLTApPDAsdT1vKFwiaW5kZXhPZlwiKTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDpzfHx1fSx7aW5kZXhPZjpmdW5jdGlvbih0KXtyZXR1cm4gcz9hLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8MDppKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLnIoZSk7cig5OCkscigxNDkpLHIoMTUwKSxyKDUxKSxyKDUyKSxyKDM1KSxyKDc0KSxyKDc1KSxyKDc5KTt2YXIgbj1yKDApLGk9ci5uKG4pLG89KHIoMjgpLHIoMSkpLGE9ci5uKG8pLHM9cigxOCksdT1yLm4ocyksYz1yKDMwKSxmPXIubihjKSxsPXIoNDApLGg9ci5uKGwpLHA9cigxNiksZD1yLm4ocCksdj1yKDU3KSxnPXIubih2KSx5PXIoNDEpLGI9ci5uKHkpLF89KHIoODEpLHIoODQpLHIoODUpLHIoODYpLHIoMzcpLHIoODcpLHIoMTU3KSxyKDE1OCkscigxNTkpLHIoMTYxKSxyKDE2MikscigxMjQpLHIoMTYzKSxyKDE2NSkscigxMjYpLHIoMTI5KSxyKDg5KSxyKDkwKSxyKDQyKSksbT1yLm4oXyksdz1yKDkpLHg9ci5uKHcpLGs9cigxNDMpLEU9ci5uKGspLFM9cig1OCksaj1yLm4oUyksUj0ocigxNzQpLHIoMTMwKSxyKDEzMSkscigxNzYpLGZ1bmN0aW9uKHQpe2Zvcig7dC5lbmRzV2l0aChcIi9cIik7KXQ9dC5zbGljZSgwLC0xKTtyZXR1cm4gdH0pLEM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc3BsaXQoXCIvXCIpLHI9ZVswXSxuPTAsaT0xO2k8ZS5sZW5ndGgtMTtpKyspe249aSxcIlwiPT09ZVtpXSYmKHIrPVwiL1wiKTticmVha31yZXR1cm4gcj1yK1wiL1wiK2VbbisxXStcIi9cIn0sST1mdW5jdGlvbih0KXtyZXR1cm4odD1SKHQpKS5zdWJzdHJpbmcoMCx0Lmxhc3RJbmRleE9mKFwiL1wiKSsxKX0sTz1mdW5jdGlvbih0KXtyZXR1cm4odD1SKHQpKS5zdWJzdHIodC5sYXN0SW5kZXhPZihcIi9cIikrMSl9LFQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxlPW5ldyBBcnJheSh0KSxyPTA7cjx0O3IrKyllW3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gZS5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHQuZW5kc1dpdGgoXCIvXCIpfSkpfSxQPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1uZXcgQXJyYXkodCkscj0wO3I8dDtyKyspZVtyXT1hcmd1bWVudHNbcl07cmV0dXJuIGUuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiF0LmVuZHNXaXRoKFwiL1wiKX0pKX0sQT17Q09OVEFJTkVSOic8aHR0cDovL3d3dy53My5vcmcvbnMvbGRwI0Jhc2ljQ29udGFpbmVyPjsgcmVsPVwidHlwZVwiJyxSRVNPVVJDRTonPGh0dHA6Ly93d3cudzMub3JnL25zL2xkcCNSZXNvdXJjZT47IHJlbD1cInR5cGVcIid9LEw9KHIoOTEpLHIoOTYpKSxGPXIubihMKSxNPXIoNik7Y29uc3R7cmRmOk4seHNkOkJ9PU0uYTt2YXIgRCxVLHE9MDtjbGFzcyBHe2NvbnN0cnVjdG9yKHQpe3RoaXMuaWQ9dH1nZXQgdmFsdWUoKXtyZXR1cm4gdGhpcy5pZH1lcXVhbHModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBHP3RoaXMuaWQ9PT10LmlkOiEhdCYmdGhpcy50ZXJtVHlwZT09PXQudGVybVR5cGUmJnRoaXMudmFsdWU9PT10LnZhbHVlfXRvSlNPTigpe3JldHVybnt0ZXJtVHlwZTp0aGlzLnRlcm1UeXBlLHZhbHVlOnRoaXMudmFsdWV9fX1jbGFzcyBXIGV4dGVuZHMgR3tnZXQgdGVybVR5cGUoKXtyZXR1cm5cIk5hbWVkTm9kZVwifX1jbGFzcyB6IGV4dGVuZHMgR3tnZXQgdGVybVR5cGUoKXtyZXR1cm5cIkxpdGVyYWxcIn1nZXQgdmFsdWUoKXtyZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcoMSx0aGlzLmlkLmxhc3RJbmRleE9mKCdcIicpKX1nZXQgbGFuZ3VhZ2UoKXt2YXIgdD10aGlzLmlkLGU9dC5sYXN0SW5kZXhPZignXCInKSsxO3JldHVybiBlPHQubGVuZ3RoJiZcIkBcIj09PXRbZSsrXT90LnN1YnN0cihlKS50b0xvd2VyQ2FzZSgpOlwiXCJ9Z2V0IGRhdGF0eXBlKCl7cmV0dXJuIG5ldyBXKHRoaXMuZGF0YXR5cGVTdHJpbmcpfWdldCBkYXRhdHlwZVN0cmluZygpe3ZhciB0LGU9dGhpcy5pZCxyPWUubGFzdEluZGV4T2YoJ1wiJykrMTtyZXR1cm4gcjxlLmxlbmd0aCYmXCJeXCI9PT0odD1lW3JdKT9lLnN1YnN0cihyKzIpOlwiQFwiIT09dD9CLnN0cmluZzpOLmxhbmdTdHJpbmd9ZXF1YWxzKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygej90aGlzLmlkPT09dC5pZDohIXQmJiEhdC5kYXRhdHlwZSYmdGhpcy50ZXJtVHlwZT09PXQudGVybVR5cGUmJnRoaXMudmFsdWU9PT10LnZhbHVlJiZ0aGlzLmxhbmd1YWdlPT09dC5sYW5ndWFnZSYmdGhpcy5kYXRhdHlwZS52YWx1ZT09PXQuZGF0YXR5cGUudmFsdWV9dG9KU09OKCl7cmV0dXJue3Rlcm1UeXBlOnRoaXMudGVybVR5cGUsdmFsdWU6dGhpcy52YWx1ZSxsYW5ndWFnZTp0aGlzLmxhbmd1YWdlLGRhdGF0eXBlOnt0ZXJtVHlwZTpcIk5hbWVkTm9kZVwiLHZhbHVlOnRoaXMuZGF0YXR5cGVTdHJpbmd9fX19Y2xhc3MgWSBleHRlbmRzIEd7Y29uc3RydWN0b3IodCl7c3VwZXIoXCJfOlwiK3QpfWdldCB0ZXJtVHlwZSgpe3JldHVyblwiQmxhbmtOb2RlXCJ9Z2V0IHZhbHVlKCl7cmV0dXJuIHRoaXMuaWQuc3Vic3RyKDIpfX1jbGFzcyBRIGV4dGVuZHMgR3tjb25zdHJ1Y3Rvcih0KXtzdXBlcihcIj9cIit0KX1nZXQgdGVybVR5cGUoKXtyZXR1cm5cIlZhcmlhYmxlXCJ9Z2V0IHZhbHVlKCl7cmV0dXJuIHRoaXMuaWQuc3Vic3RyKDEpfX1jbGFzcyAkIGV4dGVuZHMgR3tjb25zdHJ1Y3Rvcigpe3JldHVybiBzdXBlcihcIlwiKSxVfHx0aGlzfWdldCB0ZXJtVHlwZSgpe3JldHVyblwiRGVmYXVsdEdyYXBoXCJ9ZXF1YWxzKHQpe3JldHVybiB0aGlzPT09dHx8ISF0JiZ0aGlzLnRlcm1UeXBlPT09dC50ZXJtVHlwZX19VT1uZXcgJDtjbGFzcyBIe2NvbnN0cnVjdG9yKHQsZSxyLG4pe3RoaXMuc3ViamVjdD10LHRoaXMucHJlZGljYXRlPWUsdGhpcy5vYmplY3Q9cix0aGlzLmdyYXBoPW58fFV9dG9KU09OKCl7cmV0dXJue3N1YmplY3Q6dGhpcy5zdWJqZWN0LnRvSlNPTigpLHByZWRpY2F0ZTp0aGlzLnByZWRpY2F0ZS50b0pTT04oKSxvYmplY3Q6dGhpcy5vYmplY3QudG9KU09OKCksZ3JhcGg6dGhpcy5ncmFwaC50b0pTT04oKX19ZXF1YWxzKHQpe3JldHVybiEhdCYmdGhpcy5zdWJqZWN0LmVxdWFscyh0LnN1YmplY3QpJiZ0aGlzLnByZWRpY2F0ZS5lcXVhbHModC5wcmVkaWNhdGUpJiZ0aGlzLm9iamVjdC5lcXVhbHModC5vYmplY3QpJiZ0aGlzLmdyYXBoLmVxdWFscyh0LmdyYXBoKX19dmFyIEs9RD17bmFtZWROb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVyh0KX0sYmxhbmtOb2RlOmZ1bmN0aW9uKHQpe3R8fCh0PVwibjMtXCIrcSsrKTtyZXR1cm4gbmV3IFkodCl9LHZhcmlhYmxlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUSh0KX0sbGl0ZXJhbDpmdW5jdGlvbih0LGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBuZXcgeignXCInK3QrJ1wiQCcrZS50b0xvd2VyQ2FzZSgpKTtsZXQgcj1lP2UudmFsdWU6XCJcIjtcIlwiPT09ciYmKFwiYm9vbGVhblwiPT10eXBlb2YgdD9yPUIuYm9vbGVhbjpcIm51bWJlclwiPT10eXBlb2YgdCYmKE51bWJlci5pc0Zpbml0ZSh0KT9yPU51bWJlci5pc0ludGVnZXIodCk/Qi5pbnRlZ2VyOkIuZG91YmxlOihyPUIuZG91YmxlLE51bWJlci5pc05hTih0KXx8KHQ9dD4wP1wiSU5GXCI6XCItSU5GXCIpKSkpO3JldHVyblwiXCI9PT1yfHxyPT09Qi5zdHJpbmc/bmV3IHooJ1wiJyt0KydcIicpOm5ldyB6KCdcIicrdCsnXCJeXicrcil9LGRlZmF1bHRHcmFwaDpmdW5jdGlvbigpe3JldHVybiBVfSxxdWFkOlYsdHJpcGxlOlYsaW50ZXJuYWw6e1Rlcm06RyxOYW1lZE5vZGU6VyxCbGFua05vZGU6WSxWYXJpYWJsZTpRLExpdGVyYWw6eixEZWZhdWx0R3JhcGg6JCxRdWFkOkgsVHJpcGxlOkgsZnJvbUlkOmZ1bmN0aW9uKHQsZSl7aWYoZT1lfHxELCF0KXJldHVybiBlLmRlZmF1bHRHcmFwaCgpO3N3aXRjaCh0WzBdKXtjYXNlXCJfXCI6cmV0dXJuIGUuYmxhbmtOb2RlKHQuc3Vic3RyKDIpKTtjYXNlXCI/XCI6cmV0dXJuIGUudmFyaWFibGUodC5zdWJzdHIoMSkpO2Nhc2UnXCInOmlmKGU9PT1EKXJldHVybiBuZXcgeih0KTtpZignXCInPT09dFt0Lmxlbmd0aC0xXSlyZXR1cm4gZS5saXRlcmFsKHQuc3Vic3RyKDEsdC5sZW5ndGgtMikpO3ZhciByPXQubGFzdEluZGV4T2YoJ1wiJyx0Lmxlbmd0aC0xKTtyZXR1cm4gZS5saXRlcmFsKHQuc3Vic3RyKDEsci0xKSxcIkBcIj09PXRbcisxXT90LnN1YnN0cihyKzIpOmUubmFtZWROb2RlKHQuc3Vic3RyKHIrMykpKTtkZWZhdWx0OnJldHVybiBlLm5hbWVkTm9kZSh0KX19LHRvSWQ6ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIHQ7aWYodCBpbnN0YW5jZW9mIEcpcmV0dXJuIHQuaWQ7aWYoIXQpcmV0dXJuIFUuaWQ7c3dpdGNoKHQudGVybVR5cGUpe2Nhc2VcIk5hbWVkTm9kZVwiOnJldHVybiB0LnZhbHVlO2Nhc2VcIkJsYW5rTm9kZVwiOnJldHVyblwiXzpcIit0LnZhbHVlO2Nhc2VcIlZhcmlhYmxlXCI6cmV0dXJuXCI/XCIrdC52YWx1ZTtjYXNlXCJEZWZhdWx0R3JhcGhcIjpyZXR1cm5cIlwiO2Nhc2VcIkxpdGVyYWxcIjpyZXR1cm4nXCInK3QudmFsdWUrJ1wiJysodC5sYW5ndWFnZT9cIkBcIit0Lmxhbmd1YWdlOnQuZGF0YXR5cGUmJnQuZGF0YXR5cGUudmFsdWUhPT1CLnN0cmluZz9cIl5eXCIrdC5kYXRhdHlwZS52YWx1ZTpcIlwiKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdGVybVR5cGU6IFwiK3QudGVybVR5cGUpfX19fTtmdW5jdGlvbiBWKHQsZSxyLG4pe3JldHVybiBuZXcgSCh0LGUscixuKX12YXIgWj1yKDE0NSksSj0wLFg9MDtjbGFzcyB0dHtjb25zdHJ1Y3Rvcih0KXt0aGlzLl9jb250ZXh0U3RhY2s9W10sdGhpcy5fZ3JhcGg9bnVsbCx0PXR8fHt9LHRoaXMuX3NldEJhc2UodC5iYXNlSVJJKSx0LmZhY3RvcnkmJnJ0KHRoaXMsdC5mYWN0b3J5KTt2YXIgZT1cInN0cmluZ1wiPT10eXBlb2YgdC5mb3JtYXQ/dC5mb3JtYXQubWF0Y2goL1xcdyokLylbMF0udG9Mb3dlckNhc2UoKTpcIlwiLHI9XCJ0dXJ0bGVcIj09PWUsbj1cInRyaWdcIj09PWUsaT0vdHJpcGxlLy50ZXN0KGUpLG89L3F1YWQvLnRlc3QoZSksYT10aGlzLl9uM01vZGU9L24zLy50ZXN0KGUpLHM9aXx8bzsodGhpcy5fc3VwcG9ydHNOYW1lZEdyYXBocz0hKHJ8fGEpKXx8KHRoaXMuX3JlYWRQcmVkaWNhdGVPck5hbWVkR3JhcGg9dGhpcy5fcmVhZFByZWRpY2F0ZSksdGhpcy5fc3VwcG9ydHNRdWFkcz0hKHJ8fG58fGl8fGEpLHMmJih0aGlzLl9yZXNvbHZlUmVsYXRpdmVJUkk9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGx9KSx0aGlzLl9ibGFua05vZGVQcmVmaXg9XCJzdHJpbmdcIiE9dHlwZW9mIHQuYmxhbmtOb2RlUHJlZml4P1wiXCI6dC5ibGFua05vZGVQcmVmaXgucmVwbGFjZSgvXig/IV86KS8sXCJfOlwiKSx0aGlzLl9sZXhlcj10LmxleGVyfHxuZXcgWi5hKHtsaW5lTW9kZTpzLG4zOmF9KSx0aGlzLl9leHBsaWNpdFF1YW50aWZpZXJzPSEhdC5leHBsaWNpdFF1YW50aWZpZXJzfXN0YXRpYyBfcmVzZXRCbGFua05vZGVJZHMoKXtKPVg9MH1fYmxhbmsoKXtyZXR1cm4gdGhpcy5fYmxhbmtOb2RlKFwiYlwiK1grKyl9X3NldEJhc2UodCl7aWYodCl7dmFyIGU9dC5pbmRleE9mKFwiI1wiKTtlPj0wJiYodD10LnN1YnN0cigwLGUpKSx0aGlzLl9iYXNlPXQsdGhpcy5fYmFzZVBhdGg9dC5pbmRleE9mKFwiL1wiKTwwP3Q6dC5yZXBsYWNlKC9bXlxcLz9dKig/OlxcPy4qKT8kLyxcIlwiKSx0PXQubWF0Y2goL14oPzooW2Etel1bYS16MC05Ky4tXSo6KSk/KD86XFwvXFwvW15cXC9dKik/L2kpLHRoaXMuX2Jhc2VSb290PXRbMF0sdGhpcy5fYmFzZVNjaGVtZT10WzFdfWVsc2UgdGhpcy5fYmFzZT1cIlwiLHRoaXMuX2Jhc2VQYXRoPVwiXCJ9X3NhdmVDb250ZXh0KHQsZSxyLG4saSl7dmFyIG89dGhpcy5fbjNNb2RlO3RoaXMuX2NvbnRleHRTdGFjay5wdXNoKHtzdWJqZWN0OnIscHJlZGljYXRlOm4sb2JqZWN0OmksZ3JhcGg6ZSx0eXBlOnQsaW52ZXJzZTohIW8mJnRoaXMuX2ludmVyc2VQcmVkaWNhdGUsYmxhbmtQcmVmaXg6bz90aGlzLl9wcmVmaXhlcy5fOlwiXCIscXVhbnRpZmllZDpvP3RoaXMuX3F1YW50aWZpZWQ6bnVsbH0pLG8mJih0aGlzLl9pbnZlcnNlUHJlZGljYXRlPSExLHRoaXMuX3ByZWZpeGVzLl89dGhpcy5fZ3JhcGg/dGhpcy5fZ3JhcGguaWQuc3Vic3RyKDIpK1wiLlwiOlwiLlwiLHRoaXMuX3F1YW50aWZpZWQ9T2JqZWN0LmNyZWF0ZSh0aGlzLl9xdWFudGlmaWVkKSl9X3Jlc3RvcmVDb250ZXh0KCl7dmFyIHQ9dGhpcy5fY29udGV4dFN0YWNrLnBvcCgpLGU9dGhpcy5fbjNNb2RlO3RoaXMuX3N1YmplY3Q9dC5zdWJqZWN0LHRoaXMuX3ByZWRpY2F0ZT10LnByZWRpY2F0ZSx0aGlzLl9vYmplY3Q9dC5vYmplY3QsdGhpcy5fZ3JhcGg9dC5ncmFwaCxlJiYodGhpcy5faW52ZXJzZVByZWRpY2F0ZT10LmludmVyc2UsdGhpcy5fcHJlZml4ZXMuXz10LmJsYW5rUHJlZml4LHRoaXMuX3F1YW50aWZpZWQ9dC5xdWFudGlmaWVkKX1fcmVhZEluVG9wQ29udGV4dCh0KXtzd2l0Y2godC50eXBlKXtjYXNlXCJlb2ZcIjpyZXR1cm4gbnVsbCE9PXRoaXMuX2dyYXBoP3RoaXMuX2Vycm9yKFwiVW5jbG9zZWQgZ3JhcGhcIix0KTooZGVsZXRlIHRoaXMuX3ByZWZpeGVzLl8sdGhpcy5fY2FsbGJhY2sobnVsbCxudWxsLHRoaXMuX3ByZWZpeGVzKSk7Y2FzZVwiUFJFRklYXCI6dGhpcy5fc3BhcnFsU3R5bGU9ITA7Y2FzZVwiQHByZWZpeFwiOnJldHVybiB0aGlzLl9yZWFkUHJlZml4O2Nhc2VcIkJBU0VcIjp0aGlzLl9zcGFycWxTdHlsZT0hMDtjYXNlXCJAYmFzZVwiOnJldHVybiB0aGlzLl9yZWFkQmFzZUlSSTtjYXNlXCJ7XCI6aWYodGhpcy5fc3VwcG9ydHNOYW1lZEdyYXBocylyZXR1cm4gdGhpcy5fZ3JhcGg9XCJcIix0aGlzLl9zdWJqZWN0PW51bGwsdGhpcy5fcmVhZFN1YmplY3Q7Y2FzZVwiR1JBUEhcIjppZih0aGlzLl9zdXBwb3J0c05hbWVkR3JhcGhzKXJldHVybiB0aGlzLl9yZWFkTmFtZWRHcmFwaExhYmVsO2RlZmF1bHQ6cmV0dXJuIHRoaXMuX3JlYWRTdWJqZWN0KHQpfX1fcmVhZEVudGl0eSh0LGUpe3ZhciByO3N3aXRjaCh0LnR5cGUpe2Nhc2VcIklSSVwiOmNhc2VcInR5cGVJUklcIjp2YXIgbj10aGlzLl9yZXNvbHZlSVJJKHQudmFsdWUpO2lmKG51bGw9PT1uKXJldHVybiB0aGlzLl9lcnJvcihcIkludmFsaWQgSVJJXCIsdCk7cj10aGlzLl9uYW1lZE5vZGUobik7YnJlYWs7Y2FzZVwidHlwZVwiOmNhc2VcInByZWZpeGVkXCI6dmFyIGk9dGhpcy5fcHJlZml4ZXNbdC5wcmVmaXhdO2lmKHZvaWQgMD09PWkpcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmRlZmluZWQgcHJlZml4IFwiJyt0LnByZWZpeCsnOlwiJyx0KTtyPXRoaXMuX25hbWVkTm9kZShpK3QudmFsdWUpO2JyZWFrO2Nhc2VcImJsYW5rXCI6cj10aGlzLl9ibGFua05vZGUodGhpcy5fcHJlZml4ZXNbdC5wcmVmaXhdK3QudmFsdWUpO2JyZWFrO2Nhc2VcInZhclwiOnI9dGhpcy5fdmFyaWFibGUodC52YWx1ZS5zdWJzdHIoMSkpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIHRoaXMuX2Vycm9yKFwiRXhwZWN0ZWQgZW50aXR5IGJ1dCBnb3QgXCIrdC50eXBlLHQpfXJldHVybiFlJiZ0aGlzLl9uM01vZGUmJnIuaWQgaW4gdGhpcy5fcXVhbnRpZmllZCYmKHI9dGhpcy5fcXVhbnRpZmllZFtyLmlkXSkscn1fcmVhZFN1YmplY3QodCl7c3dpdGNoKHRoaXMuX3ByZWRpY2F0ZT1udWxsLHQudHlwZSl7Y2FzZVwiW1wiOnJldHVybiB0aGlzLl9zYXZlQ29udGV4dChcImJsYW5rXCIsdGhpcy5fZ3JhcGgsdGhpcy5fc3ViamVjdD10aGlzLl9ibGFuaygpLG51bGwsbnVsbCksdGhpcy5fcmVhZEJsYW5rTm9kZUhlYWQ7Y2FzZVwiKFwiOnJldHVybiB0aGlzLl9zYXZlQ29udGV4dChcImxpc3RcIix0aGlzLl9ncmFwaCx0aGlzLlJERl9OSUwsbnVsbCxudWxsKSx0aGlzLl9zdWJqZWN0PW51bGwsdGhpcy5fcmVhZExpc3RJdGVtO2Nhc2VcIntcIjpyZXR1cm4gdGhpcy5fbjNNb2RlPyh0aGlzLl9zYXZlQ29udGV4dChcImZvcm11bGFcIix0aGlzLl9ncmFwaCx0aGlzLl9ncmFwaD10aGlzLl9ibGFuaygpLG51bGwsbnVsbCksdGhpcy5fcmVhZFN1YmplY3QpOnRoaXMuX2Vycm9yKFwiVW5leHBlY3RlZCBncmFwaFwiLHQpO2Nhc2VcIn1cIjpyZXR1cm4gdGhpcy5fcmVhZFB1bmN0dWF0aW9uKHQpO2Nhc2VcIkBmb3JTb21lXCI6cmV0dXJuIHRoaXMuX24zTW9kZT8odGhpcy5fc3ViamVjdD1udWxsLHRoaXMuX3ByZWRpY2F0ZT10aGlzLk4zX0ZPUlNPTUUsdGhpcy5fcXVhbnRpZmllcj10aGlzLl9ibGFua05vZGUsdGhpcy5fcmVhZFF1YW50aWZpZXJMaXN0KTp0aGlzLl9lcnJvcignVW5leHBlY3RlZCBcIkBmb3JTb21lXCInLHQpO2Nhc2VcIkBmb3JBbGxcIjpyZXR1cm4gdGhpcy5fbjNNb2RlPyh0aGlzLl9zdWJqZWN0PW51bGwsdGhpcy5fcHJlZGljYXRlPXRoaXMuTjNfRk9SQUxMLHRoaXMuX3F1YW50aWZpZXI9dGhpcy5fdmFyaWFibGUsdGhpcy5fcmVhZFF1YW50aWZpZXJMaXN0KTp0aGlzLl9lcnJvcignVW5leHBlY3RlZCBcIkBmb3JBbGxcIicsdCk7ZGVmYXVsdDppZih2b2lkIDA9PT0odGhpcy5fc3ViamVjdD10aGlzLl9yZWFkRW50aXR5KHQpKSlyZXR1cm47aWYodGhpcy5fbjNNb2RlKXJldHVybiB0aGlzLl9nZXRQYXRoUmVhZGVyKHRoaXMuX3JlYWRQcmVkaWNhdGVPck5hbWVkR3JhcGgpfXJldHVybiB0aGlzLl9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBofV9yZWFkUHJlZGljYXRlKHQpe3ZhciBlPXQudHlwZTtzd2l0Y2goZSl7Y2FzZVwiaW52ZXJzZVwiOnRoaXMuX2ludmVyc2VQcmVkaWNhdGU9ITA7Y2FzZVwiYWJicmV2aWF0aW9uXCI6dGhpcy5fcHJlZGljYXRlPXRoaXMuQUJCUkVWSUFUSU9OU1t0LnZhbHVlXTticmVhaztjYXNlXCIuXCI6Y2FzZVwiXVwiOmNhc2VcIn1cIjpyZXR1cm4gbnVsbD09PXRoaXMuX3ByZWRpY2F0ZT90aGlzLl9lcnJvcihcIlVuZXhwZWN0ZWQgXCIrZSx0KToodGhpcy5fc3ViamVjdD1udWxsLFwiXVwiPT09ZT90aGlzLl9yZWFkQmxhbmtOb2RlVGFpbCh0KTp0aGlzLl9yZWFkUHVuY3R1YXRpb24odCkpO2Nhc2VcIjtcIjpyZXR1cm4gbnVsbCE9PXRoaXMuX3ByZWRpY2F0ZT90aGlzLl9yZWFkUHJlZGljYXRlOnRoaXMuX2Vycm9yKFwiRXhwZWN0ZWQgcHJlZGljYXRlIGJ1dCBnb3QgO1wiLHQpO2Nhc2VcImJsYW5rXCI6aWYoIXRoaXMuX24zTW9kZSlyZXR1cm4gdGhpcy5fZXJyb3IoXCJEaXNhbGxvd2VkIGJsYW5rIG5vZGUgYXMgcHJlZGljYXRlXCIsdCk7ZGVmYXVsdDppZih2b2lkIDA9PT0odGhpcy5fcHJlZGljYXRlPXRoaXMuX3JlYWRFbnRpdHkodCkpKXJldHVybn1yZXR1cm4gdGhpcy5fcmVhZE9iamVjdH1fcmVhZE9iamVjdCh0KXtzd2l0Y2godC50eXBlKXtjYXNlXCJsaXRlcmFsXCI6aWYoMD09PXQucHJlZml4Lmxlbmd0aClyZXR1cm4gdGhpcy5fbGl0ZXJhbFZhbHVlPXQudmFsdWUsdGhpcy5fcmVhZERhdGFUeXBlT3JMYW5nO3RoaXMuX29iamVjdD10aGlzLl9saXRlcmFsKHQudmFsdWUsdGhpcy5fbmFtZWROb2RlKHQucHJlZml4KSk7YnJlYWs7Y2FzZVwiW1wiOnJldHVybiB0aGlzLl9zYXZlQ29udGV4dChcImJsYW5rXCIsdGhpcy5fZ3JhcGgsdGhpcy5fc3ViamVjdCx0aGlzLl9wcmVkaWNhdGUsdGhpcy5fc3ViamVjdD10aGlzLl9ibGFuaygpKSx0aGlzLl9yZWFkQmxhbmtOb2RlSGVhZDtjYXNlXCIoXCI6cmV0dXJuIHRoaXMuX3NhdmVDb250ZXh0KFwibGlzdFwiLHRoaXMuX2dyYXBoLHRoaXMuX3N1YmplY3QsdGhpcy5fcHJlZGljYXRlLHRoaXMuUkRGX05JTCksdGhpcy5fc3ViamVjdD1udWxsLHRoaXMuX3JlYWRMaXN0SXRlbTtjYXNlXCJ7XCI6cmV0dXJuIHRoaXMuX24zTW9kZT8odGhpcy5fc2F2ZUNvbnRleHQoXCJmb3JtdWxhXCIsdGhpcy5fZ3JhcGgsdGhpcy5fc3ViamVjdCx0aGlzLl9wcmVkaWNhdGUsdGhpcy5fZ3JhcGg9dGhpcy5fYmxhbmsoKSksdGhpcy5fcmVhZFN1YmplY3QpOnRoaXMuX2Vycm9yKFwiVW5leHBlY3RlZCBncmFwaFwiLHQpO2RlZmF1bHQ6aWYodm9pZCAwPT09KHRoaXMuX29iamVjdD10aGlzLl9yZWFkRW50aXR5KHQpKSlyZXR1cm47aWYodGhpcy5fbjNNb2RlKXJldHVybiB0aGlzLl9nZXRQYXRoUmVhZGVyKHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKSl9cmV0dXJuIHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKX1fcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaCh0KXtyZXR1cm5cIntcIj09PXQudHlwZT90aGlzLl9yZWFkR3JhcGgodCk6dGhpcy5fcmVhZFByZWRpY2F0ZSh0KX1fcmVhZEdyYXBoKHQpe3JldHVyblwie1wiIT09dC50eXBlP3RoaXMuX2Vycm9yKFwiRXhwZWN0ZWQgZ3JhcGggYnV0IGdvdCBcIit0LnR5cGUsdCk6KHRoaXMuX2dyYXBoPXRoaXMuX3N1YmplY3QsdGhpcy5fc3ViamVjdD1udWxsLHRoaXMuX3JlYWRTdWJqZWN0KX1fcmVhZEJsYW5rTm9kZUhlYWQodCl7cmV0dXJuXCJdXCI9PT10LnR5cGU/KHRoaXMuX3N1YmplY3Q9bnVsbCx0aGlzLl9yZWFkQmxhbmtOb2RlVGFpbCh0KSk6KHRoaXMuX3ByZWRpY2F0ZT1udWxsLHRoaXMuX3JlYWRQcmVkaWNhdGUodCkpfV9yZWFkQmxhbmtOb2RlVGFpbCh0KXtpZihcIl1cIiE9PXQudHlwZSlyZXR1cm4gdGhpcy5fcmVhZEJsYW5rTm9kZVB1bmN0dWF0aW9uKHQpO251bGwhPT10aGlzLl9zdWJqZWN0JiZ0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5fcHJlZGljYXRlLHRoaXMuX29iamVjdCx0aGlzLl9ncmFwaCk7dmFyIGU9bnVsbD09PXRoaXMuX3ByZWRpY2F0ZTtyZXR1cm4gdGhpcy5fcmVzdG9yZUNvbnRleHQoKSxudWxsPT09dGhpcy5fb2JqZWN0P2U/dGhpcy5fcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaDp0aGlzLl9yZWFkUHJlZGljYXRlQWZ0ZXJCbGFuazp0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCl9X3JlYWRQcmVkaWNhdGVBZnRlckJsYW5rKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIi5cIjpjYXNlXCJ9XCI6cmV0dXJuIHRoaXMuX3N1YmplY3Q9bnVsbCx0aGlzLl9yZWFkUHVuY3R1YXRpb24odCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5fcmVhZFByZWRpY2F0ZSh0KX19X3JlYWRMaXN0SXRlbSh0KXt2YXIgZT1udWxsLHI9bnVsbCxuPXRoaXMuX3N1YmplY3QsaT10aGlzLl9jb250ZXh0U3RhY2ssbz1pW2kubGVuZ3RoLTFdLGE9dGhpcy5fcmVhZExpc3RJdGVtO3N3aXRjaCh0LnR5cGUpe2Nhc2VcIltcIjp0aGlzLl9zYXZlQ29udGV4dChcImJsYW5rXCIsdGhpcy5fZ3JhcGgscj10aGlzLl9ibGFuaygpLHRoaXMuUkRGX0ZJUlNULHRoaXMuX3N1YmplY3Q9ZT10aGlzLl9ibGFuaygpKSxhPXRoaXMuX3JlYWRCbGFua05vZGVIZWFkO2JyZWFrO2Nhc2VcIihcIjp0aGlzLl9zYXZlQ29udGV4dChcImxpc3RcIix0aGlzLl9ncmFwaCxyPXRoaXMuX2JsYW5rKCksdGhpcy5SREZfRklSU1QsdGhpcy5SREZfTklMKSx0aGlzLl9zdWJqZWN0PW51bGw7YnJlYWs7Y2FzZVwiKVwiOmlmKHRoaXMuX3Jlc3RvcmVDb250ZXh0KCksMCE9PWkubGVuZ3RoJiZcImxpc3RcIj09PWlbaS5sZW5ndGgtMV0udHlwZSYmdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LHRoaXMuX3ByZWRpY2F0ZSx0aGlzLl9vYmplY3QsdGhpcy5fZ3JhcGgpLG51bGw9PT10aGlzLl9wcmVkaWNhdGUpe2lmKGE9dGhpcy5fcmVhZFByZWRpY2F0ZSx0aGlzLl9zdWJqZWN0PT09dGhpcy5SREZfTklMKXJldHVybiBhfWVsc2UgaWYoYT10aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCksdGhpcy5fb2JqZWN0PT09dGhpcy5SREZfTklMKXJldHVybiBhO3I9dGhpcy5SREZfTklMO2JyZWFrO2Nhc2VcImxpdGVyYWxcIjowPT09dC5wcmVmaXgubGVuZ3RoPyh0aGlzLl9saXRlcmFsVmFsdWU9dC52YWx1ZSxhPXRoaXMuX3JlYWRMaXN0SXRlbURhdGFUeXBlT3JMYW5nKTooZT10aGlzLl9saXRlcmFsKHQudmFsdWUsdGhpcy5fbmFtZWROb2RlKHQucHJlZml4KSksYT10aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCkpO2JyZWFrO2RlZmF1bHQ6aWYodm9pZCAwPT09KGU9dGhpcy5fcmVhZEVudGl0eSh0KSkpcmV0dXJufWlmKG51bGw9PT1yJiYodGhpcy5fc3ViamVjdD1yPXRoaXMuX2JsYW5rKCkpLG51bGw9PT1uP251bGw9PT1vLnByZWRpY2F0ZT9vLnN1YmplY3Q9cjpvLm9iamVjdD1yOnRoaXMuX2VtaXQobix0aGlzLlJERl9SRVNULHIsdGhpcy5fZ3JhcGgpLG51bGwhPT1lKXtpZih0aGlzLl9uM01vZGUmJihcIklSSVwiPT09dC50eXBlfHxcInByZWZpeGVkXCI9PT10LnR5cGUpKXJldHVybiB0aGlzLl9zYXZlQ29udGV4dChcIml0ZW1cIix0aGlzLl9ncmFwaCxyLHRoaXMuUkRGX0ZJUlNULGUpLHRoaXMuX3N1YmplY3Q9ZSx0aGlzLl9wcmVkaWNhdGU9bnVsbCx0aGlzLl9nZXRQYXRoUmVhZGVyKHRoaXMuX3JlYWRMaXN0SXRlbSk7dGhpcy5fZW1pdChyLHRoaXMuUkRGX0ZJUlNULGUsdGhpcy5fZ3JhcGgpfXJldHVybiBhfV9yZWFkRGF0YVR5cGVPckxhbmcodCl7cmV0dXJuIHRoaXMuX2NvbXBsZXRlTGl0ZXJhbCh0LCExKX1fcmVhZExpc3RJdGVtRGF0YVR5cGVPckxhbmcodCl7cmV0dXJuIHRoaXMuX2NvbXBsZXRlTGl0ZXJhbCh0LCEwKX1fY29tcGxldGVMaXRlcmFsKHQsZSl7c3dpdGNoKHQudHlwZSl7Y2FzZVwidHlwZVwiOmNhc2VcInR5cGVJUklcIjp2YXIgcj10aGlzLl9yZWFkRW50aXR5KHQpO2lmKHZvaWQgMD09PXIpcmV0dXJuO3RoaXMuX29iamVjdD10aGlzLl9saXRlcmFsKHRoaXMuX2xpdGVyYWxWYWx1ZSxyKSx0PW51bGw7YnJlYWs7Y2FzZVwibGFuZ2NvZGVcIjp0aGlzLl9vYmplY3Q9dGhpcy5fbGl0ZXJhbCh0aGlzLl9saXRlcmFsVmFsdWUsdC52YWx1ZSksdD1udWxsO2JyZWFrO2RlZmF1bHQ6dGhpcy5fb2JqZWN0PXRoaXMuX2xpdGVyYWwodGhpcy5fbGl0ZXJhbFZhbHVlKX1yZXR1cm4gZSYmdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LHRoaXMuUkRGX0ZJUlNULHRoaXMuX29iamVjdCx0aGlzLl9ncmFwaCksbnVsbD09PXQ/dGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpOih0aGlzLl9yZWFkQ2FsbGJhY2s9dGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpLHRoaXMuX3JlYWRDYWxsYmFjayh0KSl9X3JlYWRGb3JtdWxhVGFpbCh0KXtyZXR1cm5cIn1cIiE9PXQudHlwZT90aGlzLl9yZWFkUHVuY3R1YXRpb24odCk6KG51bGwhPT10aGlzLl9zdWJqZWN0JiZ0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5fcHJlZGljYXRlLHRoaXMuX29iamVjdCx0aGlzLl9ncmFwaCksdGhpcy5fcmVzdG9yZUNvbnRleHQoKSxudWxsPT09dGhpcy5fb2JqZWN0P3RoaXMuX3JlYWRQcmVkaWNhdGU6dGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpKX1fcmVhZFB1bmN0dWF0aW9uKHQpe3ZhciBlLHI9dGhpcy5fc3ViamVjdCxuPXRoaXMuX2dyYXBoLGk9dGhpcy5faW52ZXJzZVByZWRpY2F0ZTtzd2l0Y2godC50eXBlKXtjYXNlXCJ9XCI6aWYobnVsbD09PXRoaXMuX2dyYXBoKXJldHVybiB0aGlzLl9lcnJvcihcIlVuZXhwZWN0ZWQgZ3JhcGggY2xvc2luZ1wiLHQpO2lmKHRoaXMuX24zTW9kZSlyZXR1cm4gdGhpcy5fcmVhZEZvcm11bGFUYWlsKHQpO3RoaXMuX2dyYXBoPW51bGw7Y2FzZVwiLlwiOnRoaXMuX3N1YmplY3Q9bnVsbCxlPXRoaXMuX2NvbnRleHRTdGFjay5sZW5ndGg/dGhpcy5fcmVhZFN1YmplY3Q6dGhpcy5fcmVhZEluVG9wQ29udGV4dCxpJiYodGhpcy5faW52ZXJzZVByZWRpY2F0ZT0hMSk7YnJlYWs7Y2FzZVwiO1wiOmU9dGhpcy5fcmVhZFByZWRpY2F0ZTticmVhaztjYXNlXCIsXCI6ZT10aGlzLl9yZWFkT2JqZWN0O2JyZWFrO2RlZmF1bHQ6aWYodGhpcy5fc3VwcG9ydHNRdWFkcyYmbnVsbD09PXRoaXMuX2dyYXBoJiZ2b2lkIDAhPT0obj10aGlzLl9yZWFkRW50aXR5KHQpKSl7ZT10aGlzLl9yZWFkUXVhZFB1bmN0dWF0aW9uO2JyZWFrfXJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgcHVuY3R1YXRpb24gdG8gZm9sbG93IFwiJyt0aGlzLl9vYmplY3QuaWQrJ1wiJyx0KX1pZihudWxsIT09cil7dmFyIG89dGhpcy5fcHJlZGljYXRlLGE9dGhpcy5fb2JqZWN0O2k/dGhpcy5fZW1pdChhLG8scixuKTp0aGlzLl9lbWl0KHIsbyxhLG4pfXJldHVybiBlfV9yZWFkQmxhbmtOb2RlUHVuY3R1YXRpb24odCl7dmFyIGU7c3dpdGNoKHQudHlwZSl7Y2FzZVwiO1wiOmU9dGhpcy5fcmVhZFByZWRpY2F0ZTticmVhaztjYXNlXCIsXCI6ZT10aGlzLl9yZWFkT2JqZWN0O2JyZWFrO2RlZmF1bHQ6cmV0dXJuIHRoaXMuX2Vycm9yKCdFeHBlY3RlZCBwdW5jdHVhdGlvbiB0byBmb2xsb3cgXCInK3RoaXMuX29iamVjdC5pZCsnXCInLHQpfXJldHVybiB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5fcHJlZGljYXRlLHRoaXMuX29iamVjdCx0aGlzLl9ncmFwaCksZX1fcmVhZFF1YWRQdW5jdHVhdGlvbih0KXtyZXR1cm5cIi5cIiE9PXQudHlwZT90aGlzLl9lcnJvcihcIkV4cGVjdGVkIGRvdCB0byBmb2xsb3cgcXVhZFwiLHQpOnRoaXMuX3JlYWRJblRvcENvbnRleHR9X3JlYWRQcmVmaXgodCl7cmV0dXJuXCJwcmVmaXhcIiE9PXQudHlwZT90aGlzLl9lcnJvcihcIkV4cGVjdGVkIHByZWZpeCB0byBmb2xsb3cgQHByZWZpeFwiLHQpOih0aGlzLl9wcmVmaXg9dC52YWx1ZSx0aGlzLl9yZWFkUHJlZml4SVJJKX1fcmVhZFByZWZpeElSSSh0KXtpZihcIklSSVwiIT09dC50eXBlKXJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgSVJJIHRvIGZvbGxvdyBwcmVmaXggXCInK3RoaXMuX3ByZWZpeCsnOlwiJyx0KTt2YXIgZT10aGlzLl9yZWFkRW50aXR5KHQpO3JldHVybiB0aGlzLl9wcmVmaXhlc1t0aGlzLl9wcmVmaXhdPWUudmFsdWUsdGhpcy5fcHJlZml4Q2FsbGJhY2sodGhpcy5fcHJlZml4LGUpLHRoaXMuX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9ufV9yZWFkQmFzZUlSSSh0KXt2YXIgZT1cIklSSVwiPT09dC50eXBlJiZ0aGlzLl9yZXNvbHZlSVJJKHQudmFsdWUpO3JldHVybiBlPyh0aGlzLl9zZXRCYXNlKGUpLHRoaXMuX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9uKTp0aGlzLl9lcnJvcihcIkV4cGVjdGVkIHZhbGlkIElSSSB0byBmb2xsb3cgYmFzZSBkZWNsYXJhdGlvblwiLHQpfV9yZWFkTmFtZWRHcmFwaExhYmVsKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIklSSVwiOmNhc2VcImJsYW5rXCI6Y2FzZVwicHJlZml4ZWRcIjpyZXR1cm4gdGhpcy5fcmVhZFN1YmplY3QodCksdGhpcy5fcmVhZEdyYXBoO2Nhc2VcIltcIjpyZXR1cm4gdGhpcy5fcmVhZE5hbWVkR3JhcGhCbGFua0xhYmVsO2RlZmF1bHQ6cmV0dXJuIHRoaXMuX2Vycm9yKFwiSW52YWxpZCBncmFwaCBsYWJlbFwiLHQpfX1fcmVhZE5hbWVkR3JhcGhCbGFua0xhYmVsKHQpe3JldHVyblwiXVwiIT09dC50eXBlP3RoaXMuX2Vycm9yKFwiSW52YWxpZCBncmFwaCBsYWJlbFwiLHQpOih0aGlzLl9zdWJqZWN0PXRoaXMuX2JsYW5rKCksdGhpcy5fcmVhZEdyYXBoKX1fcmVhZERlY2xhcmF0aW9uUHVuY3R1YXRpb24odCl7cmV0dXJuIHRoaXMuX3NwYXJxbFN0eWxlPyh0aGlzLl9zcGFycWxTdHlsZT0hMSx0aGlzLl9yZWFkSW5Ub3BDb250ZXh0KHQpKTpcIi5cIiE9PXQudHlwZT90aGlzLl9lcnJvcihcIkV4cGVjdGVkIGRlY2xhcmF0aW9uIHRvIGVuZCB3aXRoIGEgZG90XCIsdCk6dGhpcy5fcmVhZEluVG9wQ29udGV4dH1fcmVhZFF1YW50aWZpZXJMaXN0KHQpe3ZhciBlO3N3aXRjaCh0LnR5cGUpe2Nhc2VcIklSSVwiOmNhc2VcInByZWZpeGVkXCI6aWYodm9pZCAwIT09KGU9dGhpcy5fcmVhZEVudGl0eSh0LCEwKSkpYnJlYWs7ZGVmYXVsdDpyZXR1cm4gdGhpcy5fZXJyb3IoXCJVbmV4cGVjdGVkIFwiK3QudHlwZSx0KX1yZXR1cm4gdGhpcy5fZXhwbGljaXRRdWFudGlmaWVycz8obnVsbD09PXRoaXMuX3N1YmplY3Q/dGhpcy5fZW1pdCh0aGlzLl9ncmFwaHx8dGhpcy5ERUZBVUxUR1JBUEgsdGhpcy5fcHJlZGljYXRlLHRoaXMuX3N1YmplY3Q9dGhpcy5fYmxhbmsoKSx0aGlzLlFVQU5USUZJRVJTX0dSQVBIKTp0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5SREZfUkVTVCx0aGlzLl9zdWJqZWN0PXRoaXMuX2JsYW5rKCksdGhpcy5RVUFOVElGSUVSU19HUkFQSCksdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LHRoaXMuUkRGX0ZJUlNULGUsdGhpcy5RVUFOVElGSUVSU19HUkFQSCkpOnRoaXMuX3F1YW50aWZpZWRbZS5pZF09dGhpcy5fcXVhbnRpZmllcihcImJcIitYKyspLHRoaXMuX3JlYWRRdWFudGlmaWVyUHVuY3R1YXRpb259X3JlYWRRdWFudGlmaWVyUHVuY3R1YXRpb24odCl7cmV0dXJuXCIsXCI9PT10LnR5cGU/dGhpcy5fcmVhZFF1YW50aWZpZXJMaXN0Oih0aGlzLl9leHBsaWNpdFF1YW50aWZpZXJzJiYodGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LHRoaXMuUkRGX1JFU1QsdGhpcy5SREZfTklMLHRoaXMuUVVBTlRJRklFUlNfR1JBUEgpLHRoaXMuX3N1YmplY3Q9bnVsbCksdGhpcy5fcmVhZENhbGxiYWNrPXRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKSx0aGlzLl9yZWFkQ2FsbGJhY2sodCkpfV9nZXRQYXRoUmVhZGVyKHQpe3JldHVybiB0aGlzLl9hZnRlclBhdGg9dCx0aGlzLl9yZWFkUGF0aH1fcmVhZFBhdGgodCl7c3dpdGNoKHQudHlwZSl7Y2FzZVwiIVwiOnJldHVybiB0aGlzLl9yZWFkRm9yd2FyZFBhdGg7Y2FzZVwiXlwiOnJldHVybiB0aGlzLl9yZWFkQmFja3dhcmRQYXRoO2RlZmF1bHQ6dmFyIGU9dGhpcy5fY29udGV4dFN0YWNrLHI9ZS5sZW5ndGgmJmVbZS5sZW5ndGgtMV07aWYociYmXCJpdGVtXCI9PT1yLnR5cGUpe3ZhciBuPXRoaXMuX3N1YmplY3Q7dGhpcy5fcmVzdG9yZUNvbnRleHQoKSx0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5SREZfRklSU1Qsbix0aGlzLl9ncmFwaCl9cmV0dXJuIHRoaXMuX2FmdGVyUGF0aCh0KX19X3JlYWRGb3J3YXJkUGF0aCh0KXt2YXIgZSxyLG49dGhpcy5fYmxhbmsoKTtpZih2b2lkIDAhPT0ocj10aGlzLl9yZWFkRW50aXR5KHQpKSlyZXR1cm4gbnVsbD09PXRoaXMuX3ByZWRpY2F0ZT8oZT10aGlzLl9zdWJqZWN0LHRoaXMuX3N1YmplY3Q9bik6KGU9dGhpcy5fb2JqZWN0LHRoaXMuX29iamVjdD1uKSx0aGlzLl9lbWl0KGUscixuLHRoaXMuX2dyYXBoKSx0aGlzLl9yZWFkUGF0aH1fcmVhZEJhY2t3YXJkUGF0aCh0KXt2YXIgZSxyLG49dGhpcy5fYmxhbmsoKTtpZih2b2lkIDAhPT0oZT10aGlzLl9yZWFkRW50aXR5KHQpKSlyZXR1cm4gbnVsbD09PXRoaXMuX3ByZWRpY2F0ZT8ocj10aGlzLl9zdWJqZWN0LHRoaXMuX3N1YmplY3Q9bik6KHI9dGhpcy5fb2JqZWN0LHRoaXMuX29iamVjdD1uKSx0aGlzLl9lbWl0KG4sZSxyLHRoaXMuX2dyYXBoKSx0aGlzLl9yZWFkUGF0aH1fZ2V0Q29udGV4dEVuZFJlYWRlcigpe3ZhciB0PXRoaXMuX2NvbnRleHRTdGFjaztpZighdC5sZW5ndGgpcmV0dXJuIHRoaXMuX3JlYWRQdW5jdHVhdGlvbjtzd2l0Y2godFt0Lmxlbmd0aC0xXS50eXBlKXtjYXNlXCJibGFua1wiOnJldHVybiB0aGlzLl9yZWFkQmxhbmtOb2RlVGFpbDtjYXNlXCJsaXN0XCI6cmV0dXJuIHRoaXMuX3JlYWRMaXN0SXRlbTtjYXNlXCJmb3JtdWxhXCI6cmV0dXJuIHRoaXMuX3JlYWRGb3JtdWxhVGFpbH19X2VtaXQodCxlLHIsbil7dGhpcy5fY2FsbGJhY2sobnVsbCx0aGlzLl9xdWFkKHQsZSxyLG58fHRoaXMuREVGQVVMVEdSQVBIKSl9X2Vycm9yKHQsZSl7dmFyIHI9bmV3IEVycm9yKHQrXCIgb24gbGluZSBcIitlLmxpbmUrXCIuXCIpO3IuY29udGV4dD17dG9rZW46ZSxsaW5lOmUubGluZSxwcmV2aW91c1Rva2VuOnRoaXMuX2xleGVyLnByZXZpb3VzVG9rZW59LHRoaXMuX2NhbGxiYWNrKHIpLHRoaXMuX2NhbGxiYWNrPWV0fV9yZXNvbHZlSVJJKHQpe3JldHVybi9eW2Etel1bYS16MC05Ky4tXSo6L2kudGVzdCh0KT90OnRoaXMuX3Jlc29sdmVSZWxhdGl2ZUlSSSh0KX1fcmVzb2x2ZVJlbGF0aXZlSVJJKHQpe2lmKCF0Lmxlbmd0aClyZXR1cm4gdGhpcy5fYmFzZTtzd2l0Y2godFswXSl7Y2FzZVwiI1wiOnJldHVybiB0aGlzLl9iYXNlK3Q7Y2FzZVwiP1wiOnJldHVybiB0aGlzLl9iYXNlLnJlcGxhY2UoLyg/OlxcPy4qKT8kLyx0KTtjYXNlXCIvXCI6cmV0dXJuKFwiL1wiPT09dFsxXT90aGlzLl9iYXNlU2NoZW1lOnRoaXMuX2Jhc2VSb290KSt0aGlzLl9yZW1vdmVEb3RTZWdtZW50cyh0KTtkZWZhdWx0OnJldHVybi9eW14vOl0qOi8udGVzdCh0KT9udWxsOnRoaXMuX3JlbW92ZURvdFNlZ21lbnRzKHRoaXMuX2Jhc2VQYXRoK3QpfX1fcmVtb3ZlRG90U2VnbWVudHModCl7aWYoIS8oXnxcXC8pXFwuXFwuPygkfFsvIz9dKS8udGVzdCh0KSlyZXR1cm4gdDtmb3IodmFyIGU9XCJcIixyPXQubGVuZ3RoLG49LTEsaT0tMSxvPTAsYT1cIi9cIjtuPHI7KXtzd2l0Y2goYSl7Y2FzZVwiOlwiOmlmKGk8MCYmXCIvXCI9PT10Wysrbl0mJlwiL1wiPT09dFsrK25dKWZvcig7KGk9bisxKTxyJiZcIi9cIiE9PXRbaV07KW49aTticmVhaztjYXNlXCI/XCI6Y2FzZVwiI1wiOm49cjticmVhaztjYXNlXCIvXCI6aWYoXCIuXCI9PT10W24rMV0pc3dpdGNoKGE9dFsxKyArK25dKXtjYXNlXCIvXCI6ZSs9dC5zdWJzdHJpbmcobyxuLTEpLG89bisxO2JyZWFrO2Nhc2Ugdm9pZCAwOmNhc2VcIj9cIjpjYXNlXCIjXCI6cmV0dXJuIGUrdC5zdWJzdHJpbmcobyxuKSt0LnN1YnN0cihuKzEpO2Nhc2VcIi5cIjppZih2b2lkIDA9PT0oYT10WzErICsrbl0pfHxcIi9cIj09PWF8fFwiP1wiPT09YXx8XCIjXCI9PT1hKXtpZigobz0oZSs9dC5zdWJzdHJpbmcobyxuLTIpKS5sYXN0SW5kZXhPZihcIi9cIikpPj1pJiYoZT1lLnN1YnN0cigwLG8pKSxcIi9cIiE9PWEpcmV0dXJuIGUrXCIvXCIrdC5zdWJzdHIobisxKTtvPW4rMX19fWE9dFsrK25dfXJldHVybiBlK3Quc3Vic3RyaW5nKG8pfXBhcnNlKHQsZSxyKXt2YXIgbj10aGlzO2lmKHRoaXMuX3JlYWRDYWxsYmFjaz10aGlzLl9yZWFkSW5Ub3BDb250ZXh0LHRoaXMuX3NwYXJxbFN0eWxlPSExLHRoaXMuX3ByZWZpeGVzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fcHJlZml4ZXMuXz10aGlzLl9ibGFua05vZGVQcmVmaXg/dGhpcy5fYmxhbmtOb2RlUHJlZml4LnN1YnN0cigyKTpcImJcIitKKysrXCJfXCIsdGhpcy5fcHJlZml4Q2FsbGJhY2s9cnx8ZXQsdGhpcy5faW52ZXJzZVByZWRpY2F0ZT0hMSx0aGlzLl9xdWFudGlmaWVkPU9iamVjdC5jcmVhdGUobnVsbCksIWUpe3ZhciBpLG89W107aWYodGhpcy5fY2FsbGJhY2s9ZnVuY3Rpb24odCxlKXt0P2k9dDplJiZvLnB1c2goZSl9LHRoaXMuX2xleGVyLnRva2VuaXplKHQpLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gbi5fcmVhZENhbGxiYWNrPW4uX3JlYWRDYWxsYmFjayh0KX0pKSxpKXRocm93IGk7cmV0dXJuIG99dGhpcy5fY2FsbGJhY2s9ZSx0aGlzLl9sZXhlci50b2tlbml6ZSh0LChmdW5jdGlvbih0LGUpe251bGwhPT10PyhuLl9jYWxsYmFjayh0KSxuLl9jYWxsYmFjaz1ldCk6bi5fcmVhZENhbGxiYWNrJiYobi5fcmVhZENhbGxiYWNrPW4uX3JlYWRDYWxsYmFjayhlKSl9KSl9fWZ1bmN0aW9uIGV0KCl7fWZ1bmN0aW9uIHJ0KHQsZSl7dmFyIHI9ZS5uYW1lZE5vZGU7dC5fbmFtZWROb2RlPXIsdC5fYmxhbmtOb2RlPWUuYmxhbmtOb2RlLHQuX2xpdGVyYWw9ZS5saXRlcmFsLHQuX3ZhcmlhYmxlPWUudmFyaWFibGUsdC5fcXVhZD1lLnF1YWQsdC5ERUZBVUxUR1JBUEg9ZS5kZWZhdWx0R3JhcGgoKSx0LlJERl9GSVJTVD1yKE0uYS5yZGYuZmlyc3QpLHQuUkRGX1JFU1Q9cihNLmEucmRmLnJlc3QpLHQuUkRGX05JTD1yKE0uYS5yZGYubmlsKSx0Lk4zX0ZPUkFMTD1yKE0uYS5yLmZvckFsbCksdC5OM19GT1JTT01FPXIoTS5hLnIuZm9yU29tZSksdC5BQkJSRVZJQVRJT05TPXthOnIoTS5hLnJkZi50eXBlKSxcIj1cIjpyKE0uYS5vd2wuc2FtZUFzKSxcIj5cIjpyKE0uYS5sb2cuaW1wbGllcyl9LHQuUVVBTlRJRklFUlNfR1JBUEg9cihcInVybjpuMzpxdWFudGlmaWVyc1wiKX1ydCh0dC5wcm90b3R5cGUsSyk7dmFyIG50PXIoMTQ2KTtjb25zdHt0b0lkOml0LGZyb21JZDpvdH09Sy5pbnRlcm5hbDtjbGFzcyBhdHtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuX3NpemU9MCx0aGlzLl9ncmFwaHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9pZD0wLHRoaXMuX2lkcz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2lkc1tcIj48XCJdPTAsdGhpcy5fZW50aXRpZXM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ibGFua05vZGVJbmRleD0wLGV8fCF0fHx0WzBdfHwoZT10LHQ9bnVsbCksZT1lfHx7fSx0aGlzLl9mYWN0b3J5PWUuZmFjdG9yeXx8Syx0JiZ0aGlzLmFkZFF1YWRzKHQpfWdldCBzaXplKCl7dmFyIHQ9dGhpcy5fc2l6ZTtpZihudWxsIT09dClyZXR1cm4gdDt0PTA7dmFyIGUscixuPXRoaXMuX2dyYXBocztmb3IodmFyIGkgaW4gbilmb3IodmFyIG8gaW4gZT1uW2ldLnN1YmplY3RzKWZvcih2YXIgYSBpbiByPWVbb10pdCs9T2JqZWN0LmtleXMoclthXSkubGVuZ3RoO3JldHVybiB0aGlzLl9zaXplPXR9X2FkZFRvSW5kZXgodCxlLHIsbil7dmFyIGk9dFtlXXx8KHRbZV09e30pLG89aVtyXXx8KGlbcl09e30pLGE9biBpbiBvO3JldHVybiBhfHwob1tuXT1udWxsKSwhYX1fcmVtb3ZlRnJvbUluZGV4KHQsZSxyLG4pe3ZhciBpLG89dFtlXSxhPW9bcl07Zm9yKGkgaW4gZGVsZXRlIGFbbl0sYSlyZXR1cm47Zm9yKGkgaW4gZGVsZXRlIG9bcl0sbylyZXR1cm47ZGVsZXRlIHRbZV19X2ZpbmRJbkluZGV4KHQsZSxyLG4saSxvLGEscyx1LGMpe3ZhciBmLGwsaCxwPSFlKyFyKyFuPjE/T2JqZWN0LmtleXModGhpcy5faWRzKTp0aGlzLl9lbnRpdGllcztmb3IodmFyIGQgaW4gZSYmKChmPXQsdD17fSlbZV09ZltlXSksdCl7dmFyIHY9cFtkXTtpZihsPXRbZF0pZm9yKHZhciBnIGluIHImJigoZj1sLGw9e30pW3JdPWZbcl0pLGwpe3ZhciB5PXBbZ107aWYoaD1sW2ddKWZvcih2YXIgYj0obj9uIGluIGg/W25dOltdOk9iamVjdC5rZXlzKGgpKSxfPTA7XzxiLmxlbmd0aDtfKyspe3ZhciBtPXtzdWJqZWN0Om51bGwscHJlZGljYXRlOm51bGwsb2JqZWN0Om51bGx9O21baV09b3Qodix0aGlzLl9mYWN0b3J5KSxtW29dPW90KHksdGhpcy5fZmFjdG9yeSksbVthXT1vdChwW2JbX11dLHRoaXMuX2ZhY3RvcnkpO3ZhciB3PXRoaXMuX2ZhY3RvcnkucXVhZChtLnN1YmplY3QsbS5wcmVkaWNhdGUsbS5vYmplY3Qsb3Qocyx0aGlzLl9mYWN0b3J5KSk7aWYoYyljLnB1c2godyk7ZWxzZSBpZih1KHcpKXJldHVybiEwfX19cmV0dXJuIGN9X2xvb3AodCxlKXtmb3IodmFyIHIgaW4gdCllKHIpfV9sb29wQnlLZXkwKHQsZSxyKXt2YXIgbixpO2lmKG49dFtlXSlmb3IoaSBpbiBuKXIoaSl9X2xvb3BCeUtleTEodCxlLHIpe3ZhciBuO2ZvcihuIGluIHQpdFtuXVtlXSYmcihuKX1fbG9vcEJ5MktleXModCxlLHIsbil7dmFyIGksbyxhO2lmKChpPXRbZV0pJiYobz1pW3JdKSlmb3IoYSBpbiBvKW4oYSl9X2NvdW50SW5JbmRleCh0LGUscixuKXt2YXIgaSxvLGEscz0wO2Zvcih2YXIgdSBpbiBlJiYoKGk9dCx0PXt9KVtlXT1pW2VdKSx0KWlmKG89dFt1XSlmb3IodmFyIGMgaW4gciYmKChpPW8sbz17fSlbcl09aVtyXSksbykoYT1vW2NdKSYmKG4/biBpbiBhJiZzKys6cys9T2JqZWN0LmtleXMoYSkubGVuZ3RoKTtyZXR1cm4gc31fZ2V0R3JhcGhzKHQpe2lmKCFzdCh0KSlyZXR1cm4gdGhpcy5fZ3JhcGhzO3ZhciBlPXt9O3JldHVybiBlW3RdPXRoaXMuX2dyYXBoc1t0XSxlfV91bmlxdWVFbnRpdGllcyh0KXt2YXIgZT1PYmplY3QuY3JlYXRlKG51bGwpLHI9dGhpcy5fZW50aXRpZXM7cmV0dXJuIGZ1bmN0aW9uKG4pe24gaW4gZXx8KGVbbl09ITAsdChvdChyW25dKSkpfX1hZGRRdWFkKHQsZSxyLG4pe2V8fChuPXQuZ3JhcGgscj10Lm9iamVjdCxlPXQucHJlZGljYXRlLHQ9dC5zdWJqZWN0KSx0PWl0KHQpLGU9aXQoZSkscj1pdChyKSxuPWl0KG4pO3ZhciBpPXRoaXMuX2dyYXBoc1tuXTtpfHwoaT10aGlzLl9ncmFwaHNbbl09e3N1YmplY3RzOnt9LHByZWRpY2F0ZXM6e30sb2JqZWN0czp7fX0sT2JqZWN0LmZyZWV6ZShpKSk7dmFyIG89dGhpcy5faWRzLGE9dGhpcy5fZW50aXRpZXM7dD1vW3RdfHwob1thWysrdGhpcy5faWRdPXRdPXRoaXMuX2lkKSxlPW9bZV18fChvW2FbKyt0aGlzLl9pZF09ZV09dGhpcy5faWQpLHI9b1tyXXx8KG9bYVsrK3RoaXMuX2lkXT1yXT10aGlzLl9pZCk7dmFyIHM9dGhpcy5fYWRkVG9JbmRleChpLnN1YmplY3RzLHQsZSxyKTtyZXR1cm4gdGhpcy5fYWRkVG9JbmRleChpLnByZWRpY2F0ZXMsZSxyLHQpLHRoaXMuX2FkZFRvSW5kZXgoaS5vYmplY3RzLHIsdCxlKSx0aGlzLl9zaXplPW51bGwsc31hZGRRdWFkcyh0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLmFkZFF1YWQodFtlXSl9aW1wb3J0KHQpe3ZhciBlPXRoaXM7cmV0dXJuIHQub24oXCJkYXRhXCIsKGZ1bmN0aW9uKHQpe2UuYWRkUXVhZCh0KX0pKSx0fXJlbW92ZVF1YWQodCxlLHIsbil7ZXx8KG49dC5ncmFwaCxyPXQub2JqZWN0LGU9dC5wcmVkaWNhdGUsdD10LnN1YmplY3QpLHQ9aXQodCksZT1pdChlKSxyPWl0KHIpLG49aXQobik7dmFyIGksbyxhLHM9dGhpcy5faWRzLHU9dGhpcy5fZ3JhcGhzO2lmKCEoKHQ9c1t0XSkmJihlPXNbZV0pJiYocj1zW3JdKSYmKGk9dVtuXSkmJihvPWkuc3ViamVjdHNbdF0pJiYoYT1vW2VdKSYmciBpbiBhKSlyZXR1cm4hMTtmb3IodCBpbiB0aGlzLl9yZW1vdmVGcm9tSW5kZXgoaS5zdWJqZWN0cyx0LGUsciksdGhpcy5fcmVtb3ZlRnJvbUluZGV4KGkucHJlZGljYXRlcyxlLHIsdCksdGhpcy5fcmVtb3ZlRnJvbUluZGV4KGkub2JqZWN0cyxyLHQsZSksbnVsbCE9PXRoaXMuX3NpemUmJnRoaXMuX3NpemUtLSxpLnN1YmplY3RzKXJldHVybiEwO3JldHVybiBkZWxldGUgdVtuXSwhMH1yZW1vdmVRdWFkcyh0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLnJlbW92ZVF1YWQodFtlXSl9cmVtb3ZlKHQpe3ZhciBlPXRoaXM7cmV0dXJuIHQub24oXCJkYXRhXCIsKGZ1bmN0aW9uKHQpe2UucmVtb3ZlUXVhZCh0KX0pKSx0fXJlbW92ZU1hdGNoZXModCxlLHIsbil7cmV0dXJuIHRoaXMucmVtb3ZlKHRoaXMubWF0Y2godCxlLHIsbikpfWRlbGV0ZUdyYXBoKHQpe3JldHVybiB0aGlzLnJlbW92ZU1hdGNoZXMobnVsbCxudWxsLG51bGwsdCl9Z2V0UXVhZHModCxlLHIsbil7dD10JiZpdCh0KSxlPWUmJml0KGUpLHI9ciYmaXQociksbj1uJiZpdChuKTt2YXIgaSxvLGEscyx1PVtdLGM9dGhpcy5fZ2V0R3JhcGhzKG4pLGY9dGhpcy5faWRzO2lmKHN0KHQpJiYhKG89Zlt0XSl8fHN0KGUpJiYhKGE9ZltlXSl8fHN0KHIpJiYhKHM9ZltyXSkpcmV0dXJuIHU7Zm9yKHZhciBsIGluIGMpKGk9Y1tsXSkmJihvP3M/dGhpcy5fZmluZEluSW5kZXgoaS5vYmplY3RzLHMsbyxhLFwib2JqZWN0XCIsXCJzdWJqZWN0XCIsXCJwcmVkaWNhdGVcIixsLG51bGwsdSk6dGhpcy5fZmluZEluSW5kZXgoaS5zdWJqZWN0cyxvLGEsbnVsbCxcInN1YmplY3RcIixcInByZWRpY2F0ZVwiLFwib2JqZWN0XCIsbCxudWxsLHUpOmE/dGhpcy5fZmluZEluSW5kZXgoaS5wcmVkaWNhdGVzLGEscyxudWxsLFwicHJlZGljYXRlXCIsXCJvYmplY3RcIixcInN1YmplY3RcIixsLG51bGwsdSk6cz90aGlzLl9maW5kSW5JbmRleChpLm9iamVjdHMscyxudWxsLG51bGwsXCJvYmplY3RcIixcInN1YmplY3RcIixcInByZWRpY2F0ZVwiLGwsbnVsbCx1KTp0aGlzLl9maW5kSW5JbmRleChpLnN1YmplY3RzLG51bGwsbnVsbCxudWxsLFwic3ViamVjdFwiLFwicHJlZGljYXRlXCIsXCJvYmplY3RcIixsLG51bGwsdSkpO3JldHVybiB1fW1hdGNoKHQsZSxyLG4pe3ZhciBpPW5ldyBudC5SZWFkYWJsZSh7b2JqZWN0TW9kZTohMH0pO3JldHVybiBpLl9yZWFkPSgpPT57Zm9yKHZhciBvIG9mIHRoaXMuZ2V0UXVhZHModCxlLHIsbikpaS5wdXNoKG8pO2kucHVzaChudWxsKX0saX1jb3VudFF1YWRzKHQsZSxyLG4pe3Q9dCYmaXQodCksZT1lJiZpdChlKSxyPXImJml0KHIpLG49biYmaXQobik7dmFyIGksbyxhLHMsdT0wLGM9dGhpcy5fZ2V0R3JhcGhzKG4pLGY9dGhpcy5faWRzO2lmKHN0KHQpJiYhKG89Zlt0XSl8fHN0KGUpJiYhKGE9ZltlXSl8fHN0KHIpJiYhKHM9ZltyXSkpcmV0dXJuIDA7Zm9yKHZhciBsIGluIGMpKGk9Y1tsXSkmJih1Kz10P3I/dGhpcy5fY291bnRJbkluZGV4KGkub2JqZWN0cyxzLG8sYSk6dGhpcy5fY291bnRJbkluZGV4KGkuc3ViamVjdHMsbyxhLHMpOmU/dGhpcy5fY291bnRJbkluZGV4KGkucHJlZGljYXRlcyxhLHMsbyk6dGhpcy5fY291bnRJbkluZGV4KGkub2JqZWN0cyxzLG8sYSkpO3JldHVybiB1fWZvckVhY2godCxlLHIsbixpKXt0aGlzLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiB0KGUpLCExfSksZSxyLG4saSl9ZXZlcnkodCxlLHIsbixpKXt2YXIgbz0hMSxhPSF0aGlzLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBvPSEwLCF0KGUpfSksZSxyLG4saSk7cmV0dXJuIG8mJmF9c29tZSh0LGUscixuLGkpe2U9ZSYmaXQoZSkscj1yJiZpdChyKSxuPW4mJml0KG4pLGk9aSYmaXQoaSk7dmFyIG8sYSxzLHUsYz10aGlzLl9nZXRHcmFwaHMoaSksZj10aGlzLl9pZHM7aWYoc3QoZSkmJiEoYT1mW2VdKXx8c3QocikmJiEocz1mW3JdKXx8c3QobikmJiEodT1mW25dKSlyZXR1cm4hMTtmb3IodmFyIGwgaW4gYylpZihvPWNbbF0paWYoYSl7aWYodSl7aWYodGhpcy5fZmluZEluSW5kZXgoby5vYmplY3RzLHUsYSxzLFwib2JqZWN0XCIsXCJzdWJqZWN0XCIsXCJwcmVkaWNhdGVcIixsLHQsbnVsbCkpcmV0dXJuITB9ZWxzZSBpZih0aGlzLl9maW5kSW5JbmRleChvLnN1YmplY3RzLGEscyxudWxsLFwic3ViamVjdFwiLFwicHJlZGljYXRlXCIsXCJvYmplY3RcIixsLHQsbnVsbCkpcmV0dXJuITB9ZWxzZSBpZihzKXtpZih0aGlzLl9maW5kSW5JbmRleChvLnByZWRpY2F0ZXMscyx1LG51bGwsXCJwcmVkaWNhdGVcIixcIm9iamVjdFwiLFwic3ViamVjdFwiLGwsdCxudWxsKSlyZXR1cm4hMH1lbHNlIGlmKHUpe2lmKHRoaXMuX2ZpbmRJbkluZGV4KG8ub2JqZWN0cyx1LG51bGwsbnVsbCxcIm9iamVjdFwiLFwic3ViamVjdFwiLFwicHJlZGljYXRlXCIsbCx0LG51bGwpKXJldHVybiEwfWVsc2UgaWYodGhpcy5fZmluZEluSW5kZXgoby5zdWJqZWN0cyxudWxsLG51bGwsbnVsbCxcInN1YmplY3RcIixcInByZWRpY2F0ZVwiLFwib2JqZWN0XCIsbCx0LG51bGwpKXJldHVybiEwO3JldHVybiExfWdldFN1YmplY3RzKHQsZSxyKXt2YXIgbj1bXTtyZXR1cm4gdGhpcy5mb3JTdWJqZWN0cygoZnVuY3Rpb24odCl7bi5wdXNoKHQpfSksdCxlLHIpLG59Zm9yU3ViamVjdHModCxlLHIsbil7ZT1lJiZpdChlKSxyPXImJml0KHIpLG49biYmaXQobik7dmFyIGksbyxhLHM9dGhpcy5faWRzLHU9dGhpcy5fZ2V0R3JhcGhzKG4pO2lmKHQ9dGhpcy5fdW5pcXVlRW50aXRpZXModCksIShzdChlKSYmIShvPXNbZV0pfHxzdChyKSYmIShhPXNbcl0pKSlmb3IobiBpbiB1KShpPXVbbl0pJiYobz9hP3RoaXMuX2xvb3BCeTJLZXlzKGkucHJlZGljYXRlcyxvLGEsdCk6dGhpcy5fbG9vcEJ5S2V5MShpLnN1YmplY3RzLG8sdCk6YT90aGlzLl9sb29wQnlLZXkwKGkub2JqZWN0cyxhLHQpOnRoaXMuX2xvb3AoaS5zdWJqZWN0cyx0KSl9Z2V0UHJlZGljYXRlcyh0LGUscil7dmFyIG49W107cmV0dXJuIHRoaXMuZm9yUHJlZGljYXRlcygoZnVuY3Rpb24odCl7bi5wdXNoKHQpfSksdCxlLHIpLG59Zm9yUHJlZGljYXRlcyh0LGUscixuKXtlPWUmJml0KGUpLHI9ciYmaXQociksbj1uJiZpdChuKTt2YXIgaSxvLGEscz10aGlzLl9pZHMsdT10aGlzLl9nZXRHcmFwaHMobik7aWYodD10aGlzLl91bmlxdWVFbnRpdGllcyh0KSwhKHN0KGUpJiYhKG89c1tlXSl8fHN0KHIpJiYhKGE9c1tyXSkpKWZvcihuIGluIHUpKGk9dVtuXSkmJihvP2E/dGhpcy5fbG9vcEJ5MktleXMoaS5vYmplY3RzLGEsbyx0KTp0aGlzLl9sb29wQnlLZXkwKGkuc3ViamVjdHMsbyx0KTphP3RoaXMuX2xvb3BCeUtleTEoaS5wcmVkaWNhdGVzLGEsdCk6dGhpcy5fbG9vcChpLnByZWRpY2F0ZXMsdCkpfWdldE9iamVjdHModCxlLHIpe3ZhciBuPVtdO3JldHVybiB0aGlzLmZvck9iamVjdHMoKGZ1bmN0aW9uKHQpe24ucHVzaCh0KX0pLHQsZSxyKSxufWZvck9iamVjdHModCxlLHIsbil7ZT1lJiZpdChlKSxyPXImJml0KHIpLG49biYmaXQobik7dmFyIGksbyxhLHM9dGhpcy5faWRzLHU9dGhpcy5fZ2V0R3JhcGhzKG4pO2lmKHQ9dGhpcy5fdW5pcXVlRW50aXRpZXModCksIShzdChlKSYmIShvPXNbZV0pfHxzdChyKSYmIShhPXNbcl0pKSlmb3IobiBpbiB1KShpPXVbbl0pJiYobz9hP3RoaXMuX2xvb3BCeTJLZXlzKGkuc3ViamVjdHMsbyxhLHQpOnRoaXMuX2xvb3BCeUtleTEoaS5vYmplY3RzLG8sdCk6YT90aGlzLl9sb29wQnlLZXkwKGkucHJlZGljYXRlcyxhLHQpOnRoaXMuX2xvb3AoaS5vYmplY3RzLHQpKX1nZXRHcmFwaHModCxlLHIpe3ZhciBuPVtdO3JldHVybiB0aGlzLmZvckdyYXBocygoZnVuY3Rpb24odCl7bi5wdXNoKHQpfSksdCxlLHIpLG59Zm9yR3JhcGhzKHQsZSxyLG4pe2Zvcih2YXIgaSBpbiB0aGlzLl9ncmFwaHMpdGhpcy5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gdChlLmdyYXBoKSwhMH0pLGUscixuLGkpfWNyZWF0ZUJsYW5rTm9kZSh0KXt2YXIgZSxyO2lmKHQpZm9yKGU9dD1cIl86XCIrdCxyPTE7dGhpcy5faWRzW2VdOyllPXQrcisrO2Vsc2UgZG97ZT1cIl86YlwiK3RoaXMuX2JsYW5rTm9kZUluZGV4Kyt9d2hpbGUodGhpcy5faWRzW2VdKTtyZXR1cm4gdGhpcy5faWRzW2VdPSsrdGhpcy5faWQsdGhpcy5fZW50aXRpZXNbdGhpcy5faWRdPWUsdGhpcy5fZmFjdG9yeS5ibGFua05vZGUoZS5zdWJzdHIoMikpfWV4dHJhY3RMaXN0cyh7cmVtb3ZlOnQ9ITEsaWdub3JlRXJyb3JzOmU9ITF9PXt9KXt2YXIgcj17fSxuPWU/KCk9PiEwOih0LGUpPT57dGhyb3cgbmV3IEVycm9yKGAke3QudmFsdWV9ICR7ZX1gKX0saT10aGlzLmdldFF1YWRzKG51bGwsTS5hLnJkZi5yZXN0LE0uYS5yZGYubmlsLG51bGwpLG89dD9bLi4uaV06W107cmV0dXJuIGkuZm9yRWFjaChlPT57Zm9yKHZhciBpLGEscz1bXSx1PSExLGM9ZS5ncmFwaCxmPWUuc3ViamVjdDtmJiYhdTspe3ZhciBsLGgscD10aGlzLmdldFF1YWRzKG51bGwsbnVsbCxmLG51bGwpLGQ9dGhpcy5nZXRRdWFkcyhmLG51bGwsbnVsbCxudWxsKSx2PW51bGwsZz1udWxsLHk9bnVsbDtmb3IobD0wO2w8ZC5sZW5ndGgmJiF1O2wrKykoaD1kW2xdKS5ncmFwaC5lcXVhbHMoYyk/aT91PW4oZixcImhhcyBub24tbGlzdCBhcmNzIG91dFwiKTpoLnByZWRpY2F0ZS52YWx1ZT09PU0uYS5yZGYuZmlyc3Q/dj91PW4oZixcImhhcyBtdWx0aXBsZSByZGY6Zmlyc3QgYXJjc1wiKTpvLnB1c2godj1oKTpoLnByZWRpY2F0ZS52YWx1ZT09PU0uYS5yZGYucmVzdD9nP3U9bihmLFwiaGFzIG11bHRpcGxlIHJkZjpyZXN0IGFyY3NcIik6by5wdXNoKGc9aCk6cC5sZW5ndGg/dT1uKGYsXCJjYW4ndCBiZSBzdWJqZWN0IGFuZCBvYmplY3RcIik6KGk9aCxhPVwic3ViamVjdFwiKTp1PW4oZixcIm5vdCBjb25maW5lZCB0byBzaW5nbGUgZ3JhcGhcIik7Zm9yKGw9MDtsPHAubGVuZ3RoJiYhdTsrK2wpaD1wW2xdLGk/dT1uKGYsXCJjYW4ndCBoYXZlIGNvcmVmZXJlbmNlc1wiKTpoLnByZWRpY2F0ZS52YWx1ZT09PU0uYS5yZGYucmVzdD95P3U9bihmLFwiaGFzIGluY29taW5nIHJkZjpyZXN0IGFyY3NcIik6eT1oOihpPWgsYT1cIm9iamVjdFwiKTt2P3MudW5zaGlmdCh2Lm9iamVjdCk6dT1uKGYsXCJoYXMgbm8gbGlzdCBoZWFkXCIpLGY9eSYmeS5zdWJqZWN0fXU/dD0hMTppJiYocltpW2FdLnZhbHVlXT1zKX0pLHQmJnRoaXMucmVtb3ZlUXVhZHMobykscn19ZnVuY3Rpb24gc3QodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9dmFyIHV0PXIoMTQ0KSxjdD1yLm4odXQpKCkoKSxmdD1LLm5hbWVkTm9kZSxsdD1LLmxpdGVyYWwsaHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe3UoKSh0aGlzLHQpLHRoaXMuX2ZldGNoPWUsdGhpcy5wYXJzZXI9bmV3IHR0LHRoaXMuc3RvcmU9bmV3IGF0LHRoaXMuY2FjaGU9e30sdGhpcy5wcmVmaXg9e319dmFyIGUscixuLG87cmV0dXJuIGYoKSh0LFt7a2V5Olwic2V0UHJlZml4XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLnByZWZpeFt0XT1lfX0se2tleTpcImdldFByZWZpeFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnByZWZpeFt0XX19LHtrZXk6XCJxdWVyeVwiLHZhbHVlOihvPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbixvLGEpe3ZhciBzLHUsYz1hcmd1bWVudHM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDppZighKGMubGVuZ3RoPjUmJnZvaWQgMCE9PWNbNV0/Y1s1XTp7dXNlQ2FjaGU6ITB9KS51c2VDYWNoZXx8IShlIGluIHRoaXMuY2FjaGUpKXt0Lm5leHQ9MzticmVha31yZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIix0aGlzLl9xdWVyeUNhY2hlZChlLHIsbixvLGEpKTtjYXNlIDM6cmV0dXJuIHQubmV4dD01LHRoaXMuX2ZldGNoKGUse2hlYWRlcnM6e0FjY2VwdDpcInRleHQvdHVydGxlXCJ9fSk7Y2FzZSA1OnJldHVybiBzPXQuc2VudCx0Lm5leHQ9OCxzLnRleHQoKTtjYXNlIDg6cmV0dXJuIHU9dC5zZW50LHQuYWJydXB0KFwicmV0dXJuXCIsdGhpcy5xdWVyeVR1cnRsZShlLHUscixuLG8sYSkpO2Nhc2UgMTA6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSxyLG4saSl7cmV0dXJuIG8uYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJxdWVyeVR1cnRsZVwiLHZhbHVlOihuPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbixvLGEscyl7dmFyIHU7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5uZXh0PTIsdGhpcy5fcGFyc2UocixlKTtjYXNlIDI6cmV0dXJuIHU9dC5zZW50LHRoaXMuY2FjaGVbZV09dSx0LmFicnVwdChcInJldHVyblwiLHRoaXMuX3F1ZXJ5Q2FjaGVkKGUsbixvLGEscykpO2Nhc2UgNTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlLHIsaSxvLGEpe3JldHVybiBuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiX3F1ZXJ5Q2FjaGVkXCIsdmFsdWU6KHI9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUscixuLG8sYSl7dmFyIHMsdT10aGlzO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIGF8fChhPWZ0KGUpW2FdPVtyLG4sbyxhXS5tYXAoKGZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCI9PT1GKCkodCkmJnQpe2lmKHQuaWQpcmV0dXJuIHQ7dmFyIHI9T2JqZWN0LmtleXModCksbj10W3JdO3JldHVybiAxPT09ci5sZW5ndGgmJlwidGhpc0RvY1wiPT09clswXT9mdChuP2UrXCIjXCIrbjplKTpjdFtyXT9mdChjdFtyXShuKSk6dS5wcmVmaXhbcl0/ZnQodS5wcmVmaXhbcl0rbik6ZnQocituKX1yZXR1cm4gdCYmdm9pZCAwIT09dD9sdCh0KTp0fSkpKSxzPXRoaXMuY2FjaGVbZV0sdC5hYnJ1cHQoXCJyZXR1cm5cIixzLmdldFF1YWRzKGFbMF0sYVsxXSxhWzJdLGFbM10pKTtjYXNlIDM6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSxuLGksbyl7cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJfcGFyc2VcIix2YWx1ZTooZT1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSxyKXt2YXIgbixvO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIG49W10sbz1uZXcgdHQoe2Jhc2VJUkk6cn0pLHQuYWJydXB0KFwicmV0dXJuXCIsbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQscil7by5wYXJzZShlLChmdW5jdGlvbihlLGksbyl7aWYoaSYmbi5wdXNoKGkpLGUpcmV0dXJuIHIoZSk7aWYoIWkpe3ZhciBhPW5ldyBhdDthLmFkZFF1YWRzKG4pLHQoYSl9fSkpfSkpKTtjYXNlIDM6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQpfSkpKSxmdW5jdGlvbih0LHIpe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfV0pLHR9KCkscHQ9SSxkdD1PO2Z1bmN0aW9uIHZ0KHQsZSl7dmFyIHI9e3VybDp0fTtmb3IodmFyIG4gaW4gZS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10LnByZWRpY2F0ZS52YWx1ZS5yZXBsYWNlKC8uKlxcLy8sXCJcIikucmVwbGFjZSgvLiojLyxcIlwiKSxuPXQub2JqZWN0LnZhbHVlLm1hdGNoKFwiaHR0cDovL3d3dy53My5vcmcvbnMvaWFuYS9tZWRpYS10eXBlcy9cIik/dC5vYmplY3QudmFsdWUucmVwbGFjZShcImh0dHA6Ly93d3cudzMub3JnL25zL2lhbmEvbWVkaWEtdHlwZXMvXCIsXCJcIik6dC5vYmplY3QudmFsdWUucmVwbGFjZSgvLipcXC8vLFwiXCIpO2UubWF0Y2goXCJ0eXBlXCIpfHwobj1uLnJlcGxhY2UoLy4qIy8sXCJcIikpLFwibGRwI1Jlc291cmNlXCIhPT1uJiZcImxkcCNDb250YWluZXJcIiE9PW4mJihyW2VdPVtdLmNvbmNhdCh4KCkocltlXXx8W10pLFtuLnJlcGxhY2UoXCIjUmVzb3VyY2VcIixcIlwiKV0pKX0pKSxyKTE9PT1yW25dLmxlbmd0aCYmKHJbbl09cltuXVswXSk7cmV0dXJuIHZvaWQgMD09PXIudHlwZSYmKHIudHlwZT1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSxyLml0ZW1UeXBlPXIudHlwZS5pbmNsdWRlcyhcImxkcCNCYXNpY0NvbnRhaW5lclwiKT9cIkNvbnRhaW5lclwiOlwiUmVzb3VyY2VcIixyLm5hbWU9ZHQodCksci5wYXJlbnQ9cHQodCkscn1mdW5jdGlvbiBndCh0LGUscil7dmFyIG49e3R5cGU6XCJmb2xkZXJcIn07cmV0dXJuIG4ubW9kaWZpZWQ9dC5tb2RpZmllZCxuLm10aW1lPXQubXRpbWUsbi5zaXplPXQuc2l6ZSxuLml0ZW1UeXBlPXQuaXRlbVR5cGUsbi5uYW1lPXQubmFtZSxuLnBhcmVudD10LnBhcmVudCxuLnVybD10LnVybCxuLmZvbGRlcnM9ZSxuLmZpbGVzPXIsbn12YXIgeXQ9e3BhcnNlRm9sZGVyUmVzcG9uc2U6ZnVuY3Rpb24oKXt2YXIgdD1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHIsbixvLHMsdSxjLGYsbCxoPWFyZ3VtZW50cztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiByPWgubGVuZ3RoPjEmJnZvaWQgMCE9PWhbMV0/aFsxXTplLnVybCx0Lm5leHQ9MyxlLnRleHQoKTtjYXNlIDM6cmV0dXJuIG49dC5zZW50LG89bmV3IGh0LHQubmV4dD03LG8ucXVlcnlUdXJ0bGUocixuLHt0aGlzRG9jOlwiXCJ9KTtjYXNlIDc6cmV0dXJuIHM9dC5zZW50LHU9dnQocixzKSx0Lm5leHQ9MTEsby5xdWVyeVR1cnRsZShyLG4se3RoaXNEb2M6XCJcIn0se2xkcDpcImNvbnRhaW5zXCJ9KTtjYXNlIDExOnJldHVybiBjPXQuc2VudCxmPVtdLGw9W10sdC5uZXh0PTE2LFByb21pc2UuYWxsKGMubWFwKGZ1bmN0aW9uKCl7dmFyIHQ9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUpe3ZhciBuLGEscztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiBuPWUub2JqZWN0LHQubmV4dD0zLG8ucXVlcnkocixuKTtjYXNlIDM6YT10LnNlbnQsKHM9dnQobi52YWx1ZSxhKSkuaXRlbVR5cGUuaW5jbHVkZXMoXCJDb250YWluZXJcIik/KHMudHlwZT1cImZvbGRlclwiLGYucHVzaChzKSk6bC5wdXNoKHMpO2Nhc2UgNjpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCl9KSkpO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSgpKSk7Y2FzZSAxNjpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixndCh1LGYsbCkpO2Nhc2UgMTc6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQpfSkpKTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0oKX0sYnQ9KHIoMjAxKSxyKDk3KSksX3Q9ci5uKGJ0KSxtdD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ZhciByLG47dSgpKHRoaXMsZSk7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgsbz1uZXcgQXJyYXkoaT4xP2ktMTowKSxhPTE7YTxpO2ErKylvW2EtMV09YXJndW1lbnRzW2FdO3JldHVybihuPWgoKSh0aGlzLChyPWQoKShlKSkuY2FsbC5hcHBseShyLFt0aGlzXS5jb25jYXQobykpKSkubmFtZT1cIlNpbmdsZVJlc3BvbnNlRXJyb3JcIixvLmxlbmd0aHx8KG4ubWVzc2FnZT1cIlwiLmNvbmNhdCh0LnN0YXR1cyxcIiBcIikuY29uY2F0KHQudXJsKSksbi5yZXNwb25zZT10LG4ub2s9ITEsbi5zdGF0dXM9dC5zdGF0dXMsbi5zdGF0dXNUZXh0PXQuc3RhdHVzVGV4dCxuLnVybD10LnVybCxufXJldHVybiBiKCkoZSx0KSxlfShfdCgpKEVycm9yKSksd3Q9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXt2YXIgcixuLGk9dC5zdWNjZXNzZnVsLG89dm9pZCAwPT09aT9bXTppLGE9dC5yZWplY3RlZEVycm9ycyxzPXZvaWQgMD09PWE/W106YSxjPXQuZXJyb3JzLGY9dm9pZCAwPT09Yz9bXTpjO3UoKSh0aGlzLGUpO2Zvcih2YXIgbD1hcmd1bWVudHMubGVuZ3RoLHA9bmV3IEFycmF5KGw+MT9sLTE6MCksdj0xO3Y8bDt2KyspcFt2LTFdPWFyZ3VtZW50c1t2XTtyZXR1cm4obj1oKCkodGhpcywocj1kKCkoZSkpLmNhbGwuYXBwbHkocixbdGhpc10uY29uY2F0KHApKSkpLm5hbWU9XCJTRkNGZXRjaEVycm9yXCIsbi5zdWNjZXNzZnVsPW8sbi5yZWplY3RlZD1zLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVzcG9uc2V9KSksbi5yZWplY3RlZEVycm9ycz1zLG4uZXJyb3JzPWYsbi5vaz0hMSxzLmxlbmd0aD8xIT09cy5sZW5ndGh8fGYubGVuZ3RoPyhuLm1lc3NhZ2U9XCJcIi5jb25jYXQobi5uYW1lLFwiIFwiKS5jb25jYXQoW10uY29uY2F0KHgoKShzKSx4KCkoZikpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubWVzc2FnZX0pKS5qb2luKFwiXFxuXCIpKSxuLnN0YXR1cz0tMixuLnN0YXR1c1RleHQ9bi5tZXNzYWdlKToobi5tZXNzYWdlPVwiXCIuY29uY2F0KG4ubmFtZSxcIiBcIikuY29uY2F0KHNbMF0ubWVzc2FnZSksbi5zdGF0dXM9c1swXS5zdGF0dXMsbi5zdGF0dXNUZXh0PXNbMF0uc3RhdHVzVGV4dCk6KG4ubWVzc2FnZT1cIlwiLmNvbmNhdChuLm5hbWUsXCIgXCIpLmNvbmNhdChmLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubWVzc2FnZX0pKS5qb2luKFwiXFxuXCIpKSxuLnN0YXR1cz0tMSxuLnN0YXR1c1RleHQ9bi5tZXNzYWdlKSxuLnN1Y2Nlc3NmdWw9byxuLnJlamVjdGVkPXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXNwb25zZX0pKSxuLnJlamVjdGVkRXJyb3JzPXMsbi5lcnJvcnM9ZixufXJldHVybiBiKCkoZSx0KSxlfShfdCgpKEVycm9yKSkseHQ9ezQwMTpcIk1ha2Ugc3VyZSB0aGF0IHRoZSB1c2VyIGlzIHByb3Blcmx5IGxvZ2dlZCBpblwiLDQwMzpcIk1ha2Ugc3VyZSB0aGF0IHRoZSBvcmlnaW4gb2YgeW91ciBhcHAgaXMgYXV0aG9yaXplZCBmb3IgeW91ciBwb2RcIiw0MDQ6XCJUaGUgcmVxdWVzdGVkIHJlc291cmNlIGNvdWxkIG5vdCBiZSBmb3VuZFwiLDQwOTpcIkEgY29uZmxpY3QgYXBwZWFyZWQuIElmIHlvdSB0cmllZCB0byBkZWxldGUgYSBmb2xkZXIsIG1ha2Ugc3VyZSB0aGF0IGl0IGlzIGVtcHR5XCIsNTAwOlwiQW4gaW50ZXJuYWwgc2VydmVyIGVycm9yIG9jY3VyZWRcIn07ZnVuY3Rpb24ga3QodCl7cmV0dXJuIEV0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBFdCgpe3JldHVybihFdD1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHI7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gcj1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudGhlbigoZnVuY3Rpb24odCl7cmV0dXJue3N0YXR1czpcImZ1bGZpbGxlZFwiLHZhbHVlOnR9fSkpLmNhdGNoKChmdW5jdGlvbih0KXtyZXR1cm57c3RhdHVzOlwicmVqZWN0ZWRcIixyZWFzb246dH19KSl9KSksdC5hYnJ1cHQoXCJyZXR1cm5cIixQcm9taXNlLmFsbChyKSk7Y2FzZSAyOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0KX0pKSkpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBTdCgpe3JldHVybihTdD1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHIsbixvLGEscyx1LGMsZjtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0Lm5leHQ9MixrdChlKTtjYXNlIDI6aWYobj10LnNlbnQsbz0ocj1bXSkuY29uY2F0LmFwcGx5KHIseCgpKG4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm5cImZ1bGZpbGxlZFwiPT09dC5zdGF0dXN9KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YWx1ZX0pKSkpLCEoYT1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuXCJyZWplY3RlZFwiPT09dC5zdGF0dXN9KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWFzb259KSkpLmxlbmd0aCl7dC5uZXh0PTk7YnJlYWt9dGhyb3cgYz0ocz1bXSkuY29uY2F0LmFwcGx5KHMseCgpKGEubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5lcnJvcnN9KSkpKSxmPSh1PVtdKS5jb25jYXQuYXBwbHkodSx4KCkoYS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlamVjdGVkRXJyb3JzfSkpKSksbmV3IHd0KHtzdWNjZXNzZnVsOm8scmVqZWN0ZWRFcnJvcnM6ZixlcnJvcnM6Y30pO2Nhc2UgOTpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixvKTtjYXNlIDEwOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0KX0pKSkpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIganQ9e0ZldGNoRXJyb3I6d3QsU2luZ2xlUmVzcG9uc2VFcnJvcjptdCxhc3NlcnRSZXNwb25zZU9rOmZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXt2YXIgZT10LnN0YXR1cyBpbiB4dD9uZXcgbXQodCxcIlwiLmNvbmNhdCh0LnN0YXR1cyxcIiBcIikuY29uY2F0KHQudXJsLFwiIC0gXCIpLmNvbmNhdCh4dFt0LnN0YXR1c10pKTpuZXcgbXQodCk7dGhyb3cgbmV3IHd0KHtzdWNjZXNzZnVsOltdLHJlamVjdGVkRXJyb3JzOltlXX0pfXJldHVybiB0fSxjb21wb3NlZEZldGNoOmZ1bmN0aW9uKHQpe3JldHVybiBTdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHByb21pc2VzU2V0dGxlZDprdCx0b0ZldGNoRXJyb3I6ZnVuY3Rpb24odCl7dGhyb3cgdCBpbnN0YW5jZW9mIHd0P3Q6dCBpbnN0YW5jZW9mIG10P25ldyB3dCh7cmVqZWN0ZWRFcnJvcnM6W3RdfSk6dCBpbnN0YW5jZW9mIEVycm9yP25ldyB3dCh7ZXJyb3JzOlt0XX0pOnR9fTtyKDIwNCk7ZnVuY3Rpb24gUnQodCxlKXt2YXIgcj17fTtyZXR1cm4gZnVuY3Rpb24odCl7aWYodCl7cmV0dXJuIHQubWF0Y2goLzxbXj5dKj5cXHMqKFxccyo7XFxzKlteKCk8PkAsOzpcIi9bXFxdPz17fSBcXHRdKz0oKFteXFwoXFwpPD5ALDs6XCJcXC9cXFtcXF1cXD89e30gXFx0XSspfChcIlteXCJdKlwiKSkpKigsfCQpL2cpfX0odCkubWFwKChmdW5jdGlvbih0KXt2YXIgZT10LnN1YnN0cmluZyh0LmluZGV4T2YoXCI8XCIpKzEsdC5pbmRleE9mKFwiPlwiKSkscj10LnN1YnN0cmluZyh0LmluZGV4T2YoJ3JlbD1cIicpKydyZWw9XCInLmxlbmd0aCx0Lmxhc3RJbmRleE9mKCdcIicpKTtyZXR1cm5bXCJkZXNjcmliZWRieVwiPT09ci50b0xvd2VyQ2FzZSgpP1wibWV0YVwiOnIsZV19KSkuZmlsdGVyKChmdW5jdGlvbih0KXt2YXIgZT1tKCkodCwxKVswXTtyZXR1cm5bXCJtZXRhXCIsXCJhY2xcIl0uaW5jbHVkZXMoZSl9KSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49bSgpKHQsMiksaT1uWzBdLG89blsxXTtyW2ldPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLG8sYSxzPWUuaW5kZXhPZihcIiNcIik7cz4wJiYoZT1lLnNsaWNlKDAscykpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZTtpZigwPT09dC5pbmRleE9mKFwiI1wiKSlyZXR1cm4gZSt0O2lmKHQuaW5kZXhPZihcIjpcIik+PTApcmV0dXJuIHQ7aWYocj1lLmluZGV4T2YoXCI6XCIpLDA9PT1lLmxlbmd0aClyZXR1cm4gdDtpZihyPDApcmV0dXJuIHQ7aWYobj1lLnNsaWNlKDAsK3IrMXx8OWU5KSwwPT09dC5pbmRleE9mKFwiLy9cIikpcmV0dXJuIG4rdDtpZihlLmluZGV4T2YoXCIvL1wiLHIpPT09cisxKXtpZigoaT1lLmluZGV4T2YoXCIvXCIsciszKSk8MClyZXR1cm4gZS5sZW5ndGgtci0zPjA/ZStcIi9cIit0Om4rdH1lbHNlIGlmKChpPWUuaW5kZXhPZihcIi9cIixyKzEpKTwwKXJldHVybiBlLmxlbmd0aC1yLTE+MD9lK1wiL1wiK3Q6bit0O2lmKDA9PT10LmluZGV4T2YoXCIvXCIpKXJldHVybiBlLnNsaWNlKDAsaSkrdDtpZihhPWUuc2xpY2UoaSksKG89YS5sYXN0SW5kZXhPZihcIi9cIikpPDApcmV0dXJuIG4rdDtvPj0wJiZvPGEubGVuZ3RoLTEmJihhPWEuc2xpY2UoMCwrbysxfHw5ZTkpKTthKz10O2Zvcig7YS5tYXRjaCgvW15cXC9dKlxcL1xcLlxcLlxcLy8pOylhPWEucmVwbGFjZSgvW15cXC9dKlxcL1xcLlxcLlxcLy8sXCJcIik7cmV0dXJuIGE9KGE9YS5yZXBsYWNlKC9cXC5cXC8vZyxcIlwiKSkucmVwbGFjZSgvXFwvXFwuJC8sXCIvXCIpLGUuc2xpY2UoMCxpKSthfShvLGUpfSkpLHJ9dmFyIEN0PWZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0LnVybCxyPXQuaGVhZGVycy5nZXQoXCJsaW5rXCIpO3JldHVybiBudWxsPT09cj97fTpSdChyLGUpfTtmdW5jdGlvbiBJdCh0LGUpe3ZhciByPU9iamVjdC5rZXlzKHQpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7ZSYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSkuZW51bWVyYWJsZX0pKSksci5wdXNoLmFwcGx5KHIsbil9cmV0dXJuIHJ9ZnVuY3Rpb24gT3QodCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW2VdP2FyZ3VtZW50c1tlXTp7fTtlJTI/SXQoT2JqZWN0KHIpLCEwKS5mb3JFYWNoKChmdW5jdGlvbihlKXtFKCkodCxlLHJbZV0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOkl0KE9iamVjdChyKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSkpfSkpfXJldHVybiB0fXZhciBUdD1qKCkoXCJzb2xpZC1maWxlLWNsaWVudDpmZXRjaFwiKSxQdD1DLEF0PUksTHQ9TyxGdD1ULE10PVAsTnQ9QSxCdD1qdC5GZXRjaEVycm9yLER0PWp0LmFzc2VydFJlc3BvbnNlT2ssVXQ9anQuY29tcG9zZWRGZXRjaCxxdD1qdC50b0ZldGNoRXJyb3IsR3Q9Q3QsV3Q9eXQucGFyc2VGb2xkZXJSZXNwb25zZSx6dD17UkVQTEFDRTpcInJlcGxhY2VcIixLRUVQX1NPVVJDRTpcImtlZXBfc291cmNlXCIsS0VFUF9UQVJHRVQ6XCJrZWVwX3RhcmdldFwifSxZdD17RVhDTFVERTpcImV4Y2x1ZGVcIixJTkNMVURFOlwiaW5jbHVkZVwiLElOQ0xVREVfUE9TU0lCTEU6XCJpbmNsdWRlX3Bvc3NpYmxlXCJ9LFF0PVwibm9fbW9kaWZ5XCIsJHQ9XCJ0b190YXJnZXRcIixIdD1cInRvX3NvdXJjZVwiLEt0PXt3aXRoQWNsOiEwLHdpdGhNZXRhOiEwLGFnZW50OlF0LG1lcmdlOnp0LlJFUExBQ0UsY3JlYXRlUGF0aDohMH0sVnQ9e2VuYWJsZUxvZ2dpbmc6ITF9O2Z1bmN0aW9uIFp0KHQpe3JldHVybiBKdCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3RhdHVzPT09dH0pKX1mdW5jdGlvbiBKdCh0KXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXQoZSkpdGhyb3cgcXQoZSk7cmV0dXJuIGV9fXZhciBYdD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQscil7dmFyIG47cmV0dXJuIHUoKSh0aGlzLGUpLChuPWgoKSh0aGlzLGQoKShlKS5jYWxsKHRoaXMsdC5mZXRjaC5iaW5kKHQpLHIpKSkuX2F1dGg9dCxufXZhciByLG4sbyxzO3JldHVybiBiKCkoZSx0KSxmKCkoZSxbe2tleTpcInJlYWRGaWxlXCIsdmFsdWU6KHM9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUscil7dmFyIG4sbztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0Lm5leHQ9Mix0aGlzLmdldChlLHIpO2Nhc2UgMjppZihuPXQuc2VudCwhKG89bi5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSl8fCFvLm1hdGNoKC8oaW1hZ2V8YXVkaW98dmlkZW8pLykpe3QubmV4dD02O2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLG4uYmxvYigpKTtjYXNlIDY6aWYoIW4udGV4dCl7dC5uZXh0PTg7YnJlYWt9cmV0dXJuIHQuYWJydXB0KFwicmV0dXJuXCIsbi50ZXh0KCkpO2Nhc2UgODpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixuKTtjYXNlIDk6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHMuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJyZWFkSGVhZFwiLHZhbHVlOihvPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChyLG4pe3ZhciBvLGEscyx1LGMsZixsLGg7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5uZXh0PTIsZygpKGQoKShlLnByb3RvdHlwZSksXCJoZWFkXCIsdGhpcykuY2FsbCh0aGlzLHIsbik7Y2FzZSAyOmZvcihvPXQuc2VudCxhPVwiXCIscz0hMCx1PSExLGM9dm9pZCAwLHQucHJldj03LGY9by5oZWFkZXJzLmVudHJpZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCk7IShzPShsPWYubmV4dCgpKS5kb25lKTtzPSEwKWg9bC52YWx1ZSxhKz1oWzBdK1wiOiBcIitoWzFdK1wiXFxuXCI7dC5uZXh0PTE1O2JyZWFrO2Nhc2UgMTE6dC5wcmV2PTExLHQudDA9dC5jYXRjaCg3KSx1PSEwLGM9dC50MDtjYXNlIDE1OnQucHJldj0xNSx0LnByZXY9MTYsc3x8bnVsbD09Zi5yZXR1cm58fGYucmV0dXJuKCk7Y2FzZSAxODppZih0LnByZXY9MTgsIXUpe3QubmV4dD0yMTticmVha310aHJvdyBjO2Nhc2UgMjE6cmV0dXJuIHQuZmluaXNoKDE4KTtjYXNlIDIyOnJldHVybiB0LmZpbmlzaCgxNSk7Y2FzZSAyMzpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixhKTtjYXNlIDI0OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMsW1s3LDExLDE1LDIzXSxbMTYsLDE4LDIyXV0pfSkpKSxmdW5jdGlvbih0LGUpe3JldHVybiBvLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiZGVsZXRlRmlsZVwiLHZhbHVlOihuPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChyKXtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0LmFicnVwdChcInJldHVyblwiLGcoKShkKCkoZS5wcm90b3R5cGUpLFwiX2RlbGV0ZUl0ZW1XaXRoTGlua3NcIix0aGlzKS5jYWxsKHRoaXMscikpO2Nhc2UgMTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCl7cmV0dXJuIG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJkZWxldGVGb2xkZXJcIix2YWx1ZToocj1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQocixuKXtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0LmFicnVwdChcInJldHVyblwiLGcoKShkKCkoZS5wcm90b3R5cGUpLFwiZGVsZXRlRm9sZGVyUmVjdXJzaXZlbHlcIix0aGlzKS5jYWxsKHRoaXMscikpO2Nhc2UgMTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlKXtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX1dKSxlfShmdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxyKXt1KCkodGhpcyx0KSxyPU90KHt9LFZ0LHt9LHIpLHRoaXMuX2ZldGNoPWUsdGhpcy5yZGY9bmV3IGh0KHRoaXMuZmV0Y2guYmluZCh0aGlzKSksci5lbmFibGVMb2dnaW5nJiYoXCJzdHJpbmdcIj09dHlwZW9mIHIuZW5hYmxlTG9nZ2luZz9qLmEuZW5hYmxlKHIuZW5hYmxlTG9nZ2luZyk6ai5hLmVuYWJsZShcInNvbGlkLWZpbGUtY2xpZW50OipcIikpfXZhciBlLHIsbixvLHMsYyxsLGgscCxkLHYsZyx5LGIsXyx3LGs7cmV0dXJuIGYoKSh0LFt7a2V5OlwiZmV0Y2hcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9mZXRjaCh0LGUpLnRoZW4oKGZ1bmN0aW9uKHIpe3JldHVybiBUdChcIlwiLmNvbmNhdChyLnN0YXR1cyxcIiAtIFwiKS5jb25jYXQoZSYmZS5tZXRob2QsXCIgXCIpLmNvbmNhdCh0KSkscn0pKS50aGVuKER0KX19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZldGNoKHQsT3Qoe30sZSx7bWV0aG9kOlwiR0VUXCJ9KSl9fSx7a2V5OlwiZGVsZXRlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5mZXRjaCh0LE90KHt9LGUse21ldGhvZDpcIkRFTEVURVwifSkpfX0se2tleTpcInBvc3RcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZldGNoKHQsT3Qoe30sZSx7bWV0aG9kOlwiUE9TVFwifSkpfX0se2tleTpcInB1dFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZmV0Y2godCxPdCh7fSxlLHttZXRob2Q6XCJQVVRcIn0pKX19LHtrZXk6XCJwYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZmV0Y2godCxPdCh7fSxlLHttZXRob2Q6XCJQQVRDSFwifSkpfX0se2tleTpcImhlYWRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZldGNoKHQsT3Qoe30sZSx7bWV0aG9kOlwiSEVBRFwifSkpfX0se2tleTpcIm9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZldGNoKHQsT3Qoe30sZSx7bWV0aG9kOlwiT1BUSU9OU1wifSkpfX0se2tleTpcIml0ZW1FeGlzdHNcIix2YWx1ZTooaz1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIix0aGlzLmhlYWQoZSkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4hMH0pKS5jYXRjaCgoZnVuY3Rpb24odCl7cmV0dXJuIFp0KDQwNCkodCksITF9KSkpO2Nhc2UgMTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCl7cmV0dXJuIGsuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJwb3N0SXRlbVwiLHZhbHVlOih3PWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbixvLGEpe3ZhciBzLHU7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDppZihhPU90KHt9LHtjcmVhdGVQYXRoOiEwfSx7fSxhKSxzPUF0KGUpLCFhLmNyZWF0ZVBhdGgpe3QubmV4dD01O2JyZWFrfXJldHVybiB0Lm5leHQ9NSx0aGlzLmNyZWF0ZUZvbGRlcihzKTtjYXNlIDU6cmV0dXJuIHU9e2hlYWRlcnM6e2xpbms6byxzbHVnOkx0KGUpLFwiQ29udGVudC1UeXBlXCI6bn0sYm9keTpyfSx0LmFicnVwdChcInJldHVyblwiLHRoaXMucG9zdChzLHUpKTtjYXNlIDc6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSxyLG4saSl7cmV0dXJuIHcuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJjcmVhdGVGb2xkZXJcIix2YWx1ZTooXz1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSxyKXt2YXIgbjtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiByPU90KHt9LHtjcmVhdGVQYXRoOiEwLG1lcmdlOnp0LktFRVBfVEFSR0VUfSx7fSxyKSx0LnByZXY9MSx0Lm5leHQ9NCx0aGlzLmhlYWQoZSk7Y2FzZSA0OmlmKG49dC5zZW50LHIubWVyZ2U9PT16dC5SRVBMQUNFKXt0Lm5leHQ9NzticmVha31yZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixuKTtjYXNlIDc6cmV0dXJuIHQubmV4dD05LHRoaXMuZGVsZXRlRm9sZGVyUmVjdXJzaXZlbHkoZSk7Y2FzZSA5OnQubmV4dD0xNDticmVhaztjYXNlIDExOnQucHJldj0xMSx0LnQwPXQuY2F0Y2goMSksWnQoNDA0KSh0LnQwKTtjYXNlIDE0OnJldHVybiB0LmFicnVwdChcInJldHVyblwiLHRoaXMucG9zdEl0ZW0oZSxcIlwiLFwidGV4dC90dXJ0bGVcIixOdC5DT05UQUlORVIscikpO2Nhc2UgMTU6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyxbWzEsMTFdXSl9KSkpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIF8uYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJwb3N0RmlsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxyLG4pe3JldHVybiB0aGlzLnBvc3RJdGVtKHQsZSxyLE50LlJFU09VUkNFLG4pfX0se2tleTpcImNyZWF0ZUZpbGVcIix2YWx1ZTpmdW5jdGlvbih0LGUscixuKXtyZXR1cm4gdGhpcy5wdXRGaWxlKHQsZSxyLG4pfX0se2tleTpcInB1dEZpbGVcIix2YWx1ZTooYj1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSxyLG4sbyl7dmFyIGE7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDppZihvPU90KHt9LEt0LHt9LG8pLHQudDA9by5tZXJnZT09PXp0LktFRVBfVEFSR0VULCF0LnQwKXt0Lm5leHQ9NjticmVha31yZXR1cm4gdC5uZXh0PTUsdGhpcy5pdGVtRXhpc3RzKGUpO2Nhc2UgNTp0LnQwPXQuc2VudDtjYXNlIDY6aWYoIXQudDApe3QubmV4dD04O2JyZWFrfXF0KG5ldyBFcnJvcihcIkZpbGUgYWxyZWFkeSBleGlzdGVkOiBcIitlKSk7Y2FzZSA4OnJldHVybiBhPXtoZWFkZXJzOntsaW5rOk50LlJFU09VUkNFLFwiQ29udGVudC1UeXBlXCI6bn0sYm9keTpyfSx0LmFicnVwdChcInJldHVyblwiLHRoaXMucHV0KGUsYSkpO2Nhc2UgMTA6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSxyLG4pe3JldHVybiBiLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwicmVhZEZvbGRlclwiLHZhbHVlOih5PWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIpe3ZhciBuLG8scyx1PXRoaXM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gZT1lLmVuZHNXaXRoKFwiL1wiKT9lOmUrXCIvXCIscj1PdCh7bGlua3M6WXQuRVhDTFVERX0sciksdC5uZXh0PTQsdGhpcy5nZXQoZSx7aGVhZGVyczp7QWNjZXB0OlwidGV4dC90dXJ0bGVcIn19KTtjYXNlIDQ6cmV0dXJuIG49dC5zZW50LHQubmV4dD03LFd0KG4sZSk7Y2FzZSA3OmlmKG89dC5zZW50LHIubGlua3MhPT1ZdC5JTkNMVURFX1BPU1NJQkxFJiZyLmxpbmtzIT09WXQuSU5DTFVERSl7dC5uZXh0PTEyO2JyZWFrfXJldHVybiBzPWZ1bmN0aW9uKCl7dmFyIHQ9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUpe3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIHQubmV4dD0yLHUuZ2V0SXRlbUxpbmtzKGUudXJsLHIpO2Nhc2UgMjplLmxpbmtzPXQuc2VudDtjYXNlIDM6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQpfSkpKTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0oKSx0Lm5leHQ9MTIsVXQoW3MobyldLmNvbmNhdCh4KCkoby5maWxlcy5tYXAocykpKSk7Y2FzZSAxMjpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixvKTtjYXNlIDEzOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0LGUpe3JldHVybiB5LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiZ2V0SXRlbUxpbmtzXCIsdmFsdWU6KGc9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUpe3ZhciByLG4sbz1hcmd1bWVudHM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4ocj1vLmxlbmd0aD4xJiZ2b2lkIDAhPT1vWzFdP29bMV06e2xpbmtzOll0LklOQ0xVREVfUE9TU0lCTEV9KS5saW5rcz09PVl0LkVYQ0xVREUmJnF0KG5ldyBFcnJvcihcIkludmFsaWQgb3B0aW9uIExJTktTLkVYQ0xVREUgZm9yIGdldEl0ZW1MaW5rc1wiKSksdC5uZXh0PTQsdGhpcy5oZWFkKGUpLnRoZW4oR3QpO2Nhc2UgNDppZihuPXQuc2VudCxyLmxpbmtzIT09WXQuSU5DTFVERSl7dC5uZXh0PTg7YnJlYWt9cmV0dXJuIHQubmV4dD04LHRoaXMuX3JlbW92ZUluZXhpc3RpbmdMaW5rcyhuKTtjYXNlIDg6cmV0dXJuIHQuYWJydXB0KFwicmV0dXJuXCIsbik7Y2FzZSA5OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0KXtyZXR1cm4gZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcIl9yZW1vdmVJbmV4aXN0aW5nTGlua3NcIix2YWx1ZToodj1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHI9dGhpcztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0Lm5leHQ9MixVdChPYmplY3QuZW50cmllcyhlKS5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBuPW0oKSh0LDIpLGk9blswXSxvPW5bMV07cmV0dXJuIHIuaXRlbUV4aXN0cyhvKS5jYXRjaChadCg0MDQpKS50aGVuKChmdW5jdGlvbih0KXt0fHxkZWxldGUgZVtpXX0pKX0pKSk7Y2FzZSAyOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0KX0pKSksZnVuY3Rpb24odCl7cmV0dXJuIHYuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJjb3B5RmlsZVwiLHZhbHVlOihkPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbil7dmFyIG8sYSxzLHU7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDppZihuPU90KHt9LEt0LHt9LG4pLCFlLmVuZHNXaXRoKFwiL1wiKSYmIXIuZW5kc1dpdGgoXCIvXCIpKXt0Lm5leHQ9MzticmVha310aHJvdyBxdChuZXcgRXJyb3IoXCJGb2xkZXJzIGFyZSBub3QgYWxsb3dlZCB3aXRoIGNvcHlGaWxlLiBGb3VuZDogXCIuY29uY2F0KGUsXCIgYW5kIFwiKS5jb25jYXQocikpKTtjYXNlIDM6aWYoIWUuZW5kc1dpdGgoXCIuYWNsXCIpJiYhci5lbmRzV2l0aChcIi5hY2xcIikpe3QubmV4dD01O2JyZWFrfXRocm93IHF0KG5ldyBFcnJvcihcIlVzZSBjb3B5QWNsRmlsZSBmb3IgY29weWluZyBBQ0wgZmlsZXMuIEZvdW5kOiBcIi5jb25jYXQoZSxcIiBhbmQgXCIpLmNvbmNhdChyKSkpO2Nhc2UgNTpyZXR1cm4gdC5uZXh0PTcsdGhpcy5nZXQoZSk7Y2FzZSA3OnJldHVybiBvPXQuc2VudCx0Lm5leHQ9MTAsby5ibG9iKCk7Y2FzZSAxMDpyZXR1cm4gYT10LnNlbnQscz1vLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpLHQubmV4dD0xNCx0aGlzLnB1dEZpbGUocixhLHMsbik7Y2FzZSAxNDpyZXR1cm4gdT10LnNlbnQsdC5uZXh0PTE3LHRoaXMuY29weUxpbmtzRm9ySXRlbShlLHIsbixvLHUpO2Nhc2UgMTc6cmV0dXJuIHQuYWJydXB0KFwicmV0dXJuXCIsdSk7Y2FzZSAxODpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlLHIpe3JldHVybiBkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiX2xpbmtVcmxzRGVmaW5lZFwiLHZhbHVlOihwPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIpe3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3QubmV4dD00O2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLCExKTtjYXNlIDQ6aWYodC50MD1cInN0cmluZ1wiIT10eXBlb2YgciwhdC50MCl7dC5uZXh0PTk7YnJlYWt9cmV0dXJuIHQubmV4dD04LHRoaXMuaXRlbUV4aXN0cyhlKTtjYXNlIDg6dC50MD10LnNlbnQ7Y2FzZSA5OmlmKCF0LnQwKXt0Lm5leHQ9MTM7YnJlYWt9dGhyb3cgcXQobmV3IEVycm9yKFwiQ2Fubm90IGNvcHkgbGluayBmaWxlIGJlY2F1c2UgdGFyZ2V0IGxvY2F0aW9uIHdhcyBub3QgcHJvdmlkZWQgYnkgdGhlIHBvZFwiKSk7Y2FzZSAxMzppZihcInN0cmluZ1wiPT10eXBlb2Ygcil7dC5uZXh0PTE3O2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLCExKTtjYXNlIDE3OnJldHVybiB0LmFicnVwdChcInJldHVyblwiLCEwKTtjYXNlIDE4OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0LGUpe3JldHVybiBwLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiY29weU1ldGFGaWxlRm9ySXRlbVwiLHZhbHVlOihoPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIpe3ZhciBuLG8sYSxzLHUsYz1hcmd1bWVudHM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gbj1jLmxlbmd0aD4yJiZ2b2lkIDAhPT1jWzJdP2NbMl06e30sdC5uZXh0PTMsdGhpcy5nZXRJdGVtTGlua3MoZSk7Y2FzZSAzOnJldHVybiBvPXQuc2VudCxhPW8ubWV0YSx0Lm5leHQ9Nyx0aGlzLmdldEl0ZW1MaW5rcyhyKTtjYXNlIDc6cmV0dXJuIHM9dC5zZW50LHU9cy5tZXRhLHQubmV4dD0xMSx0aGlzLl9saW5rVXJsc0RlZmluZWQoYSx1KTtjYXNlIDExOmlmKHQuc2VudCl7dC5uZXh0PTEzO2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLHZvaWQgMCk7Y2FzZSAxMzpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIix0aGlzLmNvcHlGaWxlKGEsdSx7d2l0aEFjbDpuLndpdGhBY2wsd2l0aE1ldGE6ITF9KSk7Y2FzZSAxNDpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlKXtyZXR1cm4gaC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcImNvcHlBY2xGaWxlRm9ySXRlbVwiLHZhbHVlOihsPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbil7dmFyIG8sYSxzLHUsYyxmLGwsaCxwO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIG49T3Qoe30sS3Qse30se2FnZW50OlF0fSx7fSxuKSx0Lm5leHQ9Myx0aGlzLmdldEl0ZW1MaW5rcyhlKTtjYXNlIDM6cmV0dXJuIG89dC5zZW50LGE9by5hY2wsdC5uZXh0PTcsdGhpcy5nZXRJdGVtTGlua3Mocik7Y2FzZSA3OnJldHVybiBzPXQuc2VudCx1PXMuYWNsLHQubmV4dD0xMSx0aGlzLl9saW5rVXJsc0RlZmluZWQoYSx1KTtjYXNlIDExOmlmKHQuc2VudCl7dC5uZXh0PTEzO2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLHZvaWQgMCk7Y2FzZSAxMzpyZXR1cm4gdC5uZXh0PTE1LHRoaXMuZ2V0KGEpO2Nhc2UgMTU6cmV0dXJuIGM9dC5zZW50LGY9Yy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSx0Lm5leHQ9MTksYy50ZXh0KCk7Y2FzZSAxOTpyZXR1cm4gbD10LnNlbnQsaD1MdChlKSxwPUZ0KHIpP1wiXCI6THQociksbC5pbmNsdWRlcyhlKSYmKGw9bC5yZXBsYWNlKG5ldyBSZWdFeHAoXCI8XCIrZStcIj5cIixcImdcIiksXCI8Li9cIitwK1wiPlwiKSkscCE9PWgmJihsPWwucmVwbGFjZShuZXcgUmVnRXhwKGgrXCI+XCIsXCJnXCIpLHArXCI+XCIpKSxuLmFnZW50PT09JHQmJihsPShsPWwucmVwbGFjZShuZXcgUmVnRXhwKFwiPFwiK1B0KGUpK1wicHJvZmlsZS9jYXJkI1wiLFwiZ1wiKSxcIjwvcHJvZmlsZS9jYXJkI1wiKSkucmVwbGFjZShuZXcgUmVnRXhwKFwiPFwiK1B0KGUpK1wicHJvZmlsZS9jYXJkI21lPlwiLFwiZ1wiKSxcIjwvcHJvZmlsZS9jYXJkI21lPlwiKSksbi5hZ2VudD09PUh0JiYobD0obD1sLnJlcGxhY2UobmV3IFJlZ0V4cChcIjwvcHJvZmlsZS9jYXJkI1wiLFwiZ1wiKSxcIjxcIitQdChlKStcInByb2ZpbGUvY2FyZCNcIikpLnJlcGxhY2UobmV3IFJlZ0V4cChcIjwvcHJvZmlsZS9jYXJkI21lPlwiLFwiZ1wiKSxcIjxcIitQdChlKStcInByb2ZpbGUvY2FyZCNtZT5cIikpLHQuYWJydXB0KFwicmV0dXJuXCIsdGhpcy5wdXRGaWxlKHUsbCxmLG4pKTtjYXNlIDI3OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0LGUscil7cmV0dXJuIGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJjb3B5TGlua3NGb3JJdGVtXCIsdmFsdWU6KGM9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUscixuKXt2YXIgbztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOmlmKG89W10sIW4ud2l0aE1ldGEpe3QubmV4dD03O2JyZWFrfXJldHVybiB0LnQwPW8sdC5uZXh0PTUsdGhpcy5jb3B5TWV0YUZpbGVGb3JJdGVtKGUscixuKS5jYXRjaChadCg0MDQpKTtjYXNlIDU6dC50MT10LnNlbnQsdC50MC5wdXNoLmNhbGwodC50MCx0LnQxKTtjYXNlIDc6aWYoIW4ud2l0aEFjbCl7dC5uZXh0PTEzO2JyZWFrfXJldHVybiB0LnQyPW8sdC5uZXh0PTExLHRoaXMuY29weUFjbEZpbGVGb3JJdGVtKGUscixuKS5jYXRjaChadCg0MDQpKTtjYXNlIDExOnQudDM9dC5zZW50LHQudDIucHVzaC5jYWxsKHQudDIsdC50Myk7Y2FzZSAxMzpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixvLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQmJiEodCBpbnN0YW5jZW9mIEVycm9yKX0pKSk7Y2FzZSAxNDpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlLHIpe3JldHVybiBjLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiY29weUZvbGRlclwiLHZhbHVlOihzPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbil7dmFyIG8sYSxzLHUsYyxmLGw9dGhpcztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOmlmKG49T3Qoe30sS3Qse30sbiksXCJzdHJpbmdcIj09dHlwZW9mIGUmJlwic3RyaW5nXCI9PXR5cGVvZiByKXt0Lm5leHQ9MzticmVha310aHJvdyBxdChuZXcgRXJyb3IoXCJUaGUgZnJvbSBhbmQgdG8gcGFyYW1ldGVycyBvZiBjb3B5Rm9sZGVyIG11c3QgYmUgc3RyaW5ncy4gRm91bmQ6IFwiLmNvbmNhdChlLFwiIGFuZCBcIikuY29uY2F0KHIpKSk7Y2FzZSAzOmlmKGUuZW5kc1dpdGgoXCIvXCIpJiZyLmVuZHNXaXRoKFwiL1wiKSl7dC5uZXh0PTU7YnJlYWt9dGhyb3cgcXQobmV3IEVycm9yKFwiRmlsZXMgYXJlIG5vdCBhbGxvd2VkIHdpdGggY29weUZvbGRlci4gRm91bmQ6IFwiLmNvbmNhdChlLFwiIGFuZCBcIikuY29uY2F0KHIpKSk7Y2FzZSA1OnJldHVybiB0Lm5leHQ9Nyx0aGlzLnJlYWRGb2xkZXIoZSk7Y2FzZSA3OnJldHVybiBhPXQuc2VudCxzPWEuZm9sZGVycyx1PWEuZmlsZXMsdC5uZXh0PTEyLHRoaXMuY3JlYXRlRm9sZGVyKHIsbik7Y2FzZSAxMjpyZXR1cm4gYz10LnNlbnQsdC5uZXh0PTE1LHRoaXMuY29weUxpbmtzRm9ySXRlbShlLHIsbix2b2lkIDAsYyk7Y2FzZSAxNTpyZXR1cm4gdC5uZXh0PTE3LFV0KFtdLmNvbmNhdCh4KCkocy5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBpPXQubmFtZTtyZXR1cm4gbC5jb3B5Rm9sZGVyKFwiXCIuY29uY2F0KGUpLmNvbmNhdChpLFwiL1wiKSxcIlwiLmNvbmNhdChyKS5jb25jYXQoaSxcIi9cIiksbil9KSkpLHgoKSh1Lm1hcCgoZnVuY3Rpb24odCl7dmFyIGk9dC5uYW1lO3JldHVybiBsLmNvcHlGaWxlKFwiXCIuY29uY2F0KGUpLmNvbmNhdChpKSxcIlwiLmNvbmNhdChyKS5jb25jYXQoaSksbikuY2F0Y2goSnQoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1lc3NhZ2UuaW5jbHVkZXMoXCJhbHJlYWR5IGV4aXN0ZWRcIil9KSkpfSkpKSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuISh0IGluc3RhbmNlb2YgQnQpfSkpfSkpO2Nhc2UgMTc6cmV0dXJuIGY9dC5zZW50LHQuYWJydXB0KFwicmV0dXJuXCIsKG89W2NdKS5jb25jYXQuYXBwbHkobyx4KCkoZikpKTtjYXNlIDE5OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0LGUscil7cmV0dXJuIHMuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJjb3B5XCIsdmFsdWU6ZnVuY3Rpb24odCxlLHIpe3JldHVybiBGdCh0LGUpP3RoaXMuY29weUZvbGRlcih0LGUscik6TXQodCxlKT90aGlzLmNvcHlGaWxlKHQsZSxyKTp2b2lkIHF0KG5ldyBFcnJvcihcIkNhbm5vdCBjb3B5IGZyb20gYSBmb2xkZXIgdXJsIHRvIGEgZmlsZSB1cmwgb3IgdmljZSB2ZXJzYVwiKSl9fSx7a2V5OlwiX2RlbGV0ZUl0ZW1XaXRoTGlua3NcIix2YWx1ZToobz1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHI7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5uZXh0PTIsdGhpcy5nZXRJdGVtTGlua3MoZSx7bGlua3M6WXQuSU5DTFVERX0pO2Nhc2UgMjppZighKHI9dC5zZW50KS5tZXRhKXt0Lm5leHQ9NjticmVha31yZXR1cm4gdC5uZXh0PTYsdGhpcy5fZGVsZXRlSXRlbVdpdGhMaW5rcyhyLm1ldGEpO2Nhc2UgNjppZighci5hY2wpe3QubmV4dD05O2JyZWFrfXJldHVybiB0Lm5leHQ9OSx0aGlzLmRlbGV0ZShyLmFjbCk7Y2FzZSA5OnJldHVybiB0LmFicnVwdChcInJldHVyblwiLHRoaXMuZGVsZXRlKGUpKTtjYXNlIDEwOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0KXtyZXR1cm4gby5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcImRlbGV0ZUZvbGRlckNvbnRlbnRzXCIsdmFsdWU6KG49YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUpe3ZhciByLG4sbyxhPXRoaXM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5uZXh0PTIsdGhpcy5yZWFkRm9sZGVyKGUpO2Nhc2UgMjpyZXR1cm4gcj10LnNlbnQsbj1yLmZvbGRlcnMsbz1yLmZpbGVzLHQuYWJydXB0KFwicmV0dXJuXCIsVXQoW10uY29uY2F0KHgoKShuLm1hcCgoZnVuY3Rpb24odCl7dmFyIGU9dC51cmw7cmV0dXJuIGEuZGVsZXRlRm9sZGVyUmVjdXJzaXZlbHkoZSl9KSkpLHgoKShvLm1hcCgoZnVuY3Rpb24odCl7dmFyIGU9dC51cmw7cmV0dXJuIGEuX2RlbGV0ZUl0ZW1XaXRoTGlua3MoZSl9KSkpKSkpO2Nhc2UgNjpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCl7cmV0dXJuIG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJkZWxldGVGb2xkZXJSZWN1cnNpdmVseVwiLHZhbHVlOihyPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlKXt2YXIgcjtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0Lm5leHQ9Mix0aGlzLmRlbGV0ZUZvbGRlckNvbnRlbnRzKGUpO2Nhc2UgMjpyZXR1cm4gcj10LnNlbnQsdC50MD1yLHQubmV4dD02LHRoaXMuX2RlbGV0ZUl0ZW1XaXRoTGlua3MoZSk7Y2FzZSA2OnJldHVybiB0LnQxPXQuc2VudCx0LnQwLnVuc2hpZnQuY2FsbCh0LnQwLHQudDEpLHQuYWJydXB0KFwicmV0dXJuXCIscik7Y2FzZSA5OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0KXtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcIm1vdmVcIix2YWx1ZTooZT1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSxyLG4pe3ZhciBvO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIHQubmV4dD0yLHRoaXMuY29weShlLHIsbik7Y2FzZSAyOmlmKG89dC5zZW50LCFGdChlKSl7dC5uZXh0PTg7YnJlYWt9cmV0dXJuIHQubmV4dD02LHRoaXMuZGVsZXRlRm9sZGVyUmVjdXJzaXZlbHkoZSk7Y2FzZSA2OnQubmV4dD0xMDticmVhaztjYXNlIDg6cmV0dXJuIHQubmV4dD0xMCx0aGlzLl9kZWxldGVJdGVtV2l0aExpbmtzKGUpO2Nhc2UgMTA6cmV0dXJuIHQuYWJydXB0KFwicmV0dXJuXCIsbyk7Y2FzZSAxMTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxyLG4pe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwicmVuYW1lXCIsdmFsdWU6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPUF0KHQpK2UrKEZ0KHQpP1wiL1wiOlwiXCIpO3JldHVybiB0aGlzLm1vdmUodCxuLHIpfX1dKSx0fSgpKSx0ZT1qdC5GZXRjaEVycm9yLGVlPWp0LlNpbmdsZVJlc3BvbnNlRXJyb3I7WHQuRmV0Y2hFcnJvcj10ZSxYdC5TaW5nbGVSZXNwb25zZUVycm9yPWVlLFh0LkxJTktTPVl0LFh0Lk1FUkdFPXp0O2UuZGVmYXVsdD1YdH1dKS5kZWZhdWx0fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWQtZmlsZS1jbGllbnQuYnVuZGxlLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n')},function(module,exports){eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzPzQ2MzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n")},function(module,exports,__webpack_require__){eval("var core = __webpack_require__(18);\nvar global = __webpack_require__(3);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(19) ? 'pure' : 'global',\n  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanM/NTUzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsRUFBUztBQUM1QixhQUFhLG1CQUFPLENBQUMsQ0FBVztBQUNoQztBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQSxxRUFBcUU7QUFDckUsQ0FBQztBQUNEO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLEVBQVk7QUFDNUI7QUFDQSxDQUFDIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n")},function(module,exports){eval("var core = module.exports = { version: '2.6.11' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzPzgzNzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNkJBQTZCO0FBQzdCLHVDQUF1QyIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuMTEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n")},function(module,exports){eval("module.exports = false;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzPzJkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n")},function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanM/MmQ5NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n")},function(module,exports){eval('// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError("Can\'t call method on  " + it);\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzP2JlMTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n')},function(module,exports,__webpack_require__){eval("// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(45);\nvar enumBugKeys = __webpack_require__(33);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcz8wZDU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLEVBQXlCO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLEVBQWtCOztBQUU1QztBQUNBO0FBQ0EiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n")},function(module,exports,__webpack_require__){eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(24);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanM/OWRlZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkM7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///23\n")},function(module,exports){eval("// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzPzQ1ODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar isRegExp = __webpack_require__(75);\nvar anObject = __webpack_require__(2);\nvar speciesConstructor = __webpack_require__(76);\nvar advanceStringIndex = __webpack_require__(37);\nvar toLength = __webpack_require__(23);\nvar callRegExpExec = __webpack_require__(38);\nvar regexpExec = __webpack_require__(39);\nvar fails = __webpack_require__(6);\nvar $min = Math.min;\nvar $push = [].push;\nvar $SPLIT = 'split';\nvar LENGTH = 'length';\nvar LAST_INDEX = 'lastIndex';\nvar MAX_UINT32 = 0xffffffff;\n\n// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError\nvar SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });\n\n// @@split logic\n__webpack_require__(40)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = String(this);\n      if (separator === undefined && limit === 0) return [];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) return $split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = regexpExec.call(separatorCopy, string)) {\n        lastIndex = separatorCopy[LAST_INDEX];\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if (output[LENGTH] >= splitLimit) break;\n        }\n        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string[LENGTH]) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);\n    };\n  } else {\n    internalSplit = $split;\n  }\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = defined(this);\n      var splitter = separator == undefined ? undefined : separator[SPLIT];\n      return splitter !== undefined\n        ? splitter.call(separator, O, limit)\n        : internalSplit.call(String(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (regexp, limit) {\n      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (SUPPORTS_Y ? 'y' : 'g');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = SUPPORTS_Y ? q : 0;\n        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));\n        var e;\n        if (\n          z === null ||\n          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          A.push(S.slice(p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            A.push(z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      A.push(S.slice(p));\n      return A;\n    }\n  ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanM/MjhhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyx5QkFBeUIsbUJBQU8sQ0FBQyxFQUF3QjtBQUN6RCx5QkFBeUIsbUJBQU8sQ0FBQyxFQUF5QjtBQUMxRCxlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUF5QjtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFnQjtBQUN6QyxZQUFZLG1CQUFPLENBQUMsQ0FBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMseUJBQXlCLEVBQUU7O0FBRWhFO0FBQ0EsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNhbGxSZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJG1pbiA9IE1hdGgubWluO1xudmFyICRwdXNoID0gW10ucHVzaDtcbnZhciAkU1BMSVQgPSAnc3BsaXQnO1xudmFyIExFTkdUSCA9ICdsZW5ndGgnO1xudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbnZhciBNQVhfVUlOVDMyID0gMHhmZmZmZmZmZjtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCd4JywgJ3knKSAtPiAveC95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciBTVVBQT1JUU19ZID0gIWZhaWxzKGZ1bmN0aW9uICgpIHsgUmVnRXhwKE1BWF9VSU5UMzIsICd5Jyk7IH0pO1xuXG4vLyBAQHNwbGl0IGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFNQTElULCAkc3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcbiAgaWYgKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApIHtcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiAkc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICB3aGlsZSAobWF0Y2ggPSByZWdleHBFeGVjLmNhbGwoc2VwYXJhdG9yQ29weSwgc3RyaW5nKSkge1xuICAgICAgICBsYXN0SW5kZXggPSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdO1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSAkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSkge1xuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiAkc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGludGVybmFsU3BsaXQgPSAkc3BsaXQ7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNwbGl0XG4gICAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIHNwbGl0dGVyID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgICByZXR1cm4gc3BsaXR0ZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHNwbGl0dGVyLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgOiBpbnRlcm5hbFNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc3BsaXRcbiAgICAvL1xuICAgIC8vIE5PVEU6IFRoaXMgY2Fubm90IGJlIHByb3Blcmx5IHBvbHlmaWxsZWQgaW4gZW5naW5lcyB0aGF0IGRvbid0IHN1cHBvcnRcbiAgICAvLyB0aGUgJ3knIGZsYWcuXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCwgbGltaXQpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoaW50ZXJuYWxTcGxpdCwgcmVnZXhwLCB0aGlzLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gJHNwbGl0KTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XG5cbiAgICAgIHZhciB1bmljb2RlTWF0Y2hpbmcgPSByeC51bmljb2RlO1xuICAgICAgdmFyIGZsYWdzID0gKHJ4Lmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoU1VQUE9SVFNfWSA/ICd5JyA6ICdnJyk7XG5cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBTIHNsaWNpbmcsIHRvXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgQyhTVVBQT1JUU19ZID8gcnggOiAnXig/OicgKyByeC5zb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgaWYgKFMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFMpID09PSBudWxsID8gW1NdIDogW107XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgcSA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgd2hpbGUgKHEgPCBTLmxlbmd0aCkge1xuICAgICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBTVVBQT1JUU19ZID8gcSA6IDA7XG4gICAgICAgIHZhciB6ID0gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFNVUFBPUlRTX1kgPyBTIDogUy5zbGljZShxKSk7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgeiA9PT0gbnVsbCB8fFxuICAgICAgICAgIChlID0gJG1pbih0b0xlbmd0aChzcGxpdHRlci5sYXN0SW5kZXggKyAoU1VQUE9SVFNfWSA/IDAgOiBxKSksIFMubGVuZ3RoKSkgPT09IHBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcSA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCBxLCB1bmljb2RlTWF0Y2hpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEEucHVzaChTLnNsaWNlKHAsIHEpKTtcbiAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gei5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIEEucHVzaCh6W2ldKTtcbiAgICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcSA9IHAgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBBLnB1c2goUy5zbGljZShwKSk7XG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIF07XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar anObject = __webpack_require__(2);\nvar toObject = __webpack_require__(35);\nvar toLength = __webpack_require__(23);\nvar toInteger = __webpack_require__(24);\nvar advanceStringIndex = __webpack_require__(37);\nvar regExpExec = __webpack_require__(38);\nvar max = Math.max;\nvar min = Math.min;\nvar floor = Math.floor;\nvar SUBSTITUTION_SYMBOLS = /\\$([$&`']|\\d\\d?|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&`']|\\d\\d?)/g;\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// @@replace logic\n__webpack_require__(40)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = defined(this);\n      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n      return fn !== undefined\n        ? fn.call(searchValue, O, replaceValue)\n        : $replace.call(String(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace\n    function (regexp, replaceValue) {\n      var res = maybeCallNative($replace, regexp, this, replaceValue);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n      var functionalReplace = typeof replaceValue === 'function';\n      if (!functionalReplace) replaceValue = String(replaceValue);\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n        results.push(result);\n        if (!global) break;\n        var matchStr = String(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n        var matched = String(result[0]);\n        var position = max(min(toInteger(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = [matched].concat(captures, position, S);\n          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\n          var replacement = String(replaceValue.apply(undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + S.slice(nextSourcePosition);\n    }\n  ];\n\n    // https://tc39.github.io/ecma262/#sec-getsubstitution\n  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {\n    var tailPos = position + matched.length;\n    var m = captures.length;\n    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n    if (namedCaptures !== undefined) {\n      namedCaptures = toObject(namedCaptures);\n      symbols = SUBSTITUTION_SYMBOLS;\n    }\n    return $replace.call(replacement, symbols, function (match, ch) {\n      var capture;\n      switch (ch.charAt(0)) {\n        case '$': return '$';\n        case '&': return matched;\n        case '`': return str.slice(0, position);\n        case \"'\": return str.slice(tailPos);\n        case '<':\n          capture = namedCaptures[ch.slice(1, -1)];\n          break;\n        default: // \\d\\d?\n          var n = +ch;\n          if (n === 0) return match;\n          if (n > m) {\n            var f = floor(n / 10);\n            if (f === 0) return match;\n            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n            return match;\n          }\n          capture = captures[n - 1];\n      }\n      return capture === undefined ? '' : capture;\n    });\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcz9hNDgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxDQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsRUFBeUI7QUFDMUQsaUJBQWlCLG1CQUFPLENBQUMsRUFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLEVBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsImZpbGUiOiIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXCQoWyQmYCddfFxcZFxcZD98PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmYCddfFxcZFxcZD8pL2c7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkcmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgfVxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcblxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gICAgfSk7XG4gIH1cbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n")},function(module,exports,__webpack_require__){eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(9);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanM/NmE5OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxDQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n")},function(module,exports,__webpack_require__){"use strict";eval("\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = __webpack_require__(2);\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcz8wYmZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28\n")},function(module,exports,__webpack_require__){eval("var $iterators = __webpack_require__(58);\nvar getKeys = __webpack_require__(22);\nvar redefine = __webpack_require__(10);\nvar global = __webpack_require__(3);\nvar hide = __webpack_require__(5);\nvar Iterators = __webpack_require__(30);\nvar wks = __webpack_require__(1);\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanM/YWM2YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFzQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsRUFBZ0I7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLEVBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLENBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLENBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsRUFBYztBQUN0QyxVQUFVLG1CQUFPLENBQUMsQ0FBUTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyICRpdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXG4gIENTU1ZhbHVlTGlzdDogZmFsc2UsXG4gIENsaWVudFJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxuICBET01TdHJpbmdMaXN0OiBmYWxzZSxcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXG4gIEZpbGVMaXN0OiBmYWxzZSxcbiAgSFRNTEFsbENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxGb3JtRWxlbWVudDogZmFsc2UsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiBmYWxzZSxcbiAgTWVkaWFMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgTWltZVR5cGVBcnJheTogZmFsc2UsXG4gIE5hbWVkTm9kZU1hcDogZmFsc2UsXG4gIE5vZGVMaXN0OiB0cnVlLFxuICBQYWludFJlcXVlc3RMaXN0OiBmYWxzZSxcbiAgUGx1Z2luOiBmYWxzZSxcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxuICBTVkdMZW5ndGhMaXN0OiBmYWxzZSxcbiAgU1ZHTnVtYmVyTGlzdDogZmFsc2UsXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcbiAgU1ZHUG9pbnRMaXN0OiBmYWxzZSxcbiAgU1ZHU3RyaW5nTGlzdDogZmFsc2UsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxuICBTb3VyY2VCdWZmZXJMaXN0OiBmYWxzZSxcbiAgU3R5bGVTaGVldExpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcbiAgVGV4dFRyYWNrTGlzdDogZmFsc2UsXG4gIFRvdWNoTGlzdDogZmFsc2Vcbn07XG5cbmZvciAodmFyIGNvbGxlY3Rpb25zID0gZ2V0S2V5cyhET01JdGVyYWJsZXMpLCBpID0gMDsgaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XG4gIHZhciBleHBsaWNpdCA9IERPTUl0ZXJhYmxlc1tOQU1FXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBrZXk7XG4gIGlmIChwcm90bykge1xuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmICghcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n")},function(module,exports){eval("module.exports = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanM/ODRmMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge307XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(3);\nvar core = __webpack_require__(18);\nvar hide = __webpack_require__(5);\nvar redefine = __webpack_require__(10);\nvar ctx = __webpack_require__(63);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanM/NWNhMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsQ0FBVztBQUNoQyxXQUFXLG1CQUFPLENBQUMsRUFBUztBQUM1QixXQUFXLG1CQUFPLENBQUMsQ0FBUztBQUM1QixlQUFlLG1CQUFPLENBQUMsRUFBYTtBQUNwQyxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsdUJBQXVCO0FBQ3pHLGlFQUFpRTtBQUNqRSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQiIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n")},function(module,exports,__webpack_require__){eval("var shared = __webpack_require__(17)('keys');\nvar uid = __webpack_require__(12);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzPzYxM2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLEVBQVc7QUFDaEMsVUFBVSxtQkFBTyxDQUFDLEVBQVE7QUFDMUI7QUFDQTtBQUNBIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n")},function(module,exports){eval("// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzP2UxMWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n")},function(module,exports,__webpack_require__){eval("var def = __webpack_require__(7).f;\nvar has = __webpack_require__(8);\nvar TAG = __webpack_require__(1)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcz83ZjIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxDQUFjO0FBQ2hDLFVBQVUsbUJBQU8sQ0FBQyxDQUFRO0FBQzFCLFVBQVUsbUJBQU8sQ0FBQyxDQUFROztBQUUxQjtBQUNBLG9FQUFvRSxpQ0FBaUM7QUFDckciLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34\n")},function(module,exports,__webpack_require__){eval("// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(21);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanM/NGJmOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDO0FBQ0E7QUFDQSIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n")},function(module,exports){eval("exports.f = {}.propertyIsEnumerable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzPzUyYTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyIsImZpbGUiOiIzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar at = __webpack_require__(77)(true);\n\n // `AdvanceStringIndex` abstract operation\n// https://tc39.github.io/ecma262/#sec-advancestringindex\nmodule.exports = function (S, index, unicode) {\n  return index + (unicode ? at(S, index).length : 1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZHZhbmNlLXN0cmluZy1pbmRleC5qcz8wMzkwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsU0FBUyxtQkFBTyxDQUFDLEVBQWM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar classof = __webpack_require__(78);\nvar builtinExec = RegExp.prototype.exec;\n\n // `RegExpExec` abstract operation\n// https://tc39.github.io/ecma262/#sec-regexpexec\nmodule.exports = function (R, S) {\n  var exec = R.exec;\n  if (typeof exec === 'function') {\n    var result = exec.call(R, S);\n    if (typeof result !== 'object') {\n      throw new TypeError('RegExp exec method returned something other than an Object or null');\n    }\n    return result;\n  }\n  if (classof(R) !== 'RegExp') {\n    throw new TypeError('RegExp#exec called on incompatible receiver');\n  }\n  return builtinExec.call(R, S);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcz81ZjFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBidWlsdGluRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcblxuIC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cbiAgcmV0dXJuIGJ1aWx0aW5FeGVjLmNhbGwoUiwgUyk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar regexpFlags = __webpack_require__(28);\n\nvar nativeExec = RegExp.prototype.exec;\n// This always refers to the native implementation, because the\n// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n// which loads this file before patching the method.\nvar nativeReplace = String.prototype.replace;\n\nvar patchedExec = nativeExec;\n\nvar LAST_INDEX = 'lastIndex';\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/,\n      re2 = /b*/g;\n  nativeExec.call(re1, 'a');\n  nativeExec.call(re2, 'a');\n  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;\n})();\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;\n\nif (PATCH) {\n  patchedExec = function exec(str) {\n    var re = this;\n    var lastIndex, reCopy, match, i;\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + re.source + '$(?!\\\\s)', regexpFlags.call(re));\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];\n\n    match = nativeExec.call(re, str);\n\n    if (UPDATES_LAST_INDEX_WRONG && match) {\n      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      // eslint-disable-next-line no-loop-func\n      nativeReplace.call(match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    return match;\n  };\n}\n\nmodule.exports = patchedExec;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcz81MjBhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLEVBQVU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS8sXG4gICAgICByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMVtMQVNUX0lOREVYXSAhPT0gMCB8fCByZTJbTEFTVF9JTkRFWF0gIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmVbTEFTVF9JTkRFWF07XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n")},function(module,exports,__webpack_require__){"use strict";eval("\n__webpack_require__(79);\nvar redefine = __webpack_require__(10);\nvar hide = __webpack_require__(5);\nvar fails = __webpack_require__(6);\nvar defined = __webpack_require__(21);\nvar wks = __webpack_require__(1);\nvar regexpExec = __webpack_require__(39);\n\nvar SPECIES = wks('species');\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  // #replace needs built-in support for named groups.\n  // #match works fine because it just return the exec results, even if it has\n  // a \"grops\" property.\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  return ''.replace(re, '$<a>') !== '7';\n});\n\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {\n  // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length === 2 && result[0] === 'a' && result[1] === 'b';\n})();\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n    re.exec = function () { execCalled = true; return null; };\n    if (KEY === 'split') {\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n    }\n    re[SYMBOL]('');\n    return !execCalled;\n  }) : undefined;\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\n  ) {\n    var nativeRegExpMethod = /./[SYMBOL];\n    var fns = exec(\n      defined,\n      SYMBOL,\n      ''[KEY],\n      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\n        if (regexp.exec === regexpExec) {\n          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n            // The native String method already delegates to @@method (this\n            // polyfilled function), leasing to infinite recursion.\n            // We avoid it by directly calling the native @@method method.\n            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\n          }\n          return { done: true, value: nativeMethod.call(str, regexp, arg2) };\n        }\n        return { done: false };\n      }\n    );\n    var strfn = fns[0];\n    var rxfn = fns[1];\n\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzPzIxNGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixtQkFBTyxDQUFDLEVBQW1CO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxFQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxDQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxDQUFVO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDLFVBQVUsbUJBQU8sQ0FBQyxDQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLEVBQWdCOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUIsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBIiwiZmlsZSI6IjQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmV4ZWMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMnKTtcblxudmFyIFNQRUNJRVMgPSB3a3MoJ3NwZWNpZXMnKTtcblxudmFyIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gI3JlcGxhY2UgbmVlZHMgYnVpbHQtaW4gc3VwcG9ydCBmb3IgbmFtZWQgZ3JvdXBzLlxuICAvLyAjbWF0Y2ggd29ya3MgZmluZSBiZWNhdXNlIGl0IGp1c3QgcmV0dXJuIHRoZSBleGVjIHJlc3VsdHMsIGV2ZW4gaWYgaXQgaGFzXG4gIC8vIGEgXCJncm9wc1wiIHByb3BlcnR5LlxuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIENocm9tZSA1MSBoYXMgYSBidWdneSBcInNwbGl0XCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xuICB2YXIgcmUgPSAvKD86KS87XG4gIHZhciBvcmlnaW5hbEV4ZWMgPSByZS5leGVjO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JpZ2luYWxFeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gIHZhciByZXN1bHQgPSAnYWInLnNwbGl0KHJlKTtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDIgJiYgcmVzdWx0WzBdID09PSAnYScgJiYgcmVzdWx0WzFdID09PSAnYic7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYykge1xuICB2YXIgU1lNQk9MID0gd2tzKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCA/ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgIH1cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pIDogdW5kZWZpbmVkO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIChLRVkgPT09ICdyZXBsYWNlJyAmJiAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMpIHx8XG4gICAgKEtFWSA9PT0gJ3NwbGl0JyAmJiAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDKVxuICApIHtcbiAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG4gICAgdmFyIGZucyA9IGV4ZWMoXG4gICAgICBkZWZpbmVkLFxuICAgICAgU1lNQk9MLFxuICAgICAgJydbS0VZXSxcbiAgICAgIGZ1bmN0aW9uIG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICBpZiAocmVnZXhwLmV4ZWMgPT09IHJlZ2V4cEV4ZWMpIHtcbiAgICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVSZWdFeHBNZXRob2QuY2FsbChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZU1ldGhvZC5jYWxsKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XG4gICAgICB9XG4gICAgKTtcbiAgICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gICAgdmFyIHJ4Zm4gPSBmbnNbMV07XG5cbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40\n")},function(module,exports,__webpack_require__){eval("module.exports = !__webpack_require__(4) && !__webpack_require__(6)(function () {\n  return Object.defineProperty(__webpack_require__(42)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcz9jNjlhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixtQkFBTyxDQUFDLENBQWdCLE1BQU0sbUJBQU8sQ0FBQyxDQUFVO0FBQ2xFLCtCQUErQixtQkFBTyxDQUFDLEVBQWUsZ0JBQWdCLG1CQUFtQixVQUFVLEVBQUUsRUFBRTtBQUN2RyxDQUFDIiwiZmlsZSI6IjQxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(9);\nvar document = __webpack_require__(3).document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzPzIzMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLENBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLENBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///42\n")},function(module,exports){eval("module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzP2Q4ZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(2);\nvar dPs = __webpack_require__(65);\nvar enumBugKeys = __webpack_require__(33);\nvar IE_PROTO = __webpack_require__(32)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(42)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(68).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzPzJhZWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxVQUFVLG1CQUFPLENBQUMsRUFBZTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFrQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsRUFBZTtBQUN0Qyx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLEVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbUJBQU8sQ0FBQyxFQUFTO0FBQ25CLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///44\n")},function(module,exports,__webpack_require__){eval("var has = __webpack_require__(8);\nvar toIObject = __webpack_require__(11);\nvar arrayIndexOf = __webpack_require__(66)(false);\nvar IE_PROTO = __webpack_require__(32)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcz9jZTEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxDQUFRO0FBQzFCLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsRUFBbUI7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLEVBQWU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0NS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45\n")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(3);\nvar core = __webpack_require__(18);\nvar LIBRARY = __webpack_require__(19);\nvar wksExt = __webpack_require__(47);\nvar defineProperty = __webpack_require__(7).f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzPzNhNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLENBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLEVBQVM7QUFDNUIsY0FBYyxtQkFBTyxDQUFDLEVBQVk7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLEVBQVk7QUFDakMscUJBQXFCLG1CQUFPLENBQUMsQ0FBYztBQUMzQztBQUNBLDBEQUEwRCxzQkFBc0I7QUFDaEYsa0ZBQWtGLHdCQUF3QjtBQUMxRyIsImZpbGUiOiI0Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///46\n")},function(module,exports,__webpack_require__){eval("exports.f = __webpack_require__(1);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzPzM3YzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxtQkFBTyxDQUFDLENBQVEiLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///47\n")},function(module,exports){eval("exports.f = Object.getOwnPropertySymbols;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcz8yNjIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __webpack_require__(45);\nvar hiddenKeys = __webpack_require__(33).concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcz85MDkzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLEVBQXlCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLEVBQWtCOztBQUUzQztBQUNBO0FBQ0EiLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49\n")},function(module,exports){eval("function DefaultGraph () {\n  this.value = ''\n}\n\nDefaultGraph.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType\n}\n\nDefaultGraph.prototype.termType = 'DefaultGraph'\n\nmodule.exports = DefaultGraph\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL2RlZmF1bHQtZ3JhcGguanM/ZDc2YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjUwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gRGVmYXVsdEdyYXBoICgpIHtcbiAgdGhpcy52YWx1ZSA9ICcnXG59XG5cbkRlZmF1bHRHcmFwaC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiAhIW90aGVyICYmIG90aGVyLnRlcm1UeXBlID09PSB0aGlzLnRlcm1UeXBlXG59XG5cbkRlZmF1bHRHcmFwaC5wcm90b3R5cGUudGVybVR5cGUgPSAnRGVmYXVsdEdyYXBoJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRHcmFwaFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///50\n")},function(module,exports){eval("function NamedNode (iri) {\n  this.value = iri\n}\n\nNamedNode.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nNamedNode.prototype.termType = 'NamedNode'\n\nmodule.exports = NamedNode\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL25hbWVkLW5vZGUuanM/MTFhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjUxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gTmFtZWROb2RlIChpcmkpIHtcbiAgdGhpcy52YWx1ZSA9IGlyaVxufVxuXG5OYW1lZE5vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICByZXR1cm4gISFvdGhlciAmJiBvdGhlci50ZXJtVHlwZSA9PT0gdGhpcy50ZXJtVHlwZSAmJiBvdGhlci52YWx1ZSA9PT0gdGhpcy52YWx1ZVxufVxuXG5OYW1lZE5vZGUucHJvdG90eXBlLnRlcm1UeXBlID0gJ05hbWVkTm9kZSdcblxubW9kdWxlLmV4cG9ydHMgPSBOYW1lZE5vZGVcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51\n")},function(module,exports){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _solid_auth_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n // Export a singleton instance of SolidAuthClient\n\nconst auth = new _solid_auth_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n/* harmony default export */ __webpack_exports__[\"default\"] = (auth); // Bind methods to instance, so they can be invoked as regular functions\n// (e.g., to pass around the fetch function)\n\nObject.getOwnPropertyNames(_solid_auth_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype).forEach(property => {\n  const value = auth[property];\n\n  if (typeof value === 'function') {\n    auth[property] = value.bind(auth);\n  }\n}); // Expose window.SolidAuthClient for backward compatibility\n\nif (typeof window !== 'undefined') {\n  if ('SolidAuthClient' in window) {\n    console.warn('Caution: multiple versions of solid-auth-client active.');\n  } else {\n    let warned = false;\n    Object.defineProperty(window, 'SolidAuthClient', {\n      enumerable: true,\n      get: () => {\n        if (!warned) {\n          warned = true;\n          console.warn('window.SolidAuthClient has been deprecated.');\n          console.warn('Please use window.solid.auth instead.');\n        }\n\n        return auth;\n      }\n    });\n  }\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SolidAuthClient; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _authn_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);\n/* harmony import */ var _popup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);\n/* harmony import */ var _webid_oidc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* global fetch */\n\n\n\n\n\n\n // Store the global fetch, so the user is free to override it\n\nconst globalFetch = fetch;\nclass SolidAuthClient extends events__WEBPACK_IMPORTED_MODULE_1___default.a {\n  constructor() {\n    super(...arguments);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_pendingSession\", void 0);\n  }\n\n  fetch(input, options) {\n    this.emit('request', Object(_url_util__WEBPACK_IMPORTED_MODULE_6__[\"toUrlString\"])(input));\n    return Object(_authn_fetch__WEBPACK_IMPORTED_MODULE_2__[\"authnFetch\"])(Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])(), globalFetch, input, options);\n  }\n\n  login(idp, options) {\n    options = _objectSpread({}, defaultLoginOptions(Object(_url_util__WEBPACK_IMPORTED_MODULE_6__[\"currentUrlNoParams\"])()), {}, options);\n    return _webid_oidc__WEBPACK_IMPORTED_MODULE_7__[\"login\"](idp, options);\n  }\n\n  async popupLogin(options) {\n    options = _objectSpread({}, defaultLoginOptions(), {}, options);\n\n    if (!/https?:/.test(options.popupUri)) {\n      options.popupUri = new URL(options.popupUri || '/.well-known/solid/login', window.location).toString();\n    }\n\n    if (!options.callbackUri) {\n      options.callbackUri = options.popupUri;\n    }\n\n    const popup = Object(_popup__WEBPACK_IMPORTED_MODULE_3__[\"openIdpPopup\"])(options.popupUri);\n    const session = await Object(_popup__WEBPACK_IMPORTED_MODULE_3__[\"obtainSession\"])(options.storage, popup, options);\n    this.emit('login', session);\n    this.emit('session', session);\n    return session;\n  }\n\n  async currentSession() {\n    let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])();\n    // Try to obtain a stored or pending session\n    let session = this._pendingSession || (await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"getSession\"])(storage)); // If none found, attempt to create a new session\n\n    if (!session) {\n      // Try to create a new OIDC session from stored tokens\n      try {\n        this._pendingSession = _webid_oidc__WEBPACK_IMPORTED_MODULE_7__[\"currentSession\"](storage);\n        session = await this._pendingSession;\n      } catch (err) {\n        console.error(err);\n      } // Save the new session and emit session events\n\n\n      if (session) {\n        await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"saveSession\"])(storage)(session);\n        this.emit('login', session);\n        this.emit('session', session);\n      }\n\n      delete this._pendingSession;\n    }\n\n    return session;\n  }\n\n  async trackSession(callback) {\n    /* eslint-disable standard/no-callback-literal */\n    callback((await this.currentSession()));\n    this.on('session', callback);\n  }\n\n  stopTrackSession(callback) {\n    this.removeListener('session', callback);\n  }\n\n  async logout() {\n    let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])();\n    const session = await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"getSession\"])(storage);\n\n    if (session) {\n      try {\n        await _webid_oidc__WEBPACK_IMPORTED_MODULE_7__[\"logout\"](storage, globalFetch);\n        this.emit('logout');\n        this.emit('session', null);\n      } catch (err) {\n        console.warn('Error logging out:');\n        console.error(err);\n      }\n\n      await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"clearSession\"])(storage);\n    }\n  }\n\n}\n\nfunction defaultLoginOptions(url) {\n  return {\n    callbackUri: url ? url.split('#')[0] : '',\n    popupUri: '',\n    storage: Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])()\n  };\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authnFetch\", function() { return authnFetch; });\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n/* harmony import */ var _host__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);\n/* harmony import */ var _webid_oidc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);\n\n\n\n\n\nasync function authnFetch(storage, fetch, input, options) {\n  // If not authenticated, perform a regular fetch\n  const session = await Object(_session__WEBPACK_IMPORTED_MODULE_3__[\"getSession\"])(storage);\n\n  if (!session) {\n    return fetch(input, options);\n  } // If we know the server expects credentials, send them\n\n\n  if (await shouldShareCredentials(storage, input)) {\n    return Object(_webid_oidc__WEBPACK_IMPORTED_MODULE_4__[\"fetchWithCredentials\"])(session, fetch, input, options);\n  } // If we don't know for sure, try a regular fetch first\n\n\n  let resp = await fetch(input, options); // If the server then requests credentials, send them\n\n  if (resp.status === 401) {\n    await Object(_host__WEBPACK_IMPORTED_MODULE_2__[\"updateHostFromResponse\"])(storage)(resp);\n\n    if (await shouldShareCredentials(storage, input)) {\n      resp = Object(_webid_oidc__WEBPACK_IMPORTED_MODULE_4__[\"fetchWithCredentials\"])(session, fetch, input, options);\n    }\n  }\n\n  return resp;\n}\n\nasync function shouldShareCredentials(storage, input) {\n  const requestHost = await Object(_host__WEBPACK_IMPORTED_MODULE_2__[\"getHost\"])(storage)(Object(_url_util__WEBPACK_IMPORTED_MODULE_1__[\"toUrlString\"])(input));\n  return requestHost != null && requestHost.requiresAuth;\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"fetch\"]; }());\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentUrl\", function() { return currentUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentUrlNoParams\", function() { return currentUrlNoParams; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"navigateTo\", function() { return navigateTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"originOf\", function() { return originOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toUrlString\", function() { return toUrlString; });\n/* eslint-env browser */\nfunction getLocation() {\n  return typeof window !== 'undefined' ? window.location : {\n    href: 'https://example.org/',\n    pathname: '/',\n    origin: 'example.org'\n  };\n}\n\nconst currentUrl = () => getLocation().href;\nconst currentUrlNoParams = () => getLocation().origin + getLocation().pathname;\nconst navigateTo = url => {\n  getLocation().href = url;\n};\nconst originOf = url => new URL(url).origin;\nconst toUrlString = url => {\n  if (typeof url !== 'string') {\n    url = 'url' in url ? url.url : url.toString();\n  }\n\n  return new URL(url, currentUrl()).toString();\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHost\", function() { return getHost; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveHost\", function() { return saveHost; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateHostFromResponse\", function() { return updateHostFromResponse; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);\n/* harmony import */ var _webid_oidc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* globalRequest, Response, URL */\n\n\n\nfunction getHost(storage) {\n  return async url => {\n    const {\n      host\n    } = new URL(url);\n    const session = await Object(_session__WEBPACK_IMPORTED_MODULE_1__[\"getSession\"])(storage);\n\n    if (session && host === new URL(session.idp).host) {\n      return {\n        url: host,\n        requiresAuth: true\n      };\n    }\n\n    const {\n      hosts\n    } = await Object(_storage__WEBPACK_IMPORTED_MODULE_2__[\"getData\"])(storage);\n    return hosts && hosts[host];\n  };\n}\nfunction saveHost(storage) {\n  return async (_ref) => {\n    let {\n      url,\n      requiresAuth\n    } = _ref;\n    await Object(_storage__WEBPACK_IMPORTED_MODULE_2__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n      hosts: _objectSpread({}, data.hosts, {\n        [url]: {\n          requiresAuth\n        }\n      })\n    }));\n  };\n}\nfunction updateHostFromResponse(storage) {\n  return async resp => {\n    if (_webid_oidc__WEBPACK_IMPORTED_MODULE_3__[\"requiresAuth\"](resp)) {\n      const {\n        host\n      } = new URL(resp.url);\n      await saveHost(storage)({\n        url: host,\n        requiresAuth: true\n      });\n    }\n  };\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSession\", function() { return getSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveSession\", function() { return saveSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearSession\", function() { return clearSession; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\nasync function getSession(storage) {\n  const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"getData\"])(storage);\n  return data.session || null;\n}\nfunction saveSession(storage) {\n  return async session => {\n    const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n      session\n    }));\n    return data.session;\n  };\n}\nasync function clearSession(storage) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n    session: null\n  }));\n}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NAMESPACE\", function() { return NAMESPACE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultStorage\", function() { return defaultStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getData\", function() { return getData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateStorage\", function() { return updateStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asyncStorage\", function() { return asyncStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memStorage\", function() { return memStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ipcStorage\", function() { return ipcStorage; });\n/* harmony import */ var _ipc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n\nconst NAMESPACE = 'solid-auth-client';\nconst defaultStorage = () => {\n  const hasLocalStorage = typeof window !== 'undefined' && 'localStorage' in window;\n  return asyncStorage(hasLocalStorage ? window.localStorage : memStorage());\n};\n/**\n * Gets the deserialized stored data\n */\n\nasync function getData(store) {\n  let serialized;\n  let data;\n\n  try {\n    serialized = await store.getItem(NAMESPACE);\n    data = JSON.parse(serialized || '{}');\n  } catch (e) {\n    console.warn('Could not deserialize data:', serialized);\n    console.error(e);\n    data = {};\n  }\n\n  return data;\n}\n/**\n * Updates a Storage object without mutating its intermediate representation.\n */\n\nasync function updateStorage(store, update) {\n  const currentData = await getData(store);\n  const newData = update(currentData);\n  await store.setItem(NAMESPACE, JSON.stringify(newData));\n  return newData;\n}\n/**\n * Takes a synchronous storage interface and wraps it with an async interface.\n */\n\nfunction asyncStorage(storage) {\n  return {\n    getItem: key => {\n      return Promise.resolve(storage.getItem(key));\n    },\n    setItem: (key, val) => {\n      return Promise.resolve(storage.setItem(key, val));\n    },\n    removeItem: key => {\n      return Promise.resolve(storage.removeItem(key));\n    }\n  };\n}\nconst memStorage = () => {\n  const store = {};\n  return {\n    getItem: key => {\n      if (typeof store[key] === 'undefined') return null;\n      return store[key];\n    },\n    setItem: (key, val) => {\n      store[key] = val;\n    },\n    removeItem: key => {\n      delete store[key];\n    }\n  };\n};\nfunction ipcStorage(client) {\n  return {\n    getItem: key => client.request('storage/getItem', key),\n    setItem: (key, val) => client.request('storage/setItem', key, val),\n    removeItem: key => client.request('storage/removeItem', key)\n  };\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Server\", function() { return Server; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Client\", function() { return Client; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/*\n  This module describes a simple IPC interface for communicating between browser windows.\n  window.postMessage() is the transport interface, and a request/response interface\n  is defined on top of it as follows:\n\n  const request = {\n    'solid-auth-client': {\n      id: 1234,\n      method: 'doSomethingPlease',\n      args: [ 'one', 'two', 'three' ]\n    }\n  }\n\n  const response = {\n    'solid-auth-client': {\n      id: 1234,\n      ret: 'the_value'\n    }\n  }\n*/\nconst NAMESPACE = 'solid-auth-client';\n/**\n * Receives and handles remote procedure calls.\n */\n\nclass Server {\n  constructor(clientWindow, clientOrigin, handle) {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_clientWindow\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_clientOrigin\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_handler\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_messageListener\", void 0);\n\n    this._clientWindow = clientWindow;\n    this._clientOrigin = clientOrigin;\n    this._handler = handle;\n\n    this._messageListener = event => this._handleMessage(event);\n  }\n\n  async _handleMessage(_ref) {\n    let {\n      data,\n      origin\n    } = _ref;\n\n    // Ensure we can post to the origin\n    if (origin !== this._clientOrigin) {\n      console.warn(\"solid-auth-client is listening to \".concat(this._clientOrigin, \" \") + \"so ignored a message received from \".concat(origin, \".\"));\n      return;\n    } // Parse the request and send it to the handler\n\n\n    const req = data && data[NAMESPACE];\n\n    if (req && req.method) {\n      const {\n        id,\n        method,\n        args\n      } = req;\n      const ret = await this._handler(method, ...args);\n\n      this._clientWindow.postMessage({\n        [NAMESPACE]: {\n          id,\n          ret\n        }\n      }, this._clientOrigin);\n    }\n  }\n\n  start() {\n    window.addEventListener('message', this._messageListener);\n  }\n\n  stop() {\n    window.removeEventListener('message', this._messageListener);\n  }\n\n}\n/**\n * Makes remote procedure calls.\n */\n\nclass Client {\n  constructor(serverWindow, serverOrigin) {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_serverWindow\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_serverOrigin\", void 0);\n\n    this._serverWindow = serverWindow;\n    this._serverOrigin = serverOrigin;\n  }\n\n  request(method) {\n    // Send the request as a message to the server window\n    const id = Math.random();\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    this._serverWindow.postMessage({\n      [NAMESPACE]: {\n        id,\n        method,\n        args\n      }\n    }, this._serverOrigin); // Create a promise that resolves to the request's return value\n\n\n    return new Promise((resolve, reject) => {\n      // Listen for responses to the request\n      window.addEventListener('message', responseListener); // Cancel if the response takes too long\n\n      const timeout = setTimeout(() => {\n        reject(new Error('Could not connect to main window.'));\n        window.removeEventListener('message', responseListener);\n      }, 2000); // Processes a possible response to the request\n\n      function responseListener(_ref2) {\n        let {\n          data\n        } = _ref2;\n        const resp = data && data[NAMESPACE];\n\n        if (resp && resp.id === id && resp.hasOwnProperty('ret')) {\n          resolve(resp.ret);\n          clearTimeout(timeout);\n          window.removeEventListener('message', responseListener);\n        }\n      }\n    });\n  }\n\n}\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"login\", function() { return login; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentSession\", function() { return currentSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logout\", function() { return logout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRegisteredRp\", function() { return getRegisteredRp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requiresAuth\", function() { return requiresAuth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetchWithCredentials\", function() { return fetchWithCredentials; });\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var auth_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);\n/* harmony import */ var auth_header__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(auth_header__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18);\n/* harmony import */ var _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(80);\n/* harmony import */ var _solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* global Response */\n\n\n\n\n\nasync function login(idp, options) {\n  try {\n    const rp = await getRegisteredRp(idp, options);\n    await saveAppHashFragment(options.storage);\n    return sendAuthRequest(rp, options);\n  } catch (err) {\n    console.warn('Error logging in with WebID-OIDC');\n    console.error(err);\n    return null;\n  }\n}\nasync function currentSession() {\n  let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"defaultStorage\"])();\n\n  try {\n    // Obtain the Relying Party\n    const rp = await getStoredRp(storage);\n\n    if (!rp) {\n      return null;\n    } // Obtain and clear the OIDC URL fragment\n\n\n    const url = Object(_url_util__WEBPACK_IMPORTED_MODULE_5__[\"currentUrl\"])();\n\n    if (!/#(.*&)?access_token=/.test(url)) {\n      return null;\n    }\n\n    window.location.hash = '';\n    await restoreAppHashFragment(storage); // Obtain a session from the Relying Party\n\n    const storeData = await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"getData\"])(storage);\n    const session = await rp.validateResponse(url, storeData);\n\n    if (!session) {\n      return null;\n    }\n\n    return _objectSpread({}, session, {\n      webId: session.idClaims.sub,\n      idp: session.issuer\n    });\n  } catch (err) {\n    console.warn('Error finding a WebID-OIDC session');\n    console.error(err);\n    return null;\n  }\n}\nasync function logout(storage, fetch) {\n  const rp = await getStoredRp(storage);\n\n  if (rp) {\n    try {\n      // First log out from the IDP\n      await rp.logout(); // Then, log out from the RP\n\n      try {\n        await fetch('/.well-known/solid/logout', {\n          credentials: 'include'\n        });\n      } catch (e) {// Ignore errors for when we are not on a Solid pod\n      }\n    } catch (err) {\n      console.warn('Error logging out of the WebID-OIDC session');\n      console.error(err);\n    }\n  }\n}\nasync function getRegisteredRp(idp, options) {\n  // To reuse a possible previous RP,\n  // it be for the same IDP and redirect URI\n  let rp = await getStoredRp(options.storage);\n\n  if (!rp || rp.provider.url !== idp || !rp.registration.redirect_uris.includes(options.callbackUri)) {\n    // Register a new RP\n    rp = await registerRp(idp, options);\n    await storeRp(options.storage, idp, rp);\n  }\n\n  return rp;\n}\n\nasync function getStoredRp(storage) {\n  const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"getData\"])(storage);\n  const {\n    rpConfig\n  } = data;\n\n  if (rpConfig) {\n    rpConfig.store = storage;\n    return _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3___default.a.from(rpConfig);\n  } else {\n    return null;\n  }\n}\n\nasync function storeRp(storage, idp, rp) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n    rpConfig: rp\n  }));\n  return rp;\n}\n\nfunction registerRp(idp, opts) {\n  const {\n    storage,\n    callbackUri\n  } = opts;\n  const responseType = 'id_token token';\n  const clientNameI18n = {};\n  Object.entries(opts).filter((_ref) => {\n    let [key, _] = _ref;\n    return key.startsWith('clientName#');\n  }).forEach((_ref2) => {\n    let [key, value] = _ref2;\n    return clientNameI18n[key.replace('clientName#', 'client_name#')] = value;\n  });\n  const supplementaryOptions = {\n    logo_uri: opts.logoUri,\n    contacts: opts.contacts,\n    client_name: opts.clientName\n  };\n\n  const registration = _objectSpread({\n    issuer: idp,\n    grant_types: ['implicit'],\n    redirect_uris: [callbackUri],\n    response_types: [responseType],\n    scope: 'openid profile'\n  }, clientNameI18n, {}, supplementaryOptions);\n\n  const options = {\n    defaults: {\n      authenticate: {\n        redirect_uri: callbackUri,\n        response_type: responseType\n      }\n    },\n    store: storage\n  };\n  return _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3___default.a.register(idp, registration, options);\n}\n\nasync function sendAuthRequest(rp, _ref3) {\n  let {\n    callbackUri,\n    storage\n  } = _ref3;\n  const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"getData\"])(storage);\n  const url = await rp.createRequest({\n    redirect_uri: callbackUri\n  }, data);\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(storage, () => data);\n  return Object(_url_util__WEBPACK_IMPORTED_MODULE_5__[\"navigateTo\"])(url);\n}\n\nasync function saveAppHashFragment(store) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(store, data => _objectSpread({}, data, {\n    appHashFragment: window.location.hash\n  }));\n}\n\nasync function restoreAppHashFragment(store) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(store, (_ref4) => {\n    let {\n      appHashFragment = ''\n    } = _ref4,\n        data = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(_ref4, [\"appHashFragment\"]);\n\n    window.location.hash = appHashFragment;\n    return data;\n  });\n}\n/**\n * Answers whether a HTTP response requires WebID-OIDC authentication.\n */\n\n\nfunction requiresAuth(resp) {\n  if (resp.status !== 401) {\n    return false;\n  }\n\n  const wwwAuthHeader = resp.headers.get('www-authenticate');\n\n  if (!wwwAuthHeader) {\n    return false;\n  }\n\n  const auth = auth_header__WEBPACK_IMPORTED_MODULE_2__[\"parse\"](wwwAuthHeader);\n  return auth.scheme === 'Bearer' && auth.params && auth.params.scope === 'openid webid';\n}\n/**\n * Fetches a resource, providing the WebID-OIDC ID Token as authentication.\n * Assumes that the resource has requested those tokens in a previous response.\n */\n\nasync function fetchWithCredentials(session, fetch, input, options) {\n  // Create a copy of the headers\n  const headers = {};\n  const origHeaders = options ? options.headers : input.headers;\n\n  if (origHeaders) {\n    const entries = typeof origHeaders.entries === 'function' ? origHeaders.entries() : Object.entries(origHeaders);\n\n    for (const [name, value] of entries) {\n      headers[name] = value;\n    }\n  } // Add Authorization header\n\n\n  const popToken = await _solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4___default.a.issueFor(Object(_url_util__WEBPACK_IMPORTED_MODULE_5__[\"toUrlString\"])(input), session);\n  headers.authorization = \"Bearer \".concat(popToken);\n  return fetch(input, _objectSpread({}, options, {\n    credentials: 'include',\n    headers\n  }));\n}\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar objectWithoutPropertiesLoose = __webpack_require__(13);\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"format\", {\n  enumerable: true,\n  get: function get() {\n    return _format.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function get() {\n    return _parse.default;\n  }\n});\n\nvar _format = _interopRequireDefault(__webpack_require__(15));\n\nvar _parse = _interopRequireDefault(__webpack_require__(17));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = __webpack_require__(16);\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar xxx = function xxx(key) {\n  return function (value) {\n    return `${key}=${value && !(0, _util.isToken)(value) ? (0, _util.quote)(value) : value}`;\n  };\n};\n\nvar build = function build(params) {\n  return params.reduce(function (prev, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        values = _ref2[1];\n\n    var transform = xxx(key);\n\n    if (!(0, _util.isToken)(key)) {\n      throw new TypeError();\n    }\n\n    if (Array.isArray(values)) {\n      return _toConsumableArray(prev).concat(_toConsumableArray(values.map(transform)));\n    }\n\n    return _toConsumableArray(prev).concat([transform(values)]);\n  }, []);\n};\n\nvar challenge = function challenge(params, options) {\n  if (Array.isArray(params)) {\n    return build(params);\n  } else if (typeof params === 'object') {\n    var entries = params;\n    return challenge(Object.keys(params).map(function (key) {\n      return [key, entries[key]];\n    }), options);\n  }\n\n  throw new TypeError();\n};\n\nvar _default = function _default(scheme, token, params) {\n  var obj = typeof scheme === 'string' ? {\n    scheme,\n    token,\n    params\n  } : scheme;\n\n  if (typeof obj !== 'object') {\n    throw new TypeError();\n  } else if (!(0, _util.isScheme)(obj.scheme)) {\n    throw new TypeError('Invalid scheme.');\n  }\n\n  return [obj.scheme].concat(_toConsumableArray(typeof obj.token !== 'undefined' ? [obj.token] : []), _toConsumableArray(typeof obj.params !== 'undefined' ? challenge(obj.params) : [])).join(' ');\n};\n\nexports.default = _default;\n//# sourceMappingURL=format.js.map\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unquote = exports.quote = exports.isScheme = exports.isToken = void 0;\nvar token = /^[^\\u0000-\\u001F\\u007F()<>@,;:\\\\\"/?={}\\[\\]\\u0020\\u0009]+$/;\n\nvar isToken = function isToken(str) {\n  return typeof str === 'string' && token.test(str);\n};\n\nexports.isToken = isToken;\nvar isScheme = isToken;\nexports.isScheme = isScheme;\n\nvar quote = function quote(str) {\n  return `\"${str.replace(/\"/g, '\\\\\"')}\"`;\n};\n\nexports.quote = quote;\n\nvar unquote = function unquote(str) {\n  return str.substr(1, str.length - 2).replace(/\\\\\"/g, '\"');\n};\n\nexports.unquote = unquote;\n//# sourceMappingURL=util.js.map\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = __webpack_require__(16);\n\n// lol dis\nvar body = /((?:[a-zA-Z0-9._~+\\/-]+=*(?:\\s+|$))|[^\\u0000-\\u001F\\u007F()<>@,;:\\\\\"/?={}\\[\\]\\u0020\\u0009]+)(?:=([^\\\\\"=\\s,]+|\"(?:[^\"\\\\]|\\\\.)*\"))?/g; // eslint-disable-line\n\nvar normalize = function normalize(prev, _cur) {\n  // Fixup quoted strings and tokens with spaces around them\n  var cur = _cur.charAt(0) === '\"' ? (0, _util.unquote)(_cur) : _cur.trim(); // Marshal\n\n  if (Array.isArray(prev)) {\n    return prev.concat(cur);\n  } else if (typeof prev === 'string') {\n    return [prev, cur];\n  }\n\n  return cur;\n};\n\nvar parseProperties = function parseProperties(scheme, string) {\n  var token = null;\n  var params = {}; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    var res = body.exec(string);\n\n    if (res === null) {\n      break;\n    }\n\n    if (res[2]) {\n      params[res[1]] = normalize(params[res[1]], res[2]);\n    } else {\n      token = normalize(token, res[1]);\n    }\n  }\n\n  return {\n    scheme,\n    params,\n    token\n  };\n};\n\nvar _default = function _default(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Header value must be a string.');\n  }\n\n  var start = str.indexOf(' ');\n  var scheme = str.substr(0, start);\n\n  if (!(0, _util.isScheme)(scheme)) {\n    throw new TypeError(`Invalid scheme ${scheme}`);\n  }\n\n  return parseProperties(scheme, str.substr(start));\n};\n\nexports.default = _default;\n//# sourceMappingURL=parse.js.map\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(19);\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * Dependencies\n */\nconst assert = __webpack_require__(21);\n\nconst fetch = __webpack_require__(5);\n\nconst {\n  URL\n} = __webpack_require__(27);\n\nconst Headers = fetch.Headers ? fetch.Headers : global.Headers;\n\nconst {\n  JSONDocument\n} = __webpack_require__(28);\n\nconst {\n  JWKSet\n} = __webpack_require__(37);\n\nconst AuthenticationRequest = __webpack_require__(68);\n\nconst AuthenticationResponse = __webpack_require__(70);\n\nconst RelyingPartySchema = __webpack_require__(79);\n\nconst onHttpError = __webpack_require__(74);\n\nconst FormUrlEncoded = __webpack_require__(69);\n/**\n * RelyingParty\n *\n * @class\n * Client interface for OpenID Connect Relying Party.\n *\n * @example\n *  let client = RelyingParty({\n *    provider: {\n *      name: 'Anvil Research, Inc.',\n *      url: 'https://forge.anvil.io'\n *      // configuration\n *      // jwks\n *    },\n *    defaults: {\n *      popToken: false,\n *      authenticate: {\n *        response_type: 'code',\n *        display: 'popup',\n *        scope: 'openid profile email'\n *      },\n *      register: {\n *        client_name: 'Example',\n *        client_uri: 'https://example.com',\n *        logo_uri: 'https://example.com/assets/logo.png',\n *        redirect_uris: ['https://app.example.com/callback'],\n *        response_types: ['code', 'code id_token token'],\n *        grant_types: ['authorization_code'],\n *        default_max_age: 7200,\n *        post_logout_redirect_uris: ['https://app.example.com']\n *      },\n *    },\n *    registration: {\n *      // if you have it saved somewhere\n *    },\n *    store: localStorage || req.session\n *  })\n *\n *  client.discover() => Promise\n *  client.jwks() => Promise\n *  client.authenticate()\n *  client.authenticateUri()\n *  client.validateResponse(uri) => Promise\n *  client.userinfo() => Promise\n *  client.logout()\n */\n\n\nclass RelyingParty extends JSONDocument {\n  /**\n   * Schema\n   */\n  static get schema() {\n    return RelyingPartySchema;\n  }\n  /**\n   * from\n   *\n   * @description\n   * Create a RelyingParty instance from a previously registered client.\n   *\n   * @param {Object} data\n   * @returns {Promise<RelyingParty>}\n   */\n\n\n  static from(data) {\n    let rp = new RelyingParty(data);\n    let validation = rp.validate(); // schema validation\n\n    if (!validation.valid) {\n      return Promise.reject(new Error(JSON.stringify(validation)));\n    }\n\n    let jwks = rp.provider.jwks; // request the JWK Set if missing\n\n    if (!jwks) {\n      return rp.jwks().then(() => rp);\n    } // otherwise import the JWK Set to webcrypto\n\n\n    return JWKSet.importKeys(jwks).then(jwks => {\n      rp.provider.jwks = jwks;\n      return rp;\n    });\n  }\n  /**\n   * register\n   *\n   * @param issuer {string} Provider URL\n   * @param registration {Object} Client dynamic registration options\n   * @param options {Object}\n   * @param options.defaults\n   * @param [options.store] {Session|Storage}\n   * @returns {Promise<RelyingParty>} RelyingParty instance, registered.\n   */\n\n\n  static register(issuer, registration, options) {\n    let rp = new RelyingParty({\n      provider: {\n        url: issuer\n      },\n      defaults: Object.assign({}, options.defaults),\n      store: options.store\n    });\n    return Promise.resolve().then(() => rp.discover()).then(() => rp.jwks()).then(() => rp.register(registration)).then(() => rp);\n  }\n  /**\n   * Discover\n   *\n   * @description Fetches the issuer's OpenID Configuration.\n   * @returns {Promise<Object>} Resolves with the provider configuration response\n   */\n\n\n  discover() {\n    try {\n      let issuer = this.provider.url;\n      assert(issuer, 'RelyingParty provider must define \"url\"');\n      let url = new URL(issuer);\n      url.pathname = '.well-known/openid-configuration';\n      return fetch(url.toString()).then(onHttpError('Error fetching openid configuration')).then(response => {\n        return response.json().then(json => this.provider.configuration = json);\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * Register\n   *\n   * @description Register's a client with provider as a Relying Party\n   *\n   * @param options {Object}\n   * @returns {Promise<Object>} Resolves with the registration response object\n   */\n\n\n  register(options) {\n    try {\n      let configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.registration_endpoint, 'OpenID Configuration is missing registration_endpoint.');\n      let uri = configuration.registration_endpoint;\n      let method = 'post';\n      let headers = new Headers({\n        'Content-Type': 'application/json'\n      });\n      let params = this.defaults.register;\n      let body = JSON.stringify(Object.assign({}, params, options));\n      return fetch(uri, {\n        method,\n        headers,\n        body\n      }).then(onHttpError('Error registering client')).then(response => {\n        return response.json().then(json => this.registration = json);\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n\n  serialize() {\n    return JSON.stringify(this);\n  }\n  /**\n   * jwks\n   *\n   * @description Promises the issuer's JWK Set.\n   * @returns {Promise}\n   */\n\n\n  jwks() {\n    try {\n      let configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.jwks_uri, 'OpenID Configuration is missing jwks_uri.');\n      let uri = configuration.jwks_uri;\n      return fetch(uri).then(onHttpError('Error resolving provider keys')).then(response => {\n        return response.json().then(json => JWKSet.importKeys(json)).then(jwks => this.provider.jwks = jwks);\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * createRequest\n   *\n   * @param options {Object} Authn request options hashmap\n   * @param options.redirect_uri {string}\n   * @param options.response_type {string} e.g. 'code' or 'id_token token'\n   * @param session {Session|Storage} req.session or localStorage\n   * @returns {Promise<string>} Authn request URL\n   */\n\n\n  createRequest(options, session) {\n    return AuthenticationRequest.create(this, options, session || this.store);\n  }\n  /**\n   * Validate Response\n   *\n   * @param response {string} req.query or req.body.text\n   * @param session {Session|Storage} req.session or localStorage or similar\n   *\n   * @returns {Promise<Session>}\n   */\n\n\n  validateResponse(response, session = this.store) {\n    let options;\n\n    if (response.match(/^http(s?):\\/\\//)) {\n      options = {\n        rp: this,\n        redirect: response,\n        session\n      };\n    } else {\n      options = {\n        rp: this,\n        body: response,\n        session\n      };\n    }\n\n    const authResponse = new AuthenticationResponse(options);\n    return AuthenticationResponse.validateResponse(authResponse);\n  }\n  /**\n   * userinfo\n   *\n   * @description Promises the authenticated user's claims.\n   * @returns {Promise}\n   */\n\n\n  userinfo() {\n    try {\n      let configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.userinfo_endpoint, 'OpenID Configuration is missing userinfo_endpoint.');\n      let uri = configuration.userinfo_endpoint;\n      let access_token = this.store.access_token;\n      assert(access_token, 'Missing access token.');\n      let headers = new Headers({\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${access_token}`\n      });\n      return fetch(uri, {\n        headers\n      }).then(onHttpError('Error fetching userinfo')).then(response => response.json());\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * logoutRequest\n   *\n   * Composes and returns the logout request URI, based on the OP's\n   * `end_session_endpoint`, with appropriate parameters.\n   *\n   * Note: Calling client code has the responsibility to clear the local\n   * session state (for example, by calling `rp.clearSession()`). In addition,\n   * some IdPs (such as Google) may not provide an `end_session_endpoint`,\n   * in which case, this method will return null.\n   *\n   * @see https://openid.net/specs/openid-connect-session-1_0.html#RPLogout\n   *\n   * @throws {Error} If provider config is not initialized\n   *\n   * @throws {Error} If `post_logout_redirect_uri` was provided without a\n   *   corresponding `id_token_hint`\n   *\n   * @param [options={}] {object}\n   *\n   * @param [options.id_token_hint] {string} RECOMMENDED.\n   *   Previously issued ID Token passed to the logout endpoint as\n   *   a hint about the End-User's current authenticated session with the\n   *   Client. This is used as an indication of the identity of the End-User\n   *   that the RP is requesting be logged out by the OP. The OP *need not* be\n   *   listed as an audience of the ID Token when it is used as an\n   *   `id_token_hint` value.\n   *\n   * @param [options.post_logout_redirect_uri] {string} OPTIONAL. URL to which\n   *   the RP is requesting that the End-User's User Agent be redirected after\n   *   a logout has been performed. The value MUST have been previously\n   *   registered with the OP, either using the `post_logout_redirect_uris`\n   *   Registration parameter or via another mechanism. If supplied, the OP\n   *   SHOULD honor this request following the logout.\n   *\n   *   Note: The requirement to validate the uri for previous registration means\n   *   that, in practice, the `id_token_hint` is REQUIRED if\n   *   `post_logout_redirect_uri` is used. Otherwise, the OP has no way to get\n   *   the `client_id` to load the saved client registration, to validate the\n   *   uri. The only way it can get it is by decoding the `id_token_hint`.\n   *\n   * @param [options.state] {string} OPTIONAL. Opaque value used by the RP to\n   *   maintain state between the logout request and the callback to the\n   *   endpoint specified by the `post_logout_redirect_uri` query parameter. If\n   *   included in the logout request, the OP passes this value back to the RP\n   *   using the `state` query parameter when redirecting the User Agent back to\n   *   the RP.\n   *\n   * TODO: In the future, consider adding `response_mode` param, for the OP to\n   *   determine how to return the `state` back the RP.\n   *   @see http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes\n   *\n   * TODO: Handle special cases for popular providers (Google, MSFT)\n   *\n   * @returns {string|null} Logout uri (or null if no end_session_endpoint was\n   *   provided in the IdP config)\n   */\n\n\n  logoutRequest(options = {}) {\n    const {\n      id_token_hint,\n      post_logout_redirect_uri,\n      state\n    } = options;\n    let configuration;\n    assert(this.provider, 'OpenID Configuration is not initialized');\n    configuration = this.provider.configuration;\n    assert(configuration, 'OpenID Configuration is not initialized');\n\n    if (!configuration.end_session_endpoint) {\n      console.log(`OpenId Configuration for ` + `${configuration.issuer} is missing end_session_endpoint`);\n      return null;\n    }\n\n    if (post_logout_redirect_uri && !id_token_hint) {\n      throw new Error('id_token_hint is required when using post_logout_redirect_uri');\n    }\n\n    const params = {};\n\n    if (id_token_hint) {\n      params.id_token_hint = id_token_hint;\n    }\n\n    if (post_logout_redirect_uri) {\n      params.post_logout_redirect_uri = post_logout_redirect_uri;\n    }\n\n    if (state) {\n      params.state = state;\n    }\n\n    const url = new URL(configuration.end_session_endpoint);\n    url.search = FormUrlEncoded.encode(params);\n    return url.href;\n  }\n  /**\n   * Logout\n   *\n   * @deprecated\n   *\n   * TODO: Add deprecation warnings, then remove. Client code should\n   *   use `logoutRequest()` instead\n   *\n   * @returns {Promise}\n   */\n\n\n  logout() {\n    let configuration;\n\n    try {\n      assert(this.provider, 'OpenID Configuration is not initialized.');\n      configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.end_session_endpoint, 'OpenID Configuration is missing end_session_endpoint.');\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    if (!configuration.end_session_endpoint) {\n      this.clearSession();\n      return Promise.resolve(undefined);\n    }\n\n    let uri = configuration.end_session_endpoint;\n    let method = 'get';\n    return fetch(uri, {\n      method,\n      credentials: 'include'\n    }).then(onHttpError('Error logging out')).then(() => this.clearSession()); // TODO: Validate `frontchannel_logout_uri` if necessary\n\n    /**\n     * frontchannel_logout_uri - OPTIONAL. RP URL that will cause the RP to log\n     * itself out when rendered in an iframe by the OP.\n     *\n     * An `iss` (issuer) query parameter and a `sid`\n     * (session ID) query parameter MAY be included by the OP to enable the RP\n     * to validate the request and to determine which of the potentially\n     * multiple sessions is to be logged out. If a sid (session ID) query\n     * parameter is included, an iss (issuer) query parameter MUST also be\n     * included.\n     * @see https://openid.net/specs/openid-connect-frontchannel-1_0.html#RPLogout\n     */\n  }\n\n  clearSession() {\n    let session = this.store;\n\n    if (!session) {\n      return;\n    }\n\n    delete session[SESSION_PRIVATE_KEY];\n  }\n  /**\n   * @param uri {string} Target Resource Server URI\n   * @param idToken {IDToken} ID Token to be embedded in the PoP token\n   *\n   * @returns {Promise<PoPToken>}\n   */\n\n\n  popTokenFor(uri, idToken) {\n    return PoPToken.issueFor(uri, idToken);\n  }\n\n}\n\nconst SESSION_PRIVATE_KEY = 'oidc.session.privateKey';\nRelyingParty.SESSION_PRIVATE_KEY = SESSION_PRIVATE_KEY;\nmodule.exports = RelyingParty;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar objectAssign = __webpack_require__(22);\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(23);\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(25);\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(26);\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)))\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"window\"]; }());\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  Formats: __webpack_require__(29),\n  Initializer: __webpack_require__(30),\n  JSONDocument: __webpack_require__(31),\n  JSONMapping: __webpack_require__(34),\n  JSONPatch: __webpack_require__(32),\n  JSONPointer: __webpack_require__(33),\n  JSONSchema: __webpack_require__(35),\n  Validator: __webpack_require__(36)\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * JSON Schema Formats\n *\n * TODO\n * Is there a good way to express these over multiple lines with comments\n * for easier debugging and auditing?\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DATETIME_REGEXP = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i;\nvar URI_REGEXP = /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i;\nvar EMAIL_REGEXP = /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i;\nvar IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nvar IPV6_REGEXP = /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i;\nvar HOSTNAME_REGEXP = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\n\n/**\n * Formats\n */\n\nvar Formats = function () {\n  function Formats() {\n    _classCallCheck(this, Formats);\n  }\n\n  _createClass(Formats, [{\n    key: 'register',\n\n\n    /**\n     * Register\n     *\n     * @description\n     * Register a new mapping from named format to RegExp instance\n     *\n     * TODO\n     * We can do some extra validation of the RegExp to\n     * ensure it's the acceptable subset of RegExps allowed\n     * by JSON Schema.\n     *\n     * @param {string} name\n     * @param {RegExp} pattern\n     * @returns {RegExp}\n     */\n    value: function register(name, pattern) {\n      // verify name is a string\n      if (typeof name !== 'string') {\n        throw new Error('Format name must be a string');\n      }\n\n      // cast a string to RegExp\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(pattern);\n      }\n\n      return this[name] = pattern;\n    }\n\n    /**\n     * Resolve\n     *\n     * @description\n     * Given a format name, return the corresponding registered validation. In the\n     * event a format is not registered, throw an error.\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(name) {\n      var format = this[name];\n\n      if (!format) {\n        throw new Error('Unknown JSON Schema format.');\n      }\n\n      return format;\n    }\n\n    /**\n     * Test\n     *\n     * @description\n     * Test that a value conforms to a format.\n     *\n     * @param {string} name\n     * @param {string} value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'test',\n    value: function test(name, value) {\n      var format = this.resolve(name);\n      return format.test(value);\n    }\n  }], [{\n    key: 'initialize',\n\n\n    /**\n     * Initialize\n     *\n     * @description\n     * Create a new Formats instance and register default formats\n     *\n     * @returns {Formats}\n     */\n    value: function initialize() {\n      var formats = new Formats();\n      formats.register('date-time', DATETIME_REGEXP);\n      formats.register('uri', URI_REGEXP);\n      formats.register('email', EMAIL_REGEXP);\n      formats.register('ipv4', IPV4_REGEXP);\n      formats.register('ipv6', IPV6_REGEXP);\n      formats.register('hostname', HOSTNAME_REGEXP);\n      return formats;\n    }\n  }]);\n\n  return Formats;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Formats.initialize();\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Initializer\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = function () {\n\n  /**\n   * constructor\n   */\n  function Initializer(schema, options) {\n    _classCallCheck(this, Initializer);\n\n    Object.assign(this, options || {});\n    this.root = this.root || this;\n\n    this.root.depth = this.root.depth || 1;\n\n    if (this.level > this.root.depth) {\n      this.root.depth = this.level;\n    }\n\n    this.level = this.level || 0;\n    this.schema = schema;\n  }\n\n  /**\n   * compile (static)\n   */\n\n\n  _createClass(Initializer, [{\n    key: 'compile',\n\n\n    /**\n     * compile\n     */\n    value: function compile() {\n      var root = this.root,\n          depth = this.depth,\n          level = this.level;\n\n      var declarations = '';\n      var body = '';\n\n      // traverse the schema and generate code\n      body += this.default();\n      body += this.properties();\n      //body += this.additionalProperties()\n      body += this.items();\n      //body += this.additionalItems()\n\n\n      // value\n      body += this.member();\n      body += this.item();\n\n      // after traversing the schema\n      // generate the variable declarations\n      if (root === this) {\n        for (var i = 1; i <= this.root.depth; i++) {\n          declarations += this.declaration(i);\n        }\n\n        return '\\n        options = options || {}\\n\\n        if (options.filter === false) {\\n          Object.assign(target, JSON.parse(JSON.stringify(source)))\\n        }\\n\\n        ' + declarations + '\\n        ' + body + '\\n      ';\n      }\n\n      return body;\n    }\n\n    /**\n     * declaration\n     */\n\n  }, {\n    key: 'declaration',\n    value: function declaration(level) {\n      return '\\n      var target' + level + '\\n      var source' + level + '\\n      var count' + level + '\\n    ';\n    }\n\n    /**\n     * default\n     */\n\n  }, {\n    key: 'default',\n    value: function _default() {\n      var schema = this.schema,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var value = schema.default; // rename default to value because it's a keyword and syntax highlighter breaks\n\n      var block = '';\n\n      if (schema.hasOwnProperty('default')) {\n\n        if (key) {\n          block += '\\n          target' + level + '[\\'' + key + '\\'] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (index) {\n          block += '\\n          target' + level + '[' + index + '] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (options.defaults !== false) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * member\n     */\n\n  }, {\n    key: 'member',\n    value: function member() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      // `key` tells us to treat this subschema as an object member vs an array item\n      // and the absence of the other values here indicates we are dealing with a\n      // primitive value\n      if (key && !properties && !additionalProperties && !items && !additionalItems) {\n\n        // first generate the assignment statement\n        block += '\\n        target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n      ';\n\n        // for nested container objects, add the counter incrementing statement\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        // wrap the foregoing in a check for presence on the source\n        block = '\\n        if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * item\n     */\n\n  }, {\n    key: 'item',\n    value: function item() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          index = this.index;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      if (index && !properties && !additionalProperties && !items && !additionalItems) {\n\n        block += '\\n        target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n      ';\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (' + index + ' < len) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var properties = schema.properties;\n\n      var block = '';\n\n      if (properties) {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var initializer = new Initializer(subschema, { key: key, root: root, level: level + 1 });\n\n          block += initializer.compile();\n        });\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (typeof source === \\'object\\' && source !== null && !Array.isArray(source)) {\\n            if (typeof target !== \\'object\\') {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n            count1 = 0\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n\n          if (index) {\n            block = '\\n            if (' + index + ' < source' + level + '.length || typeof source' + level + '[' + index + '] === \\'object\\') {\\n\\n              source' + (level + 1) + ' = source' + level + '[' + index + '] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (' + index + ' < target' + level + '.length || typeof target' + level + '[' + index + '] !== \\'object\\') {\\n                target' + (level + 1) + ' = {}\\n                if (' + index + ' < source' + level + '.length) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[' + index + ']\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[' + index + '] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n              count' + level + '++\\n            }\\n          ';\n          }\n\n          if (key) {\n            block = '\\n            if ((typeof source' + level + '[\\'' + key + '\\'] === \\'object\\'\\n                  && source' + level + '[\\'' + key + '\\'] !== null\\n                  && !Array.isArray(source' + level + '[\\'' + key + '\\']))\\n                || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n              source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (!target' + level + '.hasOwnProperty(\\'' + key + '\\')\\n                  || typeof target' + level + '[\\'' + key + '\\'] !== \\'object\\'\\n                  || target' + level + '[\\'' + key + '\\'] === null\\n                  || Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n                target' + (level + 1) + ' = {}\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n                count' + (level + 1) + '++\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n              count' + level + '++\\n            }\\n          ';\n          }\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {}\n\n    /**\n     * items\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var items = schema.items;\n\n      var block = '';\n\n      if (items) {\n\n        if (Array.isArray(items)) {\n          // TODO\n          //\n          //\n          //\n          //\n          //\n          // ...\n\n        } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n          var _index = 'i' + (level + 1);\n          var initializer = new Initializer(items, { index: _index, root: root, level: level + 1 });\n\n          block += '\\n          var sLen = source' + (level + 1) + '.length || 0\\n          var tLen = target' + (level + 1) + '.length || 0\\n          var len = 0\\n\\n          if (sLen > len) { len = sLen }\\n          // THIS IS WRONG, CAUSED SIMPLE ARRAY INIT TO FAIL (OVERWRITE\\n          // EXISTING TARGET VALUES WITH UNDEFINED WHEN SOURCE IS SHORTER THAN\\n          // TARGET). LEAVING HERE UNTIL WE FINISH TESTING AND SEE WHY IT MIGHT\\n          // HAVE BEEN HERE IN THE FIRST PLACE.\\n          //\\n          // if (tLen > len) { len = tLen }\\n\\n          for (var ' + _index + ' = 0; ' + _index + ' < len; ' + _index + '++) {\\n            ' + initializer.compile() + '\\n          }\\n        ';\n        }\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (Array.isArray(source)) {\\n            if (!Array.isArray(target)) {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n          block = '\\n          if (Array.isArray(source' + level + '[\\'' + key + '\\']) || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n            source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || []\\n            count' + (level + 1) + ' = 0\\n\\n            if (!target' + level + '.hasOwnProperty(\\'' + key + '\\') || !Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n              target' + (level + 1) + ' = []\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n\\n            } else {\\n              target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n              count' + (level + 1) + '++\\n            }\\n\\n            ' + block + '\\n\\n            if (count' + (level + 1) + ' > 0) {\\n              target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n              count' + level + '++\\n            }\\n\\n          } else {\\n            target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n            count' + level + '++\\n          }\\n        ';\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {}\n  }], [{\n    key: 'compile',\n    value: function compile(schema) {\n      var initializer = new Initializer(schema);\n      var block = initializer.compile();\n\n      //console.log(beautify(block))\n      try {\n        return new Function('target', 'source', 'options', block);\n      } catch (e) {\n        console.log(e, e.stack);\n      }\n    }\n  }]);\n\n  return Initializer;\n}();\n\nmodule.exports = Initializer;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPatch = __webpack_require__(32);\n\n/**\n * JSONDocument\n *\n * @class\n * JSONDocument is a high level interface that binds together all other features of\n * this package and provides the principle method of data modeling.\n */\n\nvar JSONDocument = function () {\n  _createClass(JSONDocument, null, [{\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      throw new Error('Schema must be defined by classes extending JSONDocument');\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} data\n     * @param {Object} options\n     */\n\n  }]);\n\n  function JSONDocument() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSONDocument);\n\n    this.initialize(data, options);\n  }\n\n  /**\n   * Initialize\n   *\n   * @param {Object} data\n   * @param {Object} options\n   */\n\n\n  _createClass(JSONDocument, [{\n    key: 'initialize',\n    value: function initialize() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var schema = this.constructor.schema;\n\n      schema.initialize(this, data, options);\n    }\n\n    /**\n     * Validate\n     *\n     * @param {JSONSchema} alternate - OPTIONAL alternate schema\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(alternate) {\n      var schema = this.constructor.schema;\n\n      return (alternate || schema).validate(this);\n    }\n\n    /**\n     * Patch\n     *\n     * @param {Array} ops\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(ops) {\n      var patch = new JSONPatch(ops);\n      patch.apply(this);\n    }\n\n    /**\n     * Select\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {}\n\n    /**\n     * Project\n     *\n     * @description\n     * Given a mapping, return an object projected from the current instance.\n     *\n     * @example\n     * let schema = new JSONSchema({\n     *   properties: {\n     *     foo: { type: 'Array' }\n     *   }\n     * })\n     *\n     * let mapping = new JSONMapping({\n     *   '/foo/0': '/bar/baz'\n     * })\n     *\n     * class FooTracker extends JSONDocument {\n     *   static get schema () { return schema }\n     * }\n     *\n     * let instance = new FooTracker({ foo: ['qux'] })\n     * instance.project(mapping)\n     * // => { bar: { baz: 'qux' } }\n     *\n     * @param {JSONMapping} mapping\n     * @return {Object}\n     */\n\n  }, {\n    key: 'project',\n    value: function project(mapping) {\n      return mapping.project(this);\n    }\n\n    /**\n     * Serialize\n     *\n     * @param {Object} object\n     * @returns {string}\n     */\n\n  }], [{\n    key: 'serialize',\n    value: function serialize(object) {\n      return JSON.stringify(object);\n    }\n\n    /**\n     * Deserialize\n     *\n     * @param {string} data\n     * @return {*}\n     */\n\n  }, {\n    key: 'deserialize',\n    value: function deserialize(data) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        throw new Error('Failed to parse JSON');\n      }\n    }\n  }]);\n\n  return JSONDocument;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONDocument;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = __webpack_require__(33);\n\n/**\n * Modes\n */\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * Operations list\n */\nvar OPERATIONS = ['add', 'remove', 'replace', 'move', 'copy', 'test'];\n\n/**\n * Patch\n *\n * @class\n * Implements RFC 6902: JavaScript Object Notation (JSON) Patch\n * https://tools.ietf.org/html/rfc6902\n */\n\nvar JSONPatch = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Array} ops\n   */\n  function JSONPatch(ops) {\n    _classCallCheck(this, JSONPatch);\n\n    this.ops = ops || [];\n  }\n\n  /**\n   * Apply\n   *\n   * @todo handle errors/roll back\n   * @todo protect properties that are private in the schema\n   * @todo map JSON Pointers real property names\n   *\n   * @param {Object} target\n   */\n\n\n  _createClass(JSONPatch, [{\n    key: 'apply',\n    value: function apply(target) {\n      var _this = this;\n\n      this.ops.forEach(function (operation) {\n        var op = operation.op;\n\n        if (!op) {\n          throw new Error('Missing \"op\" in JSON Patch operation');\n        }\n\n        if (OPERATIONS.indexOf(op) === -1) {\n          throw new Error('Invalid \"op\" in JSON Patch operation');\n        }\n\n        if (!operation.path) {\n          throw new Error('Missing \"path\" in JSON Patch operation');\n        }\n\n        _this[op](operation, target);\n      });\n    }\n\n    /**\n     * Add\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'add',\n    value: function add(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch add operation');\n      }\n\n      var pointer = new JSONPointer(op.path, SILENT);\n      pointer.add(target, op.value);\n    }\n\n    /**\n     * Remove\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(op, target) {\n      var pointer = new JSONPointer(op.path);\n      pointer.remove(target);\n    }\n\n    /**\n     * Replace\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch replace operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      pointer.replace(target, op.value);\n    }\n\n    /**\n     * Move\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'move',\n    value: function move(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch move operation');\n      }\n\n      if (op.path.match(new RegExp('^' + op.from))) {\n        throw new Error('Invalid \"from\" in JSON Patch move operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      from.remove(target);\n      pointer.add(target, value);\n    }\n\n    /**\n     * Copy\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch copy operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      pointer.add(target, value);\n    }\n\n    /**\n     * Test\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'test',\n    value: function test(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch test operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var value = pointer.get(target);\n\n      switch (_typeof(op.value)) {\n        //case 'string':\n        //case 'number':\n        //case 'boolean':\n        //  if (value !== op.value) {\n        //    throw new Error('Mismatching JSON Patch test value')\n        //  }\n        default:\n          if (value !== op.value) {\n            throw new Error('Mismatching JSON Patch test value');\n          }\n      }\n    }\n  }]);\n\n  return JSONPatch;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPatch;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Mode enumeration\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * JSONPointer\n *\n * @class\n * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n * https://tools.ietf.org/html/rfc6901\n */\n\nvar JSONPointer = function () {\n\n  /**\n   * Constructor\n   */\n  function JSONPointer(expr, mode) {\n    _classCallCheck(this, JSONPointer);\n\n    this.expr = expr;\n    this.mode = mode || THROW;\n    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n  }\n\n  /**\n   * Escape\n   */\n\n\n  _createClass(JSONPointer, [{\n    key: 'escape',\n    value: function escape(expr) {\n      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    /**\n     * Unescape\n     */\n\n  }, {\n    key: 'unescape',\n    value: function unescape(expr) {\n      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n\n    /**\n     * Parse\n     */\n\n  }, {\n    key: 'parseJSONString',\n\n\n    /**\n     * Parse JSON String\n     *\n     * @description Parse an expression into a list of tokens\n     * @param {string} expr\n     * @returns {Array}\n     */\n    value: function parseJSONString(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr === '') {\n        return [];\n      }\n\n      if (expr.charAt(0) !== '/') {\n        throw new Error('Invalid JSON Pointer');\n      }\n\n      if (expr === '/') {\n        return [''];\n      }\n\n      return expr.substr(1).split('/').map(this.unescape);\n    }\n\n    /**\n     * To JSON String\n     *\n     * @description Render a JSON string representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toJSONString',\n    value: function toJSONString() {\n      return '/' + this.tokens.map(this.escape).join('/');\n    }\n\n    /**\n     * Parse URI Fragment Identifer\n     */\n\n  }, {\n    key: 'parseURIFragmentIdentifier',\n    value: function parseURIFragmentIdentifier(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr.charAt(0) !== '#') {\n        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n      }\n\n      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n    }\n\n    /**\n     * To URI Fragment Identifier\n     *\n     * @description Render a URI Fragment Identifier representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toURIFragmentIdentifier',\n    value: function toURIFragmentIdentifier() {\n      var _this = this;\n\n      var value = this.tokens.map(function (token) {\n        return encodeURIComponent(_this.escape(token));\n      }).join('/');\n\n      return '#/' + value;\n    }\n\n    /**\n     * Get\n     *\n     * @description Get a value from the source object referenced by the pointer\n     * @param {Object} source\n     * @returns {*}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(source) {\n      var current = source;\n      var tokens = this.tokens;\n\n      for (var i = 0; i < tokens.length; i++) {\n        if (!current || current[tokens[i]] === undefined) {\n          if (this.mode !== THROW) {\n            return undefined;\n          } else {\n            throw new Error('Invalid JSON Pointer reference');\n          }\n        }\n\n        current = current[tokens[i]];\n      }\n\n      return current;\n    }\n\n    /**\n     * Add\n     *\n     * @description Set a value on a target object referenced by the pointer. Put\n     * will insert an array element. To change an existing array elemnent, use\n     * `pointer.set()`\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'add',\n    value: function add(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      // iterate through the tokens\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        // set the property on the target location\n        if (i === tokens.length - 1) {\n          if (token === '-') {\n            current.push(value);\n          } else if (Array.isArray(current)) {\n            current.splice(token, 0, value);\n          } else if (value !== undefined) {\n            current[token] = value;\n          }\n\n          // handle missing target location based on \"mode\"\n        } else if (!current[token]) {\n          switch (this.mode) {\n            case THROW:\n              throw new Error('Invalid JSON Pointer reference');\n\n            case RECOVER:\n              current = current[token] = parseInt(token) ? [] : {};\n              break;\n\n            case SILENT:\n              return;\n\n            default:\n              throw new Error('Invalid pointer mode');\n          }\n\n          // reference the next object in the path\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Replace\n     *\n     * @description Set a value on a target object referenced by the pointer. Set will\n     * overwrite an existing array element at the target location.\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (i === tokens.length - 1) {\n          current[token] = value;\n        } else if (!current[token]) {\n          current = current[token] = parseInt(token) ? [] : {};\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Del\n     *\n     * - if this is an array it should splice the value out\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(target) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (current === undefined || current[token] === undefined) {\n          return undefined;\n        } else if (Array.isArray(current)) {\n          current.splice(token, 1);\n          return undefined;\n        } else if (i === tokens.length - 1) {\n          delete current[token];\n        }\n\n        current = current[token];\n      }\n\n      // delete from the target\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(expr) {\n      return new JSONPointer(expr);\n    }\n  }]);\n\n  return JSONPointer;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPointer;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = __webpack_require__(33);\n\n/**\n * JSONPointer mode\n */\nvar RECOVER = 1;\n\n/**\n * JSONMapping\n *\n * @class\n * Defines a means to declaratively translate between object\n * representations using JSON Pointer syntax.\n */\n\nvar JSONMapping = function () {\n\n  /**\n   * Constructor\n   *\n   * @description Translate pointers from JSON Strings into Pointer objects\n   * @param {Object} mapping\n   */\n  function JSONMapping(mapping) {\n    var _this = this;\n\n    _classCallCheck(this, JSONMapping);\n\n    Object.defineProperty(this, 'mapping', {\n      enumerable: false,\n      value: new Map()\n    });\n\n    Object.keys(mapping).forEach(function (key) {\n      var value = mapping[key];\n      _this.mapping.set(new JSONPointer(key, RECOVER), new JSONPointer(value, RECOVER));\n    });\n  }\n\n  /**\n   * Map\n   *\n   * @description Assign values from source to target by reading the mapping\n   * from right to left.\n   * @param {Object} target\n   * @param {Object} source\n   */\n\n\n  _createClass(JSONMapping, [{\n    key: 'map',\n    value: function map(target, source) {\n      this.mapping.forEach(function (right, left) {\n        left.add(target, right.get(source));\n      });\n    }\n\n    /**\n     * Project\n     *\n     * @description Assign values from source to target by reading the mapping\n     * from left to right.\n     * @param {Object} source\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'project',\n    value: function project(source, target) {\n      this.mapping.forEach(function (right, left) {\n        right.add(target, left.get(source));\n      });\n    }\n  }]);\n\n  return JSONMapping;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONMapping;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = __webpack_require__(30);\nvar Validator = __webpack_require__(36);\n\n/**\n * JSONSchema\n *\n * @class\n * Compiles JSON Schema documents to an object with object initialization\n * and validation methods.\n */\n\nvar JSONSchema = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Object} schema\n   */\n  function JSONSchema(schema) {\n    _classCallCheck(this, JSONSchema);\n\n    // TODO: optionally parse JSON string?\n    Object.assign(this, schema);\n\n    // add schema-derived initialize and validate methods\n    Object.defineProperties(this, {\n      initialize: {\n        enumerable: false,\n        writeable: false,\n        value: Initializer.compile(schema)\n      },\n      validate: {\n        enumerable: false,\n        writeable: false,\n        value: Validator.compile(schema)\n      }\n    });\n  }\n\n  /**\n   * Extend\n   *\n   * @description\n   * ...\n   * Dear future,\n   *\n   * This function was meticulously plagiarized from some curious amalgam of\n   * stackoverflow posts whilst dozing off at my keyboard, too deprived of REM-\n   * sleep to recurse unassisted. If it sucks, you have only yourself to blame.\n   *\n   * Goodnight.\n   *\n   * @param {Object} schema\n   * @returns {JSONSchema}\n   */\n\n\n  _createClass(JSONSchema, [{\n    key: 'extend',\n    value: function extend(schema) {\n      function isObject(data) {\n        return data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && !Array.isArray(data);\n      }\n\n      function extender(target, source) {\n        var result = Object.assign({}, target);\n        if (isObject(target) && isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (isObject(source[key])) {\n              if (!(key in target)) {\n                Object.assign(result, _defineProperty({}, key, source[key]));\n              } else {\n                result[key] = extender(target[key], source[key]);\n              }\n            } else {\n              Object.assign(result, _defineProperty({}, key, source[key]));\n            }\n          });\n        }\n        return result;\n      }\n\n      var descriptor = extender(this, schema);\n      return new JSONSchema(descriptor);\n    }\n  }]);\n\n  return JSONSchema;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONSchema;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar formats = __webpack_require__(29);\n\n/**\n * For variable iterator counter\n *\n * @type {number}\n */\nvar indexCount = 0;\n\n/**\n * Validator\n *\n * Compile an object describing a JSON Schema into a validation function.\n */\n\nvar Validator = function () {\n  _createClass(Validator, null, [{\n    key: 'compile',\n\n\n    /**\n     * Compile (static)\n     *\n     * @description\n     * Compile an object describing a JSON Schema into a validation function.\n     *\n     * @param {Object} schema\n     * @returns {Function}\n     */\n    value: function compile(schema) {\n      var validator = new Validator(schema);\n\n      var body = '\\n      // \"cursor\"\\n      let value = data\\n      let container\\n      let stack = []\\n      let top = -1\\n\\n      // error state\\n      let valid = true\\n      let errors = []\\n\\n      // complex schema state\\n      let initialValidity\\n      let anyValid\\n      let notValid\\n      let countOfValid\\n      let initialErrorCount\\n      let accumulatedErrorCount\\n\\n      // validation code\\n      ' + validator.compile() + '\\n\\n      // validation result\\n      return {\\n        valid,\\n        errors\\n      }\\n    ';\n\n      return new Function('data', body);\n    }\n\n    /**\n     * Return current iterator index counter and increase value\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'counter',\n    get: function get() {\n      return indexCount++;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} schema - object representation of a schema\n     * @param {string} options - compilation options\n     */\n\n  }]);\n\n  function Validator(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Validator);\n\n    // assign schema to this\n    this.schema = schema;\n\n    // assign all options to this\n    Object.assign(this, options);\n\n    // ensure address is defined\n    if (!this.address) {\n      this.address = '';\n    }\n\n    // ensure require is boolean\n    if (this.require !== true) {\n      this.require = false;\n    }\n  }\n\n  /**\n   * Compile\n   *\n   * @description\n   * The instance compile method is \"dumb\". It only sequences invocation of\n   * more specific compilation methods. It generates code to\n   *\n   *  - read a value from input\n   *  - validate type(s) of input\n   *  - validate constraints described by various schema keywords\n   *\n   * Conditional logic related to code generation is pushed downsteam to\n   * type-specific methods.\n   */\n\n\n  _createClass(Validator, [{\n    key: 'compile',\n    value: function compile() {\n      var block = '';\n\n      if (this.require) {\n        block += this.required();\n      }\n\n      // type validation\n      block += this.type();\n\n      // type specific validation generators\n      // null and boolean are covered by this.type()\n      // integer should be covered by number and this.type()\n      block += this.array();\n      block += this.number();\n      block += this.object();\n      block += this.string();\n\n      // non-type-specific validation generators\n      block += this.enum();\n      block += this.anyOf();\n      block += this.allOf();\n      block += this.not();\n      block += this.oneOf();\n\n      return block;\n    }\n\n    /**\n     * push\n     */\n\n  }, {\n    key: 'push',\n    value: function push() {\n      return '\\n      stack.push(value)\\n      container = value\\n      top++\\n    ';\n    }\n\n    /**\n     * pop\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop() {\n      return '\\n      if (stack.length > 1) {\\n        top--\\n        stack.pop()\\n      }\\n\\n      value = container = stack[top]\\n    ';\n    }\n\n    /**\n     * type\n     *\n     * @description\n     * > An instance matches successfully if its primitive type is one of the\n     * > types defined by keyword. Recall: \"number\" includes \"integer\".\n     * > JSON Schema Validation Section 5.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'type',\n    value: function type() {\n      var type = this.schema.type,\n          address = this.address;\n\n      var block = '';\n\n      if (type) {\n        var types = Array.isArray(type) ? type : [type];\n        var conditions = types.map(function (type) {\n          // TODO: can we make a mapping object for this to clean it up?\n          if (type === 'array') return '!Array.isArray(value)';\n          if (type === 'boolean') return 'typeof value !== \\'boolean\\'';\n          if (type === 'integer') return '!Number.isInteger(value)';\n          if (type === 'null') return 'value !== null';\n          if (type === 'number') return 'typeof value !== \\'number\\'';\n          if (type === 'object') return '(typeof value !== \\'object\\' || Array.isArray(value) || value === null)';\n          if (type === 'string') return 'typeof value !== \\'string\\'';\n        }).join(' && ');\n\n        block += '\\n      // ' + address + ' type checking\\n      if (value !== undefined && ' + conditions + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'type\\',\\n          message: \\'invalid type\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Type-specific validations\n     *\n     * Type checking is optional in JSON Schema, and a schema can allow\n     * multiple types. Generated code needs to apply type-specific validations\n     * only to appropriate values, and ignore everything else. Type validation\n     * itself is handled separately from other validation keywords.\n     *\n     * The methods `array`, `number`, `object`, `string` generate type-specific\n     * validation code blocks, wrapped in a conditional such that they will\n     * only be applied to values of that type.\n     *\n     * For example, the `number` method, given the schema\n     *\n     *     { minimum: 3 }\n     *\n     * will generate\n     *\n     *     if (typeof value === 'number') {\n     *       if (value < 3) {\n     *         valid = false\n     *         errors.push({ message: '...' })\n     *       }\n     *     }\n     *\n     * Integer values are also numbers, and are validated the same as numbers\n     * other than the type validation itself. Therefore no `integer` method is\n     * needed.\n     */\n\n    /**\n     * array\n     *\n     * @description\n     * Invoke methods for array-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to array values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'array',\n    value: function array() {\n      var keywords = ['additionalItems', 'items', 'minItems', 'maxItems', 'uniqueItems'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Array validations\\n       */\\n      if (Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * number\n     *\n     * @description\n     * Invoke methods for number-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to number values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'number',\n    value: function number() {\n      var keywords = ['minimum', 'maximum', 'multipleOf'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Number validations\\n       */\\n      if (typeof value === \\'number\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * object\n     *\n     * @description\n     * Invoke methods for object-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to object values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'object',\n    value: function object() {\n      var keywords = ['maxProperties', 'minProperties', 'additionalProperties', 'properties', 'patternProperties', 'dependencies', 'schemaDependencies', 'propertyDependencies'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Object validations\\n       */\\n      if (typeof value === \\'object\\' && value !== null && !Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * string\n     *\n     * @description\n     * Invoke methods for string-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to string values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'string',\n    value: function string() {\n      var keywords = ['maxLength', 'minLength', 'pattern', 'format'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * String validations\\n       */\\n      if (typeof value === \\'string\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * validations\n     *\n     * @description\n     * Iterate over an array of keywords and invoke code generator methods\n     * for each. Concatenate the results together and return. Used by \"type\"\n     * methods such as this.array() and this.string()\n     *\n     * @param {Array} keywords\n     * @returns {string}\n     */\n\n  }, {\n    key: 'validations',\n    value: function validations(keywords) {\n      var _this = this;\n\n      var schema = this.schema;\n\n      var block = '';\n\n      var constraints = Object.keys(schema).filter(function (key) {\n        return keywords.indexOf(key) !== -1;\n      });\n\n      constraints.forEach(function (keyword) {\n        block += _this[keyword]();\n      });\n\n      return block;\n    }\n\n    /**\n     * enum\n     *\n     * @description\n     * > An instance validates successfully against this keyword if its value\n     * > is equal to one of the elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.5.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'enum',\n    value: function _enum() {\n      var enumerated = this.schema.enum,\n          address = this.address;\n\n      var conditions = ['value !== undefined'];\n      var block = '';\n\n      if (enumerated) {\n        enumerated.forEach(function (value) {\n          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n            case 'boolean':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'number':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'string':\n              conditions.push('value !== \"' + value + '\"');\n              break;\n\n            case 'object':\n              if (value === null) {\n                conditions.push('value !== null');\n              } else {\n                conditions.push('\\'' + JSON.stringify(value) + '\\' !== JSON.stringify(value)');\n              }\n              break;\n\n            default:\n              throw new Error('Things are not well in the land of enum');\n\n          }\n        });\n\n        block += '\\n      /**\\n       * Validate \"' + address + '\" enum\\n       */\\n      if (' + conditions.join(' && ') + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'enum\\',\\n          message: JSON.stringify(value) + \\' is not an enumerated value\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * anyOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against at least one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.4\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'anyOf',\n    value: function anyOf() {\n      var anyOf = this.schema.anyOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(anyOf)) {\n        block += '\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        anyValid = false\\n      ';\n\n        anyOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          anyValid = true\\n        }\\n        ';\n        });\n\n        block += '\\n          if (anyValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * allOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against all schemas defined by this keyword's\n     * > value.\n     * > JSON Schema Validation Section 5.5.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'allOf',\n    value: function allOf() {\n      var allOf = this.schema.allOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(allOf)) {\n        allOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        ' + validator.compile() + '\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * oneOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against exactly one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.5\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'oneOf',\n    value: function oneOf() {\n      var oneOf = this.schema.oneOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(oneOf)) {\n        block += '\\n        /**\\n         * Validate ' + address + ' oneOf\\n         */\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        countOfValid = 0\\n      ';\n\n        oneOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          countOfValid += 1\\n        }\\n        ';\n        });\n\n        block += '\\n          if (countOfValid === 1) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors.push({\\n              keyword: \\'oneOf\\',\\n              message: \\'what is a reasonable error message for this case?\\'\\n            })\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * not\n     *\n     * @description\n     * > An instance is valid against this keyword if it fails to validate\n     * > successfully against the schema defined by this keyword.\n     * > JSON Schema Validation Section 5.5.6\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'not',\n    value: function not() {\n      var not = this.schema.not,\n          address = this.address;\n\n      var block = '';\n\n      if ((typeof not === 'undefined' ? 'undefined' : _typeof(not)) === 'object' && not !== null && !Array.isArray(not)) {\n        var subschema = not;\n        var validator = new Validator(subschema, { address: address });\n\n        block += '\\n        /**\\n         * NOT\\n         */\\n        if (value !== undefined) {\\n          initialValidity = valid\\n          initialErrorCount = errors.length\\n          notValid = true\\n\\n          accumulatedErrorCount = errors.length\\n\\n          ' + validator.compile() + '\\n\\n          if (accumulatedErrorCount === errors.length) {\\n            notValid = false\\n          }\\n\\n          if (notValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors = errors.slice(0, initialErrorCount)\\n            errors.push({\\n              keyword: \\'not\\',\\n              message: \\'hmm...\\'\\n            })\\n          }\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     *\n     * @description\n     * Iterate over the `properties` schema property if it is an object. For each\n     * key, initialize a new Validator for the subschema represented by the property\n     * value and invoke compile. Append the result of compiling each subschema to\n     * the block of code being generated.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          address = this.address;\n      var properties = schema.properties,\n          required = schema.required;\n\n      var block = this.push();\n\n      // ensure the value of \"required\" schema property is an array\n      required = Array.isArray(required) ? required : [];\n\n      if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var isRequired = required.indexOf(key) !== -1;\n          // TODO\n          // how should we be calculating these things? should be json pointer?\n          // needs a separate function\n          var pointer = [address, key].filter(function (segment) {\n            return !!segment;\n          }).join('.');\n          var validation = new Validator(subschema, { address: pointer, require: isRequired });\n\n          // read the value\n          block += '\\n        value = container[\\'' + key + '\\']\\n        ';\n\n          block += validation.compile();\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Other Properties\n     *\n     * @description\n     * This method is not for a keyword. It wraps validations for\n     * patternProperties and additionalProperties in a single iteration over\n     * an object-type value's properties.\n     *\n     * It should only be invoked once for a given subschema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'otherProperties',\n    value: function otherProperties() {\n      return '\\n      /**\\n       * Validate Other Properties\\n       */\\n      ' + this.push() + '\\n\\n      for (let key in container) {\\n        value = container[key]\\n        matched = false\\n\\n        ' + this.patternValidations() + '\\n        ' + this.additionalValidations() + '\\n      }\\n\\n      ' + this.pop() + '\\n    ';\n    }\n\n    /**\n     * Pattern Validations\n     *\n     * @description\n     * Generate validation code from a subschema for properties matching a\n     * regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternValidations',\n    value: function patternValidations() {\n      var patternProperties = this.schema.patternProperties;\n\n      var block = '';\n\n      if ((typeof patternProperties === 'undefined' ? 'undefined' : _typeof(patternProperties)) === 'object') {\n        Object.keys(patternProperties).forEach(function (pattern) {\n          var subschema = patternProperties[pattern];\n          var validator = new Validator(subschema);\n          block += '\\n          if (key.match(\\'' + pattern + '\\')) {\\n            matched = true\\n            ' + validator.compile() + '\\n          }\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * Additional Validations\n     *\n     * @description\n     * Generate validation code, either from a subschema for properties not\n     * defined in the schema, or to disallow properties not defined in the\n     * schema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalValidations',\n    value: function additionalValidations() {\n      var _schema = this.schema,\n          properties = _schema.properties,\n          additionalProperties = _schema.additionalProperties,\n          address = this.address;\n\n      var validations = '';\n      var block = '';\n\n      // catch additional unmatched properties\n      var conditions = ['matched !== true'];\n\n      // ignore defined properties\n      Object.keys(properties || {}).forEach(function (key) {\n        conditions.push('key !== \\'' + key + '\\'');\n      });\n\n      // validate additional properties\n      if ((typeof additionalProperties === 'undefined' ? 'undefined' : _typeof(additionalProperties)) === 'object') {\n        var subschema = additionalProperties;\n        var validator = new Validator(subschema, { address: address + '[APKey]' });\n        block += '\\n        // validate additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          ' + validator.compile() + '\\n        }\\n      ';\n      }\n\n      // error for additional properties\n      if (additionalProperties === false) {\n        block += '\\n        // validate non-presence of additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalProperties\\',\\n            message: key + \\' is not a defined property\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * patternProperties\n     *\n     * @description\n     * Generate validation code for properties matching a pattern\n     * defined by the property name (key), which must be a string\n     * representing a valid regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternProperties',\n    value: function patternProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * additionalProperties\n     *\n     * @description\n     * Generate validation code for additional properties not defined\n     * in the schema, or disallow additional properties if the value of\n     * `additionalProperties` in the schema is `false`.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * minProperties\n     *\n     * @description\n     * > An object instance is valid against \"minProperties\" if its number of\n     * > properties is greater than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minProperties',\n    value: function minProperties() {\n      var minProperties = this.schema.minProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min properties\\n        if (Object.keys(value).length < ' + minProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minProperties\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxProperties\n     *\n     * @description\n     * > An object instance is valid against \"maxProperties\" if its number of\n     * > properties is less than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxProperties',\n    value: function maxProperties() {\n      var maxProperties = this.schema.maxProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max properties\\n        if (Object.keys(value).length > ' + maxProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxProperties\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Dependencies\n     *\n     * @description\n     * > For all (name, schema) pair of schema dependencies, if the instance has\n     * > a property by this name, then it must also validate successfully against\n     * > the schema.\n     * >\n     * > Note that this is the instance itself which must validate successfully,\n     * > not the value associated with the property name.\n     * >\n     * > For each (name, propertyset) pair of property dependencies, if the\n     * > instance has a property by this name, then it must also have properties\n     * > with the same names as propertyset.\n     * > JSON Schema Validation Section 5.4.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'dependencies',\n    value: function dependencies() {\n      var dependencies = this.schema.dependencies,\n          address = this.address;\n\n\n      var block = this.push();\n\n      if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object') {\n        Object.keys(dependencies).forEach(function (key) {\n          var dependency = dependencies[key];\n          var conditions = [];\n\n          if (Array.isArray(dependency)) {\n            dependency.forEach(function (item) {\n              conditions.push('container[\\'' + item + '\\'] === undefined');\n            });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined && (' + conditions.join(' || ') + ')) {\\n              valid = false\\n              errors.push({\\n                keyword: \\'dependencies\\',\\n                message: \\'unmet dependencies\\'\\n              })\\n            }\\n          ';\n          } else if ((typeof dependency === 'undefined' ? 'undefined' : _typeof(dependency)) === 'object') {\n            var subschema = dependency;\n            var validator = new Validator(subschema, { address: address });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined) {\\n              ' + validator.compile() + '\\n            }\\n          ';\n          }\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Required\n     *\n     * @description\n     * > An object instance is valid against this keyword if its property set\n     * > contains all elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.4.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'required',\n    value: function required() {\n      var properties = this.schema.properties,\n          address = this.address;\n\n      var block = '';\n\n      block += '\\n      // validate ' + address + ' presence\\n      if (value === undefined) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'required\\',\\n          message: \\'is required\\'\\n        })\\n      }\\n    ';\n\n      return block;\n    }\n\n    /**\n     * additionalItems\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {\n      var _schema2 = this.schema,\n          items = _schema2.items,\n          additionalItems = _schema2.additionalItems,\n          address = this.address;\n\n      var block = '';\n\n      if (additionalItems === false && Array.isArray(items)) {\n        block += '\\n        // don\\'t allow additional items\\n        if (value.length > ' + items.length + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalItems\\',\\n            message: \\'additional items not allowed\\'\\n          })\\n        }\\n      ';\n      }\n\n      if ((typeof additionalItems === 'undefined' ? 'undefined' : _typeof(additionalItems)) === 'object' && additionalItems !== null && Array.isArray(items)) {\n        var subschema = additionalItems;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // additional items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = ' + items.length + '; i' + counter + ' <= container.length; i' + counter + '++) {\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Items\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * Code to generate\n     *\n     *     // this outer conditional is generated by this.array()\n     *     if (Array.isArray(value) {\n     *       let parent = value\n     *       for (let i = 0; i < parent.length; i++) {\n     *         value = parent[i]\n     *         // other validation code depending on value here\n     *       }\n     *       value = parent\n     *     }\n     *\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var items = this.schema.items,\n          address = this.address;\n\n      var block = '';\n\n      // if items is an array\n      if (Array.isArray(items)) {\n        block += this.push();\n\n        items.forEach(function (item, index) {\n          var subschema = item;\n          var validator = new Validator(subschema, { address: address + '[' + index + ']' });\n\n          block += '\\n          // item #' + index + '\\n          value = container[' + index + ']\\n          ' + validator.compile() + '\\n        ';\n        });\n\n        block += this.pop();\n\n        // if items is an object\n      } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n        var subschema = items;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = 0; i' + counter + ' < container.length; i' + counter + '++) {\\n          // read array element\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minItems\n     *\n     * @description\n     * > An array instance is valid against \"minItems\" if its size is greater\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minItems',\n    value: function minItems() {\n      var minItems = this.schema.minItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min items\\n        if (value.length < ' + minItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minItems\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxItems\n     *\n     * @description\n     * > An array instance is valid against \"maxItems\" if its size is less\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxItems',\n    value: function maxItems() {\n      var maxItems = this.schema.maxItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max items\\n        if (value.length > ' + maxItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxItems\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * uniqueItems\n     *\n     * @description\n     * > If this keyword has boolean value false, the instance validates\n     * > successfully. If it has boolean value true, the instance validates\n     * > successfully if all of its elements are unique.\n     * > JSON Schema Validation Section 5.3.4\n     *\n     * TODO\n     * optimize\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'uniqueItems',\n    value: function uniqueItems() {\n      var uniqueItems = this.schema.uniqueItems,\n          address = this.address;\n\n      var block = '';\n\n      if (uniqueItems === true) {\n        block += '\\n        // validate ' + address + ' unique items\\n        let values = value.map(v => JSON.stringify(v)) // TODO: optimize\\n        let set = new Set(values)\\n        if (values.length !== set.size) {\\n          valid = false\\n          errors.push({\\n            keyword: \\'uniqueItems\\',\\n            message: \\'items must be unique\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is\n     * > greater than, or equal to, the value of this keyword. The length of\n     * > a string instance is defined as the number of its characters as\n     * > defined by RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minLength',\n    value: function minLength() {\n      var minLength = this.schema.minLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate minLength\\n        if (Array.from(value).length < ' + minLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minLength\\',\\n            message: \\'too short\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is less\n     * > than, or equal to, the value of this keyword. The length of a string\n     * > instance is defined as the number of its characters as defined by\n     * > RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxLength',\n    value: function maxLength() {\n      var maxLength = this.schema.maxLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate maxLength\\n        if (Array.from(value).length > ' + maxLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxLength\\',\\n            message: \\'too long\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Pattern\n     *\n     * @description\n     * > A string instance is considered valid if the regular expression\n     * > matches the instance successfully.\n     * > JSON Schema Validation Section 5.2.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      var pattern = this.schema.pattern,\n          address = this.address;\n\n\n      if (pattern) {\n        return '\\n          // ' + address + ' validate pattern\\n          if (!value.match(new RegExp(\\'' + pattern + '\\'))) {\\n            valid = false\\n            errors.push({\\n              keyword: \\'pattern\\',\\n              message: \\'does not match the required pattern\\'\\n            })\\n          }\\n      ';\n      }\n    }\n\n    /**\n     * Format\n     *\n     * @description\n     * > Structural validation alone may be insufficient to validate that\n     * > an instance meets all the requirements of an application. The\n     * > \"format\" keyword is defined to allow interoperable semantic\n     * > validation for a fixed subset of values which are accurately\n     * > described by authoritative resources, be they RFCs or other\n     * > external specifications.\n     * > JSON Schema Validation Section 7.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'format',\n    value: function format() {\n      var format = this.schema.format,\n          address = this.address;\n\n      var matcher = formats.resolve(format);\n\n      if (matcher) {\n        return '\\n      // ' + address + ' validate format\\n      if (!value.match(' + matcher + ')) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'format\\',\\n          message: \\'is not \"' + format + '\" format\\'\\n        })\\n      }\\n      ';\n      }\n    }\n\n    /**\n     * Minimum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMinimum\": if \"exclusiveMinimum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is greater\n     * > than, or equal to, the value of \"minimum\"; if \"exclusiveMinimum\" is\n     * > present and has boolean value true, the instance is valid if it is\n     * > strictly greater than the value of \"minimum\".\n     * > JSON Schema Validation Section 5.1.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minimum',\n    value: function minimum() {\n      var _schema3 = this.schema,\n          minimum = _schema3.minimum,\n          exclusiveMinimum = _schema3.exclusiveMinimum,\n          address = this.address;\n\n      var operator = exclusiveMinimum === true ? '<=' : '<';\n\n      return '\\n        // ' + address + ' validate minimum\\n        if (value ' + operator + ' ' + minimum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minimum\\',\\n            message: \\'too small\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Maximum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMaximum\": if \"exclusiveMaximum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is lower than,\n     * > or equal to, the value of \"maximum\"; if \"exclusiveMaximum\" has\n     * > boolean value true, the instance is valid if it is strictly lower\n     * > than the value of \"maximum\".\n     * > JSON Schema Validation Section 5.1.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maximum',\n    value: function maximum() {\n      var _schema4 = this.schema,\n          maximum = _schema4.maximum,\n          exclusiveMaximum = _schema4.exclusiveMaximum,\n          address = this.address;\n\n      var operator = exclusiveMaximum === true ? '>=' : '>';\n\n      return '\\n        // ' + address + ' validate maximum\\n        if (value ' + operator + ' ' + maximum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maximum\\',\\n            message: \\'too large\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * multipleOf\n     *\n     * @description\n     * > A numeric instance is valid against \"multipleOf\" if the result of\n     * > the division of the instance by this keyword's value is an integer.\n     * > JSON Schema Validation Section 5.1.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'multipleOf',\n    value: function multipleOf() {\n      var multipleOf = this.schema.multipleOf;\n\n      var block = '';\n\n      if (typeof multipleOf === 'number') {\n        var length = multipleOf.toString().length;\n        var decimals = length - multipleOf.toFixed(0).length - 1;\n        var pow = decimals > 0 ? Math.pow(10, decimals) : 1;\n        var condition = void 0;\n\n        if (decimals > 0) {\n          condition = '(value * ' + pow + ') % ' + multipleOf * pow + ' !== 0';\n        } else {\n          condition = 'value % ' + multipleOf + ' !== 0';\n        }\n\n        block += '\\n        if (' + condition + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'multipleOf\\',\\n            message: \\'must be a multiple of ' + multipleOf + '\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n  }]);\n\n  return Validator;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Validator;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\nvar JWA = __webpack_require__(38);\nvar JWK = __webpack_require__(57);\nvar JWKSet = __webpack_require__(60);\nvar JWT = __webpack_require__(62);\nvar JWS = __webpack_require__(67);\nvar Base64URLSchema = __webpack_require__(64);\nvar JOSEHeaderSchema = __webpack_require__(66);\nvar JWKSchema = __webpack_require__(58);\nvar JWKSetSchema = __webpack_require__(61);\nvar JWTClaimsSetSchema = __webpack_require__(65);\nvar JWTSchema = __webpack_require__(63);\n\n/**\n * Export\n */\nmodule.exports = {\n  JWA: JWA,\n  JWK: JWK,\n  JWKSet: JWKSet,\n  JWT: JWT,\n  JWS: JWS,\n  Base64URLSchema: Base64URLSchema,\n  JOSEHeaderSchema: JOSEHeaderSchema,\n  JWKSchema: JWKSchema,\n  JWKSetSchema: JWKSetSchema,\n  JWTClaimsSetSchema: JWTClaimsSetSchema,\n  JWTSchema: JWTSchema\n};\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\nvar base64url = __webpack_require__(39);\nvar supportedAlgorithms = __webpack_require__(46);\n\nvar _require = __webpack_require__(55),\n    NotSupportedError = _require.NotSupportedError;\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\n\n\nvar JWA = function () {\n  function JWA() {\n    _classCallCheck(this, JWA);\n  }\n\n  _createClass(JWA, null, [{\n    key: 'sign',\n\n\n    /**\n     * Sign\n     *\n     * @description\n     * Create a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} key\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n    value: function sign(alg, key, data) {\n      // normalize the algorithm\n      var normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg);\n\n      // validate algorithm is supported\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // validate type of key\n      // TODO\n      //  - is the key suitable for the algorithm?\n      //  - does that get validated in webcrypto?\n      //if (key instanceof CryptoKey) {\n      //  return Promise.reject(new InvalidKeyError())\n      //}\n\n      // sign the data\n      return normalizedAlgorithm.sign(key, data);\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} privateKey\n     * @param {string|Buffer} signature\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(alg, key, signature, data) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // TODO\n      // validate publicKey\n\n      // verify the signature\n      return normalizedAlgorithm.verify(key, signature, data);\n    }\n\n    /**\n     * Encrypt\n     */\n\n    /**\n     * Decrypt\n     */\n\n    /**\n     * Import\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg);\n      return normalizedAlgorithm.importKey(key);\n    }\n  }]);\n\n  return JWA;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JWA;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(40).default;\nmodule.exports.default = module.exports;\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pad_string_1 = __webpack_require__(45);\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return Buffer.from(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return Buffer.from(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nexports.default = base64url;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(42)\nvar ieee754 = __webpack_require__(43)\nvar isArray = __webpack_require__(44)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = Buffer.alloc(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nexports.default = padString;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Local dependencies\n */\nvar None = __webpack_require__(47);\nvar HMAC = __webpack_require__(48);\nvar RSASSA_PKCS1_v1_5 = __webpack_require__(52);\nvar SupportedAlgorithms = __webpack_require__(53);\n\n/**\n * Register Supported Algorithms\n */\nvar supportedAlgorithms = new SupportedAlgorithms();\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n//supportedAlgorithms.define('ES256', 'sign', {})\n//supportedAlgorithms.define('ES384', 'sign', {})\n//supportedAlgorithms.define('ES512', 'sign', {})\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\n\nsupportedAlgorithms.define('none', 'sign', new None({\n  // nothing goes here\n}));\n\n/**\n * Verify\n */\nsupportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n//supportedAlgorithms.define('ES256', 'verify', {})\n//supportedAlgorithms.define('ES384', 'verify', {})\n//supportedAlgorithms.define('ES512', 'verify', {})\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\n\nsupportedAlgorithms.define('none', 'verify', new None({\n  // nothing goes here\n}));\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\n/**\n * Export\n */\nmodule.exports = supportedAlgorithms;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * None\n */\nvar None = function () {\n  function None() {\n    _classCallCheck(this, None);\n  }\n\n  _createClass(None, [{\n    key: 'sign',\n\n    /**\n     * sign\n     */\n    value: function sign() {\n      return Promise.resolve('');\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      // this will never get called. but you looked.\n    }\n  }]);\n\n  return None;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = None;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = __webpack_require__(39);\nvar crypto = __webpack_require__(49);\nvar TextEncoder = __webpack_require__(50);\n\n/**\n * HMAC with SHA-2 Functions\n */\n\nvar HMAC = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  function HMAC(params) {\n    _classCallCheck(this, HMAC);\n\n    this.params = params;\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(HMAC, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO: validate key length\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {string} signature\n     * @param {string} data\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * Assert Sufficient Key Length\n     *\n     * @description Assert that the key length is sufficient\n     * @param {string} key\n     */\n\n  }, {\n    key: 'assertSufficientKeyLength',\n    value: function assertSufficientKeyLength(key) {\n      if (key.length < this.bitlength) {\n        throw new Error('The key is too short.');\n      }\n    }\n  }]);\n\n  return HMAC;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = HMAC;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"crypto\"]; }());\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar TextEncoder = global.TextEncoder ? global.TextEncoder // browser\n: __webpack_require__(51).TextEncoder; // node shim\nmodule.exports = TextEncoder;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"TextEncoder\"]; }());\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = __webpack_require__(39);\nvar crypto = __webpack_require__(49);\nvar TextEncoder = __webpack_require__(50);\n\n/**\n * RSASSA-PKCS1-v1_5\n */\n\nvar RSASSA_PKCS1_v1_5 = function () {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  function RSASSA_PKCS1_v1_5(params) {\n    _classCallCheck(this, RSASSA_PKCS1_v1_5);\n\n    this.params = params;\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n\n  _createClass(RSASSA_PKCS1_v1_5, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO\n      //if (!this.sufficientKeySize()) {\n      //  return Promise.reject(\n      //    new Error(\n      //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n      //    )\n      //  )\n      //}\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      // ...\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * importKey\n     *\n     * @param {JWK} key\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var jwk = Object.assign({}, key);\n      var algorithm = this.params;\n      var usages = key['key_ops'] || [];\n\n      if (key.use === 'sig') {\n        usages.push('verify');\n      }\n\n      if (key.use === 'enc') {\n        // TODO: handle encryption keys\n        return Promise.resolve(key);\n      }\n\n      if (key.key_ops) {\n        usages = key.key_ops;\n      }\n\n      return crypto.subtle.importKey('jwk', jwk, algorithm, true, usages).then(function (cryptoKey) {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        });\n\n        return jwk;\n      });\n    }\n  }]);\n\n  return RSASSA_PKCS1_v1_5;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = RSASSA_PKCS1_v1_5;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n */\nvar NotSupportedError = __webpack_require__(54);\n\n/**\n * Operations\n */\nvar operations = ['sign', 'verify', 'encrypt', 'decrypt', 'importKey'];\n\n/**\n * SupportedAlgorithms\n */\n\nvar SupportedAlgorithms = function () {\n\n  /**\n   * constructor\n   */\n  function SupportedAlgorithms() {\n    var _this = this;\n\n    _classCallCheck(this, SupportedAlgorithms);\n\n    operations.forEach(function (op) {\n      _this[op] = {};\n    });\n  }\n\n  /**\n   * Supported Operations\n   */\n\n\n  _createClass(SupportedAlgorithms, [{\n    key: 'define',\n\n\n    /**\n     * define\n     *\n     * @description\n     * Register Web Crypto API algorithm parameter for an algorithm\n     * and operation.\n     *\n     * @param {string} alg\n     * @param {string} op\n     * @param {Object} argument\n     */\n    value: function define(alg, op, argument) {\n      var registeredAlgorithms = this[op];\n      registeredAlgorithms[alg] = argument;\n    }\n\n    /**\n     * normalize\n     *\n     * @description\n     * Map JWA alg name to Web Crypto API algorithm parameter\n     *\n     * @param {string} op\n     * @param {Object} alg\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(op, alg) {\n      var registeredAlgorithms = this[op];\n\n      if (!registeredAlgorithms) {\n        return new SyntaxError(); // what kind of error should this be?\n      }\n\n      var argument = registeredAlgorithms[alg];\n\n      if (!argument) {\n        return new NotSupportedError(alg);\n      }\n\n      return argument;\n    }\n  }], [{\n    key: 'operations',\n    get: function get() {\n      return operations;\n    }\n  }]);\n\n  return SupportedAlgorithms;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = SupportedAlgorithms;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * NotSupportedError\n */\nvar NotSupportedError = function (_Error) {\n  _inherits(NotSupportedError, _Error);\n\n  function NotSupportedError(alg) {\n    _classCallCheck(this, NotSupportedError);\n\n    var _this = _possibleConstructorReturn(this, (NotSupportedError.__proto__ || Object.getPrototypeOf(NotSupportedError)).call(this));\n\n    _this.message = alg + \" is not a supported algorithm\";\n    return _this;\n  }\n\n  return NotSupportedError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = NotSupportedError;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  DataError: __webpack_require__(56),\n  NotSupportedError: __webpack_require__(54)\n};\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * DataError\n */\nvar DataError = function (_Error) {\n  _inherits(DataError, _Error);\n\n  function DataError(message) {\n    _classCallCheck(this, DataError);\n\n    return _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message));\n  }\n\n  return DataError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = DataError;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = __webpack_require__(28),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSchema = __webpack_require__(58);\nvar JWA = __webpack_require__(38);\n\n/**\n * JWK Class\n */\n\nvar JWK = function (_JSONDocument) {\n  _inherits(JWK, _JSONDocument);\n\n  function JWK() {\n    _classCallCheck(this, JWK);\n\n    return _possibleConstructorReturn(this, (JWK.__proto__ || Object.getPrototypeOf(JWK)).apply(this, arguments));\n  }\n\n  _createClass(JWK, null, [{\n    key: 'importKey',\n\n\n    /**\n     * importKey\n     *\n     * TODO:\n     * - should this be on JWA?\n     */\n    value: function importKey(jwk) {\n      return JWA.importKey(jwk);\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      return JWKSchema;\n    }\n  }]);\n\n  return JWK;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWK;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\nvar _require2 = __webpack_require__(59),\n    BASE64_REGEXP = _require2.BASE64_REGEXP;\n\n/**\n * JWK Schema\n */\n\n\nvar JWKSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    kty: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['RSA', 'EC', 'oct'] // other values MAY be used\n    },\n\n    use: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['sig', 'enc'] // other values MAY be used\n    },\n\n    key_ops: {\n      type: 'array',\n      //format: 'case-sensitive',\n      items: {\n        enum: ['sign', 'verify', 'encrypt', 'decrypt', 'wrapKey', 'unwrapKey', 'deriveKey', 'deriveBits'] // other values MAY be used\n      }\n    },\n\n    alg: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'PS256', 'PS384', 'PS512', 'none'] // other values MAY be used\n    },\n\n    kid: {\n      type: 'string'\n    },\n\n    x5u: {\n      type: 'string'\n      //format: 'url'\n    },\n\n    x5c: {\n      type: 'array'\n      //format: BASE64_REGEXP\n    },\n\n    x5t: {\n      type: 'string'\n      //format: BASE64_REGEXP\n    }\n\n    //'x5t#S256': {\n    //  type: 'string',\n    //  //format: BASE64_REGEXP\n    //}\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSchema;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Package dependencies\n */\nvar _require = __webpack_require__(28),\n    Formats = _require.Formats;\n\n/**\n * Format extensions\n */\n\n\nFormats.register('StringOrURI', new RegExp());\nFormats.register('NumericDate', new RegExp());\nFormats.register('URI', new RegExp());\nFormats.register('url', new RegExp());\nFormats.register('base64', new RegExp());\nFormats.register('base64url', new RegExp());\nFormats.register('MediaType', new RegExp());\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = __webpack_require__(28),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSetSchema = __webpack_require__(61);\nvar JWK = __webpack_require__(57);\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\n\nvar JWKSet = function (_JSONDocument) {\n  _inherits(JWKSet, _JSONDocument);\n\n  function JWKSet() {\n    _classCallCheck(this, JWKSet);\n\n    return _possibleConstructorReturn(this, (JWKSet.__proto__ || Object.getPrototypeOf(JWKSet)).apply(this, arguments));\n  }\n\n  _createClass(JWKSet, null, [{\n    key: 'importKeys',\n\n\n    /**\n     * importKeys\n     */\n    value: function importKeys(jwks) {\n      var validation = this.schema.validate(jwks);\n\n      if (!validation.valid) {\n        return Promise.reject(new Error('Invalid JWKSet: ' + JSON.stringify(validation, null, 2)));\n      }\n\n      if (!jwks.keys) {\n        return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'));\n      }\n\n      var imported = void 0,\n          importing = void 0;\n\n      try {\n        imported = new JWKSet(jwks);\n        importing = jwks.keys.map(function (key) {\n          return JWK.importKey(key);\n        });\n      } catch (err) {\n        return Promise.reject(err);\n      }\n\n      return Promise.all(importing).then(function (keys) {\n        imported.keys = keys;\n        return imported;\n      });\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWKSetSchema;\n    }\n  }]);\n\n  return JWKSet;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWKSet;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\nvar JWKSchema = __webpack_require__(58);\n\n/**\n * JWKSetSchema\n */\nvar JWKSetSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    keys: {\n      type: 'array',\n      items: JWKSchema\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSetSchema;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Dependencies\n */\nvar base64url = __webpack_require__(39);\n\nvar _require = __webpack_require__(28),\n    JSONDocument = _require.JSONDocument;\n\nvar JWTSchema = __webpack_require__(63);\nvar JWS = __webpack_require__(67);\nvar DataError = __webpack_require__(56);\n\n/**\n * JWT\n */\n\nvar JWT = function (_JSONDocument) {\n  _inherits(JWT, _JSONDocument);\n\n  function JWT() {\n    _classCallCheck(this, JWT);\n\n    return _possibleConstructorReturn(this, (JWT.__proto__ || Object.getPrototypeOf(JWT)).apply(this, arguments));\n  }\n\n  _createClass(JWT, [{\n    key: 'isJWE',\n\n\n    /**\n     * isJWE\n     */\n    value: function isJWE() {\n      return !!this.header.enc;\n    }\n\n    /**\n     * resolveKeys\n     */\n\n  }, {\n    key: 'resolveKeys',\n    value: function resolveKeys(jwks) {\n      var kid = this.header.kid;\n      var keys = void 0,\n          match = void 0;\n\n      // treat an array as the \"keys\" property of a JWK Set\n      if (Array.isArray(jwks)) {\n        keys = jwks;\n      }\n\n      // presence of keys indicates object is a JWK Set\n      if (jwks.keys) {\n        keys = jwks.keys;\n      }\n\n      // wrap a plain object they is not a JWK Set in Array\n      if (!jwks.keys && (typeof jwks === 'undefined' ? 'undefined' : _typeof(jwks)) === 'object') {\n        keys = [jwks];\n      }\n\n      // ensure there are keys to search\n      if (!keys) {\n        throw new DataError('Invalid JWK argument');\n      }\n\n      // match by \"kid\" or \"use\" header\n      if (kid) {\n        match = keys.find(function (jwk) {\n          return jwk.kid === kid;\n        });\n      } else {\n        match = keys.find(function (jwk) {\n          return jwk.use === 'sig';\n        });\n      }\n\n      // assign matching key to JWT and return a boolean\n      if (match) {\n        this.key = match.cryptoKey;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode() {\n      // validate\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      var token = this;\n\n      if (this.isJWE()) {\n        return JWE.encrypt(token);\n      } else {\n        return JWS.sign(token);\n      }\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a decoded JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      return JWS.verify(this);\n    }\n  }], [{\n    key: 'decode',\n\n\n    /**\n     * decode\n     *\n     * @description\n     * Decode a JSON Web Token\n     *\n     * @param {string} data\n     * @returns {JWT}\n     */\n    value: function decode(data) {\n      var ExtendedJWT = this;\n      var jwt = void 0;\n\n      if (typeof data !== 'string') {\n        throw new DataError('JWT must be a string');\n      }\n\n      // JSON of Flattened JSON Serialization\n      if (data.startsWith('{')) {\n        try {\n          data = JSON.parse(data, function () {});\n        } catch (error) {\n          throw new DataError('Invalid JWT serialization');\n        }\n\n        if (data.signatures || data.recipients) {\n          data.serialization = 'json';\n        } else {\n          data.serialization = 'flattened';\n        }\n\n        jwt = new ExtendedJWT(data, { filter: false });\n\n        // Compact Serialization\n      } else {\n        try {\n          var serialization = 'compact';\n          var segments = data.split('.');\n          var length = segments.length;\n\n          if (length !== 3 && length !== 5) {\n            throw new Error('Malformed JWT');\n          }\n\n          var header = JSON.parse(base64url.decode(segments[0]));\n\n          // JSON Web Signature\n          if (length === 3) {\n            var type = 'JWS';\n            var payload = JSON.parse(base64url.decode(segments[1]));\n            var signature = segments[2];\n\n            jwt = new ExtendedJWT({ type: type, segments: segments, header: header, payload: payload, signature: signature, serialization: serialization }, { filter: false });\n          }\n\n          // JSON Web Encryption\n          if (length === 5) {\n            //let type = 'JWE'\n            //let [protected, encryption_key, iv, ciphertext, tag] = segments\n\n            //jwt = new ExtendedJWT({\n            //  type,\n            //  protected: base64url.decode(JSON.parse(protected)),\n            //  encryption_key,\n            //  iv,\n            //  ciphertext,\n            //  tag,\n            //  serialization\n            //})\n          }\n        } catch (error) {\n          throw new DataError('Invalid JWT compact serialization');\n        }\n      }\n\n      return jwt;\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JSON Web Token\n     *\n     * @param {Object} header\n     * @param {Object} payload\n     * @param {CryptoKey} key\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode(header, payload, key) {\n      var jwt = new JWT(header, payload);\n      return jwt.encode(key);\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     *\n     * @param {CryptoKey} key\n     * @param {string} token\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, token) {\n      var jwt = JWT.decode(token);\n      jwt.key = key;\n      return jwt.verify().then(function (verified) {\n        return jwt;\n      });\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWTSchema;\n    }\n  }]);\n\n  return JWT;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWT;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar Base64URLSchema = __webpack_require__(64);\nvar JWTClaimsSetSchema = __webpack_require__(65);\nvar JOSEHeaderSchema = __webpack_require__(66);\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTSchema\n *\n * @description\n * This schema represents all the things a deserialized JWT can be, i.e.,\n * either a JWS or JWE, and any serialization of them. Validation of well-\n * formedness for a given serialization is accomplished at the time of\n * encoding.\n */\n\n\nvar JWTSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * type\n     */\n    type: {\n      type: 'string',\n      enum: ['JWS', 'JWE']\n    },\n\n    /**\n     * segments\n     */\n    segments: {\n      type: 'array'\n    },\n\n    /**\n     * header\n     */\n    header: JOSEHeaderSchema,\n\n    /**\n     * protected\n     */\n    protected: JOSEHeaderSchema,\n\n    /**\n     * unprotected\n     */\n    unprotected: JOSEHeaderSchema,\n\n    /**\n     * iv\n     */\n    iv: Base64URLSchema,\n\n    /**\n     * aad\n     */\n    aad: Base64URLSchema,\n\n    /**\n     * ciphertext\n     */\n    ciphertext: Base64URLSchema,\n\n    /**\n     * tag\n     */\n    tag: Base64URLSchema,\n\n    /**\n     * recipients\n     */\n    recipients: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          header: JOSEHeaderSchema,\n          encrypted_key: Base64URLSchema\n        }\n      }\n    },\n\n    /**\n     * payload\n     */\n    payload: JWTClaimsSetSchema,\n\n    /**\n     * signatures\n     */\n    signatures: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          protected: JOSEHeaderSchema,\n          header: JOSEHeaderSchema,\n          signature: Base64URLSchema,\n          key: { type: 'object' }\n        }\n      }\n    },\n\n    /**\n     * signature\n     */\n    signature: Base64URLSchema,\n\n    /**\n     * verified\n     */\n    verified: {\n      type: 'boolean',\n      default: false\n    },\n\n    /**\n     * key\n     */\n    key: {\n      type: 'object'\n    },\n\n    /**\n     * serialization\n     */\n    serialization: {\n      type: 'string',\n      enum: ['compact', 'json', 'flattened'],\n      default: 'compact'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTSchema;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * Base64URLSchema\n */\n\n\nvar Base64URLSchema = new JSONSchema({\n  type: 'string',\n  format: 'base64url'\n});\n\n/**\n * Export\n */\nmodule.exports = Base64URLSchema;\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTClaimsSetSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-4\n *\n * 4.  JWT Claims\n *\n *   The JWT Claims Set represents a JSON object whose members are the\n *   claims conveyed by the JWT.  The Claim Names within a JWT Claims Set\n *   MUST be unique; JWT parsers MUST either reject JWTs with duplicate\n *   Claim Names or use a JSON parser that returns only the lexically last\n *   duplicate member name, as specified in Section 15.12 (\"The JSON\n *   Object\") of ECMAScript 5.1 [ECMAScript].\n *\n *   The set of claims that a JWT must contain to be considered valid is\n *   context dependent and is outside the scope of this specification.\n *   Specific applications of JWTs will require implementations to\n *   understand and process some claims in particular ways.  However, in\n *   the absence of such requirements, all claims that are not understood\n *   by implementations MUST be ignored.\n *\n *   There are three classes of JWT Claim Names: Registered Claim Names,\n *   Public Claim Names, and Private Claim Names.\n */\n\n\nvar JWTClaimsSetSchema = new JSONSchema({\n  properties: {\n\n    /**\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1\n     *\n     * 4.1.  Registered Claim Names\n     *\n     *   The following Claim Names are registered in the IANA \"JSON Web Token\n     *   Claims\" registry established by Section 10.1.  None of the claims\n     *   defined below are intended to be mandatory to use or implement in all\n     *   cases, but rather they provide a starting point for a set of useful,\n     *   interoperable claims.  Applications using JWTs should define which\n     *   specific claims they use and when they are required or optional.  All\n     *   the names are short because a core goal of JWTs is for the\n     *   representation to be compact.\n     */\n\n    /**\n     * iss\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.1\n     *\n     * 4.1.1.  \"iss\" (Issuer) Claim\n     *\n     *   The \"iss\" (issuer) claim identifies the principal that issued the\n     *   JWT.  The processing of this claim is generally application specific.\n     *   The \"iss\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    iss: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * sub\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.2\n     *\n     * 4.1.2.  \"sub\" (Subject) Claim\n     *\n     *   The \"sub\" (subject) claim identifies the principal that is the\n     *   subject of the JWT.  The claims in a JWT are normally statements\n     *   about the subject.  The subject value MUST either be scoped to be\n     *   locally unique in the context of the issuer or be globally unique.\n     *   The processing of this claim is generally application specific.  The\n     *   \"sub\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    sub: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * aud\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.3\n     *\n     * 4.1.3.  \"aud\" (Audience) Claim\n     *\n     *   The \"aud\" (audience) claim identifies the recipients that the JWT is\n     *   intended for.  Each principal intended to process the JWT MUST\n     *   identify itself with a value in the audience claim.  If the principal\n     *   processing the claim does not identify itself with a value in the\n     *   \"aud\" claim when this claim is present, then the JWT MUST be\n     *   rejected.  In the general case, the \"aud\" value is an array of case-\n     *   sensitive strings, each containing a StringOrURI value.  In the\n     *   special case when the JWT has one audience, the \"aud\" value MAY be a\n     *   single case-sensitive string containing a StringOrURI value.  The\n     *   interpretation of audience values is generally application specific.\n     *   Use of this claim is OPTIONAL.\n     */\n    aud: {\n      type: ['array', 'string'],\n      format: 'StringOrURI',\n      items: {\n        format: 'StringOrURI'\n      }\n    },\n\n    /**\n     * exp\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.4\n     *\n     * 4.1.4.  \"exp\" (Expiration Time) Claim\n     *\n     *   The \"exp\" (expiration time) claim identifies the expiration time on\n     *   or after which the JWT MUST NOT be accepted for processing.  The\n     *   processing of the \"exp\" claim requires that the current date/time\n     *   MUST be before the expiration date/time listed in the \"exp\" claim.\n     *\n     *   Implementers MAY provide for some small leeway, usually no more than\n     *   a few minutes, to account for clock skew.  Its value MUST be a number\n     *   containing a NumericDate value.  Use of this claim is OPTIONAL.\n     *\n     */\n    exp: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * nbf\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.5\n     *\n     * 4.1.5.  \"nbf\" (Not Before) Claim\n     *\n     *   The \"nbf\" (not before) claim identifies the time before which the JWT\n     *   MUST NOT be accepted for processing.  The processing of the \"nbf\"\n     *   claim requires that the current date/time MUST be after or equal to\n     *   the not-before date/time listed in the \"nbf\" claim.  Implementers MAY\n     *   provide for some small leeway, usually no more than a few minutes, to\n     *   account for clock skew.  Its value MUST be a number containing a\n     *   NumericDate value.  Use of this claim is OPTIONAL.\n     */\n    nbf: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * iat\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.6\n     *\n     * 4.1.6.  \"iat\" (Issued At) Claim\n     *\n     *   The \"iat\" (issued at) claim identifies the time at which the JWT was\n     *   issued.  This claim can be used to determine the age of the JWT.  Its\n     *   value MUST be a number containing a NumericDate value.  Use of this\n     *   claim is OPTIONAL.\n     */\n    iat: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * jti\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.7\n     *\n     * 4.1.7.  \"jti\" (JWT ID) Claim\n     *\n     *   The \"jti\" (JWT ID) claim provides a unique identifier for the JWT.\n     *   The identifier value MUST be assigned in a manner that ensures that\n     *   there is a negligible probability that the same value will be\n     *   accidentally assigned to a different data object; if the application\n     *   uses multiple issuers, collisions MUST be prevented among values\n     *   produced by different issuers as well.  The \"jti\" claim can be used\n     *   to prevent the JWT from being replayed.  The \"jti\" value is a case-\n     *   sensitive string.  Use of this claim is OPTIONAL.\n     */\n    jti: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTClaimsSetSchema;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar JWKSchema = __webpack_require__(58);\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JOSEHeaderSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-5\n *\n * 5.  JOSE Header\n *\n *   For a JWT object, the members of the JSON object represented by the\n *   JOSE Header describe the cryptographic operations applied to the JWT\n *   and optionally, additional properties of the JWT.  Depending upon\n *   whether the JWT is a JWS or JWE, the corresponding rules for the JOSE\n *   Header values apply.\n */\n\n\nvar JOSEHeaderSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * typ\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.1\n     *\n     * 5.1.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter defined by [JWS] and [JWE] is used\n     *   by JWT applications to declare the media type [IANA.MediaTypes] of\n     *   this complete JWT.  This is intended for use by the JWT application\n     *   when values that are not JWTs could also be present in an application\n     *   data structure that can contain a JWT object; the application can use\n     *   this value to disambiguate among the different kinds of objects that\n     *   might be present.  It will typically not be used by applications when\n     *   it is already known that the object is a JWT.  This parameter is\n     *   ignored by JWT implementations; any processing of this parameter is\n     *   performed by the JWT application.  If present, it is RECOMMENDED that\n     *   its value be \"JWT\" to indicate that this object is a JWT.  While\n     *   media type names are not case sensitive, it is RECOMMENDED that \"JWT\"\n     *   always be spelled using uppercase characters for compatibility with\n     *   legacy implementations.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.9\n     *\n     * 4.1.9.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter is used by JWS applications to\n     *   declare the media type [IANA.MediaTypes] of this complete JWS.  This\n     *   is intended for use by the application when more than one kind of\n     *   object could be present in an application data structure that can\n     *   contain a JWS; the application can use this value to disambiguate\n     *   among the different kinds of objects that might be present.  It will\n     *   typically not be used by applications when the kind of object is\n     *   already known.  This parameter is ignored by JWS implementations; any\n     *   processing of this parameter is performed by the JWS application.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"typ\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"typ\" value not containing a\n     *   '/'.  For instance, a \"typ\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     *   The \"typ\" value \"JOSE\" can be used by applications to indicate that\n     *   this object is a JWS or JWE using the JWS Compact Serialization or\n     *   the JWE Compact Serialization.  The \"typ\" value \"JOSE+JSON\" can be\n     *   used by applications to indicate that this object is a JWS or JWE\n     *   using the JWS JSON Serialization or the JWE JSON Serialization.\n     *   Other type values can also be used by applications.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.11\n     *\n     * 4.1.11.  \"typ\" (Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"typ\" Header Parameter defined in Section 4.1.9 of [JWS], except\n     *   that the type is that of this complete JWE.\n     */\n    typ: {\n      type: 'string'\n    },\n\n    /**\n     * cty\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.2\n     *\n     * 5.2.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter defined by [JWS] and [JWE]\n     *   is used by this specification to convey structural information about\n     *   the JWT.\n     *\n     *   In the normal case in which nested signing or encryption operations\n     *   are not employed, the use of this Header Parameter is NOT\n     *   RECOMMENDED.  In the case that nested signing or encryption is\n     *   employed, this Header Parameter MUST be present; in this case, the\n     *   value MUST be \"JWT\", to indicate that a Nested JWT is carried in this\n     *   JWT.  While media type names are not case sensitive, it is\n     *   RECOMMENDED that \"JWT\" always be spelled using uppercase characters\n     *   for compatibility with legacy implementations.  See Appendix A.2 for\n     *   an example of a Nested JWT.\n     *\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.10\n     *\n     * 4.1.10.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter is used by JWS applications\n     *   to declare the media type [IANA.MediaTypes] of the secured content\n     *   (the payload).  This is intended for use by the application when more\n     *   than one kind of object could be present in the JWS Payload; the\n     *   application can use this value to disambiguate among the different\n     *   kinds of objects that might be present.  It will typically not be\n     *   used by applications when the kind of object is already known.  This\n     *   parameter is ignored by JWS implementations; any processing of this\n     *   parameter is performed by the JWS application.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"cty\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"cty\" value not containing a\n     *   '/'.  For instance, a \"cty\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.12\n     *\n     * 4.1.12.  \"cty\" (Content Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"cty\" Header Parameter defined in Section 4.1.10 of [JWS], except\n     *   that the type is that of the secured content (the plaintext).\n     */\n    cty: {\n      type: 'string',\n      enum: ['JWT']\n    },\n\n    /**\n     * alg\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   The \"alg\" (algorithm) Header Parameter identifies the cryptographic\n     *   algorithm used to secure the JWS.  The JWS Signature value is not\n     *   valid if the \"alg\" value does not represent a supported algorithm or\n     *   if there is not a key for use with that algorithm associated with the\n     *   party that digitally signed or MACed the content.  \"alg\" values\n     *   should either be registered in the IANA \"JSON Web Signature and\n     *   Encryption Algorithms\" registry established by [JWA] or be a value\n     *   that contains a Collision-Resistant Name.  The \"alg\" value is a case-\n     *   sensitive ASCII string containing a StringOrURI value.  This Header\n     *   Parameter MUST be present and MUST be understood and processed by\n     *   implementations.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 3.1 of [JWA].\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"alg\" Header Parameter defined in Section 4.1.1 of [JWS], except\n     *   that the Header Parameter identifies the cryptographic algorithm used\n     *   to encrypt or determine the value of the CEK.  The encrypted content\n     *   is not usable if the \"alg\" value does not represent a supported\n     *   algorithm, or if the recipient does not have a key that can be used\n     *   with that algorithm.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 4.1 of [JWA].\n     */\n    alg: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * jku\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.2\n     *\n     * 4.1.2.  \"jku\" (JWK Set URL) Header Parameter (JWS)\n     *\n     *   The \"jku\" (JWK Set URL) Header Parameter is a URI [RFC3986] that\n     *   refers to a resource for a set of JSON-encoded public keys, one of\n     *   which corresponds to the key used to digitally sign the JWS.  The\n     *   keys MUST be encoded as a JWK Set [JWK].  The protocol used to\n     *   acquire the resource MUST provide integrity protection; an HTTP GET\n     *   request to retrieve the JWK Set MUST use Transport Layer Security\n     *   (TLS) [RFC2818] [RFC5246]; and the identity of the server MUST be\n     *   validated, as per Section 6 of RFC 6125 [RFC6125].  Also, see\n     *   Section 8 on TLS requirements.  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.4\n     *\n     * 4.1.4.  \"jku\" (JWK Set URL) Header Parameter (JWE)\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jku\" Header Parameter defined in Section 4.1.2 of [JWS], except\n     *   that the JWK Set resource contains the public key to which the JWE\n     *   was encrypted; this can be used to determine the private key needed\n     *   to decrypt the JWE.\n     */\n    jku: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * jwk\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.3\n     *\n     * 4.1.3.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   The \"jwk\" (JSON Web Key) Header Parameter is the public key that\n     *   corresponds to the key used to digitally sign the JWS.  This key is\n     *   represented as a JSON Web Key [JWK].  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.5\n     *\n     * 4.1.5.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jwk\" Header Parameter defined in Section 4.1.3 of [JWS], except\n     *   that the key is the public key to which the JWE was encrypted; this\n     *   can be used to determine the private key needed to decrypt the JWE.\n     */\n    //jwk: JWKSchema,\n\n    /**\n     * kid\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.4\n     *\n     * 4.1.4.  \"kid\" (Key ID) Header Parameter\n     *\n     *   The \"kid\" (key ID) Header Parameter is a hint indicating which key\n     *   was used to secure the JWS.  This parameter allows originators to\n     *   explicitly signal a change of key to recipients.  The structure of\n     *   the \"kid\" value is unspecified.  Its value MUST be a case-sensitive\n     *   string.  Use of this Header Parameter is OPTIONAL.\n     *\n     *   When used with a JWK, the \"kid\" value is used to match a JWK \"kid\"\n     *   parameter value.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.6\n     *\n     * 4.1.6.  \"kid\" (Key ID) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"kid\" Header Parameter defined in Section 4.1.4 of [JWS], except\n     *   that the key hint references the public key to which the JWE was\n     *   encrypted; this can be used to determine the private key needed to\n     *   decrypt the JWE.  This parameter allows originators to explicitly\n     *   signal a change of key to JWE recipients.\n     */\n    kid: {\n      type: 'string'\n    },\n\n    /**\n     * x5u\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.5\n     *\n     * 4.1.5.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   The \"x5u\" (X.509 URL) Header Parameter is a URI [RFC3986] that refers\n     *   to a resource for the X.509 public key certificate or certificate\n     *   chain [RFC5280] corresponding to the key used to digitally sign the\n     *   JWS.  The identified resource MUST provide a representation of the\n     *   certificate or certificate chain that conforms to RFC 5280 [RFC5280]\n     *   in PEM-encoded form, with each certificate delimited as specified in\n     *   Section 6.1 of RFC 4945 [RFC4945].  The certificate containing the\n     *   public key corresponding to the key used to digitally sign the JWS\n     *   MUST be the first certificate.  This MAY be followed by additional\n     *   certificates, with each subsequent certificate being the one used to\n     *   certify the previous one.  The protocol used to acquire the resource\n     *   MUST provide integrity protection; an HTTP GET request to retrieve\n     *   the certificate MUST use TLS [RFC2818] [RFC5246]; and the identity of\n     *   the server MUST be validated, as per Section 6 of RFC 6125 [RFC6125].\n     *   Also, see Section 8 on TLS requirements.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.7\n     *\n     * 4.1.7.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5u\" Header Parameter defined in Section 4.1.5 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5u: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * x5c\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.6\n     *\n     * 4.1.6.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   The \"x5c\" (X.509 certificate chain) Header Parameter contains the\n     *   X.509 public key certificate or certificate chain [RFC5280]\n     *   corresponding to the key used to digitally sign the JWS.  The\n     *   certificate or certificate chain is represented as a JSON array of\n     *   certificate value strings.  Each string in the array is a\n     *   base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER\n     *   [ITU.X690.2008] PKIX certificate value.  The certificate containing\n     *   the public key corresponding to the key used to digitally sign the\n     *   JWS MUST be the first certificate.  This MAY be followed by\n     *   additional certificates, with each subsequent certificate being the\n     *   one used to certify the previous one.  The recipient MUST validate\n     *   the certificate chain according to RFC 5280 [RFC5280] and consider\n     *   the certificate or certificate chain to be invalid if any validation\n     *   failure occurs.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.8\n     *\n     * 4.1.8.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5c\" Header Parameter defined in Section 4.1.6 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5c: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'base64'\n      }\n    },\n\n    /**\n     * x5t\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.7\n     *\n     * 4.1.7.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   The \"x5t\" (X.509 certificate SHA-1 thumbprint) Header Parameter is a\n     *   base64url-encoded SHA-1 thumbprint (a.k.a. digest) of the DER\n     *   encoding of the X.509 certificate [RFC5280] corresponding to the key\n     *   used to digitally sign the JWS.  Note that certificate thumbprints\n     *   are also sometimes known as certificate fingerprints.  Use of this\n     *   Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.9\n     *\n     * 4.1.9.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t\" Header Parameter defined in Section 4.1.7 of [JWS], except\n     *   that the certificate referenced by the thumbprint contains the public\n     *   key to which the JWE was encrypted; this can be used to determine the\n     *   private key needed to decrypt the JWE.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     */\n    x5t: {\n      type: 'string',\n      format: 'base64url'\n    },\n\n    /**\n     * x5t#S256\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.8\n     *\n     * 4.1.8.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *         Parameter\n     *\n     *   The \"x5t#S256\" (X.509 certificate SHA-256 thumbprint) Header\n     *   Parameter is a base64url-encoded SHA-256 thumbprint (a.k.a. digest)\n     *   of the DER encoding of the X.509 certificate [RFC5280] corresponding\n     *   to the key used to digitally sign the JWS.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.10\n     *\n     * 4.1.10.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *          Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t#S256\" Header Parameter defined in Section 4.1.8 of [JWS],\n     *   except that the certificate referenced by the thumbprint contains the\n     *   public key to which the JWE was encrypted; this can be used to\n     *   determine the private key needed to decrypt the JWE.  Note that\n     *   certificate thumbprints are also sometimes known as certificate\n     *   fingerprints.\n     */\n    //'x5t#S256': {\n    //  type: 'string',\n    //  format: 'base64url'\n    //},\n\n    /**\n     * crit\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.11\n     *\n     * 4.1.11.  \"crit\" (Critical) Header Parameter\n     *\n     *   The \"crit\" (critical) Header Parameter indicates that extensions to\n     *   this specification and/or [JWA] are being used that MUST be\n     *   understood and processed.  Its value is an array listing the Header\n     *   Parameter names present in the JOSE Header that use those extensions.\n     *   If any of the listed extension Header Parameters are not understood\n     *   and supported by the recipient, then the JWS is invalid.  Producers\n     *   MUST NOT include Header Parameter names defined by this specification\n     *   or [JWA] for use with JWS, duplicate names, or names that do not\n     *   occur as Header Parameter names within the JOSE Header in the \"crit\"\n     *   list.  Producers MUST NOT use the empty list \"[]\" as the \"crit\"\n     *   value.  Recipients MAY consider the JWS to be invalid if the critical\n     *   list contains any Header Parameter names defined by this\n     *   specification or [JWA] for use with JWS or if any other constraints\n     *   on its use are violated.  When used, this Header Parameter MUST be\n     *   integrity protected; therefore, it MUST occur only within the JWS\n     *   Protected Header.  Use of this Header Parameter is OPTIONAL.  This\n     *   Header Parameter MUST be understood and processed by implementations.\n     *\n     *   An example use, along with a hypothetical \"exp\" (expiration time)\n     *   field is:\n     *\n     *     {\"alg\":\"ES256\",\n     *     \"crit\":[\"exp\"],\n     *     \"exp\":1363284000\n     *     }\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.13\n     *\n     *   4.1.13.  \"crit\" (Critical) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"crit\" Header Parameter defined in Section 4.1.11 of [JWS],\n     *   except that Header Parameters for a JWE are being referred to, rather\n     *   than Header Parameters for a JWS.\n     */\n    crit: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      minItems: 1\n    },\n\n    /**\n     * enc\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.2\n     *\n     * 4.1.2.  \"enc\" (Encryption Algorithm) Header Parameter\n     *\n     *   The \"enc\" (encryption algorithm) Header Parameter identifies the\n     *   content encryption algorithm used to perform authenticated encryption\n     *   on the plaintext to produce the ciphertext and the Authentication\n     *   Tag.  This algorithm MUST be an AEAD algorithm with a specified key\n     *   length.  The encrypted content is not usable if the \"enc\" value does\n     *   not represent a supported algorithm.  \"enc\" values should either be\n     *   registered in the IANA \"JSON Web Signature and Encryption Algorithms\"\n     *   registry established by [JWA] or be a value that contains a\n     *   Collision-Resistant Name.  The \"enc\" value is a case-sensitive ASCII\n     *   string containing a StringOrURI value.  This Header Parameter MUST be\n     *   present and MUST be understood and processed by implementations.\n     *\n     *   A list of defined \"enc\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 5.1 of [JWA].\n     */\n    enc: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * zip\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.3\n     *\n     * 4.1.3.  \"zip\" (Compression Algorithm) Header Parameter\n     *\n     *   The \"zip\" (compression algorithm) applied to the plaintext before\n     *   encryption, if any.  The \"zip\" value defined by this specification\n     *   is:\n     *\n     *   o  \"DEF\" - Compression with the DEFLATE [RFC1951] algorithm\n     *\n     *   Other values MAY be used.  Compression algorithm values can be\n     *   registered in the IANA \"JSON Web Encryption Compression Algorithms\"\n     *   registry established by [JWA].  The \"zip\" value is a case-sensitive\n     *   string.  If no \"zip\" parameter is present, no compression is applied\n     *   to the plaintext before encryption.  When used, this Header Parameter\n     *   MUST be integrity protected; therefore, it MUST occur only within the\n     *   JWE Protected Header.  Use of this Header Parameter is OPTIONAL.\n     *   This Header Parameter MUST be understood and processed by\n     *   implementations.\n     */\n    zip: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JOSEHeaderSchema;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n */\nvar base64url = __webpack_require__(39);\nvar JWA = __webpack_require__(38);\n\nvar _require = __webpack_require__(55),\n    DataError = _require.DataError;\n\n/**\n * JWS\n */\n\n\nvar JWS = function () {\n  function JWS() {\n    _classCallCheck(this, JWS);\n  }\n\n  _createClass(JWS, null, [{\n    key: 'sign',\n\n\n    /**\n     * sign\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @param {Object} token\n     * @returns {Promise}\n     */\n    value: function sign(token) {\n      var payload = base64url(JSON.stringify(token.payload));\n\n      // compact serialization\n      if (token.serialization === 'compact') {\n        var key = token.key,\n            alg = token.header.alg;\n\n        var header = base64url(JSON.stringify(token.header));\n        var data = header + '.' + payload;\n\n        return JWA.sign(alg, key, data).then(function (signature) {\n          return data + '.' + signature;\n        });\n      }\n\n      // JSON serialization\n      if (token.serialization === 'json') {}\n\n      // Flattened serialization\n      if (token.serialization === 'flattened') {}\n\n      return Promise.reject(new DataError('Unsupported serialization'));\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(jwt) {\n      // multiple signatures\n      if (jwt.signatures) {\n        // ...\n      }\n\n      var key = jwt.key,\n          signature = jwt.signature,\n          alg = jwt.header.alg;\n\n      // one signature\n\n      if (jwt.signature) {\n        var _jwt$segments = _slicedToArray(jwt.segments, 2),\n            header = _jwt$segments[0],\n            payload = _jwt$segments[1];\n\n        var data = header + '.' + payload;\n\n        if (alg === 'none') {\n          return Promise.reject(new DataError('Signature provided to verify with alg: none'));\n        }\n\n        return JWA.verify(alg, key, signature, data).then(function (verified) {\n          jwt.verified = verified;\n          return verified;\n        });\n      }\n\n      if (alg === 'none') {\n        if (!key && !signature) {\n          jwt.verified = true;\n\n          return Promise.resolve(true);\n        }\n\n        if (key) {\n          return Promise.reject(new DataError('Key provided to verify signature with alg: none'));\n        }\n      }\n\n      // no signatures to verify\n      return Promise.reject(new DataError('Missing signature(s)'));\n    }\n  }]);\n\n  return JWS;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JWS;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Buffer) {/**\n * Dependencies\n */\nconst assert = __webpack_require__(21);\n\nconst base64url = __webpack_require__(39);\n\nconst crypto = __webpack_require__(49);\n\nconst {\n  JWT\n} = __webpack_require__(37);\n\nconst FormUrlEncoded = __webpack_require__(69);\n\nconst {\n  URL\n} = __webpack_require__(27);\n/**\n * Authentication Request\n */\n\n\nclass AuthenticationRequest {\n  /**\n   * create\n   *\n   * @description\n   * Create a new authentication request with generated state and nonce,\n   * validate presence of required parameters, serialize the request data and\n   * persist it to the session, and return a promise for an authentication\n   * request URI.\n   *\n   * @param {RelyingParty} rp  instance of RelyingParty\n   * @param {Object} options - optional request parameters\n   * @param {Object} session  reference to localStorage or other session object\n   *\n   * @returns {Promise}\n   */\n  static create(rp, options, session) {\n    const {\n      provider,\n      defaults,\n      registration\n    } = rp;\n    let issuer, endpoint, client, params;\n    return Promise.resolve().then(() => {\n      // validate presence of OP configuration, RP client registration,\n      // and default parameters\n      assert(provider.configuration, 'RelyingParty provider OpenID Configuration is missing');\n      assert(defaults.authenticate, 'RelyingParty default authentication parameters are missing');\n      assert(registration, 'RelyingParty client registration is missing'); // define basic elements of the request\n\n      issuer = provider.configuration.issuer;\n      endpoint = provider.configuration.authorization_endpoint;\n      client = {\n        client_id: registration.client_id\n      };\n      params = Object.assign(defaults.authenticate, client, options); // validate presence of required configuration and parameters\n\n      assert(issuer, 'Missing issuer in provider OpenID Configuration');\n      assert(endpoint, 'Missing authorization_endpoint in provider OpenID Configuration');\n      assert(params.scope, 'Missing scope parameter in authentication request');\n      assert(params.response_type, 'Missing response_type parameter in authentication request');\n      assert(params.client_id, 'Missing client_id parameter in authentication request');\n      assert(params.redirect_uri, 'Missing redirect_uri parameter in authentication request'); // generate state and nonce random octets\n\n      params.state = Array.from(crypto.getRandomValues(new Uint8Array(16)));\n      params.nonce = Array.from(crypto.getRandomValues(new Uint8Array(16))); // hash the state and nonce parameter values\n\n      return Promise.all([crypto.subtle.digest({\n        name: 'SHA-256'\n      }, new Uint8Array(params.state)), crypto.subtle.digest({\n        name: 'SHA-256'\n      }, new Uint8Array(params.nonce))]);\n    }) // serialize the request with original values, store in session by\n    // encoded state param, and replace state/nonce octets with encoded\n    // digests\n    .then(digests => {\n      let state = base64url(Buffer.from(digests[0]));\n      let nonce = base64url(Buffer.from(digests[1]));\n      let key = `${issuer}/requestHistory/${state}`; // store the request params for response validation\n      // with serialized octet values for state and nonce\n\n      session[key] = JSON.stringify(params); // replace state and nonce octets with base64url encoded digests\n\n      params.state = state;\n      params.nonce = nonce;\n    }).then(() => AuthenticationRequest.generateSessionKeys()).then(sessionKeys => {\n      AuthenticationRequest.storeSessionKeys(sessionKeys, params, session);\n    }) // optionally encode a JWT with the request parameters\n    // and replace params with `{ request: <jwt> }\n    .then(() => {\n      if (provider.configuration.request_parameter_supported) {\n        return AuthenticationRequest.encodeRequestParams(params).then(encodedParams => {\n          params = encodedParams;\n        });\n      }\n    }) // render the request URI and terminate the algorithm\n    .then(() => {\n      let url = new URL(endpoint);\n      url.search = FormUrlEncoded.encode(params);\n      return url.href;\n    });\n  }\n\n  static generateSessionKeys() {\n    return crypto.subtle.generateKey({\n      name: \"RSASSA-PKCS1-v1_5\",\n      modulusLength: 2048,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: {\n        name: \"SHA-256\"\n      }\n    }, true, [\"sign\", \"verify\"]).then(keyPair => {\n      // returns a keypair object\n      return Promise.all([crypto.subtle.exportKey('jwk', keyPair.publicKey), crypto.subtle.exportKey('jwk', keyPair.privateKey)]);\n    }).then(jwkPair => {\n      let [publicJwk, privateJwk] = jwkPair;\n      return {\n        public: publicJwk,\n        private: privateJwk\n      };\n    });\n  }\n\n  static storeSessionKeys(sessionKeys, params, session) {\n    // store the private one in session, public one goes into params\n    session['oidc.session.privateKey'] = JSON.stringify(sessionKeys.private);\n    params.key = sessionKeys.public;\n  }\n\n  static encodeRequestParams(params) {\n    const excludeParams = ['scope', 'client_id', 'response_type', 'state'];\n    const keysToEncode = Object.keys(params).filter(key => !excludeParams.includes(key));\n    let payload = {};\n    keysToEncode.forEach(key => {\n      payload[key] = params[key];\n    });\n    let requestParamJwt = new JWT({\n      header: {\n        alg: 'none'\n      },\n      payload\n    }, {\n      filter: false\n    });\n    return requestParamJwt.encode().then(requestParamCompact => {\n      let newParams = {\n        scope: params['scope'],\n        client_id: params['client_id'],\n        response_type: params['response_type'],\n        request: requestParamCompact,\n        state: params['state']\n      };\n      return newParams;\n    });\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = AuthenticationRequest;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports) {\n\n/**\n * Dependencies\n */\n\n/**\n * FormUrlEncoded\n */\nclass FormUrlEncoded {\n  /**\n   * Encode\n   *\n   * @description\n   * Represent an object as x-www-form-urlencoded string.\n   *\n   * @param {Object} data\n   * @returns {string}\n   */\n  static encode(data) {\n    let pairs = [];\n    Object.keys(data).forEach(function (key) {\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));\n    });\n    return pairs.join('&');\n  }\n  /**\n   * Decode\n   *\n   * @description\n   * Parse a x-www-form-urlencoded into an object.\n   *\n   * @param {string} data\n   * @returns {Object}\n   */\n\n\n  static decode(data) {\n    let obj = {};\n    data.split('&').forEach(function (property) {\n      let pair = property.split('=');\n      let key = decodeURIComponent(pair[0]);\n      let val = decodeURIComponent(pair[1]);\n      obj[key] = val;\n    });\n    return obj;\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = FormUrlEncoded;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, Buffer) {/**\n * Dependencies\n */\nconst {\n  URL\n} = __webpack_require__(27);\n\nconst assert = __webpack_require__(21);\n\nconst crypto = __webpack_require__(49);\n\nconst base64url = __webpack_require__(39);\n\nconst fetch = __webpack_require__(5);\n\nconst Headers = fetch.Headers ? fetch.Headers : global.Headers;\n\nconst FormUrlEncoded = __webpack_require__(69);\n\nconst IDToken = __webpack_require__(71);\n\nconst Session = __webpack_require__(73);\n\nconst onHttpError = __webpack_require__(74);\n\nconst HttpError = __webpack_require__(76);\n/**\n * AuthenticationResponse\n */\n\n\nclass AuthenticationResponse {\n  /**\n   * @param rp {RelyingParty}\n   * @param [redirect] {string} req.query\n   * @param [body] {string} req.body.text\n   * @param session {Session|Storage} req.session or localStorage or similar\n   * @param params {object} hashmap\n   * @param mode {string} 'query'/'fragment'/'form_post',\n   *   determined in `parseResponse()`\n   */\n  constructor({\n    rp,\n    redirect,\n    body,\n    session,\n    mode,\n    params = {}\n  }) {\n    this.rp = rp;\n    this.redirect = redirect;\n    this.body = body;\n    this.session = session;\n    this.mode = mode;\n    this.params = params;\n  }\n  /**\n   * validateResponse\n   *\n   * @description\n   * Authentication response validation.\n   *\n   * @param {string|Object} response\n   *\n   * @returns {Promise<Session>}\n   */\n\n\n  static validateResponse(response) {\n    return Promise.resolve(response).then(this.parseResponse).then(this.errorResponse).then(this.matchRequest).then(this.validateStateParam).then(this.validateResponseMode).then(this.validateResponseParams).then(this.exchangeAuthorizationCode).then(this.validateIDToken).then(Session.fromAuthResponse);\n  }\n  /**\n   * parseResponse\n   *\n   * @param {object} response\n   *\n   * @returns {object}\n   */\n\n\n  static parseResponse(response) {\n    let {\n      redirect,\n      body\n    } = response; // response must be either a redirect uri or request body, but not both\n\n    if (redirect && body || !redirect && !body) {\n      throw new HttpError(400, 'Invalid response mode');\n    } // parse redirect uri\n\n\n    if (redirect) {\n      let url = new URL(redirect);\n      let {\n        search,\n        hash\n      } = url;\n\n      if (search && hash || !search && !hash) {\n        throw new HttpError(400, 'Invalid response mode');\n      }\n\n      if (search) {\n        response.params = FormUrlEncoded.decode(search.substring(1));\n        response.mode = 'query';\n      }\n\n      if (hash) {\n        response.params = FormUrlEncoded.decode(hash.substring(1));\n        response.mode = 'fragment';\n      }\n    } // parse request form body\n\n\n    if (body) {\n      response.params = FormUrlEncoded.decode(body);\n      response.mode = 'form_post';\n    }\n\n    return response;\n  }\n  /**\n   * errorResponse\n   *\n   * @param {AuthenticationResponse} response\n   *\n   * @throws {Error} If response params include the OAuth2 'error' param,\n   *   throws an error based on it.\n   *\n   * @returns {AuthenticationResponse} Chainable\n   *\n   * @todo Figure out HTTP status code (typically 400, 401 or 403)\n   *   based on the OAuth2/OIDC `error` code, probably using an external library\n   */\n\n\n  static errorResponse(response) {\n    const errorCode = response.params.error;\n\n    if (errorCode) {\n      const errorParams = {};\n      errorParams['error'] = errorCode;\n      errorParams['error_description'] = response.params['error_description'];\n      errorParams['error_uri'] = response.params['error_uri'];\n      errorParams['state'] = response.params['state'];\n      const error = new Error(`AuthenticationResponse error: ${errorCode}`);\n      error.info = errorParams;\n      throw error;\n    }\n\n    return response;\n  }\n  /**\n   * matchRequest\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static matchRequest(response) {\n    let {\n      rp,\n      params,\n      session\n    } = response;\n    let state = params.state;\n    let issuer = rp.provider.configuration.issuer;\n\n    if (!state) {\n      throw new Error('Missing state parameter in authentication response');\n    }\n\n    let key = `${issuer}/requestHistory/${state}`;\n    let request = session[key];\n\n    if (!request) {\n      throw new Error('Mismatching state parameter in authentication response');\n    }\n\n    response.request = JSON.parse(request);\n    return response;\n  }\n  /**\n   * validateStateParam\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateStateParam(response) {\n    let octets = new Uint8Array(response.request.state);\n    let encoded = response.params.state;\n    return crypto.subtle.digest({\n      name: 'SHA-256'\n    }, octets).then(digest => {\n      if (encoded !== base64url(Buffer.from(digest))) {\n        throw new Error('Mismatching state parameter in authentication response');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * validateResponseMode\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateResponseMode(response) {\n    if (response.request.response_type !== 'code' && response.mode === 'query') {\n      throw new Error('Invalid response mode');\n    }\n\n    return response;\n  }\n  /**\n   * validateResponseParams\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateResponseParams(response) {\n    let {\n      request,\n      params\n    } = response;\n    let expectedParams = request.response_type.split(' ');\n\n    if (expectedParams.includes('code')) {\n      assert(params.code, 'Missing authorization code in authentication response'); // TODO assert novelty of code\n    }\n\n    if (expectedParams.includes('id_token')) {\n      assert(params.id_token, 'Missing id_token in authentication response');\n    }\n\n    if (expectedParams.includes('token')) {\n      assert(params.access_token, 'Missing access_token in authentication response');\n      assert(params.token_type, 'Missing token_type in authentication response');\n    }\n\n    return response;\n  }\n  /**\n   * exchangeAuthorizationCode\n   *\n   * @param {Object} response\n   * @returns {Promise} response object\n   */\n\n\n  static exchangeAuthorizationCode(response) {\n    let {\n      rp,\n      params,\n      request\n    } = response;\n    let code = params.code; // only exchange the authorization code when the response type is \"code\"\n\n    if (!code || request['response_type'] !== 'code') {\n      return Promise.resolve(response);\n    }\n\n    let {\n      provider,\n      registration\n    } = rp;\n    let id = registration['client_id'];\n    let secret = registration['client_secret']; // verify the client is not public\n\n    if (!secret) {\n      return Promise.reject(new Error('Client cannot exchange authorization code because ' + 'it is not a confidential client'));\n    } // initialize token request arguments\n\n\n    let endpoint = provider.configuration.token_endpoint;\n    let method = 'POST'; // initialize headers\n\n    let headers = new Headers({\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }); // initialize the token request parameters\n\n    let bodyContents = {\n      'grant_type': 'authorization_code',\n      'code': code,\n      'redirect_uri': request['redirect_uri'] // determine client authentication method\n\n    };\n    let authMethod = registration['token_endpoint_auth_method'] || 'client_secret_basic'; // client secret basic authentication\n\n    if (authMethod === 'client_secret_basic') {\n      let credentials = new Buffer(`${id}:${secret}`).toString('base64');\n      headers.set('Authorization', `Basic ${credentials}`);\n    } // client secret post authentication\n\n\n    if (authMethod === 'client_secret_post') {\n      bodyContents['client_id'] = id;\n      bodyContents['client_secret'] = secret;\n    }\n\n    let body = FormUrlEncoded.encode(bodyContents); // TODO\n    // client_secret_jwt authentication\n    // private_key_jwt\n    // make the token request\n\n    return fetch(endpoint, {\n      method,\n      headers,\n      body\n    }).then(onHttpError('Error exchanging authorization code')).then(tokenResponse => tokenResponse.json()).then(tokenResponse => {\n      assert(tokenResponse['access_token'], 'Missing access_token in token response');\n      assert(tokenResponse['token_type'], 'Missing token_type in token response');\n      assert(tokenResponse['id_token'], 'Missing id_token in token response'); // anything else?\n      // IS THIS THE RIGHT THING TO DO HERE?\n\n      response.params = Object.assign(response.params, tokenResponse);\n      return response;\n    });\n  }\n  /**\n   * validateIDToken\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateIDToken(response) {\n    // only validate the ID Token if present in the response\n    if (!response.params.id_token) {\n      return Promise.resolve(response);\n    }\n\n    return Promise.resolve(response).then(AuthenticationResponse.decryptIDToken).then(AuthenticationResponse.decodeIDToken).then(AuthenticationResponse.validateIssuer).then(AuthenticationResponse.validateAudience).then(AuthenticationResponse.resolveKeys).then(AuthenticationResponse.verifySignature).then(AuthenticationResponse.validateExpires).then(AuthenticationResponse.verifyNonce).then(AuthenticationResponse.validateAcr).then(AuthenticationResponse.validateAuthTime).then(AuthenticationResponse.validateAccessTokenHash).then(AuthenticationResponse.validateAuthorizationCodeHash);\n  }\n  /**\n   * decryptIDToken\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static decryptIDToken(response) {\n    // TODO\n    return Promise.resolve(response);\n  }\n  /**\n   * decodeIDToken\n   *\n   * Note: If the `id_token` is not present in params, this method does not\n   * get called (short-circuited in `validateIDToken()`).\n   *\n   * @param response {AuthenticationResponse}\n   * @param response.params {object}\n   * @param [response.params.id_token] {string} IDToken encoded as a JWT\n   *\n   * @returns {AuthenticationResponse} Chainable\n   */\n\n\n  static decodeIDToken(response) {\n    let jwt = response.params.id_token;\n\n    try {\n      response.decoded = IDToken.decode(jwt);\n    } catch (decodeError) {\n      const error = new HttpError(400, 'Error decoding ID Token');\n      error.cause = decodeError;\n      error.info = {\n        id_token: jwt\n      };\n      throw error;\n    }\n\n    return response;\n  }\n  /**\n   * validateIssuer\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateIssuer(response) {\n    let configuration = response.rp.provider.configuration;\n    let payload = response.decoded.payload; // validate issuer of token matches this relying party's provider\n\n    if (payload.iss !== configuration.issuer) {\n      throw new Error('Mismatching issuer in ID Token');\n    }\n\n    return response;\n  }\n  /**\n   * validateAudience\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAudience(response) {\n    let registration = response.rp.registration;\n    let {\n      aud,\n      azp\n    } = response.decoded.payload; // validate audience includes this relying party\n\n    if (typeof aud === 'string' && aud !== registration['client_id']) {\n      throw new Error('Mismatching audience in id_token');\n    } // validate audience includes this relying party\n\n\n    if (Array.isArray(aud) && !aud.includes(registration['client_id'])) {\n      throw new Error('Mismatching audience in id_token');\n    } // validate authorized party is present if required\n\n\n    if (Array.isArray(aud) && !azp) {\n      throw new Error('Missing azp claim in id_token');\n    } // validate authorized party is this relying party\n\n\n    if (azp && azp !== registration['client_id']) {\n      throw new Error('Mismatching azp claim in id_token');\n    }\n\n    return response;\n  }\n  /**\n   * resolveKeys\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static resolveKeys(response) {\n    let rp = response.rp;\n    let provider = rp.provider;\n    let decoded = response.decoded;\n    return Promise.resolve(provider.jwks).then(jwks => jwks ? jwks : rp.jwks()).then(jwks => {\n      if (decoded.resolveKeys(jwks)) {\n        return Promise.resolve(response);\n      } else {\n        throw new Error('Cannot resolve signing key for ID Token');\n      }\n    });\n  }\n  /**\n   * verifySignature\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static verifySignature(response) {\n    let alg = response.decoded.header.alg;\n    let registration = response.rp.registration;\n    let expectedAlgorithm = registration['id_token_signed_response_alg'] || 'RS256'; // validate signing algorithm matches expectation\n\n    if (alg !== expectedAlgorithm) {\n      throw new Error(`Expected ID Token to be signed with ${expectedAlgorithm}`);\n    }\n\n    return response.decoded.verify().then(verified => {\n      if (!verified) {\n        throw new Error('Invalid ID Token signature');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * validateExpires\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateExpires(response) {\n    let exp = response.decoded.payload.exp; // validate expiration of token\n\n    if (exp <= Math.floor(Date.now() / 1000)) {\n      throw new Error('Expired ID Token');\n    }\n\n    return response;\n  }\n  /**\n   * verifyNonce\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static verifyNonce(response) {\n    let octets = new Uint8Array(response.request.nonce);\n    let nonce = response.decoded.payload.nonce;\n\n    if (!nonce) {\n      throw new Error('Missing nonce in ID Token');\n    }\n\n    return crypto.subtle.digest({\n      name: 'SHA-256'\n    }, octets).then(digest => {\n      if (nonce !== base64url(Buffer.from(digest))) {\n        throw new Error('Mismatching nonce in ID Token');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * validateAcr\n   *\n   * @param {Object} response\n   * @returns {Object}\n   */\n\n\n  static validateAcr(response) {\n    // TODO\n    return response;\n  }\n  /**\n   * validateAuthTime\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAuthTime(response) {\n    // TODO\n    return response;\n  }\n  /**\n   * validateAccessTokenHash\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAccessTokenHash(response) {\n    // TODO\n    return response;\n  }\n  /**\n   * validateAuthorizationCodeHash\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAuthorizationCodeHash(response) {\n    // TODO\n    return response;\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = AuthenticationResponse;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20), __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Local dependencies\n */\nconst {\n  JWT\n} = __webpack_require__(37);\n\nconst IDTokenSchema = __webpack_require__(72);\n/**\n * IDToken\n */\n\n\nclass IDToken extends JWT {\n  /**\n   * Schema\n   */\n  static get schema() {\n    return IDTokenSchema;\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = IDToken;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Local dependencies\n */\nconst {\n  JWTSchema\n} = __webpack_require__(37);\n/**\n * IDToken Schema\n */\n\n\nconst IDTokenSchema = JWTSchema.extend({\n  properties: {\n    /**\n     * header\n     * http://openid.net/specs/openid-connect-core-1_0.html#IDToken\n     * ID Tokens SHOULD NOT use the JWS or JWE x5u, x5c, jku, or jwk Header\n     * Parameter fields. Instead, references to keys used are communicated in\n     * advance using Discovery and Registration parameters, per Section 10.\n     */\n    header: {//not: { required: ['x5u', 'x5c', 'jku', 'jwk'] }\n    },\n\n    /**\n     * payload\n     */\n    payload: {\n      properties: {\n        /**\n         * iss\n         *\n         * REQUIRED. Issuer Identifier for the Issuer of the response.\n         * The iss value is a case sensitive URL using the https scheme\n         * that contains scheme, host, and optionally, port number and\n         * path components and no query or fragment components.\n         */\n        iss: {\n          type: 'string',\n          format: 'url'\n        },\n\n        /**\n         * sub\n         *\n         * REQUIRED. Subject Identifier. A locally unique and never\n         * reassigned identifier within the Issuer for the End-User, which\n         * is intended to be consumed by the Client, e.g., 24400320 or\n         * AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed 255\n         * ASCII characters in length. The sub value is a case sensitive\n         * string.\n         */\n        sub: {\n          type: 'string',\n          maxLength: 255\n        },\n\n        /**\n         * aud\n         *\n         * REQUIRED. Audience(s) that this ID Token is intended for. It\n         * MUST contain the OAuth 2.0 client_id of the Relying Party as an\n         * audience value. It MAY also contain identifiers for other audiences.\n         * In the general case, the aud value is an array of case sensitive\n         * strings. In the common special case when there is one audience,\n         * the aud value MAY be a single case sensitive string.\n         */\n        // inherited from JWTClaimsSetSchema\n\n        /**\n         * exp\n         *\n         * REQUIRED. Expiration time on or after which the ID Token MUST NOT\n         * be accepted for processing. The processing of this parameter\n         * requires that the current date/time MUST be before the expiration\n         * date/time listed in the value. Implementers MAY provide for some\n         * small leeway, usually no more than a few minutes, to account for\n         * clock skew. Its value is a JSON number representing the number of\n         * seconds from 1970-01-01T0:0:0Z as measured in UTC until the\n         * date/time. See RFC 3339 [RFC3339] for details regarding date/times\n         * in general and UTC in particular.\n         */\n        // inherited from JWTClaimsSetSchema\n\n        /**\n         * iat\n         *\n         * REQUIRED. Time at which the JWT was issued. Its value is a\n         * JSON number representing the number of seconds from\n         * 1970-01-01T0:0:0Z as measured in UTC until the date/time.\n         */\n        // inherited from JWTClaimsSetSchema\n\n        /**\n         * auth_time\n         *\n         * Time when the End-User authentication occurred. Its value is a\n         * JSON number representing the number of seconds from\n         * 1970-01-01T0:0:0Z as measured in UTC until the date/time. When a\n         * max_age request is made or when auth_time is requested as an\n         * Essential Claim, then this Claim is REQUIRED; otherwise, its\n         * inclusion is OPTIONAL. (The auth_time Claim semantically\n         * corresponds to the OpenID 2.0 PAPE [OpenID.PAPE] auth_time\n         * response parameter.)\n         */\n        auth_time: {\n          type: 'integer',\n          format: 'NumericDate'\n        },\n\n        /**\n         * nonce\n         *\n         * String value used to associate a Client session with an ID Token,\n         * and to mitigate replay attacks. The value is passed through\n         * unmodified from the Authentication Request to the ID Token. If\n         * present in the ID Token, Clients MUST verify that the nonce Claim\n         * Value is equal to the value of the nonce parameter sent in the\n         * Authentication Request. If present in the Authentication Request,\n         * Authorization Servers MUST include a nonce Claim in the ID Token\n         * with the Claim Value being the nonce value sent in the\n         * Authentication Request. Authorization Servers SHOULD perform no\n         * other processing on nonce values used. The nonce value is a case\n         * sensitive string.\n         */\n        nonce: {\n          type: 'string'\n        },\n\n        /**\n         * acr\n         *\n         * OPTIONAL. Authentication Context Class Reference. String\n         * specifying an Authentication Context Class Reference value that\n         * identifies the Authentication Context Class that the authentication\n         * performed satisfied. The value \"0\" indicates the End-User\n         * authentication did not meet the requirements of ISO/IEC 29115\n         * [ISO29115] level 1. Authentication using a long-lived browser\n         * cookie, for instance, is one example where the use of \"level 0\" is\n         * appropriate. Authentications with level 0 SHOULD NOT be used to\n         * authorize access to any resource of any monetary value. (This\n         * corresponds to the OpenID 2.0 PAPE [OpenID.PAPE] nist_auth_level\n         * 0.) An absolute URI or an RFC 6711 [RFC6711] registered name\n         * SHOULD be used as the acr value; registered names MUST NOT be used\n         * with a different meaning than that which is registered. Parties\n         * using this claim will need to agree upon the meanings of the\n         * values used, which may be context-specific. The acr value is a\n         * case sensitive string.\n         */\n        acr: {\n          type: 'string'\n        },\n\n        /**\n         * amr\n         * OPTIONAL. Authentication Methods References. JSON array of strings\n         * that are identifiers for authentication methods used in the\n         * authentication. For instance, values might indicate that both\n         * password and OTP authentication methods were used. The definition\n         * of particular values to be used in the amr Claim is beyond the\n         * scope of this specification. Parties using this claim will need to\n         * agree upon the meanings of the values used, which may be context-\n         * specific. The amr value is an array of case sensitive strings.\n         */\n        amr: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n\n        /**\n         * azp\n         * OPTIONAL. Authorized party - the party to which the ID Token was\n         * issued. If present, it MUST contain the OAuth 2.0 Client ID of this\n         * party. This Claim is only needed when the ID Token has a single\n         * audience value and that audience is different than the authorized\n         * party. It MAY be included even when the authorized party is the\n         * same as the sole audience. The azp value is a case sensitive string\n         * containing a StringOrURI value.\n         */\n        azp: {\n          type: 'string',\n          format: 'StringOrURI'\n        }\n      },\n\n      /**\n       * Required Claims\n       */\n      required: ['iss', 'sub', 'aud', 'exp', 'iat']\n    }\n  }\n});\n/**\n * Export\n */\n\nmodule.exports = IDTokenSchema;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nconst fetch = __webpack_require__(5);\n\nconst onHttpError = __webpack_require__(74);\n\nconst PoPToken = __webpack_require__(75);\n\nclass Session {\n  /**\n   * @param options {Object}\n   *\n   * @param options.credentialType {string} 'access_token' or 'pop_token'\n   *\n   * @param options.issuer {string} Identity provider (issuer of ID/Access Token)\n   *\n   * @param options.authorization {object}\n   * @param options.authorization.client_id {string} OIDC/OAuth2 client id\n   * @param [options.authorization.id_token] {string} Compact-serialized id_token param\n   * @param [options.authorization.access_token] {string} Compact-serialized access_token param\n   * @param [options.authorization.refresh_token] {string} Compact-serialized refresh_token\n   *\n   * @param [options.sessionKey] {string} Serialized client session key generated\n   *   during the Authentication Request, used to issue PoPTokens\n   *\n   * @param [options.idClaims] {object} Decoded/verified ID Token JWT payload\n   *\n   * @param [options.accessClaims] {object} Decoded/verified Access Token JWT payload\n   */\n  constructor(options) {\n    this.credentialType = options.credentialType || 'access_token';\n    this.issuer = options.issuer;\n    this.authorization = options.authorization || {};\n    this.sessionKey = options.sessionKey;\n    this.idClaims = options.idClaims;\n    this.accessClaims = options.accessClaims;\n  }\n\n  static from(options) {\n    return new Session(options);\n  }\n  /**\n   * @param response {AuthenticationResponse}\n   *\n   * @returns {Session} RelyingParty Session object\n   */\n\n\n  static fromAuthResponse(response) {\n    const RelyingParty = __webpack_require__(19); // import here due to circular dep\n\n\n    let idClaims = response.decoded && response.decoded.payload || {};\n    let {\n      rp\n    } = response;\n    let registration = rp.registration;\n    let rpAuthOptions = rp.defaults.authenticate || {};\n    let credentialType = rpAuthOptions['credential_type'] || rp.defaults.popToken ? 'pop_token' : 'access_token';\n    let sessionKey = response.session[RelyingParty.SESSION_PRIVATE_KEY];\n    let options = {\n      credentialType,\n      sessionKey,\n      issuer: idClaims.iss,\n      idClaims,\n      authorization: {\n        client_id: registration['client_id'],\n        access_token: response.params['access_token'],\n        id_token: response.params['id_token'],\n        refresh_token: response.params['refresh_token']\n      }\n    };\n    return Session.from(options);\n  }\n  /**\n   * Authenticated fetch() getter\n   *\n   * @returns {function}\n   */\n\n\n  get fetch() {\n    /**\n     * fetch() function signature\n     *\n     * @param url {RequestInfo|string}\n     * @param options {object}\n     *\n     * @returns {Function<Promise<Response>>}\n     */\n    return (url, options) => {\n      return Promise.resolve().then(() => {\n        if (this.hasCredentials()) {\n          return this.fetchWithCredentials(url, options);\n        } else {\n          return fetch(url, options);\n        }\n      }).then(onHttpError('Error while fetching resource'));\n    };\n  }\n  /**\n   * bearerTokenFor\n   *\n   * @param url {string}\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  bearerTokenFor(url) {\n    switch (this.credentialType) {\n      case 'pop_token':\n        return PoPToken.issueFor(url, this);\n\n      default:\n        // 'access_token' etc\n        return Promise.resolve(this.authorization[this.credentialType]);\n    }\n  }\n  /**\n   * hasCredentials\n   *\n   * @returns {boolean}\n   */\n\n\n  hasCredentials() {\n    switch (this.credentialType) {\n      case 'pop_token':\n        return !!this.authorization['id_token'];\n\n      default:\n        // 'access_token' etc\n        return !!this.authorization[this.credentialType];\n    }\n  }\n  /**\n   * fetchWithCredentials\n   *\n   * @param url {RequestInfo|string}\n   * @param options {object}\n   *\n   * @returns {Promise<Response>}\n   */\n\n\n  fetchWithCredentials(url, options = {}) {\n    options.headers = options.headers || {};\n    return this.bearerTokenFor(url).then(token => {\n      options.headers.authorization = `Bearer ${token}`;\n      return fetch(url, options);\n    });\n  }\n\n}\n\nmodule.exports = Session;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Throws an error when a fetch response status code indicates a 400 or 500\n * HTTP error. (The whatwg fetch api does not normally reject on http error\n * responses).\n *\n * Usage:\n *\n * ```\n * return fetch(url)\n *   .then(onHttpError('Error while fetching resource')\n *   .catch(err => console.log(err))\n *\n * // -> 'Error while fetching resource: 404 Not Found' error\n * // if a 404 response is encountered\n * ```\n *\n * @param [message] {string} Optional error message to clarify context\n *\n * @throws {Error} For http status codes > 300\n *\n * @return {Object} fetch response object (passed through if no error)\n */\n\nfunction onHttpError(message = 'fetch error') {\n  return response => {\n    if (response.status >= 200 && response.status < 300) {\n      return response;\n    }\n\n    let errorMessage = `${message}: ${response.status} ${response.statusText}`;\n    let error = new Error(errorMessage);\n    error.response = response;\n    error.statusCode = response.status;\n    throw error;\n  };\n}\n\nmodule.exports = onHttpError;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nconst {\n  URL\n} = __webpack_require__(27);\n\nconst {\n  JWT,\n  JWK\n} = __webpack_require__(37);\n\nconst DEFAULT_MAX_AGE = 3600; // Default token expiration, in seconds\n\nclass PoPToken extends JWT {\n  /**\n   * @param resourceServerUri {string} RS URI for which this token is intended\n   *\n   * @param session {Session}\n   * @param session.sessionKey {string}\n   * @param session.authorization.client_id {string}\n   * @param session.authorization.id_token {string}\n   *\n   * @returns {Promise<string>} PoPToken, encoded as compact JWT\n   */\n  static issueFor(resourceServerUri, session) {\n    if (!resourceServerUri) {\n      throw new Error('Cannot issue PoPToken - missing resource server URI');\n    }\n\n    if (!session.sessionKey) {\n      throw new Error('Cannot issue PoPToken - missing session key');\n    }\n\n    if (!session.authorization.id_token) {\n      throw new Error('Cannot issue PoPToken - missing id token');\n    }\n\n    let jwk = JSON.parse(session.sessionKey);\n    return JWK.importKey(jwk).then(importedSessionJwk => {\n      let options = {\n        aud: new URL(resourceServerUri).origin,\n        key: importedSessionJwk,\n        iss: session.authorization.client_id,\n        id_token: session.authorization.id_token\n      };\n      return PoPToken.issue(options);\n    }).then(jwt => {\n      return jwt.encode();\n    });\n  }\n  /**\n   * issue\n   *\n   * @param options {Object}\n   * @param options.iss {string} Token issuer (RP client_id)\n   * @param options.aud {string|Array<string>} Audience for the token\n   *   (such as the Resource Server url)\n   * @param options.key {JWK} Proof of Possession (private) signing key, see\n   *   https://tools.ietf.org/html/rfc7800#section-3.1\n   *\n   * @param options.id_token {string} JWT compact encoded ID Token\n   *\n   * Optional:\n   * @param [options.iat] {number} Issued at timestamp (in seconds)\n   * @param [options.max] {number} Max token lifetime in seconds\n   *\n   * @returns {PoPToken} Proof of Possession Token (JWT instance)\n   */\n\n\n  static issue(options) {\n    let {\n      aud,\n      iss,\n      key\n    } = options;\n    let alg = key.alg;\n    let iat = options.iat || Math.floor(Date.now() / 1000);\n    let max = options.max || DEFAULT_MAX_AGE;\n    let exp = iat + max; // token expiration\n\n    let header = {\n      alg\n    };\n    let payload = {\n      iss,\n      aud,\n      exp,\n      iat,\n      id_token: options.id_token,\n      token_type: 'pop'\n    };\n    let jwt = new PoPToken({\n      header,\n      payload,\n      key: key.cryptoKey\n    }, {\n      filter: false\n    });\n    return jwt;\n  }\n\n}\n\nmodule.exports = PoPToken;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = HttpError\nvar StandardError = __webpack_require__(77)\nvar STATUS_CODE_TO_NAME = __webpack_require__(78)\nvar STATUS_NAME_TO_CODE = exports\n\nfunction HttpError(code, msg, props) {\n  if (typeof code == \"string\") code = STATUS_NAME_TO_CODE[code]\n  if (typeof code != \"number\") throw new TypeError(\"Non-numeric HTTP code\")\n  if (typeof msg == \"object\" && msg != null) { props = msg; msg = null }\n  StandardError.call(this, msg || STATUS_CODE_TO_NAME[code], props)\n  this.code = code\n}\n\nHttpError.prototype = Object.create(StandardError.prototype, {\n  constructor: {value: HttpError, configurable: true, writable: true}\n})\n\n// Set name explicitly for when the code gets minified.\nHttpError.prototype.name = \"HttpError\"\n\nObject.defineProperties(HttpError.prototype, {\n  statusCode: alias(\"code\"),\n  statusMessage: alias(\"message\"),\n\n  status: {\n    configurable: true,\n    get: function() { return this.code },\n    set: function(value) {\n      Object.defineProperty(this, \"status\", {\n        value: value, configurable: true, enumerable: true, writable: true\n      })\n    }\n  }\n})\n\nHttpError.prototype.toString = function() {\n  return this.name + \": \" + this.code + \" \" + this.message\n}\n\nfor (var code in STATUS_CODE_TO_NAME) {\n  var name = STATUS_CODE_TO_NAME[code]\n  exports[name.replace(\"'\", \"\").replace(/[- ]/g, \"_\").toUpperCase()] = +code\n}\n\nfunction alias(name) {\n  return {\n    configurable: true,\n    get: function() { return this[name] },\n    set: function(value) { return this[name] = value }\n  }\n}\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports) {\n\nvar has = Object.hasOwnProperty\nvar proto = Object.getPrototypeOf\nvar trace = Error.captureStackTrace\nmodule.exports = StandardError\n\nfunction StandardError(msg, props) {\n  // Let all properties be enumerable for easier serialization.\n  if (msg && typeof msg == \"object\") props = msg, msg = undefined\n  else this.message = msg\n\n  // Name has to be an own property (or on the prototype a single step up) for\n  // the stack to be printed with the correct name.\n  if (props) for (var key in props) this[key] = props[key]\n  if (!has.call(this, \"name\"))\n    this.name = has.call(proto(this), \"name\")? this.name : this.constructor.name\n\n  if (trace && !(\"stack\" in this)) trace(this, this.constructor)\n}\n\nStandardError.prototype = Object.create(Error.prototype, {\n  constructor: {value: StandardError, configurable: true, writable: true}\n})\n\n// Set name explicitly for when the code gets minified.\nStandardError.prototype.name = \"StandardError\"\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"100\\\":\\\"Continue\\\",\\\"101\\\":\\\"Switching Protocols\\\",\\\"102\\\":\\\"Processing\\\",\\\"200\\\":\\\"OK\\\",\\\"201\\\":\\\"Created\\\",\\\"202\\\":\\\"Accepted\\\",\\\"203\\\":\\\"Non-Authoritative Information\\\",\\\"204\\\":\\\"No Content\\\",\\\"205\\\":\\\"Reset Content\\\",\\\"206\\\":\\\"Partial Content\\\",\\\"207\\\":\\\"Multi-Status\\\",\\\"208\\\":\\\"Already Reported\\\",\\\"226\\\":\\\"IM Used\\\",\\\"300\\\":\\\"Multiple Choices\\\",\\\"301\\\":\\\"Moved Permanently\\\",\\\"302\\\":\\\"Found\\\",\\\"303\\\":\\\"See Other\\\",\\\"304\\\":\\\"Not Modified\\\",\\\"305\\\":\\\"Use Proxy\\\",\\\"307\\\":\\\"Temporary Redirect\\\",\\\"308\\\":\\\"Permanent Redirect\\\",\\\"400\\\":\\\"Bad Request\\\",\\\"401\\\":\\\"Unauthorized\\\",\\\"402\\\":\\\"Payment Required\\\",\\\"403\\\":\\\"Forbidden\\\",\\\"404\\\":\\\"Not Found\\\",\\\"405\\\":\\\"Method Not Allowed\\\",\\\"406\\\":\\\"Not Acceptable\\\",\\\"407\\\":\\\"Proxy Authentication Required\\\",\\\"408\\\":\\\"Request Timeout\\\",\\\"409\\\":\\\"Conflict\\\",\\\"410\\\":\\\"Gone\\\",\\\"411\\\":\\\"Length Required\\\",\\\"412\\\":\\\"Precondition Failed\\\",\\\"413\\\":\\\"Payload Too Large\\\",\\\"414\\\":\\\"URI Too Long\\\",\\\"415\\\":\\\"Unsupported Media Type\\\",\\\"416\\\":\\\"Range Not Satisfiable\\\",\\\"417\\\":\\\"Expectation Failed\\\",\\\"418\\\":\\\"I'm a teapot\\\",\\\"421\\\":\\\"Misdirected Request\\\",\\\"422\\\":\\\"Unprocessable Entity\\\",\\\"423\\\":\\\"Locked\\\",\\\"424\\\":\\\"Failed Dependency\\\",\\\"425\\\":\\\"Unordered Collection\\\",\\\"426\\\":\\\"Upgrade Required\\\",\\\"428\\\":\\\"Precondition Required\\\",\\\"429\\\":\\\"Too Many Requests\\\",\\\"431\\\":\\\"Request Header Fields Too Large\\\",\\\"500\\\":\\\"Internal Server Error\\\",\\\"501\\\":\\\"Not Implemented\\\",\\\"502\\\":\\\"Bad Gateway\\\",\\\"503\\\":\\\"Service Unavailable\\\",\\\"504\\\":\\\"Gateway Timeout\\\",\\\"505\\\":\\\"HTTP Version Not Supported\\\",\\\"506\\\":\\\"Variant Also Negotiates\\\",\\\"507\\\":\\\"Insufficient Storage\\\",\\\"508\\\":\\\"Loop Detected\\\",\\\"509\\\":\\\"Bandwidth Limit Exceeded\\\",\\\"510\\\":\\\"Not Extended\\\",\\\"511\\\":\\\"Network Authentication Required\\\"}\");\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Dependencies\n */\nconst {\n  JSONSchema\n} = __webpack_require__(28);\n/**\n * RelyingParty Schema\n *\n * This schema initializes and verifies Relying Party client configuration.\n * RelyingParty objects can be persisted and rehydrated. By encapsulating this data in\n * it's own class, it's possible to have multiple RP configurations running\n * simultaneously.\n */\n\n\nconst RelyingPartySchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    /**\n     * provider\n     *\n     * Information about the provider, including issuer URL, human readable name,\n     * and any configuration or provider metadata retrieved from the OP.\n     */\n    provider: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string'\n        },\n        url: {\n          type: 'string',\n          format: 'uri'\n        },\n        // NOTE:\n        // OpenID Configuration (discovery response) and JSON Web Keys Set for an\n        // issuer can be cached here. However the cache should not be persisted or\n        // relied upon.\n        //\n        configuration: {},\n        // .well-known/openid-configuration\n        jwks: {} // /jwks\n\n      },\n      required: ['url']\n    },\n\n    /**\n     * defaults\n     *\n     * Default request parameters for authentication and dynamic registration requests.\n     * These values can be extended or overridden via arguments to the respective\n     * request methods.\n     *\n     * These are part of the relying party client configuration and can be serialized\n     * and persisted.\n     */\n    defaults: {\n      type: 'object',\n      properties: {\n        /**\n         * Use Proof of Possession token semantics for the ID Token\n         */\n        popToken: {\n          type: 'boolean',\n          default: false\n        },\n\n        /**\n         * Default authentication request parameters\n         */\n        authenticate: {\n          type: 'object',\n          properties: {\n            redirect_uri: {\n              type: 'string',\n              format: 'uri'\n            },\n            response_type: {\n              type: 'string',\n              default: 'id_token token',\n              // browser detection\n              enum: ['code', 'token', 'id_token token', 'id_token token code']\n            },\n            display: {\n              type: 'string',\n              default: 'page',\n              enum: ['page', 'popup']\n            },\n            scope: {\n              type: ['string', 'array'],\n              default: ['openid']\n            }\n          }\n        },\n\n        /**\n         * Default client registration parameters\n         */\n        register: {}\n      }\n    },\n\n    /**\n     * registration\n     *\n     * This is the client registration response from dynamic registration. It should\n     * always reflect the client configuration on the openid provider. A client access\n     * token is stored here\n     */\n    registration: {},\n    // ClientMetadataSchema\n\n    /**\n     * store\n     */\n    store: {\n      type: 'object',\n      default: {}\n    }\n  }\n});\n/**\n * Export\n */\n\nmodule.exports = RelyingPartySchema;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar _require = __webpack_require__(27),\n    URL = _require.URL;\n\nvar _require2 = __webpack_require__(37),\n    JWT = _require2.JWT,\n    JWK = _require2.JWK;\n\nvar DEFAULT_MAX_AGE = 3600; // Default token expiration, in seconds\n\nvar PoPToken = function (_JWT) {\n  _inherits(PoPToken, _JWT);\n\n  function PoPToken() {\n    _classCallCheck(this, PoPToken);\n\n    return _possibleConstructorReturn(this, (PoPToken.__proto__ || Object.getPrototypeOf(PoPToken)).apply(this, arguments));\n  }\n\n  _createClass(PoPToken, null, [{\n    key: 'issueFor',\n\n    /**\n     * @param resourceServerUri {string} RS URI for which this token is intended\n     *\n     * @param session {Session}\n     * @param session.sessionKey {string}\n     * @param session.authorization.client_id {string}\n     * @param session.authorization.id_token {string}\n     *\n     * @returns {Promise<string>} PoPToken, encoded as compact JWT\n     */\n    value: function issueFor(resourceServerUri, session) {\n      if (!resourceServerUri) {\n        throw new Error('Cannot issue PoPToken - missing resource server URI');\n      }\n\n      if (!session.sessionKey) {\n        throw new Error('Cannot issue PoPToken - missing session key');\n      }\n\n      if (!session.authorization.id_token) {\n        throw new Error('Cannot issue PoPToken - missing id token');\n      }\n\n      var jwk = JSON.parse(session.sessionKey);\n      return JWK.importKey(jwk).then(function (importedSessionJwk) {\n        var options = {\n          aud: new URL(resourceServerUri).origin,\n          key: importedSessionJwk,\n          iss: session.authorization.client_id,\n          id_token: session.authorization.id_token\n        };\n        return PoPToken.issue(options);\n      }).then(function (jwt) {\n        return jwt.encode();\n      });\n    }\n    /**\n     * issue\n     *\n     * @param options {Object}\n     * @param options.iss {string} Token issuer (RP client_id)\n     * @param options.aud {string|Array<string>} Audience for the token\n     *   (such as the Resource Server url)\n     * @param options.key {JWK} Proof of Possession (private) signing key, see\n     *   https://tools.ietf.org/html/rfc7800#section-3.1\n     *\n     * @param options.id_token {string} JWT compact encoded ID Token\n     *\n     * Optional:\n     * @param [options.iat] {number} Issued at timestamp (in seconds)\n     * @param [options.max] {number} Max token lifetime in seconds\n     *\n     * @returns {PoPToken} Proof of Possession Token (JWT instance)\n     */\n\n  }, {\n    key: 'issue',\n    value: function issue(options) {\n      var aud = options.aud,\n          iss = options.iss,\n          key = options.key;\n      var alg = key.alg;\n      var iat = options.iat || Math.floor(Date.now() / 1000);\n      var max = options.max || DEFAULT_MAX_AGE;\n      var exp = iat + max; // token expiration\n\n      var header = {\n        alg: alg\n      };\n      var payload = {\n        iss: iss,\n        aud: aud,\n        exp: exp,\n        iat: iat,\n        id_token: options.id_token,\n        token_type: 'pop'\n      };\n      var jwt = new PoPToken({\n        header: header,\n        payload: payload,\n        key: key.cryptoKey\n      }, {\n        filter: false\n      });\n      return jwt;\n    }\n  }]);\n\n  return PoPToken;\n}(JWT);\n\nmodule.exports = PoPToken;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"openIdpPopup\", function() { return openIdpPopup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"obtainSession\", function() { return obtainSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"popupHandler\", function() { return popupHandler; });\n/* harmony import */ var _ipc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n\n\nfunction openIdpPopup(popupUri) {\n  const width = 650;\n  const height = 400;\n  const left = window.screenX + (window.innerWidth - width) / 2;\n  const top = window.screenY + (window.innerHeight - height) / 2;\n  const settings = \"width=\".concat(width, \",height=\").concat(height, \",left=\").concat(left, \",top=\").concat(top);\n  return window.open(popupUri, 'solid-auth-client', settings);\n}\nfunction obtainSession(store, popup, options) {\n  return new Promise((resolve, reject) => {\n    const popupServer = new _ipc__WEBPACK_IMPORTED_MODULE_0__[\"Server\"](popup, Object(_url_util__WEBPACK_IMPORTED_MODULE_1__[\"originOf\"])(options.popupUri || ''), popupHandler(store, options, session => {\n      popupServer.stop();\n      resolve(session);\n    }));\n    popupServer.start();\n  });\n}\nfunction popupHandler(store, _ref, foundSessionCb) {\n  let {\n    popupUri,\n    callbackUri\n  } = _ref;\n  return async function (method) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    switch (method) {\n      // Origin\n      case 'getAppOrigin':\n        return window.location.origin;\n      // Storage\n\n      case 'storage/getItem':\n        return store.getItem(...args);\n\n      case 'storage/setItem':\n        return store.setItem(...args);\n\n      case 'storage/removeItem':\n        return store.removeItem(...args);\n      // Login\n\n      case 'getLoginOptions':\n        return {\n          popupUri,\n          callbackUri\n        };\n\n      case 'foundSession':\n        foundSessionCb(...args);\n    }\n  };\n}\n\n/***/ })\n/******/ ])[\"default\"];\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29saWQtYXV0aC1jbGllbnQvYnJvd3Nlci9pbmRleC5qcz8wMGU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7QUFDckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRyx3QkFBd0IsRUFBRTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsMENBQTBDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxnRUFBZ0UsRUFBRSxFQUFFLGdDQUFnQyxFQUFFLGFBQWE7O0FBRW5WLGdDQUFnQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsK0NBQStDLHdHQUF3RyxFQUFFLEVBQUUsRUFBRSw2Q0FBNkMsMkVBQTJFLEVBQUUsT0FBTyx5Q0FBeUMsa0ZBQWtGLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFamtCOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixpR0FBaUc7QUFDL0g7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwyQkFBMkI7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDs7QUFFdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvR0FBb0csbUJBQW1CLEVBQUU7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxhQUFhLGtDQUFrQyxFQUFFOztBQUVqRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0dBQW9HLG1CQUFtQixFQUFFO0FBQ3pILDRHQUE0RywyQkFBMkIsRUFBRTtBQUN6SSxvR0FBb0csbUJBQW1CLEVBQUU7QUFDekgsa0dBQWtHLGlCQUFpQixFQUFFO0FBQ3JILHFHQUFxRyxvQkFBb0IsRUFBRTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRyxnQkFBZ0IsRUFBRTtBQUNuSCxrR0FBa0csaUJBQWlCLEVBQUU7QUFDckgsZ0hBQWdILCtCQUErQixFQUFFO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDBDQUEwQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsZ0VBQWdFLEVBQUUsRUFBRSxnQ0FBZ0MsRUFBRSxhQUFhOztBQUVuVixnQ0FBZ0MsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLCtDQUErQyx3R0FBd0csRUFBRSxFQUFFLEVBQUUsNkNBQTZDLDJFQUEyRSxFQUFFLE9BQU8seUNBQXlDLGtGQUFrRixFQUFFLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRWprQjs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEdBQTBHO0FBQzFHLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9HQUFvRyxtQkFBbUIsRUFBRTtBQUN6SCxxR0FBcUcsb0JBQW9CLEVBQUU7QUFDM0gsc0dBQXNHLHFCQUFxQixFQUFFO0FBQzdIO0FBQ0E7QUFDQTs7O0FBR0EsMENBQTBDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxnRUFBZ0UsRUFBRSxFQUFFLGdDQUFnQyxFQUFFLGFBQWE7O0FBRW5WLGdDQUFnQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsK0NBQStDLHdHQUF3RyxFQUFFLEVBQUUsRUFBRSw2Q0FBNkMsMkVBQTJFLEVBQUUsT0FBTyx5Q0FBeUMsa0ZBQWtGLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZTs7O0FBR2prQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7QUFDdkg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1HQUFtRyxrQkFBa0IsRUFBRTtBQUN2SCx3R0FBd0csdUJBQXVCLEVBQUU7QUFDakksaUdBQWlHLGdCQUFnQixFQUFFO0FBQ25ILHVHQUF1RyxzQkFBc0IsRUFBRTtBQUMvSCxzR0FBc0cscUJBQXFCLEVBQUU7QUFDN0gsb0dBQW9HLG1CQUFtQixFQUFFO0FBQ3pILG9HQUFvRyxtQkFBbUIsRUFBRTtBQUN6SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdHQUFnRyxlQUFlLEVBQUU7QUFDakgsZ0dBQWdHLGVBQWUsRUFBRTtBQUNqSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzQkFBc0I7OztBQUczQjtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQSxPQUFPLFFBQVE7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0ZBQStGLGNBQWMsRUFBRTtBQUMvRyx3R0FBd0csdUJBQXVCLEVBQUU7QUFDakksZ0dBQWdHLGVBQWUsRUFBRTtBQUNqSCx5R0FBeUcsd0JBQXdCLEVBQUU7QUFDbkksc0dBQXNHLHFCQUFxQixFQUFFO0FBQzdILDhHQUE4Ryw2QkFBNkIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSwwQ0FBMEMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsOERBQThELGdFQUFnRSxFQUFFLEVBQUUsZ0NBQWdDLEVBQUUsYUFBYTs7QUFFblYsZ0NBQWdDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSwrQ0FBK0Msd0dBQXdHLEVBQUUsRUFBRSxFQUFFLDZDQUE2QywyRUFBMkUsRUFBRSxPQUFPLHlDQUF5QyxrRkFBa0YsRUFBRSxFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUVqa0I7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLFlBQVk7QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0JBQW9COztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjtBQUM3Rjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQSxrQ0FBa0MsaUZBQWlGOztBQUVuSCwrQkFBK0Isd0VBQXdFOztBQUV2RyxpQ0FBaUMsK0hBQStIOztBQUVoSyxrQ0FBa0MsMEJBQTBCLDhDQUE4QyxnQkFBZ0IsT0FBTyxrQkFBa0IsRUFBRSxhQUFhLEVBQUU7O0FBRXBLLGlDQUFpQyxvRkFBb0Y7O0FBRXJILDZCQUE2Qiw2RUFBNkU7O0FBRTFHLHdDQUF3QyxlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsbUNBQW1DLEVBQUUsRUFBRSxjQUFjLFdBQVcsVUFBVSxFQUFFLFVBQVUsTUFBTSxpREFBaUQsRUFBRSxVQUFVLGtCQUFrQixFQUFFLEVBQUUsYUFBYTs7QUFFdlosK0JBQStCLG9DQUFvQzs7QUFFbkU7QUFDQTtBQUNBLGNBQWMsSUFBSSxHQUFHLHNFQUFzRTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyxTQUFTOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQSw0RUFBNEUsU0FBUywyREFBMkQ7O0FBRWhKO0FBQ0E7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLDBCQUEwQixPQUFPO0FBQ2pDLHFCQUFxQjtBQUNyQjtBQUNBLDZCQUE2QjtBQUM3QixlQUFlLHNCQUFzQjtBQUNyQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGVBQWUsZ0JBQWdCO0FBQy9COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsa0NBQWtDO0FBQ2xDLG1DQUFtQyxPQUFPO0FBQzFDLHFCQUFxQixnQkFBZ0I7QUFDckMsZUFBZSxnQkFBZ0I7QUFDL0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLHVCQUF1QixHQUFHO0FBQzFCO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTs7O0FBR0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELHFCQUFxQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlFQUF5RTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIscUJBQXFCLFFBQVE7QUFDN0I7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msb0JBQW9COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNCQUFzQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsS0FBSzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsT0FBTztBQUNQ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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtB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Q0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQyw2QkFBNkIsT0FBTztBQUNwQztBQUNBLGlCQUFpQixTQUFTO0FBQzFCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzR0FBc0cscUJBQXFCLEVBQUU7QUFDN0gsdUdBQXVHLHNCQUFzQixFQUFFO0FBQy9ILHNHQUFzRyxxQkFBcUIsRUFBRTtBQUM3SDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBIiwiZmlsZSI6IjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NvbGlkX2F1dGhfY2xpZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuIC8vIEV4cG9ydCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBTb2xpZEF1dGhDbGllbnRcblxuY29uc3QgYXV0aCA9IG5ldyBfc29saWRfYXV0aF9jbGllbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0oKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoYXV0aCk7IC8vIEJpbmQgbWV0aG9kcyB0byBpbnN0YW5jZSwgc28gdGhleSBjYW4gYmUgaW52b2tlZCBhcyByZWd1bGFyIGZ1bmN0aW9uc1xuLy8gKGUuZy4sIHRvIHBhc3MgYXJvdW5kIHRoZSBmZXRjaCBmdW5jdGlvbilcblxuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoX3NvbGlkX2F1dGhfY2xpZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLnByb3RvdHlwZSkuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gYXV0aFtwcm9wZXJ0eV07XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGF1dGhbcHJvcGVydHldID0gdmFsdWUuYmluZChhdXRoKTtcbiAgfVxufSk7IC8vIEV4cG9zZSB3aW5kb3cuU29saWRBdXRoQ2xpZW50IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAoJ1NvbGlkQXV0aENsaWVudCcgaW4gd2luZG93KSB7XG4gICAgY29uc29sZS53YXJuKCdDYXV0aW9uOiBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBzb2xpZC1hdXRoLWNsaWVudCBhY3RpdmUuJyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHdhcm5lZCA9IGZhbHNlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdTb2xpZEF1dGhDbGllbnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3dpbmRvdy5Tb2xpZEF1dGhDbGllbnQgaGFzIGJlZW4gZGVwcmVjYXRlZC4nKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1BsZWFzZSB1c2Ugd2luZG93LnNvbGlkLmF1dGggaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdXRoO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU29saWRBdXRoQ2xpZW50OyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2F1dGhuX2ZldGNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb3B1cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Nlc3Npb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyogZ2xvYmFsIGZldGNoICovXG5cblxuXG5cblxuXG4gLy8gU3RvcmUgdGhlIGdsb2JhbCBmZXRjaCwgc28gdGhlIHVzZXIgaXMgZnJlZSB0byBvdmVycmlkZSBpdFxuXG5jb25zdCBnbG9iYWxGZXRjaCA9IGZldGNoO1xuY2xhc3MgU29saWRBdXRoQ2xpZW50IGV4dGVuZHMgZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdC5hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcblxuICAgIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcywgXCJfcGVuZGluZ1Nlc3Npb25cIiwgdm9pZCAwKTtcbiAgfVxuXG4gIGZldGNoKGlucHV0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgT2JqZWN0KF91cmxfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1widG9VcmxTdHJpbmdcIl0pKGlucHV0KSk7XG4gICAgcmV0dXJuIE9iamVjdChfYXV0aG5fZmV0Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImF1dGhuRmV0Y2hcIl0pKE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFN0b3JhZ2VcIl0pKCksIGdsb2JhbEZldGNoLCBpbnB1dCwgb3B0aW9ucyk7XG4gIH1cblxuICBsb2dpbihpZHAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdExvZ2luT3B0aW9ucyhPYmplY3QoX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJjdXJyZW50VXJsTm9QYXJhbXNcIl0pKCkpLCB7fSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dpblwiXShpZHAsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgcG9wdXBMb2dpbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRMb2dpbk9wdGlvbnMoKSwge30sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCEvaHR0cHM/Oi8udGVzdChvcHRpb25zLnBvcHVwVXJpKSkge1xuICAgICAgb3B0aW9ucy5wb3B1cFVyaSA9IG5ldyBVUkwob3B0aW9ucy5wb3B1cFVyaSB8fCAnLy53ZWxsLWtub3duL3NvbGlkL2xvZ2luJywgd2luZG93LmxvY2F0aW9uKS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5jYWxsYmFja1VyaSkge1xuICAgICAgb3B0aW9ucy5jYWxsYmFja1VyaSA9IG9wdGlvbnMucG9wdXBVcmk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9wdXAgPSBPYmplY3QoX3BvcHVwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJvcGVuSWRwUG9wdXBcIl0pKG9wdGlvbnMucG9wdXBVcmkpO1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBPYmplY3QoX3BvcHVwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJvYnRhaW5TZXNzaW9uXCJdKShvcHRpb25zLnN0b3JhZ2UsIHBvcHVwLCBvcHRpb25zKTtcbiAgICB0aGlzLmVtaXQoJ2xvZ2luJywgc2Vzc2lvbik7XG4gICAgdGhpcy5lbWl0KCdzZXNzaW9uJywgc2Vzc2lvbik7XG4gICAgcmV0dXJuIHNlc3Npb247XG4gIH1cblxuICBhc3luYyBjdXJyZW50U2Vzc2lvbigpIHtcbiAgICBsZXQgc3RvcmFnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0U3RvcmFnZVwiXSkoKTtcbiAgICAvLyBUcnkgdG8gb2J0YWluIGEgc3RvcmVkIG9yIHBlbmRpbmcgc2Vzc2lvblxuICAgIGxldCBzZXNzaW9uID0gdGhpcy5fcGVuZGluZ1Nlc3Npb24gfHwgKGF3YWl0IE9iamVjdChfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZ2V0U2Vzc2lvblwiXSkoc3RvcmFnZSkpOyAvLyBJZiBub25lIGZvdW5kLCBhdHRlbXB0IHRvIGNyZWF0ZSBhIG5ldyBzZXNzaW9uXG5cbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIC8vIFRyeSB0byBjcmVhdGUgYSBuZXcgT0lEQyBzZXNzaW9uIGZyb20gc3RvcmVkIHRva2Vuc1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1Nlc3Npb24gPSBfd2ViaWRfb2lkY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiY3VycmVudFNlc3Npb25cIl0oc3RvcmFnZSk7XG4gICAgICAgIHNlc3Npb24gPSBhd2FpdCB0aGlzLl9wZW5kaW5nU2Vzc2lvbjtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9IC8vIFNhdmUgdGhlIG5ldyBzZXNzaW9uIGFuZCBlbWl0IHNlc3Npb24gZXZlbnRzXG5cblxuICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgT2JqZWN0KF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJzYXZlU2Vzc2lvblwiXSkoc3RvcmFnZSkoc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZW1pdCgnbG9naW4nLCBzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzZXNzaW9uJywgc2Vzc2lvbik7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nU2Vzc2lvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gc2Vzc2lvbjtcbiAgfVxuXG4gIGFzeW5jIHRyYWNrU2Vzc2lvbihjYWxsYmFjaykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIHN0YW5kYXJkL25vLWNhbGxiYWNrLWxpdGVyYWwgKi9cbiAgICBjYWxsYmFjaygoYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbigpKSk7XG4gICAgdGhpcy5vbignc2Vzc2lvbicsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHN0b3BUcmFja1Nlc3Npb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdzZXNzaW9uJywgY2FsbGJhY2spO1xuICB9XG5cbiAgYXN5bmMgbG9nb3V0KCkge1xuICAgIGxldCBzdG9yYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRTdG9yYWdlXCJdKSgpO1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBPYmplY3QoX3Nlc3Npb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImdldFNlc3Npb25cIl0pKHN0b3JhZ2UpO1xuXG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dvdXRcIl0oc3RvcmFnZSwgZ2xvYmFsRmV0Y2gpO1xuICAgICAgICB0aGlzLmVtaXQoJ2xvZ291dCcpO1xuICAgICAgICB0aGlzLmVtaXQoJ3Nlc3Npb24nLCBudWxsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGxvZ2dpbmcgb3V0OicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IE9iamVjdChfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiY2xlYXJTZXNzaW9uXCJdKShzdG9yYWdlKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBkZWZhdWx0TG9naW5PcHRpb25zKHVybCkge1xuICByZXR1cm4ge1xuICAgIGNhbGxiYWNrVXJpOiB1cmwgPyB1cmwuc3BsaXQoJyMnKVswXSA6ICcnLFxuICAgIHBvcHVwVXJpOiAnJyxcbiAgICBzdG9yYWdlOiBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRTdG9yYWdlXCJdKSgpXG4gIH07XG59XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgUmVmbGVjdEFwcGx5KHRoaXMubGlzdGVuZXIsIHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImF1dGhuRmV0Y2hcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhdXRobkZldGNoOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBpc29tb3JwaGljX2ZldGNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGlzb21vcnBoaWNfZmV0Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc29tb3JwaGljX2ZldGNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91cmxfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9zdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfd2ViaWRfb2lkY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblxuXG5cblxuYXN5bmMgZnVuY3Rpb24gYXV0aG5GZXRjaChzdG9yYWdlLCBmZXRjaCwgaW5wdXQsIG9wdGlvbnMpIHtcbiAgLy8gSWYgbm90IGF1dGhlbnRpY2F0ZWQsIHBlcmZvcm0gYSByZWd1bGFyIGZldGNoXG4gIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBPYmplY3QoX3Nlc3Npb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImdldFNlc3Npb25cIl0pKHN0b3JhZ2UpO1xuXG4gIGlmICghc2Vzc2lvbikge1xuICAgIHJldHVybiBmZXRjaChpbnB1dCwgb3B0aW9ucyk7XG4gIH0gLy8gSWYgd2Uga25vdyB0aGUgc2VydmVyIGV4cGVjdHMgY3JlZGVudGlhbHMsIHNlbmQgdGhlbVxuXG5cbiAgaWYgKGF3YWl0IHNob3VsZFNoYXJlQ3JlZGVudGlhbHMoc3RvcmFnZSwgaW5wdXQpKSB7XG4gICAgcmV0dXJuIE9iamVjdChfd2ViaWRfb2lkY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZmV0Y2hXaXRoQ3JlZGVudGlhbHNcIl0pKHNlc3Npb24sIGZldGNoLCBpbnB1dCwgb3B0aW9ucyk7XG4gIH0gLy8gSWYgd2UgZG9uJ3Qga25vdyBmb3Igc3VyZSwgdHJ5IGEgcmVndWxhciBmZXRjaCBmaXJzdFxuXG5cbiAgbGV0IHJlc3AgPSBhd2FpdCBmZXRjaChpbnB1dCwgb3B0aW9ucyk7IC8vIElmIHRoZSBzZXJ2ZXIgdGhlbiByZXF1ZXN0cyBjcmVkZW50aWFscywgc2VuZCB0aGVtXG5cbiAgaWYgKHJlc3Auc3RhdHVzID09PSA0MDEpIHtcbiAgICBhd2FpdCBPYmplY3QoX2hvc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInVwZGF0ZUhvc3RGcm9tUmVzcG9uc2VcIl0pKHN0b3JhZ2UpKHJlc3ApO1xuXG4gICAgaWYgKGF3YWl0IHNob3VsZFNoYXJlQ3JlZGVudGlhbHMoc3RvcmFnZSwgaW5wdXQpKSB7XG4gICAgICByZXNwID0gT2JqZWN0KF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJmZXRjaFdpdGhDcmVkZW50aWFsc1wiXSkoc2Vzc2lvbiwgZmV0Y2gsIGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzcDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2hvdWxkU2hhcmVDcmVkZW50aWFscyhzdG9yYWdlLCBpbnB1dCkge1xuICBjb25zdCByZXF1ZXN0SG9zdCA9IGF3YWl0IE9iamVjdChfaG9zdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZ2V0SG9zdFwiXSkoc3RvcmFnZSkoT2JqZWN0KF91cmxfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1widG9VcmxTdHJpbmdcIl0pKGlucHV0KSk7XG4gIHJldHVybiByZXF1ZXN0SG9zdCAhPSBudWxsICYmIHJlcXVlc3RIb3N0LnJlcXVpcmVzQXV0aDtcbn1cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJmZXRjaFwiXTsgfSgpKTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImN1cnJlbnRVcmxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50VXJsOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjdXJyZW50VXJsTm9QYXJhbXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50VXJsTm9QYXJhbXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hdmlnYXRlVG9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBuYXZpZ2F0ZVRvOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvcmlnaW5PZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9yaWdpbk9mOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b1VybFN0cmluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRvVXJsU3RyaW5nOyB9KTtcbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuZnVuY3Rpb24gZ2V0TG9jYXRpb24oKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbiA6IHtcbiAgICBocmVmOiAnaHR0cHM6Ly9leGFtcGxlLm9yZy8nLFxuICAgIHBhdGhuYW1lOiAnLycsXG4gICAgb3JpZ2luOiAnZXhhbXBsZS5vcmcnXG4gIH07XG59XG5cbmNvbnN0IGN1cnJlbnRVcmwgPSAoKSA9PiBnZXRMb2NhdGlvbigpLmhyZWY7XG5jb25zdCBjdXJyZW50VXJsTm9QYXJhbXMgPSAoKSA9PiBnZXRMb2NhdGlvbigpLm9yaWdpbiArIGdldExvY2F0aW9uKCkucGF0aG5hbWU7XG5jb25zdCBuYXZpZ2F0ZVRvID0gdXJsID0+IHtcbiAgZ2V0TG9jYXRpb24oKS5ocmVmID0gdXJsO1xufTtcbmNvbnN0IG9yaWdpbk9mID0gdXJsID0+IG5ldyBVUkwodXJsKS5vcmlnaW47XG5jb25zdCB0b1VybFN0cmluZyA9IHVybCA9PiB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHVybCA9ICd1cmwnIGluIHVybCA/IHVybC51cmwgOiB1cmwudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVVJMKHVybCwgY3VycmVudFVybCgpKS50b1N0cmluZygpO1xufTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEhvc3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRIb3N0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzYXZlSG9zdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNhdmVIb3N0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ1cGRhdGVIb3N0RnJvbVJlc3BvbnNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlSG9zdEZyb21SZXNwb25zZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfd2ViaWRfb2lkY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qIGdsb2JhbFJlcXVlc3QsIFJlc3BvbnNlLCBVUkwgKi9cblxuXG5cbmZ1bmN0aW9uIGdldEhvc3Qoc3RvcmFnZSkge1xuICByZXR1cm4gYXN5bmMgdXJsID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBob3N0XG4gICAgfSA9IG5ldyBVUkwodXJsKTtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgT2JqZWN0KF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJnZXRTZXNzaW9uXCJdKShzdG9yYWdlKTtcblxuICAgIGlmIChzZXNzaW9uICYmIGhvc3QgPT09IG5ldyBVUkwoc2Vzc2lvbi5pZHApLmhvc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogaG9zdCxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGhvc3RzXG4gICAgfSA9IGF3YWl0IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZ2V0RGF0YVwiXSkoc3RvcmFnZSk7XG4gICAgcmV0dXJuIGhvc3RzICYmIGhvc3RzW2hvc3RdO1xuICB9O1xufVxuZnVuY3Rpb24gc2F2ZUhvc3Qoc3RvcmFnZSkge1xuICByZXR1cm4gYXN5bmMgKF9yZWYpID0+IHtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgcmVxdWlyZXNBdXRoXG4gICAgfSA9IF9yZWY7XG4gICAgYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJ1cGRhdGVTdG9yYWdlXCJdKShzdG9yYWdlLCBkYXRhID0+IF9vYmplY3RTcHJlYWQoe30sIGRhdGEsIHtcbiAgICAgIGhvc3RzOiBfb2JqZWN0U3ByZWFkKHt9LCBkYXRhLmhvc3RzLCB7XG4gICAgICAgIFt1cmxdOiB7XG4gICAgICAgICAgcmVxdWlyZXNBdXRoXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSkpO1xuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlSG9zdEZyb21SZXNwb25zZShzdG9yYWdlKSB7XG4gIHJldHVybiBhc3luYyByZXNwID0+IHtcbiAgICBpZiAoX3dlYmlkX29pZGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcInJlcXVpcmVzQXV0aFwiXShyZXNwKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBob3N0XG4gICAgICB9ID0gbmV3IFVSTChyZXNwLnVybCk7XG4gICAgICBhd2FpdCBzYXZlSG9zdChzdG9yYWdlKSh7XG4gICAgICAgIHVybDogaG9zdCxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRTZXNzaW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U2Vzc2lvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2F2ZVNlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzYXZlU2Vzc2lvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY2xlYXJTZXNzaW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2xlYXJTZXNzaW9uOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cbmFzeW5jIGZ1bmN0aW9uIGdldFNlc3Npb24oc3RvcmFnZSkge1xuICBjb25zdCBkYXRhID0gYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJnZXREYXRhXCJdKShzdG9yYWdlKTtcbiAgcmV0dXJuIGRhdGEuc2Vzc2lvbiB8fCBudWxsO1xufVxuZnVuY3Rpb24gc2F2ZVNlc3Npb24oc3RvcmFnZSkge1xuICByZXR1cm4gYXN5bmMgc2Vzc2lvbiA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1widXBkYXRlU3RvcmFnZVwiXSkoc3RvcmFnZSwgZGF0YSA9PiBfb2JqZWN0U3ByZWFkKHt9LCBkYXRhLCB7XG4gICAgICBzZXNzaW9uXG4gICAgfSkpO1xuICAgIHJldHVybiBkYXRhLnNlc3Npb247XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBjbGVhclNlc3Npb24oc3RvcmFnZSkge1xuICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JhZ2UsIGRhdGEgPT4gX29iamVjdFNwcmVhZCh7fSwgZGF0YSwge1xuICAgIHNlc3Npb246IG51bGxcbiAgfSkpO1xufVxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTkFNRVNQQUNFXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTkFNRVNQQUNFOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0U3RvcmFnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZmF1bHRTdG9yYWdlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXREYXRhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RGF0YTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidXBkYXRlU3RvcmFnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHVwZGF0ZVN0b3JhZ2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFzeW5jU3RvcmFnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFzeW5jU3RvcmFnZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWVtU3RvcmFnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1lbVN0b3JhZ2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlwY1N0b3JhZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpcGNTdG9yYWdlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXBjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuY29uc3QgTkFNRVNQQUNFID0gJ3NvbGlkLWF1dGgtY2xpZW50JztcbmNvbnN0IGRlZmF1bHRTdG9yYWdlID0gKCkgPT4ge1xuICBjb25zdCBoYXNMb2NhbFN0b3JhZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3c7XG4gIHJldHVybiBhc3luY1N0b3JhZ2UoaGFzTG9jYWxTdG9yYWdlID8gd2luZG93LmxvY2FsU3RvcmFnZSA6IG1lbVN0b3JhZ2UoKSk7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBkZXNlcmlhbGl6ZWQgc3RvcmVkIGRhdGFcbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBnZXREYXRhKHN0b3JlKSB7XG4gIGxldCBzZXJpYWxpemVkO1xuICBsZXQgZGF0YTtcblxuICB0cnkge1xuICAgIHNlcmlhbGl6ZWQgPSBhd2FpdCBzdG9yZS5nZXRJdGVtKE5BTUVTUEFDRSk7XG4gICAgZGF0YSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCB8fCAne30nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGRlc2VyaWFsaXplIGRhdGE6Jywgc2VyaWFsaXplZCk7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgICBkYXRhID0ge307XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogVXBkYXRlcyBhIFN0b3JhZ2Ugb2JqZWN0IHdpdGhvdXQgbXV0YXRpbmcgaXRzIGludGVybWVkaWF0ZSByZXByZXNlbnRhdGlvbi5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVTdG9yYWdlKHN0b3JlLCB1cGRhdGUpIHtcbiAgY29uc3QgY3VycmVudERhdGEgPSBhd2FpdCBnZXREYXRhKHN0b3JlKTtcbiAgY29uc3QgbmV3RGF0YSA9IHVwZGF0ZShjdXJyZW50RGF0YSk7XG4gIGF3YWl0IHN0b3JlLnNldEl0ZW0oTkFNRVNQQUNFLCBKU09OLnN0cmluZ2lmeShuZXdEYXRhKSk7XG4gIHJldHVybiBuZXdEYXRhO1xufVxuLyoqXG4gKiBUYWtlcyBhIHN5bmNocm9ub3VzIHN0b3JhZ2UgaW50ZXJmYWNlIGFuZCB3cmFwcyBpdCB3aXRoIGFuIGFzeW5jIGludGVyZmFjZS5cbiAqL1xuXG5mdW5jdGlvbiBhc3luY1N0b3JhZ2Uoc3RvcmFnZSkge1xuICByZXR1cm4ge1xuICAgIGdldEl0ZW06IGtleSA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbiAgICB9LFxuICAgIHNldEl0ZW06IChrZXksIHZhbCkgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWwpKTtcbiAgICB9LFxuICAgIHJlbW92ZUl0ZW06IGtleSA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBtZW1TdG9yYWdlID0gKCkgPT4ge1xuICBjb25zdCBzdG9yZSA9IHt9O1xuICByZXR1cm4ge1xuICAgIGdldEl0ZW06IGtleSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHN0b3JlW2tleV0gPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBzdG9yZVtrZXldO1xuICAgIH0sXG4gICAgc2V0SXRlbTogKGtleSwgdmFsKSA9PiB7XG4gICAgICBzdG9yZVtrZXldID0gdmFsO1xuICAgIH0sXG4gICAgcmVtb3ZlSXRlbToga2V5ID0+IHtcbiAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBpcGNTdG9yYWdlKGNsaWVudCkge1xuICByZXR1cm4ge1xuICAgIGdldEl0ZW06IGtleSA9PiBjbGllbnQucmVxdWVzdCgnc3RvcmFnZS9nZXRJdGVtJywga2V5KSxcbiAgICBzZXRJdGVtOiAoa2V5LCB2YWwpID0+IGNsaWVudC5yZXF1ZXN0KCdzdG9yYWdlL3NldEl0ZW0nLCBrZXksIHZhbCksXG4gICAgcmVtb3ZlSXRlbToga2V5ID0+IGNsaWVudC5yZXF1ZXN0KCdzdG9yYWdlL3JlbW92ZUl0ZW0nLCBrZXkpXG4gIH07XG59XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU2VydmVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2VydmVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDbGllbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDbGllbnQ7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG5cblxuLypcbiAgVGhpcyBtb2R1bGUgZGVzY3JpYmVzIGEgc2ltcGxlIElQQyBpbnRlcmZhY2UgZm9yIGNvbW11bmljYXRpbmcgYmV0d2VlbiBicm93c2VyIHdpbmRvd3MuXG4gIHdpbmRvdy5wb3N0TWVzc2FnZSgpIGlzIHRoZSB0cmFuc3BvcnQgaW50ZXJmYWNlLCBhbmQgYSByZXF1ZXN0L3Jlc3BvbnNlIGludGVyZmFjZVxuICBpcyBkZWZpbmVkIG9uIHRvcCBvZiBpdCBhcyBmb2xsb3dzOlxuXG4gIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgJ3NvbGlkLWF1dGgtY2xpZW50Jzoge1xuICAgICAgaWQ6IDEyMzQsXG4gICAgICBtZXRob2Q6ICdkb1NvbWV0aGluZ1BsZWFzZScsXG4gICAgICBhcmdzOiBbICdvbmUnLCAndHdvJywgJ3RocmVlJyBdXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgJ3NvbGlkLWF1dGgtY2xpZW50Jzoge1xuICAgICAgaWQ6IDEyMzQsXG4gICAgICByZXQ6ICd0aGVfdmFsdWUnXG4gICAgfVxuICB9XG4qL1xuY29uc3QgTkFNRVNQQUNFID0gJ3NvbGlkLWF1dGgtY2xpZW50Jztcbi8qKlxuICogUmVjZWl2ZXMgYW5kIGhhbmRsZXMgcmVtb3RlIHByb2NlZHVyZSBjYWxscy5cbiAqL1xuXG5jbGFzcyBTZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcihjbGllbnRXaW5kb3csIGNsaWVudE9yaWdpbiwgaGFuZGxlKSB7XG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9jbGllbnRXaW5kb3dcIiwgdm9pZCAwKTtcblxuICAgIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcywgXCJfY2xpZW50T3JpZ2luXCIsIHZvaWQgMCk7XG5cbiAgICBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMsIFwiX2hhbmRsZXJcIiwgdm9pZCAwKTtcblxuICAgIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcywgXCJfbWVzc2FnZUxpc3RlbmVyXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9jbGllbnRXaW5kb3cgPSBjbGllbnRXaW5kb3c7XG4gICAgdGhpcy5fY2xpZW50T3JpZ2luID0gY2xpZW50T3JpZ2luO1xuICAgIHRoaXMuX2hhbmRsZXIgPSBoYW5kbGU7XG5cbiAgICB0aGlzLl9tZXNzYWdlTGlzdGVuZXIgPSBldmVudCA9PiB0aGlzLl9oYW5kbGVNZXNzYWdlKGV2ZW50KTtcbiAgfVxuXG4gIGFzeW5jIF9oYW5kbGVNZXNzYWdlKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgZGF0YSxcbiAgICAgIG9yaWdpblxuICAgIH0gPSBfcmVmO1xuXG4gICAgLy8gRW5zdXJlIHdlIGNhbiBwb3N0IHRvIHRoZSBvcmlnaW5cbiAgICBpZiAob3JpZ2luICE9PSB0aGlzLl9jbGllbnRPcmlnaW4pIHtcbiAgICAgIGNvbnNvbGUud2FybihcInNvbGlkLWF1dGgtY2xpZW50IGlzIGxpc3RlbmluZyB0byBcIi5jb25jYXQodGhpcy5fY2xpZW50T3JpZ2luLCBcIiBcIikgKyBcInNvIGlnbm9yZWQgYSBtZXNzYWdlIHJlY2VpdmVkIGZyb20gXCIuY29uY2F0KG9yaWdpbiwgXCIuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFBhcnNlIHRoZSByZXF1ZXN0IGFuZCBzZW5kIGl0IHRvIHRoZSBoYW5kbGVyXG5cblxuICAgIGNvbnN0IHJlcSA9IGRhdGEgJiYgZGF0YVtOQU1FU1BBQ0VdO1xuXG4gICAgaWYgKHJlcSAmJiByZXEubWV0aG9kKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGFyZ3NcbiAgICAgIH0gPSByZXE7XG4gICAgICBjb25zdCByZXQgPSBhd2FpdCB0aGlzLl9oYW5kbGVyKG1ldGhvZCwgLi4uYXJncyk7XG5cbiAgICAgIHRoaXMuX2NsaWVudFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIFtOQU1FU1BBQ0VdOiB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcmV0XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuX2NsaWVudE9yaWdpbik7XG4gICAgfVxuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9tZXNzYWdlTGlzdGVuZXIpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gIH1cblxufVxuLyoqXG4gKiBNYWtlcyByZW1vdGUgcHJvY2VkdXJlIGNhbGxzLlxuICovXG5cbmNsYXNzIENsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHNlcnZlcldpbmRvdywgc2VydmVyT3JpZ2luKSB7XG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9zZXJ2ZXJXaW5kb3dcIiwgdm9pZCAwKTtcblxuICAgIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcywgXCJfc2VydmVyT3JpZ2luXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9zZXJ2ZXJXaW5kb3cgPSBzZXJ2ZXJXaW5kb3c7XG4gICAgdGhpcy5fc2VydmVyT3JpZ2luID0gc2VydmVyT3JpZ2luO1xuICB9XG5cbiAgcmVxdWVzdChtZXRob2QpIHtcbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0IGFzIGEgbWVzc2FnZSB0byB0aGUgc2VydmVyIHdpbmRvd1xuICAgIGNvbnN0IGlkID0gTWF0aC5yYW5kb20oKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHRoaXMuX3NlcnZlcldpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICBbTkFNRVNQQUNFXToge1xuICAgICAgICBpZCxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBhcmdzXG4gICAgICB9XG4gICAgfSwgdGhpcy5fc2VydmVyT3JpZ2luKTsgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXF1ZXN0J3MgcmV0dXJuIHZhbHVlXG5cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlc3BvbnNlcyB0byB0aGUgcmVxdWVzdFxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCByZXNwb25zZUxpc3RlbmVyKTsgLy8gQ2FuY2VsIGlmIHRoZSByZXNwb25zZSB0YWtlcyB0b28gbG9uZ1xuXG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb25uZWN0IHRvIG1haW4gd2luZG93LicpKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCByZXNwb25zZUxpc3RlbmVyKTtcbiAgICAgIH0sIDIwMDApOyAvLyBQcm9jZXNzZXMgYSBwb3NzaWJsZSByZXNwb25zZSB0byB0aGUgcmVxdWVzdFxuXG4gICAgICBmdW5jdGlvbiByZXNwb25zZUxpc3RlbmVyKF9yZWYyKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgZGF0YVxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBkYXRhICYmIGRhdGFbTkFNRVNQQUNFXTtcblxuICAgICAgICBpZiAocmVzcCAmJiByZXNwLmlkID09PSBpZCAmJiByZXNwLmhhc093blByb3BlcnR5KCdyZXQnKSkge1xuICAgICAgICAgIHJlc29sdmUocmVzcC5yZXQpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHJlc3BvbnNlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxvZ2luXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9naW47IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImN1cnJlbnRTZXNzaW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudFNlc3Npb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxvZ291dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZ291dDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0UmVnaXN0ZXJlZFJwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0UmVnaXN0ZXJlZFJwOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZXF1aXJlc0F1dGhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlc0F1dGg7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZldGNoV2l0aENyZWRlbnRpYWxzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmV0Y2hXaXRoQ3JlZGVudGlhbHM7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfYmFiZWxfcnVudGltZV9oZWxwZXJzX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgYXV0aF9oZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGF1dGhfaGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYXV0aF9oZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NvbGlkX29pZGNfcnBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zb2xpZF9vaWRjX3JwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3NvbGlkX29pZGNfcnBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NvbGlkX29pZGNfcnBfbGliX1BvUFRva2VuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc29saWRfb2lkY19ycF9saWJfUG9QVG9rZW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc29saWRfb2lkY19ycF9saWJfUG9QVG9rZW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0KCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qIGdsb2JhbCBSZXNwb25zZSAqL1xuXG5cblxuXG5cbmFzeW5jIGZ1bmN0aW9uIGxvZ2luKGlkcCwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIGNvbnN0IHJwID0gYXdhaXQgZ2V0UmVnaXN0ZXJlZFJwKGlkcCwgb3B0aW9ucyk7XG4gICAgYXdhaXQgc2F2ZUFwcEhhc2hGcmFnbWVudChvcHRpb25zLnN0b3JhZ2UpO1xuICAgIHJldHVybiBzZW5kQXV0aFJlcXVlc3QocnAsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGxvZ2dpbmcgaW4gd2l0aCBXZWJJRC1PSURDJyk7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBjdXJyZW50U2Vzc2lvbigpIHtcbiAgbGV0IHN0b3JhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVmYXVsdFN0b3JhZ2VcIl0pKCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBPYnRhaW4gdGhlIFJlbHlpbmcgUGFydHlcbiAgICBjb25zdCBycCA9IGF3YWl0IGdldFN0b3JlZFJwKHN0b3JhZ2UpO1xuXG4gICAgaWYgKCFycCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBPYnRhaW4gYW5kIGNsZWFyIHRoZSBPSURDIFVSTCBmcmFnbWVudFxuXG5cbiAgICBjb25zdCB1cmwgPSBPYmplY3QoX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJjdXJyZW50VXJsXCJdKSgpO1xuXG4gICAgaWYgKCEvIyguKiYpP2FjY2Vzc190b2tlbj0vLnRlc3QodXJsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICBhd2FpdCByZXN0b3JlQXBwSGFzaEZyYWdtZW50KHN0b3JhZ2UpOyAvLyBPYnRhaW4gYSBzZXNzaW9uIGZyb20gdGhlIFJlbHlpbmcgUGFydHlcblxuICAgIGNvbnN0IHN0b3JlRGF0YSA9IGF3YWl0IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZ2V0RGF0YVwiXSkoc3RvcmFnZSk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHJwLnZhbGlkYXRlUmVzcG9uc2UodXJsLCBzdG9yZURhdGEpO1xuXG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgc2Vzc2lvbiwge1xuICAgICAgd2ViSWQ6IHNlc3Npb24uaWRDbGFpbXMuc3ViLFxuICAgICAgaWRwOiBzZXNzaW9uLmlzc3VlclxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGZpbmRpbmcgYSBXZWJJRC1PSURDIHNlc3Npb24nKTtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGxvZ291dChzdG9yYWdlLCBmZXRjaCkge1xuICBjb25zdCBycCA9IGF3YWl0IGdldFN0b3JlZFJwKHN0b3JhZ2UpO1xuXG4gIGlmIChycCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBsb2cgb3V0IGZyb20gdGhlIElEUFxuICAgICAgYXdhaXQgcnAubG9nb3V0KCk7IC8vIFRoZW4sIGxvZyBvdXQgZnJvbSB0aGUgUlBcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmV0Y2goJy8ud2VsbC1rbm93bi9zb2xpZC9sb2dvdXQnLCB7XG4gICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJ1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsvLyBJZ25vcmUgZXJyb3JzIGZvciB3aGVuIHdlIGFyZSBub3Qgb24gYSBTb2xpZCBwb2RcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybignRXJyb3IgbG9nZ2luZyBvdXQgb2YgdGhlIFdlYklELU9JREMgc2Vzc2lvbicpO1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFJwKGlkcCwgb3B0aW9ucykge1xuICAvLyBUbyByZXVzZSBhIHBvc3NpYmxlIHByZXZpb3VzIFJQLFxuICAvLyBpdCBiZSBmb3IgdGhlIHNhbWUgSURQIGFuZCByZWRpcmVjdCBVUklcbiAgbGV0IHJwID0gYXdhaXQgZ2V0U3RvcmVkUnAob3B0aW9ucy5zdG9yYWdlKTtcblxuICBpZiAoIXJwIHx8IHJwLnByb3ZpZGVyLnVybCAhPT0gaWRwIHx8ICFycC5yZWdpc3RyYXRpb24ucmVkaXJlY3RfdXJpcy5pbmNsdWRlcyhvcHRpb25zLmNhbGxiYWNrVXJpKSkge1xuICAgIC8vIFJlZ2lzdGVyIGEgbmV3IFJQXG4gICAgcnAgPSBhd2FpdCByZWdpc3RlclJwKGlkcCwgb3B0aW9ucyk7XG4gICAgYXdhaXQgc3RvcmVScChvcHRpb25zLnN0b3JhZ2UsIGlkcCwgcnApO1xuICB9XG5cbiAgcmV0dXJuIHJwO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRTdG9yZWRScChzdG9yYWdlKSB7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImdldERhdGFcIl0pKHN0b3JhZ2UpO1xuICBjb25zdCB7XG4gICAgcnBDb25maWdcbiAgfSA9IGRhdGE7XG5cbiAgaWYgKHJwQ29uZmlnKSB7XG4gICAgcnBDb25maWcuc3RvcmUgPSBzdG9yYWdlO1xuICAgIHJldHVybiBfc29saWRfb2lkY19ycF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5mcm9tKHJwQ29uZmlnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzdG9yZVJwKHN0b3JhZ2UsIGlkcCwgcnApIHtcbiAgYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJ1cGRhdGVTdG9yYWdlXCJdKShzdG9yYWdlLCBkYXRhID0+IF9vYmplY3RTcHJlYWQoe30sIGRhdGEsIHtcbiAgICBycENvbmZpZzogcnBcbiAgfSkpO1xuICByZXR1cm4gcnA7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUnAoaWRwLCBvcHRzKSB7XG4gIGNvbnN0IHtcbiAgICBzdG9yYWdlLFxuICAgIGNhbGxiYWNrVXJpXG4gIH0gPSBvcHRzO1xuICBjb25zdCByZXNwb25zZVR5cGUgPSAnaWRfdG9rZW4gdG9rZW4nO1xuICBjb25zdCBjbGllbnROYW1lSTE4biA9IHt9O1xuICBPYmplY3QuZW50cmllcyhvcHRzKS5maWx0ZXIoKF9yZWYpID0+IHtcbiAgICBsZXQgW2tleSwgX10gPSBfcmVmO1xuICAgIHJldHVybiBrZXkuc3RhcnRzV2l0aCgnY2xpZW50TmFtZSMnKTtcbiAgfSkuZm9yRWFjaCgoX3JlZjIpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjI7XG4gICAgcmV0dXJuIGNsaWVudE5hbWVJMThuW2tleS5yZXBsYWNlKCdjbGllbnROYW1lIycsICdjbGllbnRfbmFtZSMnKV0gPSB2YWx1ZTtcbiAgfSk7XG4gIGNvbnN0IHN1cHBsZW1lbnRhcnlPcHRpb25zID0ge1xuICAgIGxvZ29fdXJpOiBvcHRzLmxvZ29VcmksXG4gICAgY29udGFjdHM6IG9wdHMuY29udGFjdHMsXG4gICAgY2xpZW50X25hbWU6IG9wdHMuY2xpZW50TmFtZVxuICB9O1xuXG4gIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IF9vYmplY3RTcHJlYWQoe1xuICAgIGlzc3VlcjogaWRwLFxuICAgIGdyYW50X3R5cGVzOiBbJ2ltcGxpY2l0J10sXG4gICAgcmVkaXJlY3RfdXJpczogW2NhbGxiYWNrVXJpXSxcbiAgICByZXNwb25zZV90eXBlczogW3Jlc3BvbnNlVHlwZV0sXG4gICAgc2NvcGU6ICdvcGVuaWQgcHJvZmlsZSdcbiAgfSwgY2xpZW50TmFtZUkxOG4sIHt9LCBzdXBwbGVtZW50YXJ5T3B0aW9ucyk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBkZWZhdWx0czoge1xuICAgICAgYXV0aGVudGljYXRlOiB7XG4gICAgICAgIHJlZGlyZWN0X3VyaTogY2FsbGJhY2tVcmksXG4gICAgICAgIHJlc3BvbnNlX3R5cGU6IHJlc3BvbnNlVHlwZVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcmU6IHN0b3JhZ2VcbiAgfTtcbiAgcmV0dXJuIF9zb2xpZF9vaWRjX3JwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLnJlZ2lzdGVyKGlkcCwgcmVnaXN0cmF0aW9uLCBvcHRpb25zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2VuZEF1dGhSZXF1ZXN0KHJwLCBfcmVmMykge1xuICBsZXQge1xuICAgIGNhbGxiYWNrVXJpLFxuICAgIHN0b3JhZ2VcbiAgfSA9IF9yZWYzO1xuICBjb25zdCBkYXRhID0gYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJnZXREYXRhXCJdKShzdG9yYWdlKTtcbiAgY29uc3QgdXJsID0gYXdhaXQgcnAuY3JlYXRlUmVxdWVzdCh7XG4gICAgcmVkaXJlY3RfdXJpOiBjYWxsYmFja1VyaVxuICB9LCBkYXRhKTtcbiAgYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJ1cGRhdGVTdG9yYWdlXCJdKShzdG9yYWdlLCAoKSA9PiBkYXRhKTtcbiAgcmV0dXJuIE9iamVjdChfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIm5hdmlnYXRlVG9cIl0pKHVybCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNhdmVBcHBIYXNoRnJhZ21lbnQoc3RvcmUpIHtcbiAgYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJ1cGRhdGVTdG9yYWdlXCJdKShzdG9yZSwgZGF0YSA9PiBfb2JqZWN0U3ByZWFkKHt9LCBkYXRhLCB7XG4gICAgYXBwSGFzaEZyYWdtZW50OiB3aW5kb3cubG9jYXRpb24uaGFzaFxuICB9KSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc3RvcmVBcHBIYXNoRnJhZ21lbnQoc3RvcmUpIHtcbiAgYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJ1cGRhdGVTdG9yYWdlXCJdKShzdG9yZSwgKF9yZWY0KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGFwcEhhc2hGcmFnbWVudCA9ICcnXG4gICAgfSA9IF9yZWY0LFxuICAgICAgICBkYXRhID0gX2JhYmVsX3J1bnRpbWVfaGVscGVyc19vYmplY3RXaXRob3V0UHJvcGVydGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShfcmVmNCwgW1wiYXBwSGFzaEZyYWdtZW50XCJdKTtcblxuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gYXBwSGFzaEZyYWdtZW50O1xuICAgIHJldHVybiBkYXRhO1xuICB9KTtcbn1cbi8qKlxuICogQW5zd2VycyB3aGV0aGVyIGEgSFRUUCByZXNwb25zZSByZXF1aXJlcyBXZWJJRC1PSURDIGF1dGhlbnRpY2F0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gcmVxdWlyZXNBdXRoKHJlc3ApIHtcbiAgaWYgKHJlc3Auc3RhdHVzICE9PSA0MDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCB3d3dBdXRoSGVhZGVyID0gcmVzcC5oZWFkZXJzLmdldCgnd3d3LWF1dGhlbnRpY2F0ZScpO1xuXG4gIGlmICghd3d3QXV0aEhlYWRlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGF1dGggPSBhdXRoX2hlYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wicGFyc2VcIl0od3d3QXV0aEhlYWRlcik7XG4gIHJldHVybiBhdXRoLnNjaGVtZSA9PT0gJ0JlYXJlcicgJiYgYXV0aC5wYXJhbXMgJiYgYXV0aC5wYXJhbXMuc2NvcGUgPT09ICdvcGVuaWQgd2ViaWQnO1xufVxuLyoqXG4gKiBGZXRjaGVzIGEgcmVzb3VyY2UsIHByb3ZpZGluZyB0aGUgV2ViSUQtT0lEQyBJRCBUb2tlbiBhcyBhdXRoZW50aWNhdGlvbi5cbiAqIEFzc3VtZXMgdGhhdCB0aGUgcmVzb3VyY2UgaGFzIHJlcXVlc3RlZCB0aG9zZSB0b2tlbnMgaW4gYSBwcmV2aW91cyByZXNwb25zZS5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhDcmVkZW50aWFscyhzZXNzaW9uLCBmZXRjaCwgaW5wdXQsIG9wdGlvbnMpIHtcbiAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgaGVhZGVyc1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGNvbnN0IG9yaWdIZWFkZXJzID0gb3B0aW9ucyA/IG9wdGlvbnMuaGVhZGVycyA6IGlucHV0LmhlYWRlcnM7XG5cbiAgaWYgKG9yaWdIZWFkZXJzKSB7XG4gICAgY29uc3QgZW50cmllcyA9IHR5cGVvZiBvcmlnSGVhZGVycy5lbnRyaWVzID09PSAnZnVuY3Rpb24nID8gb3JpZ0hlYWRlcnMuZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMob3JpZ0hlYWRlcnMpO1xuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0gLy8gQWRkIEF1dGhvcml6YXRpb24gaGVhZGVyXG5cblxuICBjb25zdCBwb3BUb2tlbiA9IGF3YWl0IF9zb2xpZF9vaWRjX3JwX2xpYl9Qb1BUb2tlbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQuYS5pc3N1ZUZvcihPYmplY3QoX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJ0b1VybFN0cmluZ1wiXSkoaW5wdXQpLCBzZXNzaW9uKTtcbiAgaGVhZGVycy5hdXRob3JpemF0aW9uID0gXCJCZWFyZXIgXCIuY29uY2F0KHBvcFRva2VuKTtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICBoZWFkZXJzXG4gIH0pKTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Zvcm1hdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wYXJzZS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9mb3JtYXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTUpKTtcblxudmFyIF9wYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNykpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG52YXIgeHh4ID0gZnVuY3Rpb24geHh4KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke2tleX09JHt2YWx1ZSAmJiAhKDAsIF91dGlsLmlzVG9rZW4pKHZhbHVlKSA/ICgwLCBfdXRpbC5xdW90ZSkodmFsdWUpIDogdmFsdWV9YDtcbiAgfTtcbn07XG5cbnZhciBidWlsZCA9IGZ1bmN0aW9uIGJ1aWxkKHBhcmFtcykge1xuICByZXR1cm4gcGFyYW1zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgX3JlZikge1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICBrZXkgPSBfcmVmMlswXSxcbiAgICAgICAgdmFsdWVzID0gX3JlZjJbMV07XG5cbiAgICB2YXIgdHJhbnNmb3JtID0geHh4KGtleSk7XG5cbiAgICBpZiAoISgwLCBfdXRpbC5pc1Rva2VuKShrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShwcmV2KS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHZhbHVlcy5tYXAodHJhbnNmb3JtKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkocHJldikuY29uY2F0KFt0cmFuc2Zvcm0odmFsdWVzKV0pO1xuICB9LCBbXSk7XG59O1xuXG52YXIgY2hhbGxlbmdlID0gZnVuY3Rpb24gY2hhbGxlbmdlKHBhcmFtcywgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgcmV0dXJuIGJ1aWxkKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgZW50cmllcyA9IHBhcmFtcztcbiAgICByZXR1cm4gY2hhbGxlbmdlKE9iamVjdC5rZXlzKHBhcmFtcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBlbnRyaWVzW2tleV1dO1xuICAgIH0pLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KHNjaGVtZSwgdG9rZW4sIHBhcmFtcykge1xuICB2YXIgb2JqID0gdHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycgPyB7XG4gICAgc2NoZW1lLFxuICAgIHRva2VuLFxuICAgIHBhcmFtc1xuICB9IDogc2NoZW1lO1xuXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgfSBlbHNlIGlmICghKDAsIF91dGlsLmlzU2NoZW1lKShvYmouc2NoZW1lKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc2NoZW1lLicpO1xuICB9XG5cbiAgcmV0dXJuIFtvYmouc2NoZW1lXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHR5cGVvZiBvYmoudG9rZW4gIT09ICd1bmRlZmluZWQnID8gW29iai50b2tlbl0gOiBbXSksIF90b0NvbnN1bWFibGVBcnJheSh0eXBlb2Ygb2JqLnBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgPyBjaGFsbGVuZ2Uob2JqLnBhcmFtcykgOiBbXSkpLmpvaW4oJyAnKTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcFxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVucXVvdGUgPSBleHBvcnRzLnF1b3RlID0gZXhwb3J0cy5pc1NjaGVtZSA9IGV4cG9ydHMuaXNUb2tlbiA9IHZvaWQgMDtcbnZhciB0b2tlbiA9IC9eW15cXHUwMDAwLVxcdTAwMUZcXHUwMDdGKCk8PkAsOzpcXFxcXCIvPz17fVxcW1xcXVxcdTAwMjBcXHUwMDA5XSskLztcblxudmFyIGlzVG9rZW4gPSBmdW5jdGlvbiBpc1Rva2VuKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgdG9rZW4udGVzdChzdHIpO1xufTtcblxuZXhwb3J0cy5pc1Rva2VuID0gaXNUb2tlbjtcbnZhciBpc1NjaGVtZSA9IGlzVG9rZW47XG5leHBvcnRzLmlzU2NoZW1lID0gaXNTY2hlbWU7XG5cbnZhciBxdW90ZSA9IGZ1bmN0aW9uIHF1b3RlKHN0cikge1xuICByZXR1cm4gYFwiJHtzdHIucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpfVwiYDtcbn07XG5cbmV4cG9ydHMucXVvdGUgPSBxdW90ZTtcblxudmFyIHVucXVvdGUgPSBmdW5jdGlvbiB1bnF1b3RlKHN0cikge1xuICByZXR1cm4gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMikucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xufTtcblxuZXhwb3J0cy51bnF1b3RlID0gdW5xdW90ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbi8vIGxvbCBkaXNcbnZhciBib2R5ID0gLygoPzpbYS16QS1aMC05Ll9+K1xcLy1dKz0qKD86XFxzK3wkKSl8W15cXHUwMDAwLVxcdTAwMUZcXHUwMDdGKCk8PkAsOzpcXFxcXCIvPz17fVxcW1xcXVxcdTAwMjBcXHUwMDA5XSspKD86PShbXlxcXFxcIj1cXHMsXSt8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwiKSk/L2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShwcmV2LCBfY3VyKSB7XG4gIC8vIEZpeHVwIHF1b3RlZCBzdHJpbmdzIGFuZCB0b2tlbnMgd2l0aCBzcGFjZXMgYXJvdW5kIHRoZW1cbiAgdmFyIGN1ciA9IF9jdXIuY2hhckF0KDApID09PSAnXCInID8gKDAsIF91dGlsLnVucXVvdGUpKF9jdXIpIDogX2N1ci50cmltKCk7IC8vIE1hcnNoYWxcblxuICBpZiAoQXJyYXkuaXNBcnJheShwcmV2KSkge1xuICAgIHJldHVybiBwcmV2LmNvbmNhdChjdXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcmV2ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBbcHJldiwgY3VyXTtcbiAgfVxuXG4gIHJldHVybiBjdXI7XG59O1xuXG52YXIgcGFyc2VQcm9wZXJ0aWVzID0gZnVuY3Rpb24gcGFyc2VQcm9wZXJ0aWVzKHNjaGVtZSwgc3RyaW5nKSB7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHZhciBwYXJhbXMgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHJlcyA9IGJvZHkuZXhlYyhzdHJpbmcpO1xuXG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHJlc1syXSkge1xuICAgICAgcGFyYW1zW3Jlc1sxXV0gPSBub3JtYWxpemUocGFyYW1zW3Jlc1sxXV0sIHJlc1syXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gbm9ybWFsaXplKHRva2VuLCByZXNbMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2NoZW1lLFxuICAgIHBhcmFtcyxcbiAgICB0b2tlblxuICB9O1xufTtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlciB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gc3RyLmluZGV4T2YoJyAnKTtcbiAgdmFyIHNjaGVtZSA9IHN0ci5zdWJzdHIoMCwgc3RhcnQpO1xuXG4gIGlmICghKDAsIF91dGlsLmlzU2NoZW1lKShzY2hlbWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzY2hlbWUgJHtzY2hlbWV9YCk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VQcm9wZXJ0aWVzKHNjaGVtZSwgc3RyLnN1YnN0cihzdGFydCkpO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXBcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5jb25zdCBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxuY29uc3QgZmV0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5jb25zdCB7XG4gIFVSTFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG5jb25zdCBIZWFkZXJzID0gZmV0Y2guSGVhZGVycyA/IGZldGNoLkhlYWRlcnMgOiBnbG9iYWwuSGVhZGVycztcblxuY29uc3Qge1xuICBKU09ORG9jdW1lbnRcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuY29uc3Qge1xuICBKV0tTZXRcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxuY29uc3QgQXV0aGVudGljYXRpb25SZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG5cbmNvbnN0IEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuY29uc3QgUmVseWluZ1BhcnR5U2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG5cbmNvbnN0IG9uSHR0cEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cbmNvbnN0IEZvcm1VcmxFbmNvZGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG4vKipcbiAqIFJlbHlpbmdQYXJ0eVxuICpcbiAqIEBjbGFzc1xuICogQ2xpZW50IGludGVyZmFjZSBmb3IgT3BlbklEIENvbm5lY3QgUmVseWluZyBQYXJ0eS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIGxldCBjbGllbnQgPSBSZWx5aW5nUGFydHkoe1xuICogICAgcHJvdmlkZXI6IHtcbiAqICAgICAgbmFtZTogJ0FudmlsIFJlc2VhcmNoLCBJbmMuJyxcbiAqICAgICAgdXJsOiAnaHR0cHM6Ly9mb3JnZS5hbnZpbC5pbydcbiAqICAgICAgLy8gY29uZmlndXJhdGlvblxuICogICAgICAvLyBqd2tzXG4gKiAgICB9LFxuICogICAgZGVmYXVsdHM6IHtcbiAqICAgICAgcG9wVG9rZW46IGZhbHNlLFxuICogICAgICBhdXRoZW50aWNhdGU6IHtcbiAqICAgICAgICByZXNwb25zZV90eXBlOiAnY29kZScsXG4gKiAgICAgICAgZGlzcGxheTogJ3BvcHVwJyxcbiAqICAgICAgICBzY29wZTogJ29wZW5pZCBwcm9maWxlIGVtYWlsJ1xuICogICAgICB9LFxuICogICAgICByZWdpc3Rlcjoge1xuICogICAgICAgIGNsaWVudF9uYW1lOiAnRXhhbXBsZScsXG4gKiAgICAgICAgY2xpZW50X3VyaTogJ2h0dHBzOi8vZXhhbXBsZS5jb20nLFxuICogICAgICAgIGxvZ29fdXJpOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9hc3NldHMvbG9nby5wbmcnLFxuICogICAgICAgIHJlZGlyZWN0X3VyaXM6IFsnaHR0cHM6Ly9hcHAuZXhhbXBsZS5jb20vY2FsbGJhY2snXSxcbiAqICAgICAgICByZXNwb25zZV90eXBlczogWydjb2RlJywgJ2NvZGUgaWRfdG9rZW4gdG9rZW4nXSxcbiAqICAgICAgICBncmFudF90eXBlczogWydhdXRob3JpemF0aW9uX2NvZGUnXSxcbiAqICAgICAgICBkZWZhdWx0X21heF9hZ2U6IDcyMDAsXG4gKiAgICAgICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpczogWydodHRwczovL2FwcC5leGFtcGxlLmNvbSddXG4gKiAgICAgIH0sXG4gKiAgICB9LFxuICogICAgcmVnaXN0cmF0aW9uOiB7XG4gKiAgICAgIC8vIGlmIHlvdSBoYXZlIGl0IHNhdmVkIHNvbWV3aGVyZVxuICogICAgfSxcbiAqICAgIHN0b3JlOiBsb2NhbFN0b3JhZ2UgfHwgcmVxLnNlc3Npb25cbiAqICB9KVxuICpcbiAqICBjbGllbnQuZGlzY292ZXIoKSA9PiBQcm9taXNlXG4gKiAgY2xpZW50Lmp3a3MoKSA9PiBQcm9taXNlXG4gKiAgY2xpZW50LmF1dGhlbnRpY2F0ZSgpXG4gKiAgY2xpZW50LmF1dGhlbnRpY2F0ZVVyaSgpXG4gKiAgY2xpZW50LnZhbGlkYXRlUmVzcG9uc2UodXJpKSA9PiBQcm9taXNlXG4gKiAgY2xpZW50LnVzZXJpbmZvKCkgPT4gUHJvbWlzZVxuICogIGNsaWVudC5sb2dvdXQoKVxuICovXG5cblxuY2xhc3MgUmVseWluZ1BhcnR5IGV4dGVuZHMgSlNPTkRvY3VtZW50IHtcbiAgLyoqXG4gICAqIFNjaGVtYVxuICAgKi9cbiAgc3RhdGljIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIFJlbHlpbmdQYXJ0eVNjaGVtYTtcbiAgfVxuICAvKipcbiAgICogZnJvbVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlIGEgUmVseWluZ1BhcnR5IGluc3RhbmNlIGZyb20gYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWx5aW5nUGFydHk+fVxuICAgKi9cblxuXG4gIHN0YXRpYyBmcm9tKGRhdGEpIHtcbiAgICBsZXQgcnAgPSBuZXcgUmVseWluZ1BhcnR5KGRhdGEpO1xuICAgIGxldCB2YWxpZGF0aW9uID0gcnAudmFsaWRhdGUoKTsgLy8gc2NoZW1hIHZhbGlkYXRpb25cblxuICAgIGlmICghdmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uKSkpO1xuICAgIH1cblxuICAgIGxldCBqd2tzID0gcnAucHJvdmlkZXIuandrczsgLy8gcmVxdWVzdCB0aGUgSldLIFNldCBpZiBtaXNzaW5nXG5cbiAgICBpZiAoIWp3a3MpIHtcbiAgICAgIHJldHVybiBycC5qd2tzKCkudGhlbigoKSA9PiBycCk7XG4gICAgfSAvLyBvdGhlcndpc2UgaW1wb3J0IHRoZSBKV0sgU2V0IHRvIHdlYmNyeXB0b1xuXG5cbiAgICByZXR1cm4gSldLU2V0LmltcG9ydEtleXMoandrcykudGhlbihqd2tzID0+IHtcbiAgICAgIHJwLnByb3ZpZGVyLmp3a3MgPSBqd2tzO1xuICAgICAgcmV0dXJuIHJwO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZWdpc3RlclxuICAgKlxuICAgKiBAcGFyYW0gaXNzdWVyIHtzdHJpbmd9IFByb3ZpZGVyIFVSTFxuICAgKiBAcGFyYW0gcmVnaXN0cmF0aW9uIHtPYmplY3R9IENsaWVudCBkeW5hbWljIHJlZ2lzdHJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRzXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5zdG9yZV0ge1Nlc3Npb258U3RvcmFnZX1cbiAgICogQHJldHVybnMge1Byb21pc2U8UmVseWluZ1BhcnR5Pn0gUmVseWluZ1BhcnR5IGluc3RhbmNlLCByZWdpc3RlcmVkLlxuICAgKi9cblxuXG4gIHN0YXRpYyByZWdpc3Rlcihpc3N1ZXIsIHJlZ2lzdHJhdGlvbiwgb3B0aW9ucykge1xuICAgIGxldCBycCA9IG5ldyBSZWx5aW5nUGFydHkoe1xuICAgICAgcHJvdmlkZXI6IHtcbiAgICAgICAgdXJsOiBpc3N1ZXJcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0czogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5kZWZhdWx0cyksXG4gICAgICBzdG9yZTogb3B0aW9ucy5zdG9yZVxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHJwLmRpc2NvdmVyKCkpLnRoZW4oKCkgPT4gcnAuandrcygpKS50aGVuKCgpID0+IHJwLnJlZ2lzdGVyKHJlZ2lzdHJhdGlvbikpLnRoZW4oKCkgPT4gcnApO1xuICB9XG4gIC8qKlxuICAgKiBEaXNjb3ZlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gRmV0Y2hlcyB0aGUgaXNzdWVyJ3MgT3BlbklEIENvbmZpZ3VyYXRpb24uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFJlc29sdmVzIHdpdGggdGhlIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb24gcmVzcG9uc2VcbiAgICovXG5cblxuICBkaXNjb3ZlcigpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGlzc3VlciA9IHRoaXMucHJvdmlkZXIudXJsO1xuICAgICAgYXNzZXJ0KGlzc3VlciwgJ1JlbHlpbmdQYXJ0eSBwcm92aWRlciBtdXN0IGRlZmluZSBcInVybFwiJyk7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChpc3N1ZXIpO1xuICAgICAgdXJsLnBhdGhuYW1lID0gJy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJztcbiAgICAgIHJldHVybiBmZXRjaCh1cmwudG9TdHJpbmcoKSkudGhlbihvbkh0dHBFcnJvcignRXJyb3IgZmV0Y2hpbmcgb3BlbmlkIGNvbmZpZ3VyYXRpb24nKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCkudGhlbihqc29uID0+IHRoaXMucHJvdmlkZXIuY29uZmlndXJhdGlvbiA9IGpzb24pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXIncyBhIGNsaWVudCB3aXRoIHByb3ZpZGVyIGFzIGEgUmVseWluZyBQYXJ0eVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSZXNvbHZlcyB3aXRoIHRoZSByZWdpc3RyYXRpb24gcmVzcG9uc2Ugb2JqZWN0XG4gICAqL1xuXG5cbiAgcmVnaXN0ZXIob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHRoaXMucHJvdmlkZXIuY29uZmlndXJhdGlvbjtcbiAgICAgIGFzc2VydChjb25maWd1cmF0aW9uLCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgICAgYXNzZXJ0KGNvbmZpZ3VyYXRpb24ucmVnaXN0cmF0aW9uX2VuZHBvaW50LCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbWlzc2luZyByZWdpc3RyYXRpb25fZW5kcG9pbnQuJyk7XG4gICAgICBsZXQgdXJpID0gY29uZmlndXJhdGlvbi5yZWdpc3RyYXRpb25fZW5kcG9pbnQ7XG4gICAgICBsZXQgbWV0aG9kID0gJ3Bvc3QnO1xuICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0pO1xuICAgICAgbGV0IHBhcmFtcyA9IHRoaXMuZGVmYXVsdHMucmVnaXN0ZXI7XG4gICAgICBsZXQgYm9keSA9IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcywgb3B0aW9ucykpO1xuICAgICAgcmV0dXJuIGZldGNoKHVyaSwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHlcbiAgICAgIH0pLnRoZW4ob25IdHRwRXJyb3IoJ0Vycm9yIHJlZ2lzdGVyaW5nIGNsaWVudCcpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKS50aGVuKGpzb24gPT4gdGhpcy5yZWdpc3RyYXRpb24gPSBqc29uKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIGp3a3NcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIFByb21pc2VzIHRoZSBpc3N1ZXIncyBKV0sgU2V0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBqd2tzKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHRoaXMucHJvdmlkZXIuY29uZmlndXJhdGlvbjtcbiAgICAgIGFzc2VydChjb25maWd1cmF0aW9uLCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgICAgYXNzZXJ0KGNvbmZpZ3VyYXRpb24uandrc191cmksICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBtaXNzaW5nIGp3a3NfdXJpLicpO1xuICAgICAgbGV0IHVyaSA9IGNvbmZpZ3VyYXRpb24uandrc191cmk7XG4gICAgICByZXR1cm4gZmV0Y2godXJpKS50aGVuKG9uSHR0cEVycm9yKCdFcnJvciByZXNvbHZpbmcgcHJvdmlkZXIga2V5cycpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKS50aGVuKGpzb24gPT4gSldLU2V0LmltcG9ydEtleXMoanNvbikpLnRoZW4oandrcyA9PiB0aGlzLnByb3ZpZGVyLmp3a3MgPSBqd2tzKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogY3JlYXRlUmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBBdXRobiByZXF1ZXN0IG9wdGlvbnMgaGFzaG1hcFxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdF91cmkge3N0cmluZ31cbiAgICogQHBhcmFtIG9wdGlvbnMucmVzcG9uc2VfdHlwZSB7c3RyaW5nfSBlLmcuICdjb2RlJyBvciAnaWRfdG9rZW4gdG9rZW4nXG4gICAqIEBwYXJhbSBzZXNzaW9uIHtTZXNzaW9ufFN0b3JhZ2V9IHJlcS5zZXNzaW9uIG9yIGxvY2FsU3RvcmFnZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBdXRobiByZXF1ZXN0IFVSTFxuICAgKi9cblxuXG4gIGNyZWF0ZVJlcXVlc3Qob3B0aW9ucywgc2Vzc2lvbikge1xuICAgIHJldHVybiBBdXRoZW50aWNhdGlvblJlcXVlc3QuY3JlYXRlKHRoaXMsIG9wdGlvbnMsIHNlc3Npb24gfHwgdGhpcy5zdG9yZSk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIFJlc3BvbnNlXG4gICAqXG4gICAqIEBwYXJhbSByZXNwb25zZSB7c3RyaW5nfSByZXEucXVlcnkgb3IgcmVxLmJvZHkudGV4dFxuICAgKiBAcGFyYW0gc2Vzc2lvbiB7U2Vzc2lvbnxTdG9yYWdlfSByZXEuc2Vzc2lvbiBvciBsb2NhbFN0b3JhZ2Ugb3Igc2ltaWxhclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXNzaW9uPn1cbiAgICovXG5cblxuICB2YWxpZGF0ZVJlc3BvbnNlKHJlc3BvbnNlLCBzZXNzaW9uID0gdGhpcy5zdG9yZSkge1xuICAgIGxldCBvcHRpb25zO1xuXG4gICAgaWYgKHJlc3BvbnNlLm1hdGNoKC9eaHR0cChzPyk6XFwvXFwvLykpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHJwOiB0aGlzLFxuICAgICAgICByZWRpcmVjdDogcmVzcG9uc2UsXG4gICAgICAgIHNlc3Npb25cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHJwOiB0aGlzLFxuICAgICAgICBib2R5OiByZXNwb25zZSxcbiAgICAgICAgc2Vzc2lvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBhdXRoUmVzcG9uc2UgPSBuZXcgQXV0aGVudGljYXRpb25SZXNwb25zZShvcHRpb25zKTtcbiAgICByZXR1cm4gQXV0aGVudGljYXRpb25SZXNwb25zZS52YWxpZGF0ZVJlc3BvbnNlKGF1dGhSZXNwb25zZSk7XG4gIH1cbiAgLyoqXG4gICAqIHVzZXJpbmZvXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBQcm9taXNlcyB0aGUgYXV0aGVudGljYXRlZCB1c2VyJ3MgY2xhaW1zLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICB1c2VyaW5mbygpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLnByb3ZpZGVyLmNvbmZpZ3VyYXRpb247XG4gICAgICBhc3NlcnQoY29uZmlndXJhdGlvbiwgJ09wZW5JRCBDb25maWd1cmF0aW9uIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICAgIGFzc2VydChjb25maWd1cmF0aW9uLnVzZXJpbmZvX2VuZHBvaW50LCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbWlzc2luZyB1c2VyaW5mb19lbmRwb2ludC4nKTtcbiAgICAgIGxldCB1cmkgPSBjb25maWd1cmF0aW9uLnVzZXJpbmZvX2VuZHBvaW50O1xuICAgICAgbGV0IGFjY2Vzc190b2tlbiA9IHRoaXMuc3RvcmUuYWNjZXNzX3Rva2VuO1xuICAgICAgYXNzZXJ0KGFjY2Vzc190b2tlbiwgJ01pc3NpbmcgYWNjZXNzIHRva2VuLicpO1xuICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2FjY2Vzc190b2tlbn1gXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmZXRjaCh1cmksIHtcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSkudGhlbihvbkh0dHBFcnJvcignRXJyb3IgZmV0Y2hpbmcgdXNlcmluZm8nKSkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogbG9nb3V0UmVxdWVzdFxuICAgKlxuICAgKiBDb21wb3NlcyBhbmQgcmV0dXJucyB0aGUgbG9nb3V0IHJlcXVlc3QgVVJJLCBiYXNlZCBvbiB0aGUgT1Anc1xuICAgKiBgZW5kX3Nlc3Npb25fZW5kcG9pbnRgLCB3aXRoIGFwcHJvcHJpYXRlIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIE5vdGU6IENhbGxpbmcgY2xpZW50IGNvZGUgaGFzIHRoZSByZXNwb25zaWJpbGl0eSB0byBjbGVhciB0aGUgbG9jYWxcbiAgICogc2Vzc2lvbiBzdGF0ZSAoZm9yIGV4YW1wbGUsIGJ5IGNhbGxpbmcgYHJwLmNsZWFyU2Vzc2lvbigpYCkuIEluIGFkZGl0aW9uLFxuICAgKiBzb21lIElkUHMgKHN1Y2ggYXMgR29vZ2xlKSBtYXkgbm90IHByb3ZpZGUgYW4gYGVuZF9zZXNzaW9uX2VuZHBvaW50YCxcbiAgICogaW4gd2hpY2ggY2FzZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gbnVsbC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3Qtc2Vzc2lvbi0xXzAuaHRtbCNSUExvZ291dFxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcHJvdmlkZXIgY29uZmlnIGlzIG5vdCBpbml0aWFsaXplZFxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaWAgd2FzIHByb3ZpZGVkIHdpdGhvdXQgYVxuICAgKiAgIGNvcnJlc3BvbmRpbmcgYGlkX3Rva2VuX2hpbnRgXG4gICAqXG4gICAqIEBwYXJhbSBbb3B0aW9ucz17fV0ge29iamVjdH1cbiAgICpcbiAgICogQHBhcmFtIFtvcHRpb25zLmlkX3Rva2VuX2hpbnRdIHtzdHJpbmd9IFJFQ09NTUVOREVELlxuICAgKiAgIFByZXZpb3VzbHkgaXNzdWVkIElEIFRva2VuIHBhc3NlZCB0byB0aGUgbG9nb3V0IGVuZHBvaW50IGFzXG4gICAqICAgYSBoaW50IGFib3V0IHRoZSBFbmQtVXNlcidzIGN1cnJlbnQgYXV0aGVudGljYXRlZCBzZXNzaW9uIHdpdGggdGhlXG4gICAqICAgQ2xpZW50LiBUaGlzIGlzIHVzZWQgYXMgYW4gaW5kaWNhdGlvbiBvZiB0aGUgaWRlbnRpdHkgb2YgdGhlIEVuZC1Vc2VyXG4gICAqICAgdGhhdCB0aGUgUlAgaXMgcmVxdWVzdGluZyBiZSBsb2dnZWQgb3V0IGJ5IHRoZSBPUC4gVGhlIE9QICpuZWVkIG5vdCogYmVcbiAgICogICBsaXN0ZWQgYXMgYW4gYXVkaWVuY2Ugb2YgdGhlIElEIFRva2VuIHdoZW4gaXQgaXMgdXNlZCBhcyBhblxuICAgKiAgIGBpZF90b2tlbl9oaW50YCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIFtvcHRpb25zLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaV0ge3N0cmluZ30gT1BUSU9OQUwuIFVSTCB0byB3aGljaFxuICAgKiAgIHRoZSBSUCBpcyByZXF1ZXN0aW5nIHRoYXQgdGhlIEVuZC1Vc2VyJ3MgVXNlciBBZ2VudCBiZSByZWRpcmVjdGVkIGFmdGVyXG4gICAqICAgYSBsb2dvdXQgaGFzIGJlZW4gcGVyZm9ybWVkLiBUaGUgdmFsdWUgTVVTVCBoYXZlIGJlZW4gcHJldmlvdXNseVxuICAgKiAgIHJlZ2lzdGVyZWQgd2l0aCB0aGUgT1AsIGVpdGhlciB1c2luZyB0aGUgYHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaXNgXG4gICAqICAgUmVnaXN0cmF0aW9uIHBhcmFtZXRlciBvciB2aWEgYW5vdGhlciBtZWNoYW5pc20uIElmIHN1cHBsaWVkLCB0aGUgT1BcbiAgICogICBTSE9VTEQgaG9ub3IgdGhpcyByZXF1ZXN0IGZvbGxvd2luZyB0aGUgbG9nb3V0LlxuICAgKlxuICAgKiAgIE5vdGU6IFRoZSByZXF1aXJlbWVudCB0byB2YWxpZGF0ZSB0aGUgdXJpIGZvciBwcmV2aW91cyByZWdpc3RyYXRpb24gbWVhbnNcbiAgICogICB0aGF0LCBpbiBwcmFjdGljZSwgdGhlIGBpZF90b2tlbl9oaW50YCBpcyBSRVFVSVJFRCBpZlxuICAgKiAgIGBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmlgIGlzIHVzZWQuIE90aGVyd2lzZSwgdGhlIE9QIGhhcyBubyB3YXkgdG8gZ2V0XG4gICAqICAgdGhlIGBjbGllbnRfaWRgIHRvIGxvYWQgdGhlIHNhdmVkIGNsaWVudCByZWdpc3RyYXRpb24sIHRvIHZhbGlkYXRlIHRoZVxuICAgKiAgIHVyaS4gVGhlIG9ubHkgd2F5IGl0IGNhbiBnZXQgaXQgaXMgYnkgZGVjb2RpbmcgdGhlIGBpZF90b2tlbl9oaW50YC5cbiAgICpcbiAgICogQHBhcmFtIFtvcHRpb25zLnN0YXRlXSB7c3RyaW5nfSBPUFRJT05BTC4gT3BhcXVlIHZhbHVlIHVzZWQgYnkgdGhlIFJQIHRvXG4gICAqICAgbWFpbnRhaW4gc3RhdGUgYmV0d2VlbiB0aGUgbG9nb3V0IHJlcXVlc3QgYW5kIHRoZSBjYWxsYmFjayB0byB0aGVcbiAgICogICBlbmRwb2ludCBzcGVjaWZpZWQgYnkgdGhlIGBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmlgIHF1ZXJ5IHBhcmFtZXRlci4gSWZcbiAgICogICBpbmNsdWRlZCBpbiB0aGUgbG9nb3V0IHJlcXVlc3QsIHRoZSBPUCBwYXNzZXMgdGhpcyB2YWx1ZSBiYWNrIHRvIHRoZSBSUFxuICAgKiAgIHVzaW5nIHRoZSBgc3RhdGVgIHF1ZXJ5IHBhcmFtZXRlciB3aGVuIHJlZGlyZWN0aW5nIHRoZSBVc2VyIEFnZW50IGJhY2sgdG9cbiAgICogICB0aGUgUlAuXG4gICAqXG4gICAqIFRPRE86IEluIHRoZSBmdXR1cmUsIGNvbnNpZGVyIGFkZGluZyBgcmVzcG9uc2VfbW9kZWAgcGFyYW0sIGZvciB0aGUgT1AgdG9cbiAgICogICBkZXRlcm1pbmUgaG93IHRvIHJldHVybiB0aGUgYHN0YXRlYCBiYWNrIHRoZSBSUC5cbiAgICogICBAc2VlIGh0dHA6Ly9vcGVuaWQubmV0L3NwZWNzL29hdXRoLXYyLW11bHRpcGxlLXJlc3BvbnNlLXR5cGVzLTFfMC5odG1sI1Jlc3BvbnNlTW9kZXNcbiAgICpcbiAgICogVE9ETzogSGFuZGxlIHNwZWNpYWwgY2FzZXMgZm9yIHBvcHVsYXIgcHJvdmlkZXJzIChHb29nbGUsIE1TRlQpXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gTG9nb3V0IHVyaSAob3IgbnVsbCBpZiBubyBlbmRfc2Vzc2lvbl9lbmRwb2ludCB3YXNcbiAgICogICBwcm92aWRlZCBpbiB0aGUgSWRQIGNvbmZpZylcbiAgICovXG5cblxuICBsb2dvdXRSZXF1ZXN0KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmksXG4gICAgICBzdGF0ZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGxldCBjb25maWd1cmF0aW9uO1xuICAgIGFzc2VydCh0aGlzLnByb3ZpZGVyLCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgY29uZmlndXJhdGlvbiA9IHRoaXMucHJvdmlkZXIuY29uZmlndXJhdGlvbjtcbiAgICBhc3NlcnQoY29uZmlndXJhdGlvbiwgJ09wZW5JRCBDb25maWd1cmF0aW9uIGlzIG5vdCBpbml0aWFsaXplZCcpO1xuXG4gICAgaWYgKCFjb25maWd1cmF0aW9uLmVuZF9zZXNzaW9uX2VuZHBvaW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhgT3BlbklkIENvbmZpZ3VyYXRpb24gZm9yIGAgKyBgJHtjb25maWd1cmF0aW9uLmlzc3Vlcn0gaXMgbWlzc2luZyBlbmRfc2Vzc2lvbl9lbmRwb2ludGApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSAmJiAhaWRfdG9rZW5faGludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpZF90b2tlbl9oaW50IGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgICBpZiAoaWRfdG9rZW5faGludCkge1xuICAgICAgcGFyYW1zLmlkX3Rva2VuX2hpbnQgPSBpZF90b2tlbl9oaW50O1xuICAgIH1cblxuICAgIGlmIChwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkpIHtcbiAgICAgIHBhcmFtcy5wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgPSBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBwYXJhbXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNvbmZpZ3VyYXRpb24uZW5kX3Nlc3Npb25fZW5kcG9pbnQpO1xuICAgIHVybC5zZWFyY2ggPSBGb3JtVXJsRW5jb2RlZC5lbmNvZGUocGFyYW1zKTtcbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH1cbiAgLyoqXG4gICAqIExvZ291dFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKlxuICAgKiBUT0RPOiBBZGQgZGVwcmVjYXRpb24gd2FybmluZ3MsIHRoZW4gcmVtb3ZlLiBDbGllbnQgY29kZSBzaG91bGRcbiAgICogICB1c2UgYGxvZ291dFJlcXVlc3QoKWAgaW5zdGVhZFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBsb2dvdXQoKSB7XG4gICAgbGV0IGNvbmZpZ3VyYXRpb247XG5cbiAgICB0cnkge1xuICAgICAgYXNzZXJ0KHRoaXMucHJvdmlkZXIsICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICBjb25maWd1cmF0aW9uID0gdGhpcy5wcm92aWRlci5jb25maWd1cmF0aW9uO1xuICAgICAgYXNzZXJ0KGNvbmZpZ3VyYXRpb24sICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICBhc3NlcnQoY29uZmlndXJhdGlvbi5lbmRfc2Vzc2lvbl9lbmRwb2ludCwgJ09wZW5JRCBDb25maWd1cmF0aW9uIGlzIG1pc3NpbmcgZW5kX3Nlc3Npb25fZW5kcG9pbnQuJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKCFjb25maWd1cmF0aW9uLmVuZF9zZXNzaW9uX2VuZHBvaW50KSB7XG4gICAgICB0aGlzLmNsZWFyU2Vzc2lvbigpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIGxldCB1cmkgPSBjb25maWd1cmF0aW9uLmVuZF9zZXNzaW9uX2VuZHBvaW50O1xuICAgIGxldCBtZXRob2QgPSAnZ2V0JztcbiAgICByZXR1cm4gZmV0Y2godXJpLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnXG4gICAgfSkudGhlbihvbkh0dHBFcnJvcignRXJyb3IgbG9nZ2luZyBvdXQnKSkudGhlbigoKSA9PiB0aGlzLmNsZWFyU2Vzc2lvbigpKTsgLy8gVE9ETzogVmFsaWRhdGUgYGZyb250Y2hhbm5lbF9sb2dvdXRfdXJpYCBpZiBuZWNlc3NhcnlcblxuICAgIC8qKlxuICAgICAqIGZyb250Y2hhbm5lbF9sb2dvdXRfdXJpIC0gT1BUSU9OQUwuIFJQIFVSTCB0aGF0IHdpbGwgY2F1c2UgdGhlIFJQIHRvIGxvZ1xuICAgICAqIGl0c2VsZiBvdXQgd2hlbiByZW5kZXJlZCBpbiBhbiBpZnJhbWUgYnkgdGhlIE9QLlxuICAgICAqXG4gICAgICogQW4gYGlzc2AgKGlzc3VlcikgcXVlcnkgcGFyYW1ldGVyIGFuZCBhIGBzaWRgXG4gICAgICogKHNlc3Npb24gSUQpIHF1ZXJ5IHBhcmFtZXRlciBNQVkgYmUgaW5jbHVkZWQgYnkgdGhlIE9QIHRvIGVuYWJsZSB0aGUgUlBcbiAgICAgKiB0byB2YWxpZGF0ZSB0aGUgcmVxdWVzdCBhbmQgdG8gZGV0ZXJtaW5lIHdoaWNoIG9mIHRoZSBwb3RlbnRpYWxseVxuICAgICAqIG11bHRpcGxlIHNlc3Npb25zIGlzIHRvIGJlIGxvZ2dlZCBvdXQuIElmIGEgc2lkIChzZXNzaW9uIElEKSBxdWVyeVxuICAgICAqIHBhcmFtZXRlciBpcyBpbmNsdWRlZCwgYW4gaXNzIChpc3N1ZXIpIHF1ZXJ5IHBhcmFtZXRlciBNVVNUIGFsc28gYmVcbiAgICAgKiBpbmNsdWRlZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vb3BlbmlkLm5ldC9zcGVjcy9vcGVuaWQtY29ubmVjdC1mcm9udGNoYW5uZWwtMV8wLmh0bWwjUlBMb2dvdXRcbiAgICAgKi9cbiAgfVxuXG4gIGNsZWFyU2Vzc2lvbigpIHtcbiAgICBsZXQgc2Vzc2lvbiA9IHRoaXMuc3RvcmU7XG5cbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgc2Vzc2lvbltTRVNTSU9OX1BSSVZBVEVfS0VZXTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHVyaSB7c3RyaW5nfSBUYXJnZXQgUmVzb3VyY2UgU2VydmVyIFVSSVxuICAgKiBAcGFyYW0gaWRUb2tlbiB7SURUb2tlbn0gSUQgVG9rZW4gdG8gYmUgZW1iZWRkZWQgaW4gdGhlIFBvUCB0b2tlblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQb1BUb2tlbj59XG4gICAqL1xuXG5cbiAgcG9wVG9rZW5Gb3IodXJpLCBpZFRva2VuKSB7XG4gICAgcmV0dXJuIFBvUFRva2VuLmlzc3VlRm9yKHVyaSwgaWRUb2tlbik7XG4gIH1cblxufVxuXG5jb25zdCBTRVNTSU9OX1BSSVZBVEVfS0VZID0gJ29pZGMuc2Vzc2lvbi5wcml2YXRlS2V5JztcblJlbHlpbmdQYXJ0eS5TRVNTSU9OX1BSSVZBVEVfS0VZID0gU0VTU0lPTl9QUklWQVRFX0tFWTtcbm1vZHVsZS5leHBvcnRzID0gUmVseWluZ1BhcnR5O1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMjApKSlcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblxudmFyIG9iamVjdEFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG4vLyBjb21wYXJlIGFuZCBpc0J1ZmZlciB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgdHlwZW9mIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgfVxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn1cblxuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcbi8vIE5COiBUaGUgVVJMIHRvIHRoZSBDb21tb25KUyBzcGVjIGlzIGtlcHQganVzdCBmb3IgdHJhZGl0aW9uLlxuLy8gICAgIG5vZGUtYXNzZXJ0IGhhcyBldm9sdmVkIGEgbG90IHNpbmNlIHRoZW4sIGJvdGggaW4gQVBJIGFuZCBiZWhhdmlvci5cblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG4vLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuZnVuY3Rpb24gc3RyaWN0KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIHN0cmljdCk7XG59XG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSkpXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsLCByZXQpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQsIHJlaiwgY2IpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyNCkpKVxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4oZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W1wid2luZG93XCJdOyB9KCkpO1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGb3JtYXRzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KSxcbiAgSW5pdGlhbGl6ZXI6IF9fd2VicGFja19yZXF1aXJlX18oMzApLFxuICBKU09ORG9jdW1lbnQ6IF9fd2VicGFja19yZXF1aXJlX18oMzEpLFxuICBKU09OTWFwcGluZzogX193ZWJwYWNrX3JlcXVpcmVfXygzNCksXG4gIEpTT05QYXRjaDogX193ZWJwYWNrX3JlcXVpcmVfXygzMiksXG4gIEpTT05Qb2ludGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSxcbiAgSlNPTlNjaGVtYTogX193ZWJwYWNrX3JlcXVpcmVfXygzNSksXG4gIFZhbGlkYXRvcjogX193ZWJwYWNrX3JlcXVpcmVfXygzNilcbn07XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBKU09OIFNjaGVtYSBGb3JtYXRzXG4gKlxuICogVE9ET1xuICogSXMgdGhlcmUgYSBnb29kIHdheSB0byBleHByZXNzIHRoZXNlIG92ZXIgbXVsdGlwbGUgbGluZXMgd2l0aCBjb21tZW50c1xuICogZm9yIGVhc2llciBkZWJ1Z2dpbmcgYW5kIGF1ZGl0aW5nP1xuICovXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEQVRFVElNRV9SRUdFWFAgPSAvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXVswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkOlxcZFxcZCkkL2k7XG52YXIgVVJJX1JFR0VYUCA9IC9eKD86W2Etel1bYS16MC05Ky0uXSopPyg/OlxcOnxcXC8pXFwvP1teXFxzXSokL2k7XG52YXIgRU1BSUxfUkVHRVhQID0gL15bYS16MC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykqJC9pO1xudmFyIElQVjRfUkVHRVhQID0gL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykkLztcbnZhciBJUFY2X1JFR0VYUCA9IC9eXFxzKig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs3fSg/OlswLTlhLWZdezEsNH18OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs2fSg/OjpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwyfSl8Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NH0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwzfSl8KD86KD86OlswLTlhLWZdezEsNH0pPzooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXszfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDR9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwyfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsyfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDV9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwzfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsxfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw0fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/OjooPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw3fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNX06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoPzolLispP1xccyokL2k7XG52YXIgSE9TVE5BTUVfUkVHRVhQID0gL15bYS16XSg/Oig/OlstMC05YS16XXswLDYxfSk/WzAtOWEtel0pPyhcXC5bYS16XSg/Oig/OlstMC05YS16XXswLDYxfSk/WzAtOWEtel0pPykqJC9pO1xuXG4vKipcbiAqIEZvcm1hdHNcbiAqL1xuXG52YXIgRm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9ybWF0cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybWF0cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRm9ybWF0cywgW3tcbiAgICBrZXk6ICdyZWdpc3RlcicsXG5cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZWdpc3RlciBhIG5ldyBtYXBwaW5nIGZyb20gbmFtZWQgZm9ybWF0IHRvIFJlZ0V4cCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogVE9ET1xuICAgICAqIFdlIGNhbiBkbyBzb21lIGV4dHJhIHZhbGlkYXRpb24gb2YgdGhlIFJlZ0V4cCB0b1xuICAgICAqIGVuc3VyZSBpdCdzIHRoZSBhY2NlcHRhYmxlIHN1YnNldCBvZiBSZWdFeHBzIGFsbG93ZWRcbiAgICAgKiBieSBKU09OIFNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAgICAgKiBAcmV0dXJucyB7UmVnRXhwfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcihuYW1lLCBwYXR0ZXJuKSB7XG4gICAgICAvLyB2ZXJpZnkgbmFtZSBpcyBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBuYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FzdCBhIHN0cmluZyB0byBSZWdFeHBcbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW25hbWVdID0gcGF0dGVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBHaXZlbiBhIGZvcm1hdCBuYW1lLCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVnaXN0ZXJlZCB2YWxpZGF0aW9uLiBJbiB0aGVcbiAgICAgKiBldmVudCBhIGZvcm1hdCBpcyBub3QgcmVnaXN0ZXJlZCwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc29sdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKG5hbWUpIHtcbiAgICAgIHZhciBmb3JtYXQgPSB0aGlzW25hbWVdO1xuXG4gICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gSlNPTiBTY2hlbWEgZm9ybWF0LicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRlc3QgdGhhdCBhIHZhbHVlIGNvbmZvcm1zIHRvIGEgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndGVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlc3QobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBmb3JtYXQgPSB0aGlzLnJlc29sdmUobmFtZSk7XG4gICAgICByZXR1cm4gZm9ybWF0LnRlc3QodmFsdWUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZScsXG5cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIENyZWF0ZSBhIG5ldyBGb3JtYXRzIGluc3RhbmNlIGFuZCByZWdpc3RlciBkZWZhdWx0IGZvcm1hdHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGb3JtYXRzfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgdmFyIGZvcm1hdHMgPSBuZXcgRm9ybWF0cygpO1xuICAgICAgZm9ybWF0cy5yZWdpc3RlcignZGF0ZS10aW1lJywgREFURVRJTUVfUkVHRVhQKTtcbiAgICAgIGZvcm1hdHMucmVnaXN0ZXIoJ3VyaScsIFVSSV9SRUdFWFApO1xuICAgICAgZm9ybWF0cy5yZWdpc3RlcignZW1haWwnLCBFTUFJTF9SRUdFWFApO1xuICAgICAgZm9ybWF0cy5yZWdpc3RlcignaXB2NCcsIElQVjRfUkVHRVhQKTtcbiAgICAgIGZvcm1hdHMucmVnaXN0ZXIoJ2lwdjYnLCBJUFY2X1JFR0VYUCk7XG4gICAgICBmb3JtYXRzLnJlZ2lzdGVyKCdob3N0bmFtZScsIEhPU1ROQU1FX1JFR0VYUCk7XG4gICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9ybWF0cztcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybWF0cy5pbml0aWFsaXplKCk7XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBJbml0aWFsaXplclxuICovXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEluaXRpYWxpemVyID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gSW5pdGlhbGl6ZXIoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluaXRpYWxpemVyKTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyB8fCB7fSk7XG4gICAgdGhpcy5yb290ID0gdGhpcy5yb290IHx8IHRoaXM7XG5cbiAgICB0aGlzLnJvb3QuZGVwdGggPSB0aGlzLnJvb3QuZGVwdGggfHwgMTtcblxuICAgIGlmICh0aGlzLmxldmVsID4gdGhpcy5yb290LmRlcHRoKSB7XG4gICAgICB0aGlzLnJvb3QuZGVwdGggPSB0aGlzLmxldmVsO1xuICAgIH1cblxuICAgIHRoaXMubGV2ZWwgPSB0aGlzLmxldmVsIHx8IDA7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIH1cblxuICAvKipcbiAgICogY29tcGlsZSAoc3RhdGljKVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhJbml0aWFsaXplciwgW3tcbiAgICBrZXk6ICdjb21waWxlJyxcblxuXG4gICAgLyoqXG4gICAgICogY29tcGlsZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlKCkge1xuICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QsXG4gICAgICAgICAgZGVwdGggPSB0aGlzLmRlcHRoLFxuICAgICAgICAgIGxldmVsID0gdGhpcy5sZXZlbDtcblxuICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9ICcnO1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgLy8gdHJhdmVyc2UgdGhlIHNjaGVtYSBhbmQgZ2VuZXJhdGUgY29kZVxuICAgICAgYm9keSArPSB0aGlzLmRlZmF1bHQoKTtcbiAgICAgIGJvZHkgKz0gdGhpcy5wcm9wZXJ0aWVzKCk7XG4gICAgICAvL2JvZHkgKz0gdGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcygpXG4gICAgICBib2R5ICs9IHRoaXMuaXRlbXMoKTtcbiAgICAgIC8vYm9keSArPSB0aGlzLmFkZGl0aW9uYWxJdGVtcygpXG5cblxuICAgICAgLy8gdmFsdWVcbiAgICAgIGJvZHkgKz0gdGhpcy5tZW1iZXIoKTtcbiAgICAgIGJvZHkgKz0gdGhpcy5pdGVtKCk7XG5cbiAgICAgIC8vIGFmdGVyIHRyYXZlcnNpbmcgdGhlIHNjaGVtYVxuICAgICAgLy8gZ2VuZXJhdGUgdGhlIHZhcmlhYmxlIGRlY2xhcmF0aW9uc1xuICAgICAgaWYgKHJvb3QgPT09IHRoaXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5yb290LmRlcHRoOyBpKyspIHtcbiAgICAgICAgICBkZWNsYXJhdGlvbnMgKz0gdGhpcy5kZWNsYXJhdGlvbihpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnXFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxcblxcbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyID09PSBmYWxzZSkge1xcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzb3VyY2UpKSlcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICcgKyBkZWNsYXJhdGlvbnMgKyAnXFxuICAgICAgICAnICsgYm9keSArICdcXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZWNsYXJhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWNsYXJhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY2xhcmF0aW9uKGxldmVsKSB7XG4gICAgICByZXR1cm4gJ1xcbiAgICAgIHZhciB0YXJnZXQnICsgbGV2ZWwgKyAnXFxuICAgICAgdmFyIHNvdXJjZScgKyBsZXZlbCArICdcXG4gICAgICB2YXIgY291bnQnICsgbGV2ZWwgKyAnXFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGVmYXVsdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWZhdWx0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWEsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgICAgIGtleSA9IHRoaXMua2V5LFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIHZhciB2YWx1ZSA9IHNjaGVtYS5kZWZhdWx0OyAvLyByZW5hbWUgZGVmYXVsdCB0byB2YWx1ZSBiZWNhdXNlIGl0J3MgYSBrZXl3b3JkIGFuZCBzeW50YXggaGlnaGxpZ2h0ZXIgYnJlYWtzXG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoc2NoZW1hLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHtcblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSA9ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnXFxuICAgICAgICAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddID0gJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdcXG4gICAgICAgICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGV2ZWwgPiAxKSB7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICBjb3VudCcgKyBsZXZlbCArICcrK1xcbiAgICAgICAgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMgIT09IGZhbHNlKSB7XFxuICAgICAgICAgICcgKyBibG9jayArICdcXG4gICAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWVtYmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21lbWJlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lbWJlcigpIHtcbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYSxcbiAgICAgICAgICByb290ID0gdGhpcy5yb290LFxuICAgICAgICAgIGxldmVsID0gdGhpcy5sZXZlbCxcbiAgICAgICAgICBrZXkgPSB0aGlzLmtleTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXMsXG4gICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgICAgICAgaXRlbXMgPSBzY2hlbWEuaXRlbXMsXG4gICAgICAgICAgYWRkaXRpb25hbEl0ZW1zID0gc2NoZW1hLmFkZGl0aW9uYWxJdGVtcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIC8vIGBrZXlgIHRlbGxzIHVzIHRvIHRyZWF0IHRoaXMgc3Vic2NoZW1hIGFzIGFuIG9iamVjdCBtZW1iZXIgdnMgYW4gYXJyYXkgaXRlbVxuICAgICAgLy8gYW5kIHRoZSBhYnNlbmNlIG9mIHRoZSBvdGhlciB2YWx1ZXMgaGVyZSBpbmRpY2F0ZXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBhXG4gICAgICAvLyBwcmltaXRpdmUgdmFsdWVcbiAgICAgIGlmIChrZXkgJiYgIXByb3BlcnRpZXMgJiYgIWFkZGl0aW9uYWxQcm9wZXJ0aWVzICYmICFpdGVtcyAmJiAhYWRkaXRpb25hbEl0ZW1zKSB7XG5cbiAgICAgICAgLy8gZmlyc3QgZ2VuZXJhdGUgdGhlIGFzc2lnbm1lbnQgc3RhdGVtZW50XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddID0gc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ11cXG4gICAgICAnO1xuXG4gICAgICAgIC8vIGZvciBuZXN0ZWQgY29udGFpbmVyIG9iamVjdHMsIGFkZCB0aGUgY291bnRlciBpbmNyZW1lbnRpbmcgc3RhdGVtZW50XG4gICAgICAgIGlmIChsZXZlbCA+IDEpIHtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIGNvdW50JyArIGxldmVsICsgJysrXFxuICAgICAgICAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd3JhcCB0aGUgZm9yZWdvaW5nIGluIGEgY2hlY2sgZm9yIHByZXNlbmNlIG9uIHRoZSBzb3VyY2VcbiAgICAgICAgYmxvY2sgPSAnXFxuICAgICAgICBpZiAoc291cmNlJyArIGxldmVsICsgJy5oYXNPd25Qcm9wZXJ0eShcXCcnICsga2V5ICsgJ1xcJykpIHtcXG4gICAgICAgICAgJyArIGJsb2NrICsgJ1xcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpdGVtXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2l0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpdGVtKCkge1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIHJvb3QgPSB0aGlzLnJvb3QsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXMsXG4gICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgICAgICAgaXRlbXMgPSBzY2hlbWEuaXRlbXMsXG4gICAgICAgICAgYWRkaXRpb25hbEl0ZW1zID0gc2NoZW1hLmFkZGl0aW9uYWxJdGVtcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmIChpbmRleCAmJiAhcHJvcGVydGllcyAmJiAhYWRkaXRpb25hbFByb3BlcnRpZXMgJiYgIWl0ZW1zICYmICFhZGRpdGlvbmFsSXRlbXMpIHtcblxuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddID0gc291cmNlJyArIGxldmVsICsgJ1snICsgaW5kZXggKyAnXVxcbiAgICAgICc7XG5cbiAgICAgICAgaWYgKGxldmVsID4gMSkge1xuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICc7XG4gICAgICAgIH1cblxuICAgICAgICBibG9jayA9ICdcXG4gICAgICAgIGlmICgnICsgaW5kZXggKyAnIDwgbGVuKSB7XFxuICAgICAgICAgICcgKyBibG9jayArICdcXG4gICAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJvcGVydGllc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9wZXJ0aWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcGVydGllcygpIHtcbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYSxcbiAgICAgICAgICByb290ID0gdGhpcy5yb290LFxuICAgICAgICAgIGxldmVsID0gdGhpcy5sZXZlbCxcbiAgICAgICAgICBrZXkgPSB0aGlzLmtleSxcbiAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHN1YnNjaGVtYSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBuZXcgSW5pdGlhbGl6ZXIoc3Vic2NoZW1hLCB7IGtleToga2V5LCByb290OiByb290LCBsZXZlbDogbGV2ZWwgKyAxIH0pO1xuXG4gICAgICAgICAgYmxvY2sgKz0gaW5pdGlhbGl6ZXIuY29tcGlsZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByb290LWxldmVsIHByb3BlcnRpZXMgYm9pbGVycGxhdGVcbiAgICAgICAgaWYgKHJvb3QgPT09IHRoaXMpIHtcbiAgICAgICAgICBibG9jayA9ICdcXG4gICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFxcJ29iamVjdFxcJyAmJiBzb3VyY2UgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoc291cmNlKSkge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcXCdvYmplY3RcXCcpIHtcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXCc/XFwnKVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBzb3VyY2UxID0gc291cmNlXFxuICAgICAgICAgICAgdGFyZ2V0MSA9IHRhcmdldFxcbiAgICAgICAgICAgIGNvdW50MSA9IDBcXG5cXG4gICAgICAgICAgICAnICsgYmxvY2sgKyAnXFxuICAgICAgICAgIH1cXG4gICAgICAgICc7XG5cbiAgICAgICAgICAvLyBuZXN0ZWQgcHJvcGVydGllcyBib2lsZXJwbGF0ZVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICBibG9jayA9ICdcXG4gICAgICAgICAgICBpZiAoJyArIGluZGV4ICsgJyA8IHNvdXJjZScgKyBsZXZlbCArICcubGVuZ3RoIHx8IHR5cGVvZiBzb3VyY2UnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddID09PSBcXCdvYmplY3RcXCcpIHtcXG5cXG4gICAgICAgICAgICAgIHNvdXJjZScgKyAobGV2ZWwgKyAxKSArICcgPSBzb3VyY2UnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddIHx8IHt9XFxuICAgICAgICAgICAgICBjb3VudCcgKyAobGV2ZWwgKyAxKSArICcgPSAwXFxuXFxuICAgICAgICAgICAgICBpZiAoJyArIGluZGV4ICsgJyA8IHRhcmdldCcgKyBsZXZlbCArICcubGVuZ3RoIHx8IHR5cGVvZiB0YXJnZXQnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddICE9PSBcXCdvYmplY3RcXCcpIHtcXG4gICAgICAgICAgICAgICAgdGFyZ2V0JyArIChsZXZlbCArIDEpICsgJyA9IHt9XFxuICAgICAgICAgICAgICAgIGlmICgnICsgaW5kZXggKyAnIDwgc291cmNlJyArIGxldmVsICsgJy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICBjb3VudCcgKyAobGV2ZWwgKyAxKSArICcrK1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnID0gdGFyZ2V0JyArIGxldmVsICsgJ1snICsgaW5kZXggKyAnXVxcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgJyArIGJsb2NrICsgJ1xcblxcbiAgICAgICAgICAgICAgaWYgKGNvdW50JyArIChsZXZlbCArIDEpICsgJyA+IDApIHtcXG4gICAgICAgICAgICAgICAgdGFyZ2V0JyArIGxldmVsICsgJ1snICsgaW5kZXggKyAnXSA9IHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICdcXG4gICAgICAgICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdGFyZ2V0JyArIGxldmVsICsgJ1snICsgaW5kZXggKyAnXSA9IHNvdXJjZScgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ11cXG4gICAgICAgICAgICAgIGNvdW50JyArIGxldmVsICsgJysrXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHNvdXJjZScgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddID09PSBcXCdvYmplY3RcXCdcXG4gICAgICAgICAgICAgICAgICAmJiBzb3VyY2UnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSAhPT0gbnVsbFxcbiAgICAgICAgICAgICAgICAgICYmICFBcnJheS5pc0FycmF5KHNvdXJjZScgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddKSlcXG4gICAgICAgICAgICAgICAgfHwgIXNvdXJjZScgKyBsZXZlbCArICcuaGFzT3duUHJvcGVydHkoXFwnJyArIGtleSArICdcXCcpKSB7XFxuXFxuICAgICAgICAgICAgICBzb3VyY2UnICsgKGxldmVsICsgMSkgKyAnID0gc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gfHwge31cXG4gICAgICAgICAgICAgIGNvdW50JyArIChsZXZlbCArIDEpICsgJyA9IDBcXG5cXG4gICAgICAgICAgICAgIGlmICghdGFyZ2V0JyArIGxldmVsICsgJy5oYXNPd25Qcm9wZXJ0eShcXCcnICsga2V5ICsgJ1xcJylcXG4gICAgICAgICAgICAgICAgICB8fCB0eXBlb2YgdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gIT09IFxcJ29iamVjdFxcJ1xcbiAgICAgICAgICAgICAgICAgIHx8IHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddID09PSBudWxsXFxuICAgICAgICAgICAgICAgICAgfHwgQXJyYXkuaXNBcnJheSh0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSkpIHtcXG4gICAgICAgICAgICAgICAgdGFyZ2V0JyArIChsZXZlbCArIDEpICsgJyA9IHt9XFxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UnICsgbGV2ZWwgKyAnLmhhc093blByb3BlcnR5KFxcJycgKyBrZXkgKyAnXFwnKSkge1xcbiAgICAgICAgICAgICAgICAgIGNvdW50JyArIChsZXZlbCArIDEpICsgJysrXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICcgPSB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXVxcbiAgICAgICAgICAgICAgICBjb3VudCcgKyAobGV2ZWwgKyAxKSArICcrK1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgJyArIGJsb2NrICsgJ1xcblxcbiAgICAgICAgICAgICAgaWYgKGNvdW50JyArIChsZXZlbCArIDEpICsgJyA+IDApIHtcXG4gICAgICAgICAgICAgICAgdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPSB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnXFxuICAgICAgICAgICAgICAgIGNvdW50JyArIGxldmVsICsgJysrXFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddID0gc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ11cXG4gICAgICAgICAgICAgIGNvdW50JyArIGxldmVsICsgJysrXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkaXRpb25hbFByb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydGllcygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBpdGVtc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGl0ZW1zKCkge1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIHJvb3QgPSB0aGlzLnJvb3QsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgICAgIGtleSA9IHRoaXMua2V5LFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIHZhciBpdGVtcyA9IHNjaGVtYS5pdGVtcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmIChpdGVtcykge1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gLi4uXG5cbiAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGl0ZW1zID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpdGVtcykpID09PSAnb2JqZWN0JyAmJiBpdGVtcyAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW5kZXggPSAnaScgKyAobGV2ZWwgKyAxKTtcbiAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBuZXcgSW5pdGlhbGl6ZXIoaXRlbXMsIHsgaW5kZXg6IF9pbmRleCwgcm9vdDogcm9vdCwgbGV2ZWw6IGxldmVsICsgMSB9KTtcblxuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgICAgdmFyIHNMZW4gPSBzb3VyY2UnICsgKGxldmVsICsgMSkgKyAnLmxlbmd0aCB8fCAwXFxuICAgICAgICAgIHZhciB0TGVuID0gdGFyZ2V0JyArIChsZXZlbCArIDEpICsgJy5sZW5ndGggfHwgMFxcbiAgICAgICAgICB2YXIgbGVuID0gMFxcblxcbiAgICAgICAgICBpZiAoc0xlbiA+IGxlbikgeyBsZW4gPSBzTGVuIH1cXG4gICAgICAgICAgLy8gVEhJUyBJUyBXUk9ORywgQ0FVU0VEIFNJTVBMRSBBUlJBWSBJTklUIFRPIEZBSUwgKE9WRVJXUklURVxcbiAgICAgICAgICAvLyBFWElTVElORyBUQVJHRVQgVkFMVUVTIFdJVEggVU5ERUZJTkVEIFdIRU4gU09VUkNFIElTIFNIT1JURVIgVEhBTlxcbiAgICAgICAgICAvLyBUQVJHRVQpLiBMRUFWSU5HIEhFUkUgVU5USUwgV0UgRklOSVNIIFRFU1RJTkcgQU5EIFNFRSBXSFkgSVQgTUlHSFRcXG4gICAgICAgICAgLy8gSEFWRSBCRUVOIEhFUkUgSU4gVEhFIEZJUlNUIFBMQUNFLlxcbiAgICAgICAgICAvL1xcbiAgICAgICAgICAvLyBpZiAodExlbiA+IGxlbikgeyBsZW4gPSB0TGVuIH1cXG5cXG4gICAgICAgICAgZm9yICh2YXIgJyArIF9pbmRleCArICcgPSAwOyAnICsgX2luZGV4ICsgJyA8IGxlbjsgJyArIF9pbmRleCArICcrKykge1xcbiAgICAgICAgICAgICcgKyBpbml0aWFsaXplci5jb21waWxlKCkgKyAnXFxuICAgICAgICAgIH1cXG4gICAgICAgICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByb290LWxldmVsIHByb3BlcnRpZXMgYm9pbGVycGxhdGVcbiAgICAgICAgaWYgKHJvb3QgPT09IHRoaXMpIHtcbiAgICAgICAgICBibG9jayA9ICdcXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFwnP1xcJylcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgc291cmNlMSA9IHNvdXJjZVxcbiAgICAgICAgICAgIHRhcmdldDEgPSB0YXJnZXRcXG5cXG4gICAgICAgICAgICAnICsgYmxvY2sgKyAnXFxuICAgICAgICAgIH1cXG4gICAgICAgICc7XG5cbiAgICAgICAgICAvLyBuZXN0ZWQgcHJvcGVydGllcyBib2lsZXJwbGF0ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSkgfHwgIXNvdXJjZScgKyBsZXZlbCArICcuaGFzT3duUHJvcGVydHkoXFwnJyArIGtleSArICdcXCcpKSB7XFxuXFxuICAgICAgICAgICAgc291cmNlJyArIChsZXZlbCArIDEpICsgJyA9IHNvdXJjZScgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddIHx8IFtdXFxuICAgICAgICAgICAgY291bnQnICsgKGxldmVsICsgMSkgKyAnID0gMFxcblxcbiAgICAgICAgICAgIGlmICghdGFyZ2V0JyArIGxldmVsICsgJy5oYXNPd25Qcm9wZXJ0eShcXCcnICsga2V5ICsgJ1xcJykgfHwgIUFycmF5LmlzQXJyYXkodGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10pKSB7XFxuICAgICAgICAgICAgICB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnID0gW11cXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZScgKyBsZXZlbCArICcuaGFzT3duUHJvcGVydHkoXFwnJyArIGtleSArICdcXCcpKSB7XFxuICAgICAgICAgICAgICAgICAgY291bnQnICsgKGxldmVsICsgMSkgKyAnKytcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnID0gdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ11cXG4gICAgICAgICAgICAgIGNvdW50JyArIChsZXZlbCArIDEpICsgJysrXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICcgKyBibG9jayArICdcXG5cXG4gICAgICAgICAgICBpZiAoY291bnQnICsgKGxldmVsICsgMSkgKyAnID4gMCkge1xcbiAgICAgICAgICAgICAgdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPSB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnXFxuICAgICAgICAgICAgICBjb3VudCcgKyBsZXZlbCArICcrK1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSA9IHNvdXJjZScgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddXFxuICAgICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICAgfVxcbiAgICAgICAgJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkaXRpb25hbEl0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkaXRpb25hbEl0ZW1zKCkge31cbiAgfV0sIFt7XG4gICAga2V5OiAnY29tcGlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUoc2NoZW1hKSB7XG4gICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBuZXcgSW5pdGlhbGl6ZXIoc2NoZW1hKTtcbiAgICAgIHZhciBibG9jayA9IGluaXRpYWxpemVyLmNvbXBpbGUoKTtcblxuICAgICAgLy9jb25zb2xlLmxvZyhiZWF1dGlmeShibG9jaykpXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCd0YXJnZXQnLCAnc291cmNlJywgJ29wdGlvbnMnLCBibG9jayk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGUsIGUuc3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbml0aWFsaXplcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbml0aWFsaXplcjtcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSlNPTlBhdGNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG5cbi8qKlxuICogSlNPTkRvY3VtZW50XG4gKlxuICogQGNsYXNzXG4gKiBKU09ORG9jdW1lbnQgaXMgYSBoaWdoIGxldmVsIGludGVyZmFjZSB0aGF0IGJpbmRzIHRvZ2V0aGVyIGFsbCBvdGhlciBmZWF0dXJlcyBvZlxuICogdGhpcyBwYWNrYWdlIGFuZCBwcm92aWRlcyB0aGUgcHJpbmNpcGxlIG1ldGhvZCBvZiBkYXRhIG1vZGVsaW5nLlxuICovXG5cbnZhciBKU09ORG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhKU09ORG9jdW1lbnQsIG51bGwsIFt7XG4gICAga2V5OiAnc2NoZW1hJyxcblxuXG4gICAgLyoqXG4gICAgICogU2NoZW1hXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjaGVtYSBtdXN0IGJlIGRlZmluZWQgYnkgY2xhc3NlcyBleHRlbmRpbmcgSlNPTkRvY3VtZW50Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9XSk7XG5cbiAgZnVuY3Rpb24gSlNPTkRvY3VtZW50KCkge1xuICAgIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTkRvY3VtZW50KTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZShkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEpTT05Eb2N1bWVudCwgW3tcbiAgICBrZXk6ICdpbml0aWFsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLmNvbnN0cnVjdG9yLnNjaGVtYTtcblxuICAgICAgc2NoZW1hLmluaXRpYWxpemUodGhpcywgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gYWx0ZXJuYXRlIC0gT1BUSU9OQUwgYWx0ZXJuYXRlIHNjaGVtYVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZhbGlkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUoYWx0ZXJuYXRlKSB7XG4gICAgICB2YXIgc2NoZW1hID0gdGhpcy5jb25zdHJ1Y3Rvci5zY2hlbWE7XG5cbiAgICAgIHJldHVybiAoYWx0ZXJuYXRlIHx8IHNjaGVtYSkudmFsaWRhdGUodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGNoKG9wcykge1xuICAgICAgdmFyIHBhdGNoID0gbmV3IEpTT05QYXRjaChvcHMpO1xuICAgICAgcGF0Y2guYXBwbHkodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBHaXZlbiBhIG1hcHBpbmcsIHJldHVybiBhbiBvYmplY3QgcHJvamVjdGVkIGZyb20gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGxldCBzY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gICAgICogICBwcm9wZXJ0aWVzOiB7XG4gICAgICogICAgIGZvbzogeyB0eXBlOiAnQXJyYXknIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogbGV0IG1hcHBpbmcgPSBuZXcgSlNPTk1hcHBpbmcoe1xuICAgICAqICAgJy9mb28vMCc6ICcvYmFyL2JheidcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogY2xhc3MgRm9vVHJhY2tlciBleHRlbmRzIEpTT05Eb2N1bWVudCB7XG4gICAgICogICBzdGF0aWMgZ2V0IHNjaGVtYSAoKSB7IHJldHVybiBzY2hlbWEgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGxldCBpbnN0YW5jZSA9IG5ldyBGb29UcmFja2VyKHsgZm9vOiBbJ3F1eCddIH0pXG4gICAgICogaW5zdGFuY2UucHJvamVjdChtYXBwaW5nKVxuICAgICAqIC8vID0+IHsgYmFyOiB7IGJhejogJ3F1eCcgfSB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05NYXBwaW5nfSBtYXBwaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvamVjdChtYXBwaW5nKSB7XG4gICAgICByZXR1cm4gbWFwcGluZy5wcm9qZWN0KHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfV0sIFt7XG4gICAga2V5OiAnc2VyaWFsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKG9iamVjdCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVzZXJpYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgSlNPTicpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKU09ORG9jdW1lbnQ7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05Eb2N1bWVudDtcblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBKU09OUG9pbnRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG4vKipcbiAqIE1vZGVzXG4gKi9cbnZhciBUSFJPVyA9IDA7XG52YXIgUkVDT1ZFUiA9IDE7XG52YXIgU0lMRU5UID0gMjtcblxuLyoqXG4gKiBPcGVyYXRpb25zIGxpc3RcbiAqL1xudmFyIE9QRVJBVElPTlMgPSBbJ2FkZCcsICdyZW1vdmUnLCAncmVwbGFjZScsICdtb3ZlJywgJ2NvcHknLCAndGVzdCddO1xuXG4vKipcbiAqIFBhdGNoXG4gKlxuICogQGNsYXNzXG4gKiBJbXBsZW1lbnRzIFJGQyA2OTAyOiBKYXZhU2NyaXB0IE9iamVjdCBOb3RhdGlvbiAoSlNPTikgUGF0Y2hcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAyXG4gKi9cblxudmFyIEpTT05QYXRjaCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb3BzXG4gICAqL1xuICBmdW5jdGlvbiBKU09OUGF0Y2gob3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpTT05QYXRjaCk7XG5cbiAgICB0aGlzLm9wcyA9IG9wcyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseVxuICAgKlxuICAgKiBAdG9kbyBoYW5kbGUgZXJyb3JzL3JvbGwgYmFja1xuICAgKiBAdG9kbyBwcm90ZWN0IHByb3BlcnRpZXMgdGhhdCBhcmUgcHJpdmF0ZSBpbiB0aGUgc2NoZW1hXG4gICAqIEB0b2RvIG1hcCBKU09OIFBvaW50ZXJzIHJlYWwgcHJvcGVydHkgbmFtZXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhKU09OUGF0Y2gsIFt7XG4gICAga2V5OiAnYXBwbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSh0YXJnZXQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMub3BzLmZvckVhY2goZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgICAgICB2YXIgb3AgPSBvcGVyYXRpb24ub3A7XG5cbiAgICAgICAgaWYgKCFvcCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBcIm9wXCIgaW4gSlNPTiBQYXRjaCBvcGVyYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPUEVSQVRJT05TLmluZGV4T2Yob3ApID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcIm9wXCIgaW4gSlNPTiBQYXRjaCBvcGVyYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3BlcmF0aW9uLnBhdGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJwYXRoXCIgaW4gSlNPTiBQYXRjaCBvcGVyYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzW29wXShvcGVyYXRpb24sIHRhcmdldCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKG9wLCB0YXJnZXQpIHtcbiAgICAgIGlmIChvcC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBcInZhbHVlXCIgaW4gSlNPTiBQYXRjaCBhZGQgb3BlcmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gbmV3IEpTT05Qb2ludGVyKG9wLnBhdGgsIFNJTEVOVCk7XG4gICAgICBwb2ludGVyLmFkZCh0YXJnZXQsIG9wLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKG9wLCB0YXJnZXQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gbmV3IEpTT05Qb2ludGVyKG9wLnBhdGgpO1xuICAgICAgcG9pbnRlci5yZW1vdmUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKG9wLCB0YXJnZXQpIHtcbiAgICAgIGlmIChvcC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBcInZhbHVlXCIgaW4gSlNPTiBQYXRjaCByZXBsYWNlIG9wZXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IG5ldyBKU09OUG9pbnRlcihvcC5wYXRoKTtcbiAgICAgIHBvaW50ZXIucmVwbGFjZSh0YXJnZXQsIG9wLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlKG9wLCB0YXJnZXQpIHtcbiAgICAgIGlmIChvcC5mcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwiZnJvbVwiIGluIEpTT04gUGF0Y2ggbW92ZSBvcGVyYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wLnBhdGgubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyBvcC5mcm9tKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwiZnJvbVwiIGluIEpTT04gUGF0Y2ggbW92ZSBvcGVyYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgSlNPTlBvaW50ZXIob3AucGF0aCk7XG4gICAgICB2YXIgZnJvbSA9IG5ldyBKU09OUG9pbnRlcihvcC5mcm9tKTtcbiAgICAgIHZhciB2YWx1ZSA9IGZyb20uZ2V0KHRhcmdldCk7XG5cbiAgICAgIGZyb20ucmVtb3ZlKHRhcmdldCk7XG4gICAgICBwb2ludGVyLmFkZCh0YXJnZXQsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3B5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvcHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KG9wLCB0YXJnZXQpIHtcbiAgICAgIGlmIChvcC5mcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwiZnJvbVwiIGluIEpTT04gUGF0Y2ggY29weSBvcGVyYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgSlNPTlBvaW50ZXIob3AucGF0aCk7XG4gICAgICB2YXIgZnJvbSA9IG5ldyBKU09OUG9pbnRlcihvcC5mcm9tKTtcbiAgICAgIHZhciB2YWx1ZSA9IGZyb20uZ2V0KHRhcmdldCk7XG5cbiAgICAgIHBvaW50ZXIuYWRkKHRhcmdldCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndGVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlc3Qob3AsIHRhcmdldCkge1xuICAgICAgaWYgKG9wLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwidmFsdWVcIiBpbiBKU09OIFBhdGNoIHRlc3Qgb3BlcmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gbmV3IEpTT05Qb2ludGVyKG9wLnBhdGgpO1xuICAgICAgdmFyIHZhbHVlID0gcG9pbnRlci5nZXQodGFyZ2V0KTtcblxuICAgICAgc3dpdGNoIChfdHlwZW9mKG9wLnZhbHVlKSkge1xuICAgICAgICAvL2Nhc2UgJ3N0cmluZyc6XG4gICAgICAgIC8vY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgLy9jYXNlICdib29sZWFuJzpcbiAgICAgICAgLy8gIGlmICh2YWx1ZSAhPT0gb3AudmFsdWUpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBKU09OIFBhdGNoIHRlc3QgdmFsdWUnKVxuICAgICAgICAvLyAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gb3AudmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hpbmcgSlNPTiBQYXRjaCB0ZXN0IHZhbHVlJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKU09OUGF0Y2g7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0c1xuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUGF0Y2g7XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBNb2RlIGVudW1lcmF0aW9uXG4gKi9cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFRIUk9XID0gMDtcbnZhciBSRUNPVkVSID0gMTtcbnZhciBTSUxFTlQgPSAyO1xuXG4vKipcbiAqIEpTT05Qb2ludGVyXG4gKlxuICogQGNsYXNzXG4gKiBJbXBsZW1lbnRzIFJGQyA2OTAxOiBKYXZhU2NyaXB0IE9iamVjdCBOb3RhdGlvbiAoSlNPTikgUG9pbnRlclxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDFcbiAqL1xuXG52YXIgSlNPTlBvaW50ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBKU09OUG9pbnRlcihleHByLCBtb2RlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpTT05Qb2ludGVyKTtcblxuICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgdGhpcy5tb2RlID0gbW9kZSB8fCBUSFJPVztcbiAgICB0aGlzLnRva2VucyA9IGV4cHIgJiYgZXhwci5jaGFyQXQoMCkgPT09ICcjJyA/IHRoaXMucGFyc2VVUklGcmFnbWVudElkZW50aWZpZXIoZXhwcikgOiB0aGlzLnBhcnNlSlNPTlN0cmluZyhleHByKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSlNPTlBvaW50ZXIsIFt7XG4gICAga2V5OiAnZXNjYXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXNjYXBlKGV4cHIpIHtcbiAgICAgIHJldHVybiBleHByLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuZXNjYXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VuZXNjYXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5lc2NhcGUoZXhwcikge1xuICAgICAgcmV0dXJuIGV4cHIucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlSlNPTlN0cmluZycsXG5cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIEpTT04gU3RyaW5nXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUGFyc2UgYW4gZXhwcmVzc2lvbiBpbnRvIGEgbGlzdCBvZiB0b2tlbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VKU09OU3RyaW5nKGV4cHIpIHtcbiAgICAgIGlmICh0eXBlb2YgZXhwciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OIFBvaW50ZXIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhwciA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhwci5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBQb2ludGVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHByID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIFsnJ107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByLnN1YnN0cigxKS5zcGxpdCgnLycpLm1hcCh0aGlzLnVuZXNjYXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBKU09OIFN0cmluZ1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbmRlciBhIEpTT04gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcG9pbnRlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTlN0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTlN0cmluZygpIHtcbiAgICAgIHJldHVybiAnLycgKyB0aGlzLnRva2Vucy5tYXAodGhpcy5lc2NhcGUpLmpvaW4oJy8nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBVUkkgRnJhZ21lbnQgSWRlbnRpZmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlVVJJRnJhZ21lbnRJZGVudGlmaWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VVUklGcmFnbWVudElkZW50aWZpZXIoZXhwcikge1xuICAgICAgaWYgKHR5cGVvZiBleHByICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04gUG9pbnRlciBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHByLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIFBvaW50ZXIgVVJJIEZyYWdtZW50IElkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VKU09OU3RyaW5nKGRlY29kZVVSSUNvbXBvbmVudChleHByLnN1YnN0cigxKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvIFVSSSBGcmFnbWVudCBJZGVudGlmaWVyXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVuZGVyIGEgVVJJIEZyYWdtZW50IElkZW50aWZpZXIgcmVwcmVzZW50YXRpb24gb2YgYSBwb2ludGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9VUklGcmFnbWVudElkZW50aWZpZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1VSSUZyYWdtZW50SWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChfdGhpcy5lc2NhcGUodG9rZW4pKTtcbiAgICAgIH0pLmpvaW4oJy8nKTtcblxuICAgICAgcmV0dXJuICcjLycgKyB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIHBvaW50ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChzb3VyY2UpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gc291cmNlO1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWN1cnJlbnQgfHwgY3VycmVudFt0b2tlbnNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlICE9PSBUSFJPVykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gUG9pbnRlciByZWZlcmVuY2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gY3VycmVudFt0b2tlbnNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgYSB2YWx1ZSBvbiBhIHRhcmdldCBvYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgcG9pbnRlci4gUHV0XG4gICAgICogd2lsbCBpbnNlcnQgYW4gYXJyYXkgZWxlbWVudC4gVG8gY2hhbmdlIGFuIGV4aXN0aW5nIGFycmF5IGVsZW1uZW50LCB1c2VcbiAgICAgKiBgcG9pbnRlci5zZXQoKWBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuICAgICAgdmFyIGN1cnJlbnQgPSB0YXJnZXQ7XG5cbiAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCB0aGUgdG9rZW5zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgLy8gc2V0IHRoZSBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IGxvY2F0aW9uXG4gICAgICAgIGlmIChpID09PSB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmICh0b2tlbiA9PT0gJy0nKSB7XG4gICAgICAgICAgICBjdXJyZW50LnB1c2godmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICAgICAgY3VycmVudC5zcGxpY2UodG9rZW4sIDAsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRbdG9rZW5dID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaGFuZGxlIG1pc3NpbmcgdGFyZ2V0IGxvY2F0aW9uIGJhc2VkIG9uIFwibW9kZVwiXG4gICAgICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgVEhST1c6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIFBvaW50ZXIgcmVmZXJlbmNlJyk7XG5cbiAgICAgICAgICAgIGNhc2UgUkVDT1ZFUjpcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbdG9rZW5dID0gcGFyc2VJbnQodG9rZW4pID8gW10gOiB7fTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU0lMRU5UOlxuICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwb2ludGVyIG1vZGUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZWZlcmVuY2UgdGhlIG5leHQgb2JqZWN0IGluIHRoZSBwYXRoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCBhIHZhbHVlIG9uIGEgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2VkIGJ5IHRoZSBwb2ludGVyLiBTZXQgd2lsbFxuICAgICAqIG92ZXJ3cml0ZSBhbiBleGlzdGluZyBhcnJheSBlbGVtZW50IGF0IHRoZSB0YXJnZXQgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuICAgICAgdmFyIGN1cnJlbnQgPSB0YXJnZXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAoaSA9PT0gdG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjdXJyZW50W3Rva2VuXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFjdXJyZW50W3Rva2VuXSkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3Rva2VuXSA9IHBhcnNlSW50KHRva2VuKSA/IFtdIDoge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsXG4gICAgICpcbiAgICAgKiAtIGlmIHRoaXMgaXMgYW4gYXJyYXkgaXQgc2hvdWxkIHNwbGljZSB0aGUgdmFsdWUgb3V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSh0YXJnZXQpIHtcbiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VucztcbiAgICAgIHZhciBjdXJyZW50ID0gdGFyZ2V0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50W3Rva2VuXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgY3VycmVudC5zcGxpY2UodG9rZW4sIDEpO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gdG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkZWxldGUgY3VycmVudFt0b2tlbl07XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gY3VycmVudFt0b2tlbl07XG4gICAgICB9XG5cbiAgICAgIC8vIGRlbGV0ZSBmcm9tIHRoZSB0YXJnZXRcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3BhcnNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoZXhwcikge1xuICAgICAgcmV0dXJuIG5ldyBKU09OUG9pbnRlcihleHByKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSlNPTlBvaW50ZXI7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0c1xuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUG9pbnRlcjtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSlNPTlBvaW50ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcblxuLyoqXG4gKiBKU09OUG9pbnRlciBtb2RlXG4gKi9cbnZhciBSRUNPVkVSID0gMTtcblxuLyoqXG4gKiBKU09OTWFwcGluZ1xuICpcbiAqIEBjbGFzc1xuICogRGVmaW5lcyBhIG1lYW5zIHRvIGRlY2xhcmF0aXZlbHkgdHJhbnNsYXRlIGJldHdlZW4gb2JqZWN0XG4gKiByZXByZXNlbnRhdGlvbnMgdXNpbmcgSlNPTiBQb2ludGVyIHN5bnRheC5cbiAqL1xuXG52YXIgSlNPTk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBUcmFuc2xhdGUgcG9pbnRlcnMgZnJvbSBKU09OIFN0cmluZ3MgaW50byBQb2ludGVyIG9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcHBpbmdcbiAgICovXG4gIGZ1bmN0aW9uIEpTT05NYXBwaW5nKG1hcHBpbmcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpTT05NYXBwaW5nKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWFwcGluZycsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmtleXMobWFwcGluZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBtYXBwaW5nW2tleV07XG4gICAgICBfdGhpcy5tYXBwaW5nLnNldChuZXcgSlNPTlBvaW50ZXIoa2V5LCBSRUNPVkVSKSwgbmV3IEpTT05Qb2ludGVyKHZhbHVlLCBSRUNPVkVSKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWFwXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBBc3NpZ24gdmFsdWVzIGZyb20gc291cmNlIHRvIHRhcmdldCBieSByZWFkaW5nIHRoZSBtYXBwaW5nXG4gICAqIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEpTT05NYXBwaW5nLCBbe1xuICAgIGtleTogJ21hcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgdGhpcy5tYXBwaW5nLmZvckVhY2goZnVuY3Rpb24gKHJpZ2h0LCBsZWZ0KSB7XG4gICAgICAgIGxlZnQuYWRkKHRhcmdldCwgcmlnaHQuZ2V0KHNvdXJjZSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvamVjdFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEFzc2lnbiB2YWx1ZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IGJ5IHJlYWRpbmcgdGhlIG1hcHBpbmdcbiAgICAgKiBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2plY3Qoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgIHRoaXMubWFwcGluZy5mb3JFYWNoKGZ1bmN0aW9uIChyaWdodCwgbGVmdCkge1xuICAgICAgICByaWdodC5hZGQodGFyZ2V0LCBsZWZ0LmdldChzb3VyY2UpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKU09OTWFwcGluZztcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRzXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05NYXBwaW5nO1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEluaXRpYWxpemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG52YXIgVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbi8qKlxuICogSlNPTlNjaGVtYVxuICpcbiAqIEBjbGFzc1xuICogQ29tcGlsZXMgSlNPTiBTY2hlbWEgZG9jdW1lbnRzIHRvIGFuIG9iamVjdCB3aXRoIG9iamVjdCBpbml0aWFsaXphdGlvblxuICogYW5kIHZhbGlkYXRpb24gbWV0aG9kcy5cbiAqL1xuXG52YXIgSlNPTlNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYVxuICAgKi9cbiAgZnVuY3Rpb24gSlNPTlNjaGVtYShzY2hlbWEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTlNjaGVtYSk7XG5cbiAgICAvLyBUT0RPOiBvcHRpb25hbGx5IHBhcnNlIEpTT04gc3RyaW5nP1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgc2NoZW1hKTtcblxuICAgIC8vIGFkZCBzY2hlbWEtZGVyaXZlZCBpbml0aWFsaXplIGFuZCB2YWxpZGF0ZSBtZXRob2RzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgaW5pdGlhbGl6ZToge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGVhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IEluaXRpYWxpemVyLmNvbXBpbGUoc2NoZW1hKVxuICAgICAgfSxcbiAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0ZWFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogVmFsaWRhdG9yLmNvbXBpbGUoc2NoZW1hKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogLi4uXG4gICAqIERlYXIgZnV0dXJlLFxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdhcyBtZXRpY3Vsb3VzbHkgcGxhZ2lhcml6ZWQgZnJvbSBzb21lIGN1cmlvdXMgYW1hbGdhbSBvZlxuICAgKiBzdGFja292ZXJmbG93IHBvc3RzIHdoaWxzdCBkb3ppbmcgb2ZmIGF0IG15IGtleWJvYXJkLCB0b28gZGVwcml2ZWQgb2YgUkVNLVxuICAgKiBzbGVlcCB0byByZWN1cnNlIHVuYXNzaXN0ZWQuIElmIGl0IHN1Y2tzLCB5b3UgaGF2ZSBvbmx5IHlvdXJzZWxmIHRvIGJsYW1lLlxuICAgKlxuICAgKiBHb29kbmlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFcbiAgICogQHJldHVybnMge0pTT05TY2hlbWF9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEpTT05TY2hlbWEsIFt7XG4gICAga2V5OiAnZXh0ZW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKHNjaGVtYSkge1xuICAgICAgZnVuY3Rpb24gaXNPYmplY3QoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PT0gJ29iamVjdCcgJiYgZGF0YSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXh0ZW5kZXIodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCk7XG4gICAgICAgIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgc291cmNlW2tleV0pKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGV4dGVuZGVyKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgc291cmNlW2tleV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGV4dGVuZGVyKHRoaXMsIHNjaGVtYSk7XG4gICAgICByZXR1cm4gbmV3IEpTT05TY2hlbWEoZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpTT05TY2hlbWE7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05TY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKiBAaWdub3JlXG4gKi9cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgZm9ybWF0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG4vKipcbiAqIEZvciB2YXJpYWJsZSBpdGVyYXRvciBjb3VudGVyXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIGluZGV4Q291bnQgPSAwO1xuXG4vKipcbiAqIFZhbGlkYXRvclxuICpcbiAqIENvbXBpbGUgYW4gb2JqZWN0IGRlc2NyaWJpbmcgYSBKU09OIFNjaGVtYSBpbnRvIGEgdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqL1xuXG52YXIgVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MoVmFsaWRhdG9yLCBudWxsLCBbe1xuICAgIGtleTogJ2NvbXBpbGUnLFxuXG5cbiAgICAvKipcbiAgICAgKiBDb21waWxlIChzdGF0aWMpXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBDb21waWxlIGFuIG9iamVjdCBkZXNjcmliaW5nIGEgSlNPTiBTY2hlbWEgaW50byBhIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlKHNjaGVtYSkge1xuICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3Ioc2NoZW1hKTtcblxuICAgICAgdmFyIGJvZHkgPSAnXFxuICAgICAgLy8gXCJjdXJzb3JcIlxcbiAgICAgIGxldCB2YWx1ZSA9IGRhdGFcXG4gICAgICBsZXQgY29udGFpbmVyXFxuICAgICAgbGV0IHN0YWNrID0gW11cXG4gICAgICBsZXQgdG9wID0gLTFcXG5cXG4gICAgICAvLyBlcnJvciBzdGF0ZVxcbiAgICAgIGxldCB2YWxpZCA9IHRydWVcXG4gICAgICBsZXQgZXJyb3JzID0gW11cXG5cXG4gICAgICAvLyBjb21wbGV4IHNjaGVtYSBzdGF0ZVxcbiAgICAgIGxldCBpbml0aWFsVmFsaWRpdHlcXG4gICAgICBsZXQgYW55VmFsaWRcXG4gICAgICBsZXQgbm90VmFsaWRcXG4gICAgICBsZXQgY291bnRPZlZhbGlkXFxuICAgICAgbGV0IGluaXRpYWxFcnJvckNvdW50XFxuICAgICAgbGV0IGFjY3VtdWxhdGVkRXJyb3JDb3VudFxcblxcbiAgICAgIC8vIHZhbGlkYXRpb24gY29kZVxcbiAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcblxcbiAgICAgIC8vIHZhbGlkYXRpb24gcmVzdWx0XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHZhbGlkLFxcbiAgICAgICAgZXJyb3JzXFxuICAgICAgfVxcbiAgICAnO1xuXG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdkYXRhJywgYm9keSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgaXRlcmF0b3IgaW5kZXggY291bnRlciBhbmQgaW5jcmVhc2UgdmFsdWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvdW50ZXInLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGluZGV4Q291bnQrKztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYSAtIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNjaGVtYVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zIC0gY29tcGlsYXRpb24gb3B0aW9uc1xuICAgICAqL1xuXG4gIH1dKTtcblxuICBmdW5jdGlvbiBWYWxpZGF0b3Ioc2NoZW1hKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZhbGlkYXRvcik7XG5cbiAgICAvLyBhc3NpZ24gc2NoZW1hIHRvIHRoaXNcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcblxuICAgIC8vIGFzc2lnbiBhbGwgb3B0aW9ucyB0byB0aGlzXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcblxuICAgIC8vIGVuc3VyZSBhZGRyZXNzIGlzIGRlZmluZWRcbiAgICBpZiAoIXRoaXMuYWRkcmVzcykge1xuICAgICAgdGhpcy5hZGRyZXNzID0gJyc7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHJlcXVpcmUgaXMgYm9vbGVhblxuICAgIGlmICh0aGlzLnJlcXVpcmUgIT09IHRydWUpIHtcbiAgICAgIHRoaXMucmVxdWlyZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgaW5zdGFuY2UgY29tcGlsZSBtZXRob2QgaXMgXCJkdW1iXCIuIEl0IG9ubHkgc2VxdWVuY2VzIGludm9jYXRpb24gb2ZcbiAgICogbW9yZSBzcGVjaWZpYyBjb21waWxhdGlvbiBtZXRob2RzLiBJdCBnZW5lcmF0ZXMgY29kZSB0b1xuICAgKlxuICAgKiAgLSByZWFkIGEgdmFsdWUgZnJvbSBpbnB1dFxuICAgKiAgLSB2YWxpZGF0ZSB0eXBlKHMpIG9mIGlucHV0XG4gICAqICAtIHZhbGlkYXRlIGNvbnN0cmFpbnRzIGRlc2NyaWJlZCBieSB2YXJpb3VzIHNjaGVtYSBrZXl3b3Jkc1xuICAgKlxuICAgKiBDb25kaXRpb25hbCBsb2dpYyByZWxhdGVkIHRvIGNvZGUgZ2VuZXJhdGlvbiBpcyBwdXNoZWQgZG93bnN0ZWFtIHRvXG4gICAqIHR5cGUtc3BlY2lmaWMgbWV0aG9kcy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVmFsaWRhdG9yLCBbe1xuICAgIGtleTogJ2NvbXBpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlKCkge1xuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICh0aGlzLnJlcXVpcmUpIHtcbiAgICAgICAgYmxvY2sgKz0gdGhpcy5yZXF1aXJlZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyB0eXBlIHZhbGlkYXRpb25cbiAgICAgIGJsb2NrICs9IHRoaXMudHlwZSgpO1xuXG4gICAgICAvLyB0eXBlIHNwZWNpZmljIHZhbGlkYXRpb24gZ2VuZXJhdG9yc1xuICAgICAgLy8gbnVsbCBhbmQgYm9vbGVhbiBhcmUgY292ZXJlZCBieSB0aGlzLnR5cGUoKVxuICAgICAgLy8gaW50ZWdlciBzaG91bGQgYmUgY292ZXJlZCBieSBudW1iZXIgYW5kIHRoaXMudHlwZSgpXG4gICAgICBibG9jayArPSB0aGlzLmFycmF5KCk7XG4gICAgICBibG9jayArPSB0aGlzLm51bWJlcigpO1xuICAgICAgYmxvY2sgKz0gdGhpcy5vYmplY3QoKTtcbiAgICAgIGJsb2NrICs9IHRoaXMuc3RyaW5nKCk7XG5cbiAgICAgIC8vIG5vbi10eXBlLXNwZWNpZmljIHZhbGlkYXRpb24gZ2VuZXJhdG9yc1xuICAgICAgYmxvY2sgKz0gdGhpcy5lbnVtKCk7XG4gICAgICBibG9jayArPSB0aGlzLmFueU9mKCk7XG4gICAgICBibG9jayArPSB0aGlzLmFsbE9mKCk7XG4gICAgICBibG9jayArPSB0aGlzLm5vdCgpO1xuICAgICAgYmxvY2sgKz0gdGhpcy5vbmVPZigpO1xuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHVzaFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgIHJldHVybiAnXFxuICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcXG4gICAgICBjb250YWluZXIgPSB2YWx1ZVxcbiAgICAgIHRvcCsrXFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcG9wXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAgIHJldHVybiAnXFxuICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIHRvcC0tXFxuICAgICAgICBzdGFjay5wb3AoKVxcbiAgICAgIH1cXG5cXG4gICAgICB2YWx1ZSA9IGNvbnRhaW5lciA9IHN0YWNrW3RvcF1cXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0eXBlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIG1hdGNoZXMgc3VjY2Vzc2Z1bGx5IGlmIGl0cyBwcmltaXRpdmUgdHlwZSBpcyBvbmUgb2YgdGhlXG4gICAgICogPiB0eXBlcyBkZWZpbmVkIGJ5IGtleXdvcmQuIFJlY2FsbDogXCJudW1iZXJcIiBpbmNsdWRlcyBcImludGVnZXJcIi5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjUuMlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR5cGUoKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuc2NoZW1hLnR5cGUsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHZhciB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IHR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIC8vIFRPRE86IGNhbiB3ZSBtYWtlIGEgbWFwcGluZyBvYmplY3QgZm9yIHRoaXMgdG8gY2xlYW4gaXQgdXA/XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdhcnJheScpIHJldHVybiAnIUFycmF5LmlzQXJyYXkodmFsdWUpJztcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gJ3R5cGVvZiB2YWx1ZSAhPT0gXFwnYm9vbGVhblxcJyc7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdpbnRlZ2VyJykgcmV0dXJuICchTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSknO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnbnVsbCcpIHJldHVybiAndmFsdWUgIT09IG51bGwnO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuICd0eXBlb2YgdmFsdWUgIT09IFxcJ251bWJlclxcJyc7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSByZXR1cm4gJyh0eXBlb2YgdmFsdWUgIT09IFxcJ29iamVjdFxcJyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCknO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykgcmV0dXJuICd0eXBlb2YgdmFsdWUgIT09IFxcJ3N0cmluZ1xcJyc7XG4gICAgICAgIH0pLmpvaW4oJyAmJiAnKTtcblxuICAgICAgICBibG9jayArPSAnXFxuICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIHR5cGUgY2hlY2tpbmdcXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAnICsgY29uZGl0aW9ucyArICcpIHtcXG4gICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAga2V5d29yZDogXFwndHlwZVxcJyxcXG4gICAgICAgICAgbWVzc2FnZTogXFwnaW52YWxpZCB0eXBlXFwnXFxuICAgICAgICB9KVxcbiAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHlwZS1zcGVjaWZpYyB2YWxpZGF0aW9uc1xuICAgICAqXG4gICAgICogVHlwZSBjaGVja2luZyBpcyBvcHRpb25hbCBpbiBKU09OIFNjaGVtYSwgYW5kIGEgc2NoZW1hIGNhbiBhbGxvd1xuICAgICAqIG11bHRpcGxlIHR5cGVzLiBHZW5lcmF0ZWQgY29kZSBuZWVkcyB0byBhcHBseSB0eXBlLXNwZWNpZmljIHZhbGlkYXRpb25zXG4gICAgICogb25seSB0byBhcHByb3ByaWF0ZSB2YWx1ZXMsIGFuZCBpZ25vcmUgZXZlcnl0aGluZyBlbHNlLiBUeXBlIHZhbGlkYXRpb25cbiAgICAgKiBpdHNlbGYgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGZyb20gb3RoZXIgdmFsaWRhdGlvbiBrZXl3b3Jkcy5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2RzIGBhcnJheWAsIGBudW1iZXJgLCBgb2JqZWN0YCwgYHN0cmluZ2AgZ2VuZXJhdGUgdHlwZS1zcGVjaWZpY1xuICAgICAqIHZhbGlkYXRpb24gY29kZSBibG9ja3MsIHdyYXBwZWQgaW4gYSBjb25kaXRpb25hbCBzdWNoIHRoYXQgdGhleSB3aWxsXG4gICAgICogb25seSBiZSBhcHBsaWVkIHRvIHZhbHVlcyBvZiB0aGF0IHR5cGUuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgdGhlIGBudW1iZXJgIG1ldGhvZCwgZ2l2ZW4gdGhlIHNjaGVtYVxuICAgICAqXG4gICAgICogICAgIHsgbWluaW11bTogMyB9XG4gICAgICpcbiAgICAgKiB3aWxsIGdlbmVyYXRlXG4gICAgICpcbiAgICAgKiAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgKiAgICAgICBpZiAodmFsdWUgPCAzKSB7XG4gICAgICogICAgICAgICB2YWxpZCA9IGZhbHNlXG4gICAgICogICAgICAgICBlcnJvcnMucHVzaCh7IG1lc3NhZ2U6ICcuLi4nIH0pXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBJbnRlZ2VyIHZhbHVlcyBhcmUgYWxzbyBudW1iZXJzLCBhbmQgYXJlIHZhbGlkYXRlZCB0aGUgc2FtZSBhcyBudW1iZXJzXG4gICAgICogb3RoZXIgdGhhbiB0aGUgdHlwZSB2YWxpZGF0aW9uIGl0c2VsZi4gVGhlcmVmb3JlIG5vIGBpbnRlZ2VyYCBtZXRob2QgaXNcbiAgICAgKiBuZWVkZWQuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBhcnJheVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogSW52b2tlIG1ldGhvZHMgZm9yIGFycmF5LXNwZWNpZmljIGtleXdvcmRzIGFuZCB3cmFwIHJlc3VsdGluZyBjb2RlIGluXG4gICAgICogdHlwZS1jaGVja2luZyBjb25kaXRpb25hbCBzbyB0aGF0IGFueSByZXN1bHRpbmcgdmFsaWRhdGlvbnMgYXJlIG9ubHlcbiAgICAgKiBhcHBsaWVkIHRvIGFycmF5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FycmF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXJyYXkoKSB7XG4gICAgICB2YXIga2V5d29yZHMgPSBbJ2FkZGl0aW9uYWxJdGVtcycsICdpdGVtcycsICdtaW5JdGVtcycsICdtYXhJdGVtcycsICd1bmlxdWVJdGVtcyddO1xuICAgICAgdmFyIHZhbGlkYXRpb25zID0gdGhpcy52YWxpZGF0aW9ucyhrZXl3b3Jkcyk7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHZhbGlkYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEFycmF5IHZhbGlkYXRpb25zXFxuICAgICAgICovXFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgICAgJyArIHZhbGlkYXRpb25zICsgJ1xcbiAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbnVtYmVyXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJbnZva2UgbWV0aG9kcyBmb3IgbnVtYmVyLXNwZWNpZmljIGtleXdvcmRzIGFuZCB3cmFwIHJlc3VsdGluZyBjb2RlIGluXG4gICAgICogdHlwZS1jaGVja2luZyBjb25kaXRpb25hbCBzbyB0aGF0IGFueSByZXN1bHRpbmcgdmFsaWRhdGlvbnMgYXJlIG9ubHlcbiAgICAgKiBhcHBsaWVkIHRvIG51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdudW1iZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBudW1iZXIoKSB7XG4gICAgICB2YXIga2V5d29yZHMgPSBbJ21pbmltdW0nLCAnbWF4aW11bScsICdtdWx0aXBsZU9mJ107XG4gICAgICB2YXIgdmFsaWRhdGlvbnMgPSB0aGlzLnZhbGlkYXRpb25zKGtleXdvcmRzKTtcbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAodmFsaWRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgLyoqXFxuICAgICAgICogTnVtYmVyIHZhbGlkYXRpb25zXFxuICAgICAgICovXFxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXFwnbnVtYmVyXFwnKSB7XFxuICAgICAgJyArIHZhbGlkYXRpb25zICsgJ1xcbiAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb2JqZWN0XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJbnZva2UgbWV0aG9kcyBmb3Igb2JqZWN0LXNwZWNpZmljIGtleXdvcmRzIGFuZCB3cmFwIHJlc3VsdGluZyBjb2RlIGluXG4gICAgICogdHlwZS1jaGVja2luZyBjb25kaXRpb25hbCBzbyB0aGF0IGFueSByZXN1bHRpbmcgdmFsaWRhdGlvbnMgYXJlIG9ubHlcbiAgICAgKiBhcHBsaWVkIHRvIG9iamVjdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvYmplY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvYmplY3QoKSB7XG4gICAgICB2YXIga2V5d29yZHMgPSBbJ21heFByb3BlcnRpZXMnLCAnbWluUHJvcGVydGllcycsICdhZGRpdGlvbmFsUHJvcGVydGllcycsICdwcm9wZXJ0aWVzJywgJ3BhdHRlcm5Qcm9wZXJ0aWVzJywgJ2RlcGVuZGVuY2llcycsICdzY2hlbWFEZXBlbmRlbmNpZXMnLCAncHJvcGVydHlEZXBlbmRlbmNpZXMnXTtcbiAgICAgIHZhciB2YWxpZGF0aW9ucyA9IHRoaXMudmFsaWRhdGlvbnMoa2V5d29yZHMpO1xuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICh2YWxpZGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAvKipcXG4gICAgICAgKiBPYmplY3QgdmFsaWRhdGlvbnNcXG4gICAgICAgKi9cXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcXCdvYmplY3RcXCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgICAgJyArIHZhbGlkYXRpb25zICsgJ1xcbiAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc3RyaW5nXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJbnZva2UgbWV0aG9kcyBmb3Igc3RyaW5nLXNwZWNpZmljIGtleXdvcmRzIGFuZCB3cmFwIHJlc3VsdGluZyBjb2RlIGluXG4gICAgICogdHlwZS1jaGVja2luZyBjb25kaXRpb25hbCBzbyB0aGF0IGFueSByZXN1bHRpbmcgdmFsaWRhdGlvbnMgYXJlIG9ubHlcbiAgICAgKiBhcHBsaWVkIHRvIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgICB2YXIga2V5d29yZHMgPSBbJ21heExlbmd0aCcsICdtaW5MZW5ndGgnLCAncGF0dGVybicsICdmb3JtYXQnXTtcbiAgICAgIHZhciB2YWxpZGF0aW9ucyA9IHRoaXMudmFsaWRhdGlvbnMoa2V5d29yZHMpO1xuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICh2YWxpZGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAvKipcXG4gICAgICAgKiBTdHJpbmcgdmFsaWRhdGlvbnNcXG4gICAgICAgKi9cXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcXCdzdHJpbmdcXCcpIHtcXG4gICAgICAnICsgdmFsaWRhdGlvbnMgKyAnXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB2YWxpZGF0aW9uc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogSXRlcmF0ZSBvdmVyIGFuIGFycmF5IG9mIGtleXdvcmRzIGFuZCBpbnZva2UgY29kZSBnZW5lcmF0b3IgbWV0aG9kc1xuICAgICAqIGZvciBlYWNoLiBDb25jYXRlbmF0ZSB0aGUgcmVzdWx0cyB0b2dldGhlciBhbmQgcmV0dXJuLiBVc2VkIGJ5IFwidHlwZVwiXG4gICAgICogbWV0aG9kcyBzdWNoIGFzIHRoaXMuYXJyYXkoKSBhbmQgdGhpcy5zdHJpbmcoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5d29yZHNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2YWxpZGF0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25zKGtleXdvcmRzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWE7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICB2YXIgY29uc3RyYWludHMgPSBPYmplY3Qua2V5cyhzY2hlbWEpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXl3b3Jkcy5pbmRleE9mKGtleSkgIT09IC0xO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGtleXdvcmQpIHtcbiAgICAgICAgYmxvY2sgKz0gX3RoaXNba2V5d29yZF0oKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZW51bVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBpbnN0YW5jZSB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0cyB2YWx1ZVxuICAgICAqID4gaXMgZXF1YWwgdG8gb25lIG9mIHRoZSBlbGVtZW50cyBpbiB0aGlzIGtleXdvcmQncyBhcnJheSB2YWx1ZS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjUuMVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW51bScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnVtKCkge1xuICAgICAgdmFyIGVudW1lcmF0ZWQgPSB0aGlzLnNjaGVtYS5lbnVtLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBjb25kaXRpb25zID0gWyd2YWx1ZSAhPT0gdW5kZWZpbmVkJ107XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKGVudW1lcmF0ZWQpIHtcbiAgICAgICAgZW51bWVyYXRlZC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goJ3ZhbHVlICE9PSAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKCd2YWx1ZSAhPT0gJyArIHZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCgndmFsdWUgIT09IFwiJyArIHZhbHVlICsgJ1wiJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goJ3ZhbHVlICE9PSBudWxsJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKCdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ1xcJyAhPT0gSlNPTi5zdHJpbmdpZnkodmFsdWUpJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpbmdzIGFyZSBub3Qgd2VsbCBpbiB0aGUgbGFuZCBvZiBlbnVtJyk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAvKipcXG4gICAgICAgKiBWYWxpZGF0ZSBcIicgKyBhZGRyZXNzICsgJ1wiIGVudW1cXG4gICAgICAgKi9cXG4gICAgICBpZiAoJyArIGNvbmRpdGlvbnMuam9pbignICYmICcpICsgJykge1xcbiAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICBrZXl3b3JkOiBcXCdlbnVtXFwnLFxcbiAgICAgICAgICBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyBcXCcgaXMgbm90IGFuIGVudW1lcmF0ZWQgdmFsdWVcXCdcXG4gICAgICAgIH0pXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhbnlPZlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBpbnN0YW5jZSB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0XG4gICAgICogPiB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgYXQgbGVhc3Qgb25lIHNjaGVtYSBkZWZpbmVkIGJ5IHRoaXNcbiAgICAgKiA+IGtleXdvcmQncyB2YWx1ZS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjUuNFxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYW55T2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbnlPZigpIHtcbiAgICAgIHZhciBhbnlPZiA9IHRoaXMuc2NoZW1hLmFueU9mLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhbnlPZikpIHtcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgaW5pdGlhbFZhbGlkaXR5ID0gdmFsaWRcXG4gICAgICAgIGluaXRpYWxFcnJvckNvdW50ID0gZXJyb3JzLmxlbmd0aFxcbiAgICAgICAgYW55VmFsaWQgPSBmYWxzZVxcbiAgICAgICc7XG5cbiAgICAgICAgYW55T2YuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NoZW1hKSB7XG4gICAgICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hLCB7IGFkZHJlc3M6IGFkZHJlc3MgfSk7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgYWNjdW11bGF0ZWRFcnJvckNvdW50ID0gZXJyb3JzLmxlbmd0aFxcbiAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICBpZiAoYWNjdW11bGF0ZWRFcnJvckNvdW50ID09PSBlcnJvcnMubGVuZ3RoKSB7XFxuICAgICAgICAgIGFueVZhbGlkID0gdHJ1ZVxcbiAgICAgICAgfVxcbiAgICAgICAgJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICBpZiAoYW55VmFsaWQgPT09IHRydWUpIHtcXG4gICAgICAgICAgICB2YWxpZCA9IGluaXRpYWxWYWxpZGl0eVxcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5zbGljZSgwLCBpbml0aWFsRXJyb3JDb3VudClcXG4gICAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhbGxPZlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBpbnN0YW5jZSB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0XG4gICAgICogPiB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgYWxsIHNjaGVtYXMgZGVmaW5lZCBieSB0aGlzIGtleXdvcmQnc1xuICAgICAqID4gdmFsdWUuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS41LjNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FsbE9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsT2YoKSB7XG4gICAgICB2YXIgYWxsT2YgPSB0aGlzLnNjaGVtYS5hbGxPZixcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWxsT2YpKSB7XG4gICAgICAgIGFsbE9mLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjaGVtYSkge1xuICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSwgeyBhZGRyZXNzOiBhZGRyZXNzIH0pO1xuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgJztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvbmVPZlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBpbnN0YW5jZSB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0XG4gICAgICogPiB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgZXhhY3RseSBvbmUgc2NoZW1hIGRlZmluZWQgYnkgdGhpc1xuICAgICAqID4ga2V5d29yZCdzIHZhbHVlLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNS41XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvbmVPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uZU9mKCkge1xuICAgICAgdmFyIG9uZU9mID0gdGhpcy5zY2hlbWEub25lT2YsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9uZU9mKSkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFZhbGlkYXRlICcgKyBhZGRyZXNzICsgJyBvbmVPZlxcbiAgICAgICAgICovXFxuICAgICAgICBpbml0aWFsVmFsaWRpdHkgPSB2YWxpZFxcbiAgICAgICAgaW5pdGlhbEVycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoXFxuICAgICAgICBjb3VudE9mVmFsaWQgPSAwXFxuICAgICAgJztcblxuICAgICAgICBvbmVPZi5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY2hlbWEpIHtcbiAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICBhY2N1bXVsYXRlZEVycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoXFxuICAgICAgICAnICsgdmFsaWRhdG9yLmNvbXBpbGUoKSArICdcXG4gICAgICAgIGlmIChhY2N1bXVsYXRlZEVycm9yQ291bnQgPT09IGVycm9ycy5sZW5ndGgpIHtcXG4gICAgICAgICAgY291bnRPZlZhbGlkICs9IDFcXG4gICAgICAgIH1cXG4gICAgICAgICc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgICAgaWYgKGNvdW50T2ZWYWxpZCA9PT0gMSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gaW5pdGlhbFZhbGlkaXR5XFxuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLnNsaWNlKDAsIGluaXRpYWxFcnJvckNvdW50KVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAgICBrZXl3b3JkOiBcXCdvbmVPZlxcJyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3doYXQgaXMgYSByZWFzb25hYmxlIGVycm9yIG1lc3NhZ2UgZm9yIHRoaXMgY2FzZT9cXCdcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG5vdFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IHRoaXMga2V5d29yZCBpZiBpdCBmYWlscyB0byB2YWxpZGF0ZVxuICAgICAqID4gc3VjY2Vzc2Z1bGx5IGFnYWluc3QgdGhlIHNjaGVtYSBkZWZpbmVkIGJ5IHRoaXMga2V5d29yZC5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjUuNlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbm90JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm90KCkge1xuICAgICAgdmFyIG5vdCA9IHRoaXMuc2NoZW1hLm5vdCxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKCh0eXBlb2Ygbm90ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihub3QpKSA9PT0gJ29iamVjdCcgJiYgbm90ICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5vdCkpIHtcbiAgICAgICAgdmFyIHN1YnNjaGVtYSA9IG5vdDtcbiAgICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hLCB7IGFkZHJlc3M6IGFkZHJlc3MgfSk7XG5cbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBOT1RcXG4gICAgICAgICAqL1xcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgaW5pdGlhbFZhbGlkaXR5ID0gdmFsaWRcXG4gICAgICAgICAgaW5pdGlhbEVycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoXFxuICAgICAgICAgIG5vdFZhbGlkID0gdHJ1ZVxcblxcbiAgICAgICAgICBhY2N1bXVsYXRlZEVycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoXFxuXFxuICAgICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcblxcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZWRFcnJvckNvdW50ID09PSBlcnJvcnMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgbm90VmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChub3RWYWxpZCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gaW5pdGlhbFZhbGlkaXR5XFxuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLnNsaWNlKDAsIGluaXRpYWxFcnJvckNvdW50KVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuc2xpY2UoMCwgaW5pdGlhbEVycm9yQ291bnQpXFxuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgICAga2V5d29yZDogXFwnbm90XFwnLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogXFwnaG1tLi4uXFwnXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJdGVyYXRlIG92ZXIgdGhlIGBwcm9wZXJ0aWVzYCBzY2hlbWEgcHJvcGVydHkgaWYgaXQgaXMgYW4gb2JqZWN0LiBGb3IgZWFjaFxuICAgICAqIGtleSwgaW5pdGlhbGl6ZSBhIG5ldyBWYWxpZGF0b3IgZm9yIHRoZSBzdWJzY2hlbWEgcmVwcmVzZW50ZWQgYnkgdGhlIHByb3BlcnR5XG4gICAgICogdmFsdWUgYW5kIGludm9rZSBjb21waWxlLiBBcHBlbmQgdGhlIHJlc3VsdCBvZiBjb21waWxpbmcgZWFjaCBzdWJzY2hlbWEgdG9cbiAgICAgKiB0aGUgYmxvY2sgb2YgY29kZSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9wZXJ0aWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcGVydGllcygpIHtcbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYSxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICByZXF1aXJlZCA9IHNjaGVtYS5yZXF1aXJlZDtcblxuICAgICAgdmFyIGJsb2NrID0gdGhpcy5wdXNoKCk7XG5cbiAgICAgIC8vIGVuc3VyZSB0aGUgdmFsdWUgb2YgXCJyZXF1aXJlZFwiIHNjaGVtYSBwcm9wZXJ0eSBpcyBhbiBhcnJheVxuICAgICAgcmVxdWlyZWQgPSBBcnJheS5pc0FycmF5KHJlcXVpcmVkKSA/IHJlcXVpcmVkIDogW107XG5cbiAgICAgIGlmICgodHlwZW9mIHByb3BlcnRpZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb3BlcnRpZXMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHN1YnNjaGVtYSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICB2YXIgaXNSZXF1aXJlZCA9IHJlcXVpcmVkLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgIC8vIGhvdyBzaG91bGQgd2UgYmUgY2FsY3VsYXRpbmcgdGhlc2UgdGhpbmdzPyBzaG91bGQgYmUganNvbiBwb2ludGVyP1xuICAgICAgICAgIC8vIG5lZWRzIGEgc2VwYXJhdGUgZnVuY3Rpb25cbiAgICAgICAgICB2YXIgcG9pbnRlciA9IFthZGRyZXNzLCBrZXldLmZpbHRlcihmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuICEhc2VnbWVudDtcbiAgICAgICAgICB9KS5qb2luKCcuJyk7XG4gICAgICAgICAgdmFyIHZhbGlkYXRpb24gPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSwgeyBhZGRyZXNzOiBwb2ludGVyLCByZXF1aXJlOiBpc1JlcXVpcmVkIH0pO1xuXG4gICAgICAgICAgLy8gcmVhZCB0aGUgdmFsdWVcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcltcXCcnICsga2V5ICsgJ1xcJ11cXG4gICAgICAgICc7XG5cbiAgICAgICAgICBibG9jayArPSB2YWxpZGF0aW9uLmNvbXBpbGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrICs9IHRoaXMucG9wKCk7XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdGhlciBQcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgZm9yIGEga2V5d29yZC4gSXQgd3JhcHMgdmFsaWRhdGlvbnMgZm9yXG4gICAgICogcGF0dGVyblByb3BlcnRpZXMgYW5kIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIGluIGEgc2luZ2xlIGl0ZXJhdGlvbiBvdmVyXG4gICAgICogYW4gb2JqZWN0LXR5cGUgdmFsdWUncyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogSXQgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCBvbmNlIGZvciBhIGdpdmVuIHN1YnNjaGVtYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ290aGVyUHJvcGVydGllcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG90aGVyUHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiAnXFxuICAgICAgLyoqXFxuICAgICAgICogVmFsaWRhdGUgT3RoZXIgUHJvcGVydGllc1xcbiAgICAgICAqL1xcbiAgICAgICcgKyB0aGlzLnB1c2goKSArICdcXG5cXG4gICAgICBmb3IgKGxldCBrZXkgaW4gY29udGFpbmVyKSB7XFxuICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcltrZXldXFxuICAgICAgICBtYXRjaGVkID0gZmFsc2VcXG5cXG4gICAgICAgICcgKyB0aGlzLnBhdHRlcm5WYWxpZGF0aW9ucygpICsgJ1xcbiAgICAgICAgJyArIHRoaXMuYWRkaXRpb25hbFZhbGlkYXRpb25zKCkgKyAnXFxuICAgICAgfVxcblxcbiAgICAgICcgKyB0aGlzLnBvcCgpICsgJ1xcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gVmFsaWRhdGlvbnNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdlbmVyYXRlIHZhbGlkYXRpb24gY29kZSBmcm9tIGEgc3Vic2NoZW1hIGZvciBwcm9wZXJ0aWVzIG1hdGNoaW5nIGFcbiAgICAgKiByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXR0ZXJuVmFsaWRhdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXR0ZXJuVmFsaWRhdGlvbnMoKSB7XG4gICAgICB2YXIgcGF0dGVyblByb3BlcnRpZXMgPSB0aGlzLnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICgodHlwZW9mIHBhdHRlcm5Qcm9wZXJ0aWVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXR0ZXJuUHJvcGVydGllcykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBPYmplY3Qua2V5cyhwYXR0ZXJuUHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICAgIHZhciBzdWJzY2hlbWEgPSBwYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXTtcbiAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEpO1xuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgICAgaWYgKGtleS5tYXRjaChcXCcnICsgcGF0dGVybiArICdcXCcpKSB7XFxuICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWVcXG4gICAgICAgICAgICAnICsgdmFsaWRhdG9yLmNvbXBpbGUoKSArICdcXG4gICAgICAgICAgfVxcbiAgICAgICAgJztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIFZhbGlkYXRpb25zXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBHZW5lcmF0ZSB2YWxpZGF0aW9uIGNvZGUsIGVpdGhlciBmcm9tIGEgc3Vic2NoZW1hIGZvciBwcm9wZXJ0aWVzIG5vdFxuICAgICAqIGRlZmluZWQgaW4gdGhlIHNjaGVtYSwgb3IgdG8gZGlzYWxsb3cgcHJvcGVydGllcyBub3QgZGVmaW5lZCBpbiB0aGVcbiAgICAgKiBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRpdGlvbmFsVmFsaWRhdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRpdGlvbmFsVmFsaWRhdGlvbnMoKSB7XG4gICAgICB2YXIgX3NjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIHByb3BlcnRpZXMgPSBfc2NoZW1hLnByb3BlcnRpZXMsXG4gICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPSBfc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciB2YWxpZGF0aW9ucyA9ICcnO1xuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIC8vIGNhdGNoIGFkZGl0aW9uYWwgdW5tYXRjaGVkIHByb3BlcnRpZXNcbiAgICAgIHZhciBjb25kaXRpb25zID0gWydtYXRjaGVkICE9PSB0cnVlJ107XG5cbiAgICAgIC8vIGlnbm9yZSBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjb25kaXRpb25zLnB1c2goJ2tleSAhPT0gXFwnJyArIGtleSArICdcXCcnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB2YWxpZGF0ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgIGlmICgodHlwZW9mIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhZGRpdGlvbmFsUHJvcGVydGllcykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgc3Vic2NoZW1hID0gYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSwgeyBhZGRyZXNzOiBhZGRyZXNzICsgJ1tBUEtleV0nIH0pO1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvLyB2YWxpZGF0ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcXG4gICAgICAgIGlmICgnICsgY29uZGl0aW9ucy5qb2luKCcgJiYgJykgKyAnKSB7XFxuICAgICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIC8vIGVycm9yIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgIGlmIChhZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgLy8gdmFsaWRhdGUgbm9uLXByZXNlbmNlIG9mIGFkZGl0aW9uYWwgcHJvcGVydGllc1xcbiAgICAgICAgaWYgKCcgKyBjb25kaXRpb25zLmpvaW4oJyAmJiAnKSArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnYWRkaXRpb25hbFByb3BlcnRpZXNcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZToga2V5ICsgXFwnIGlzIG5vdCBhIGRlZmluZWQgcHJvcGVydHlcXCdcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGF0dGVyblByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdlbmVyYXRlIHZhbGlkYXRpb24gY29kZSBmb3IgcHJvcGVydGllcyBtYXRjaGluZyBhIHBhdHRlcm5cbiAgICAgKiBkZWZpbmVkIGJ5IHRoZSBwcm9wZXJ0eSBuYW1lIChrZXkpLCB3aGljaCBtdXN0IGJlIGEgc3RyaW5nXG4gICAgICogcmVwcmVzZW50aW5nIGEgdmFsaWQgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGF0dGVyblByb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoIXRoaXMub3RoZXJQcm9wZXJ0aWVzQ2FsbGVkKSB7XG4gICAgICAgIHRoaXMub3RoZXJQcm9wZXJ0aWVzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgYmxvY2sgKz0gdGhpcy5vdGhlclByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBHZW5lcmF0ZSB2YWxpZGF0aW9uIGNvZGUgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllcyBub3QgZGVmaW5lZFxuICAgICAqIGluIHRoZSBzY2hlbWEsIG9yIGRpc2FsbG93IGFkZGl0aW9uYWwgcHJvcGVydGllcyBpZiB0aGUgdmFsdWUgb2ZcbiAgICAgKiBgYWRkaXRpb25hbFByb3BlcnRpZXNgIGluIHRoZSBzY2hlbWEgaXMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkaXRpb25hbFByb3BlcnRpZXMoKSB7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKCF0aGlzLm90aGVyUHJvcGVydGllc0NhbGxlZCkge1xuICAgICAgICB0aGlzLm90aGVyUHJvcGVydGllc0NhbGxlZCA9IHRydWU7XG4gICAgICAgIGJsb2NrICs9IHRoaXMub3RoZXJQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtaW5Qcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIG9iamVjdCBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IFwibWluUHJvcGVydGllc1wiIGlmIGl0cyBudW1iZXIgb2ZcbiAgICAgKiA+IHByb3BlcnRpZXMgaXMgZ3JlYXRlciB0aGFuLCBvciBlcXVhbCB0bywgdGhlIHZhbHVlIG9mIHRoaXMga2V5d29yZC5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjQuMlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWluUHJvcGVydGllcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pblByb3BlcnRpZXMoKSB7XG4gICAgICB2YXIgbWluUHJvcGVydGllcyA9IHRoaXMuc2NoZW1hLm1pblByb3BlcnRpZXMsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuXG4gICAgICByZXR1cm4gJ1xcbiAgICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIG1pbiBwcm9wZXJ0aWVzXFxuICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA8ICcgKyBtaW5Qcm9wZXJ0aWVzICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdtaW5Qcm9wZXJ0aWVzXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBmZXcgcHJvcGVydGllc1xcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1heFByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQW4gb2JqZWN0IGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgXCJtYXhQcm9wZXJ0aWVzXCIgaWYgaXRzIG51bWJlciBvZlxuICAgICAqID4gcHJvcGVydGllcyBpcyBsZXNzIHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgdGhpcyBrZXl3b3JkLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNC4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtYXhQcm9wZXJ0aWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4UHJvcGVydGllcygpIHtcbiAgICAgIHZhciBtYXhQcm9wZXJ0aWVzID0gdGhpcy5zY2hlbWEubWF4UHJvcGVydGllcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIHJldHVybiAnXFxuICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgbWF4IHByb3BlcnRpZXNcXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gJyArIG1heFByb3BlcnRpZXMgKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ21heFByb3BlcnRpZXNcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwndG9vIG1hbnkgcHJvcGVydGllc1xcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcGVuZGVuY2llc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBGb3IgYWxsIChuYW1lLCBzY2hlbWEpIHBhaXIgb2Ygc2NoZW1hIGRlcGVuZGVuY2llcywgaWYgdGhlIGluc3RhbmNlIGhhc1xuICAgICAqID4gYSBwcm9wZXJ0eSBieSB0aGlzIG5hbWUsIHRoZW4gaXQgbXVzdCBhbHNvIHZhbGlkYXRlIHN1Y2Nlc3NmdWxseSBhZ2FpbnN0XG4gICAgICogPiB0aGUgc2NoZW1hLlxuICAgICAqID5cbiAgICAgKiA+IE5vdGUgdGhhdCB0aGlzIGlzIHRoZSBpbnN0YW5jZSBpdHNlbGYgd2hpY2ggbXVzdCB2YWxpZGF0ZSBzdWNjZXNzZnVsbHksXG4gICAgICogPiBub3QgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvcGVydHkgbmFtZS5cbiAgICAgKiA+XG4gICAgICogPiBGb3IgZWFjaCAobmFtZSwgcHJvcGVydHlzZXQpIHBhaXIgb2YgcHJvcGVydHkgZGVwZW5kZW5jaWVzLCBpZiB0aGVcbiAgICAgKiA+IGluc3RhbmNlIGhhcyBhIHByb3BlcnR5IGJ5IHRoaXMgbmFtZSwgdGhlbiBpdCBtdXN0IGFsc28gaGF2ZSBwcm9wZXJ0aWVzXG4gICAgICogPiB3aXRoIHRoZSBzYW1lIG5hbWVzIGFzIHByb3BlcnR5c2V0LlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNC41LjJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlcGVuZGVuY2llcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlcGVuZGVuY2llcygpIHtcbiAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSB0aGlzLnNjaGVtYS5kZXBlbmRlbmNpZXMsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuXG4gICAgICB2YXIgYmxvY2sgPSB0aGlzLnB1c2goKTtcblxuICAgICAgaWYgKCh0eXBlb2YgZGVwZW5kZW5jaWVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkZXBlbmRlbmNpZXMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVwZW5kZW5jaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1trZXldO1xuICAgICAgICAgIHZhciBjb25kaXRpb25zID0gW107XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZXBlbmRlbmN5KSkge1xuICAgICAgICAgICAgZGVwZW5kZW5jeS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCgnY29udGFpbmVyW1xcJycgKyBpdGVtICsgJ1xcJ10gPT09IHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgICAgICBpZiAoY29udGFpbmVyW1xcJycgKyBrZXkgKyAnXFwnXSAhPT0gdW5kZWZpbmVkICYmICgnICsgY29uZGl0aW9ucy5qb2luKCcgfHwgJykgKyAnKSkge1xcbiAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcXCdkZXBlbmRlbmNpZXNcXCcsXFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3VubWV0IGRlcGVuZGVuY2llc1xcJ1xcbiAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICc7XG4gICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGRlcGVuZGVuY3kgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRlcGVuZGVuY3kpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY2hlbWEgPSBkZXBlbmRlbmN5O1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hLCB7IGFkZHJlc3M6IGFkZHJlc3MgfSk7XG5cbiAgICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgICAgICBpZiAoY29udGFpbmVyW1xcJycgKyBrZXkgKyAnXFwnXSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAnICsgdmFsaWRhdG9yLmNvbXBpbGUoKSArICdcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYmxvY2sgKz0gdGhpcy5wb3AoKTtcblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIG9iamVjdCBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IHRoaXMga2V5d29yZCBpZiBpdHMgcHJvcGVydHkgc2V0XG4gICAgICogPiBjb250YWlucyBhbGwgZWxlbWVudHMgaW4gdGhpcyBrZXl3b3JkJ3MgYXJyYXkgdmFsdWUuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS40LjNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlcXVpcmVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWlyZWQoKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuc2NoZW1hLnByb3BlcnRpZXMsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGJsb2NrICs9ICdcXG4gICAgICAvLyB2YWxpZGF0ZSAnICsgYWRkcmVzcyArICcgcHJlc2VuY2VcXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICBrZXl3b3JkOiBcXCdyZXF1aXJlZFxcJyxcXG4gICAgICAgICAgbWVzc2FnZTogXFwnaXMgcmVxdWlyZWRcXCdcXG4gICAgICAgIH0pXFxuICAgICAgfVxcbiAgICAnO1xuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkaXRpb25hbEl0ZW1zXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IFN1Y2Nlc3NmdWwgdmFsaWRhdGlvbiBvZiBhbiBhcnJheSBpbnN0YW5jZSB3aXRoIHJlZ2FyZHMgdG8gdGhlc2UgdHdvXG4gICAgICogPiBrZXl3b3JkcyBpcyBkZXRlcm1pbmVkIGFzIGZvbGxvd3M6IGlmIFwiaXRlbXNcIiBpcyBub3QgcHJlc2VudCwgb3IgaXRzXG4gICAgICogPiB2YWx1ZSBpcyBhbiBvYmplY3QsIHZhbGlkYXRpb24gb2YgdGhlIGluc3RhbmNlIGFsd2F5cyBzdWNjZWVkcyxcbiAgICAgKiA+IHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIFwiYWRkaXRpb25hbEl0ZW1zXCI7IGlmIHRoZSB2YWx1ZSBvZlxuICAgICAqID4gXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBib29sZWFuIHZhbHVlIHRydWUgb3IgYW4gb2JqZWN0LCB2YWxpZGF0aW9uIG9mXG4gICAgICogPiB0aGUgaW5zdGFuY2UgYWx3YXlzIHN1Y2NlZWRzOyBpZiB0aGUgdmFsdWUgb2YgXCJhZGRpdGlvbmFsSXRlbXNcIiBpc1xuICAgICAqID4gYm9vbGVhbiB2YWx1ZSBmYWxzZSBhbmQgdGhlIHZhbHVlIG9mIFwiaXRlbXNcIiBpcyBhbiBhcnJheSwgdGhlXG4gICAgICogPiBpbnN0YW5jZSBpcyB2YWxpZCBpZiBpdHMgc2l6ZSBpcyBsZXNzIHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgc2l6ZVxuICAgICAqID4gb2YgXCJpdGVtc1wiLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMy4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRpdGlvbmFsSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRpdGlvbmFsSXRlbXMoKSB7XG4gICAgICB2YXIgX3NjaGVtYTIgPSB0aGlzLnNjaGVtYSxcbiAgICAgICAgICBpdGVtcyA9IF9zY2hlbWEyLml0ZW1zLFxuICAgICAgICAgIGFkZGl0aW9uYWxJdGVtcyA9IF9zY2hlbWEyLmFkZGl0aW9uYWxJdGVtcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKGFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgLy8gZG9uXFwndCBhbGxvdyBhZGRpdGlvbmFsIGl0ZW1zXFxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gJyArIGl0ZW1zLmxlbmd0aCArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnYWRkaXRpb25hbEl0ZW1zXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ2FkZGl0aW9uYWwgaXRlbXMgbm90IGFsbG93ZWRcXCdcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHR5cGVvZiBhZGRpdGlvbmFsSXRlbXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFkZGl0aW9uYWxJdGVtcykpID09PSAnb2JqZWN0JyAmJiBhZGRpdGlvbmFsSXRlbXMgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgdmFyIHN1YnNjaGVtYSA9IGFkZGl0aW9uYWxJdGVtcztcbiAgICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hKTtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBWYWxpZGF0b3IuY291bnRlcjtcblxuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvLyBhZGRpdGlvbmFsIGl0ZW1zXFxuICAgICAgICAnICsgdGhpcy5wdXNoKCkgKyAnXFxuXFxuICAgICAgICBmb3IgKHZhciBpJyArIGNvdW50ZXIgKyAnID0gJyArIGl0ZW1zLmxlbmd0aCArICc7IGknICsgY291bnRlciArICcgPD0gY29udGFpbmVyLmxlbmd0aDsgaScgKyBjb3VudGVyICsgJysrKSB7XFxuICAgICAgICAgIHZhbHVlID0gY29udGFpbmVyW2knICsgY291bnRlciArICddXFxuICAgICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJyArIHRoaXMucG9wKCkgKyAnXFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZW1zXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IFN1Y2Nlc3NmdWwgdmFsaWRhdGlvbiBvZiBhbiBhcnJheSBpbnN0YW5jZSB3aXRoIHJlZ2FyZHMgdG8gdGhlc2UgdHdvXG4gICAgICogPiBrZXl3b3JkcyBpcyBkZXRlcm1pbmVkIGFzIGZvbGxvd3M6IGlmIFwiaXRlbXNcIiBpcyBub3QgcHJlc2VudCwgb3IgaXRzXG4gICAgICogPiB2YWx1ZSBpcyBhbiBvYmplY3QsIHZhbGlkYXRpb24gb2YgdGhlIGluc3RhbmNlIGFsd2F5cyBzdWNjZWVkcyxcbiAgICAgKiA+IHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIFwiYWRkaXRpb25hbEl0ZW1zXCI7IGlmIHRoZSB2YWx1ZSBvZlxuICAgICAqID4gXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBib29sZWFuIHZhbHVlIHRydWUgb3IgYW4gb2JqZWN0LCB2YWxpZGF0aW9uIG9mXG4gICAgICogPiB0aGUgaW5zdGFuY2UgYWx3YXlzIHN1Y2NlZWRzOyBpZiB0aGUgdmFsdWUgb2YgXCJhZGRpdGlvbmFsSXRlbXNcIiBpc1xuICAgICAqID4gYm9vbGVhbiB2YWx1ZSBmYWxzZSBhbmQgdGhlIHZhbHVlIG9mIFwiaXRlbXNcIiBpcyBhbiBhcnJheSwgdGhlXG4gICAgICogPiBpbnN0YW5jZSBpcyB2YWxpZCBpZiBpdHMgc2l6ZSBpcyBsZXNzIHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgc2l6ZVxuICAgICAqID4gb2YgXCJpdGVtc1wiLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMy4xXG4gICAgICpcbiAgICAgKiBDb2RlIHRvIGdlbmVyYXRlXG4gICAgICpcbiAgICAgKiAgICAgLy8gdGhpcyBvdXRlciBjb25kaXRpb25hbCBpcyBnZW5lcmF0ZWQgYnkgdGhpcy5hcnJheSgpXG4gICAgICogICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB7XG4gICAgICogICAgICAgbGV0IHBhcmVudCA9IHZhbHVlXG4gICAgICogICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgKiAgICAgICAgIHZhbHVlID0gcGFyZW50W2ldXG4gICAgICogICAgICAgICAvLyBvdGhlciB2YWxpZGF0aW9uIGNvZGUgZGVwZW5kaW5nIG9uIHZhbHVlIGhlcmVcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgICAgdmFsdWUgPSBwYXJlbnRcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGl0ZW1zKCkge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5zY2hlbWEuaXRlbXMsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIC8vIGlmIGl0ZW1zIGlzIGFuIGFycmF5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgYmxvY2sgKz0gdGhpcy5wdXNoKCk7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgc3Vic2NoZW1hID0gaXRlbTtcbiAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEsIHsgYWRkcmVzczogYWRkcmVzcyArICdbJyArIGluZGV4ICsgJ10nIH0pO1xuXG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICAvLyBpdGVtICMnICsgaW5kZXggKyAnXFxuICAgICAgICAgIHZhbHVlID0gY29udGFpbmVyWycgKyBpbmRleCArICddXFxuICAgICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmxvY2sgKz0gdGhpcy5wb3AoKTtcblxuICAgICAgICAvLyBpZiBpdGVtcyBpcyBhbiBvYmplY3RcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBpdGVtcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaXRlbXMpKSA9PT0gJ29iamVjdCcgJiYgaXRlbXMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN1YnNjaGVtYSA9IGl0ZW1zO1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEpO1xuICAgICAgICB2YXIgY291bnRlciA9IFZhbGlkYXRvci5jb3VudGVyO1xuXG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIC8vIGl0ZW1zXFxuICAgICAgICAnICsgdGhpcy5wdXNoKCkgKyAnXFxuXFxuICAgICAgICBmb3IgKHZhciBpJyArIGNvdW50ZXIgKyAnID0gMDsgaScgKyBjb3VudGVyICsgJyA8IGNvbnRhaW5lci5sZW5ndGg7IGknICsgY291bnRlciArICcrKykge1xcbiAgICAgICAgICAvLyByZWFkIGFycmF5IGVsZW1lbnRcXG4gICAgICAgICAgdmFsdWUgPSBjb250YWluZXJbaScgKyBjb3VudGVyICsgJ11cXG4gICAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICB9XFxuXFxuICAgICAgICAnICsgdGhpcy5wb3AoKSArICdcXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWluSXRlbXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQW4gYXJyYXkgaW5zdGFuY2UgaXMgdmFsaWQgYWdhaW5zdCBcIm1pbkl0ZW1zXCIgaWYgaXRzIHNpemUgaXMgZ3JlYXRlclxuICAgICAqID4gdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSB2YWx1ZSBvZiB0aGlzIGtleXdvcmQuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS4zLjNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21pbkl0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluSXRlbXMoKSB7XG4gICAgICB2YXIgbWluSXRlbXMgPSB0aGlzLnNjaGVtYS5taW5JdGVtcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIHJldHVybiAnXFxuICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgbWluIGl0ZW1zXFxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDwgJyArIG1pbkl0ZW1zICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdtaW5JdGVtc1xcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBcXCd0b28gZmV3IHByb3BlcnRpZXNcXCdcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYXhJdGVtc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBhcnJheSBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IFwibWF4SXRlbXNcIiBpZiBpdHMgc2l6ZSBpcyBsZXNzXG4gICAgICogPiB0aGFuLCBvciBlcXVhbCB0bywgdGhlIHZhbHVlIG9mIHRoaXMga2V5d29yZC5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjMuMlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWF4SXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhJdGVtcygpIHtcbiAgICAgIHZhciBtYXhJdGVtcyA9IHRoaXMuc2NoZW1hLm1heEl0ZW1zLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cblxuICAgICAgcmV0dXJuICdcXG4gICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyBtYXggaXRlbXNcXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAnICsgbWF4SXRlbXMgKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ21heEl0ZW1zXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBtYW55IHByb3BlcnRpZXNcXCdcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1bmlxdWVJdGVtc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBJZiB0aGlzIGtleXdvcmQgaGFzIGJvb2xlYW4gdmFsdWUgZmFsc2UsIHRoZSBpbnN0YW5jZSB2YWxpZGF0ZXNcbiAgICAgKiA+IHN1Y2Nlc3NmdWxseS4gSWYgaXQgaGFzIGJvb2xlYW4gdmFsdWUgdHJ1ZSwgdGhlIGluc3RhbmNlIHZhbGlkYXRlc1xuICAgICAqID4gc3VjY2Vzc2Z1bGx5IGlmIGFsbCBvZiBpdHMgZWxlbWVudHMgYXJlIHVuaXF1ZS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjMuNFxuICAgICAqXG4gICAgICogVE9ET1xuICAgICAqIG9wdGltaXplXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bmlxdWVJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuaXF1ZUl0ZW1zKCkge1xuICAgICAgdmFyIHVuaXF1ZUl0ZW1zID0gdGhpcy5zY2hlbWEudW5pcXVlSXRlbXMsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICh1bmlxdWVJdGVtcyA9PT0gdHJ1ZSkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvLyB2YWxpZGF0ZSAnICsgYWRkcmVzcyArICcgdW5pcXVlIGl0ZW1zXFxuICAgICAgICBsZXQgdmFsdWVzID0gdmFsdWUubWFwKHYgPT4gSlNPTi5zdHJpbmdpZnkodikpIC8vIFRPRE86IG9wdGltaXplXFxuICAgICAgICBsZXQgc2V0ID0gbmV3IFNldCh2YWx1ZXMpXFxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gc2V0LnNpemUpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwndW5pcXVlSXRlbXNcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwnaXRlbXMgbXVzdCBiZSB1bmlxdWVcXCdcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWluTGVuZ3RoXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEEgc3RyaW5nIGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0cyBsZW5ndGggaXNcbiAgICAgKiA+IGdyZWF0ZXIgdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSB2YWx1ZSBvZiB0aGlzIGtleXdvcmQuIFRoZSBsZW5ndGggb2ZcbiAgICAgKiA+IGEgc3RyaW5nIGluc3RhbmNlIGlzIGRlZmluZWQgYXMgdGhlIG51bWJlciBvZiBpdHMgY2hhcmFjdGVycyBhc1xuICAgICAqID4gZGVmaW5lZCBieSBSRkMgNDYyNyBbUkZDNDYyN10uXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS4yLjJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21pbkxlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbkxlbmd0aCgpIHtcbiAgICAgIHZhciBtaW5MZW5ndGggPSB0aGlzLnNjaGVtYS5taW5MZW5ndGgsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuXG4gICAgICByZXR1cm4gJ1xcbiAgICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIHZhbGlkYXRlIG1pbkxlbmd0aFxcbiAgICAgICAgaWYgKEFycmF5LmZyb20odmFsdWUpLmxlbmd0aCA8ICcgKyBtaW5MZW5ndGggKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ21pbkxlbmd0aFxcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBcXCd0b28gc2hvcnRcXCdcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYXhMZW5ndGhcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQSBzdHJpbmcgaW5zdGFuY2UgaXMgdmFsaWQgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRzIGxlbmd0aCBpcyBsZXNzXG4gICAgICogPiB0aGFuLCBvciBlcXVhbCB0bywgdGhlIHZhbHVlIG9mIHRoaXMga2V5d29yZC4gVGhlIGxlbmd0aCBvZiBhIHN0cmluZ1xuICAgICAqID4gaW5zdGFuY2UgaXMgZGVmaW5lZCBhcyB0aGUgbnVtYmVyIG9mIGl0cyBjaGFyYWN0ZXJzIGFzIGRlZmluZWQgYnlcbiAgICAgKiA+IFJGQyA0NjI3IFtSRkM0NjI3XS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjIuMVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWF4TGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4TGVuZ3RoKCkge1xuICAgICAgdmFyIG1heExlbmd0aCA9IHRoaXMuc2NoZW1hLm1heExlbmd0aCxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIHJldHVybiAnXFxuICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgdmFsaWRhdGUgbWF4TGVuZ3RoXFxuICAgICAgICBpZiAoQXJyYXkuZnJvbSh2YWx1ZSkubGVuZ3RoID4gJyArIG1heExlbmd0aCArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbWF4TGVuZ3RoXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBsb25nXFwnXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0dGVyblxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBIHN0cmluZyBpbnN0YW5jZSBpcyBjb25zaWRlcmVkIHZhbGlkIGlmIHRoZSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgKiA+IG1hdGNoZXMgdGhlIGluc3RhbmNlIHN1Y2Nlc3NmdWxseS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjIuM1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGF0dGVybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdHRlcm4oKSB7XG4gICAgICB2YXIgcGF0dGVybiA9IHRoaXMuc2NoZW1hLnBhdHRlcm4sXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuXG4gICAgICBpZiAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gJ1xcbiAgICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgdmFsaWRhdGUgcGF0dGVyblxcbiAgICAgICAgICBpZiAoIXZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoXFwnJyArIHBhdHRlcm4gKyAnXFwnKSkpIHtcXG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgICAga2V5d29yZDogXFwncGF0dGVyblxcJyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ2RvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlZCBwYXR0ZXJuXFwnXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IFN0cnVjdHVyYWwgdmFsaWRhdGlvbiBhbG9uZSBtYXkgYmUgaW5zdWZmaWNpZW50IHRvIHZhbGlkYXRlIHRoYXRcbiAgICAgKiA+IGFuIGluc3RhbmNlIG1lZXRzIGFsbCB0aGUgcmVxdWlyZW1lbnRzIG9mIGFuIGFwcGxpY2F0aW9uLiBUaGVcbiAgICAgKiA+IFwiZm9ybWF0XCIga2V5d29yZCBpcyBkZWZpbmVkIHRvIGFsbG93IGludGVyb3BlcmFibGUgc2VtYW50aWNcbiAgICAgKiA+IHZhbGlkYXRpb24gZm9yIGEgZml4ZWQgc3Vic2V0IG9mIHZhbHVlcyB3aGljaCBhcmUgYWNjdXJhdGVseVxuICAgICAqID4gZGVzY3JpYmVkIGJ5IGF1dGhvcml0YXRpdmUgcmVzb3VyY2VzLCBiZSB0aGV5IFJGQ3Mgb3Igb3RoZXJcbiAgICAgKiA+IGV4dGVybmFsIHNwZWNpZmljYXRpb25zLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDcuMVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KCkge1xuICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuc2NoZW1hLmZvcm1hdCxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgbWF0Y2hlciA9IGZvcm1hdHMucmVzb2x2ZShmb3JtYXQpO1xuXG4gICAgICBpZiAobWF0Y2hlcikge1xuICAgICAgICByZXR1cm4gJ1xcbiAgICAgIC8vICcgKyBhZGRyZXNzICsgJyB2YWxpZGF0ZSBmb3JtYXRcXG4gICAgICBpZiAoIXZhbHVlLm1hdGNoKCcgKyBtYXRjaGVyICsgJykpIHtcXG4gICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAga2V5d29yZDogXFwnZm9ybWF0XFwnLFxcbiAgICAgICAgICBtZXNzYWdlOiBcXCdpcyBub3QgXCInICsgZm9ybWF0ICsgJ1wiIGZvcm1hdFxcJ1xcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IFN1Y2Nlc3NmdWwgdmFsaWRhdGlvbiBkZXBlbmRzIG9uIHRoZSBwcmVzZW5jZSBhbmQgdmFsdWUgb2ZcbiAgICAgKiA+IFwiZXhjbHVzaXZlTWluaW11bVwiOiBpZiBcImV4Y2x1c2l2ZU1pbmltdW1cIiBpcyBub3QgcHJlc2VudCwgb3IgaGFzXG4gICAgICogPiBib29sZWFuIHZhbHVlIGZhbHNlLCB0aGVuIHRoZSBpbnN0YW5jZSBpcyB2YWxpZCBpZiBpdCBpcyBncmVhdGVyXG4gICAgICogPiB0aGFuLCBvciBlcXVhbCB0bywgdGhlIHZhbHVlIG9mIFwibWluaW11bVwiOyBpZiBcImV4Y2x1c2l2ZU1pbmltdW1cIiBpc1xuICAgICAqID4gcHJlc2VudCBhbmQgaGFzIGJvb2xlYW4gdmFsdWUgdHJ1ZSwgdGhlIGluc3RhbmNlIGlzIHZhbGlkIGlmIGl0IGlzXG4gICAgICogPiBzdHJpY3RseSBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIFwibWluaW11bVwiLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMS4zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtaW5pbXVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluaW11bSgpIHtcbiAgICAgIHZhciBfc2NoZW1hMyA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIG1pbmltdW0gPSBfc2NoZW1hMy5taW5pbXVtLFxuICAgICAgICAgIGV4Y2x1c2l2ZU1pbmltdW0gPSBfc2NoZW1hMy5leGNsdXNpdmVNaW5pbXVtLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBvcGVyYXRvciA9IGV4Y2x1c2l2ZU1pbmltdW0gPT09IHRydWUgPyAnPD0nIDogJzwnO1xuXG4gICAgICByZXR1cm4gJ1xcbiAgICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIHZhbGlkYXRlIG1pbmltdW1cXG4gICAgICAgIGlmICh2YWx1ZSAnICsgb3BlcmF0b3IgKyAnICcgKyBtaW5pbXVtICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdtaW5pbXVtXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBzbWFsbFxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1heGltdW1cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gU3VjY2Vzc2Z1bCB2YWxpZGF0aW9uIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIGFuZCB2YWx1ZSBvZlxuICAgICAqID4gXCJleGNsdXNpdmVNYXhpbXVtXCI6IGlmIFwiZXhjbHVzaXZlTWF4aW11bVwiIGlzIG5vdCBwcmVzZW50LCBvciBoYXNcbiAgICAgKiA+IGJvb2xlYW4gdmFsdWUgZmFsc2UsIHRoZW4gdGhlIGluc3RhbmNlIGlzIHZhbGlkIGlmIGl0IGlzIGxvd2VyIHRoYW4sXG4gICAgICogPiBvciBlcXVhbCB0bywgdGhlIHZhbHVlIG9mIFwibWF4aW11bVwiOyBpZiBcImV4Y2x1c2l2ZU1heGltdW1cIiBoYXNcbiAgICAgKiA+IGJvb2xlYW4gdmFsdWUgdHJ1ZSwgdGhlIGluc3RhbmNlIGlzIHZhbGlkIGlmIGl0IGlzIHN0cmljdGx5IGxvd2VyXG4gICAgICogPiB0aGFuIHRoZSB2YWx1ZSBvZiBcIm1heGltdW1cIi5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjEuMlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWF4aW11bScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heGltdW0oKSB7XG4gICAgICB2YXIgX3NjaGVtYTQgPSB0aGlzLnNjaGVtYSxcbiAgICAgICAgICBtYXhpbXVtID0gX3NjaGVtYTQubWF4aW11bSxcbiAgICAgICAgICBleGNsdXNpdmVNYXhpbXVtID0gX3NjaGVtYTQuZXhjbHVzaXZlTWF4aW11bSxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgb3BlcmF0b3IgPSBleGNsdXNpdmVNYXhpbXVtID09PSB0cnVlID8gJz49JyA6ICc+JztcblxuICAgICAgcmV0dXJuICdcXG4gICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyB2YWxpZGF0ZSBtYXhpbXVtXFxuICAgICAgICBpZiAodmFsdWUgJyArIG9wZXJhdG9yICsgJyAnICsgbWF4aW11bSArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbWF4aW11bVxcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBcXCd0b28gbGFyZ2VcXCdcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtdWx0aXBsZU9mXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEEgbnVtZXJpYyBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IFwibXVsdGlwbGVPZlwiIGlmIHRoZSByZXN1bHQgb2ZcbiAgICAgKiA+IHRoZSBkaXZpc2lvbiBvZiB0aGUgaW5zdGFuY2UgYnkgdGhpcyBrZXl3b3JkJ3MgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjEuMVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbXVsdGlwbGVPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGxlT2YoKSB7XG4gICAgICB2YXIgbXVsdGlwbGVPZiA9IHRoaXMuc2NoZW1hLm11bHRpcGxlT2Y7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAodHlwZW9mIG11bHRpcGxlT2YgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBtdWx0aXBsZU9mLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICB2YXIgZGVjaW1hbHMgPSBsZW5ndGggLSBtdWx0aXBsZU9mLnRvRml4ZWQoMCkubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHBvdyA9IGRlY2ltYWxzID4gMCA/IE1hdGgucG93KDEwLCBkZWNpbWFscykgOiAxO1xuICAgICAgICB2YXIgY29uZGl0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChkZWNpbWFscyA+IDApIHtcbiAgICAgICAgICBjb25kaXRpb24gPSAnKHZhbHVlICogJyArIHBvdyArICcpICUgJyArIG11bHRpcGxlT2YgKiBwb3cgKyAnICE9PSAwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25kaXRpb24gPSAndmFsdWUgJSAnICsgbXVsdGlwbGVPZiArICcgIT09IDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgaWYgKCcgKyBjb25kaXRpb24gKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ211bHRpcGxlT2ZcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwnbXVzdCBiZSBhIG11bHRpcGxlIG9mICcgKyBtdWx0aXBsZU9mICsgJ1xcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmFsaWRhdG9yO1xufSgpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBWYWxpZGF0b3I7XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBAbW9kdWxlIEpTT04gT2JqZWN0IFNpZ25pbmcgYW5kIEVuY3J5cHRpb24gKEpPU0UpXG4gKi9cbnZhciBKV0EgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbnZhciBKV0sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcbnZhciBKV0tTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcbnZhciBKV1QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcbnZhciBKV1MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBCYXNlNjRVUkxTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcbnZhciBKT1NFSGVhZGVyU2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG52YXIgSldLU2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG52YXIgSldLU2V0U2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG52YXIgSldUQ2xhaW1zU2V0U2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG52YXIgSldUU2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBKV0E6IEpXQSxcbiAgSldLOiBKV0ssXG4gIEpXS1NldDogSldLU2V0LFxuICBKV1Q6IEpXVCxcbiAgSldTOiBKV1MsXG4gIEJhc2U2NFVSTFNjaGVtYTogQmFzZTY0VVJMU2NoZW1hLFxuICBKT1NFSGVhZGVyU2NoZW1hOiBKT1NFSGVhZGVyU2NoZW1hLFxuICBKV0tTY2hlbWE6IEpXS1NjaGVtYSxcbiAgSldLU2V0U2NoZW1hOiBKV0tTZXRTY2hlbWEsXG4gIEpXVENsYWltc1NldFNjaGVtYTogSldUQ2xhaW1zU2V0U2NoZW1hLFxuICBKV1RTY2hlbWE6IEpXVFNjaGVtYVxufTtcblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICpcbiAqIFRPRE9cbiAqIC0gc3dpdGNoIGJldHdlZW4gTm9kZS5qcyB3ZWJjcnlwdG8gcGFja2FnZSBhbmQgYnJvd3NlciBpbXBsZW1lbnRhdGlvblxuICovXG52YXIgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgc3VwcG9ydGVkQWxnb3JpdGhtcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KSxcbiAgICBOb3RTdXBwb3J0ZWRFcnJvciA9IF9yZXF1aXJlLk5vdFN1cHBvcnRlZEVycm9yO1xuXG4vKipcbiAqIEpXQVxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MThcbiAqL1xuXG5cbnZhciBKV0EgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEpXQSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSldBKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKV0EsIG51bGwsIFt7XG4gICAga2V5OiAnc2lnbicsXG5cblxuICAgIC8qKlxuICAgICAqIFNpZ25cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIENyZWF0ZSBhIGRpZ2l0YWwgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsZ1xuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5fSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGRhdGFcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oYWxnLCBrZXksIGRhdGEpIHtcbiAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgYWxnb3JpdGhtXG4gICAgICB2YXIgbm9ybWFsaXplZEFsZ29yaXRobSA9IHN1cHBvcnRlZEFsZ29yaXRobXMubm9ybWFsaXplKCdzaWduJywgYWxnKTtcblxuICAgICAgLy8gdmFsaWRhdGUgYWxnb3JpdGhtIGlzIHN1cHBvcnRlZFxuICAgICAgaWYgKG5vcm1hbGl6ZWRBbGdvcml0aG0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IE5vdFN1cHBvcnRlZEVycm9yKGFsZykpO1xuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZGF0ZSB0eXBlIG9mIGtleVxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gIC0gaXMgdGhlIGtleSBzdWl0YWJsZSBmb3IgdGhlIGFsZ29yaXRobT9cbiAgICAgIC8vICAtIGRvZXMgdGhhdCBnZXQgdmFsaWRhdGVkIGluIHdlYmNyeXB0bz9cbiAgICAgIC8vaWYgKGtleSBpbnN0YW5jZW9mIENyeXB0b0tleSkge1xuICAgICAgLy8gIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgSW52YWxpZEtleUVycm9yKCkpXG4gICAgICAvL31cblxuICAgICAgLy8gc2lnbiB0aGUgZGF0YVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBbGdvcml0aG0uc2lnbihrZXksIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZlcmlmeVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVmVyaWZ5IGEgZGlnaXRhbCBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxnXG4gICAgICogQHBhcmFtIHtDcnlwdG9LZXl9IHByaXZhdGVLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IHNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmVyaWZ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5KGFsZywga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgIHZhciBub3JtYWxpemVkQWxnb3JpdGhtID0gc3VwcG9ydGVkQWxnb3JpdGhtcy5ub3JtYWxpemUoJ3ZlcmlmeScsIGFsZyk7XG5cbiAgICAgIGlmIChub3JtYWxpemVkQWxnb3JpdGhtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBOb3RTdXBwb3J0ZWRFcnJvcihhbGcpKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gdmFsaWRhdGUgcHVibGljS2V5XG5cbiAgICAgIC8vIHZlcmlmeSB0aGUgc2lnbmF0dXJlXG4gICAgICByZXR1cm4gbm9ybWFsaXplZEFsZ29yaXRobS52ZXJpZnkoa2V5LCBzaWduYXR1cmUsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY3J5cHRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIERlY3J5cHRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEltcG9ydFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbXBvcnRLZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbXBvcnRLZXkoa2V5KSB7XG4gICAgICB2YXIgbm9ybWFsaXplZEFsZ29yaXRobSA9IHN1cHBvcnRlZEFsZ29yaXRobXMubm9ybWFsaXplKCdpbXBvcnRLZXknLCBrZXkuYWxnKTtcbiAgICAgIHJldHVybiBub3JtYWxpemVkQWxnb3JpdGhtLmltcG9ydEtleShrZXkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKV0E7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpXQTtcblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDApLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG4vKiA0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihCdWZmZXIpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwYWRfc3RyaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcbmZ1bmN0aW9uIGVuY29kZShpbnB1dCwgZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IFwidXRmOFwiOyB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21CYXNlNjQoaW5wdXQudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUJhc2U2NChCdWZmZXIuZnJvbShpbnB1dCwgZW5jb2RpbmcpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbn1cbjtcbmZ1bmN0aW9uIGRlY29kZShiYXNlNjR1cmwsIGVuY29kaW5nKSB7XG4gICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApIHsgZW5jb2RpbmcgPSBcInV0ZjhcIjsgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0b0Jhc2U2NChiYXNlNjR1cmwpLCBcImJhc2U2NFwiKS50b1N0cmluZyhlbmNvZGluZyk7XG59XG5mdW5jdGlvbiB0b0Jhc2U2NChiYXNlNjR1cmwpIHtcbiAgICBiYXNlNjR1cmwgPSBiYXNlNjR1cmwudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gcGFkX3N0cmluZ18xLmRlZmF1bHQoYmFzZTY0dXJsKVxuICAgICAgICAucmVwbGFjZSgvXFwtL2csIFwiK1wiKVxuICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIik7XG59XG5mdW5jdGlvbiBmcm9tQmFzZTY0KGJhc2U2NCkge1xuICAgIHJldHVybiBiYXNlNjRcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCBcIi1cIilcbiAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG59XG5mdW5jdGlvbiB0b0J1ZmZlcihiYXNlNjR1cmwpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odG9CYXNlNjQoYmFzZTY0dXJsKSwgXCJiYXNlNjRcIik7XG59XG52YXIgYmFzZTY0dXJsID0gZW5jb2RlO1xuYmFzZTY0dXJsLmVuY29kZSA9IGVuY29kZTtcbmJhc2U2NHVybC5kZWNvZGUgPSBkZWNvZGU7XG5iYXNlNjR1cmwudG9CYXNlNjQgPSB0b0Jhc2U2NDtcbmJhc2U2NHVybC5mcm9tQmFzZTY0ID0gZnJvbUJhc2U2NDtcbmJhc2U2NHVybC50b0J1ZmZlciA9IHRvQnVmZmVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gYmFzZTY0dXJsO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkuQnVmZmVyKSlcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG5cblxudmFyIGJhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpXG52YXIgaWVlZTc1NCA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpKVxuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oQnVmZmVyKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBwYWRTdHJpbmcoaW5wdXQpIHtcbiAgICB2YXIgc2VnbWVudExlbmd0aCA9IDQ7XG4gICAgdmFyIHN0cmluZ0xlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB2YXIgZGlmZiA9IHN0cmluZ0xlbmd0aCAlIHNlZ21lbnRMZW5ndGg7XG4gICAgaWYgKCFkaWZmKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgdmFyIHBvc2l0aW9uID0gc3RyaW5nTGVuZ3RoO1xuICAgIHZhciBwYWRMZW5ndGggPSBzZWdtZW50TGVuZ3RoIC0gZGlmZjtcbiAgICB2YXIgcGFkZGVkU3RyaW5nTGVuZ3RoID0gc3RyaW5nTGVuZ3RoICsgcGFkTGVuZ3RoO1xuICAgIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MocGFkZGVkU3RyaW5nTGVuZ3RoKTtcbiAgICBidWZmZXIud3JpdGUoaW5wdXQpO1xuICAgIHdoaWxlIChwYWRMZW5ndGgtLSkge1xuICAgICAgICBidWZmZXIud3JpdGUoXCI9XCIsIHBvc2l0aW9uKyspO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYWRTdHJpbmc7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKS5CdWZmZXIpKVxuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogTG9jYWwgZGVwZW5kZW5jaWVzXG4gKi9cbnZhciBOb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG52YXIgSE1BQyA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xudmFyIFJTQVNTQV9QS0NTMV92MV81ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG52YXIgU3VwcG9ydGVkQWxnb3JpdGhtcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xuXG4vKipcbiAqIFJlZ2lzdGVyIFN1cHBvcnRlZCBBbGdvcml0aG1zXG4gKi9cbnZhciBzdXBwb3J0ZWRBbGdvcml0aG1zID0gbmV3IFN1cHBvcnRlZEFsZ29yaXRobXMoKTtcblxuLyoqXG4gKiBTaWduXG4gKi9cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdIUzI1NicsICdzaWduJywgbmV3IEhNQUMoe1xuICBuYW1lOiAnSE1BQycsXG4gIGhhc2g6IHtcbiAgICBuYW1lOiAnU0hBLTI1NidcbiAgfVxufSkpO1xuXG5zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnSFMzODQnLCAnc2lnbicsIG5ldyBITUFDKHtcbiAgbmFtZTogJ0hNQUMnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0zODQnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0hTNTEyJywgJ3NpZ24nLCBuZXcgSE1BQyh7XG4gIG5hbWU6ICdITUFDJyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtNTEyJ1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdSUzI1NicsICdzaWduJywgbmV3IFJTQVNTQV9QS0NTMV92MV81KHtcbiAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMjU2J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdSUzM4NCcsICdzaWduJywgbmV3IFJTQVNTQV9QS0NTMV92MV81KHtcbiAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMzg0J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdSUzUxMicsICdzaWduJywgbmV3IFJTQVNTQV9QS0NTMV92MV81KHtcbiAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtNTEyJ1xuICB9XG59KSk7XG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdFUzI1NicsICdzaWduJywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdFUzM4NCcsICdzaWduJywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdFUzUxMicsICdzaWduJywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdQUzI1NicsICdzaWduJywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdQUzM4NCcsICdzaWduJywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdQUzUxMicsICdzaWduJywge30pXG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdub25lJywgJ3NpZ24nLCBuZXcgTm9uZSh7XG4gIC8vIG5vdGhpbmcgZ29lcyBoZXJlXG59KSk7XG5cbi8qKlxuICogVmVyaWZ5XG4gKi9cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdIUzI1NicsICd2ZXJpZnknLCBuZXcgSE1BQyh7XG4gIG5hbWU6ICdITUFDJyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMjU2J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdIUzM4NCcsICd2ZXJpZnknLCBuZXcgSE1BQyh7XG4gIG5hbWU6ICdITUFDJyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMzg0J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdIUzUxMicsICd2ZXJpZnknLCBuZXcgSE1BQyh7XG4gIG5hbWU6ICdITUFDJyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtNTEyJ1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdSUzI1NicsICd2ZXJpZnknLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0yNTYnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTMzg0JywgJ3ZlcmlmeScsIG5ldyBSU0FTU0FfUEtDUzFfdjFfNSh7XG4gIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gIGhhc2g6IHtcbiAgICBuYW1lOiAnU0hBLTM4NCdcbiAgfVxufSkpO1xuXG5zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnUlM1MTInLCAndmVyaWZ5JywgbmV3IFJTQVNTQV9QS0NTMV92MV81KHtcbiAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtNTEyJ1xuICB9XG59KSk7XG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdFUzI1NicsICd2ZXJpZnknLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0VTMzg0JywgJ3ZlcmlmeScsIHt9KVxuLy9zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnRVM1MTInLCAndmVyaWZ5Jywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdQUzI1NicsICd2ZXJpZnknLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1BTMzg0JywgJ3ZlcmlmeScsIHt9KVxuLy9zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnUFM1MTInLCAndmVyaWZ5Jywge30pXG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdub25lJywgJ3ZlcmlmeScsIG5ldyBOb25lKHtcbiAgLy8gbm90aGluZyBnb2VzIGhlcmVcbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTMjU2JywgJ2ltcG9ydEtleScsIG5ldyBSU0FTU0FfUEtDUzFfdjFfNSh7XG4gIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gIGhhc2g6IHtcbiAgICBuYW1lOiAnU0hBLTI1NidcbiAgfVxufSkpO1xuXG5zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnUlMzODQnLCAnaW1wb3J0S2V5JywgbmV3IFJTQVNTQV9QS0NTMV92MV81KHtcbiAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMzg0J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdSUzUxMicsICdpbXBvcnRLZXknLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS01MTInXG4gIH1cbn0pKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0ZWRBbGdvcml0aG1zO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogTm9uZVxuICovXG52YXIgTm9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9uZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9uZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9uZSwgW3tcbiAgICBrZXk6ICdzaWduJyxcblxuICAgIC8qKlxuICAgICAqIHNpZ25cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbigpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHZlcmlmeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoKSB7XG4gICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgZ2V0IGNhbGxlZC4gYnV0IHlvdSBsb29rZWQuXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vbmU7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vbmU7XG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oQnVmZmVyKSB7XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKiBAaWdub3JlXG4gKi9cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGJhc2U2NHVybCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xudmFyIGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xudmFyIFRleHRFbmNvZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG5cbi8qKlxuICogSE1BQyB3aXRoIFNIQS0yIEZ1bmN0aW9uc1xuICovXG5cbnZhciBITUFDID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYml0bGVuZ3RoXG4gICAqL1xuICBmdW5jdGlvbiBITUFDKHBhcmFtcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBITUFDKTtcblxuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdlbmVyYXRlIGEgaGFzaC1iYXNlZCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUgZm9yIGFcbiAgICogZ2l2ZW4gaW5wdXQgYW5kIGtleS4gRW5mb3JjZSB0aGUga2V5IGxlbmd0aCBpcyBlcXVhbCB0b1xuICAgKiBvciBncmVhdGVyIHRoYW4gdGhlIGJpdGxlbmd0aC5cbiAgICpcbiAgICogQHBhcmFtIHtDcnlwdG9LZXl9IGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhITUFDLCBbe1xuICAgIGtleTogJ3NpZ24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduKGtleSwgZGF0YSkge1xuICAgICAgdmFyIGFsZ29yaXRobSA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAvLyBUT0RPOiB2YWxpZGF0ZSBrZXkgbGVuZ3RoXG5cbiAgICAgIGRhdGEgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSk7XG5cbiAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLnNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpLnRoZW4oZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gYmFzZTY0dXJsKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWZXJpZnkgYSBkaWdpdGFsIHNpZ25hdHVyZSBmb3IgYSBnaXZlbiBpbnB1dCBhbmQgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NyeXB0b0tleX0ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmVyaWZ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5KGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XG4gICAgICB2YXIgYWxnb3JpdGhtID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzaWduYXR1cmUgPSBVaW50OEFycmF5LmZyb20oYmFzZTY0dXJsLnRvQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLnZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgU3VmZmljaWVudCBLZXkgTGVuZ3RoXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQXNzZXJ0IHRoYXQgdGhlIGtleSBsZW5ndGggaXMgc3VmZmljaWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXNzZXJ0U3VmZmljaWVudEtleUxlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2VydFN1ZmZpY2llbnRLZXlMZW5ndGgoa2V5KSB7XG4gICAgICBpZiAoa2V5Lmxlbmd0aCA8IHRoaXMuYml0bGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGtleSBpcyB0b28gc2hvcnQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhNQUM7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEhNQUM7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkuQnVmZmVyKSlcblxuLyoqKi8gfSksXG4vKiA0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4oZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiY3J5cHRvXCJdOyB9KCkpO1xuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG52YXIgVGV4dEVuY29kZXIgPSBnbG9iYWwuVGV4dEVuY29kZXIgPyBnbG9iYWwuVGV4dEVuY29kZXIgLy8gYnJvd3NlclxuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKS5UZXh0RW5jb2RlcjsgLy8gbm9kZSBzaGltXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRFbmNvZGVyO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMjApKSlcblxuLyoqKi8gfSksXG4vKiA1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4oZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiVGV4dEVuY29kZXJcIl07IH0oKSk7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oQnVmZmVyKSB7XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKiBAaWdub3JlXG4gKi9cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGJhc2U2NHVybCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xudmFyIGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xudmFyIFRleHRFbmNvZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG5cbi8qKlxuICogUlNBU1NBLVBLQ1MxLXYxXzVcbiAqL1xuXG52YXIgUlNBU1NBX1BLQ1MxX3YxXzUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiaXRsZW5ndGhcbiAgICovXG4gIGZ1bmN0aW9uIFJTQVNTQV9QS0NTMV92MV81KHBhcmFtcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSU0FTU0FfUEtDUzFfdjFfNSk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBzaWduXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBHZW5lcmF0ZSBhIGRpZ2l0YWwgc2lnbmF0dXJlIGZvciBhIGdpdmVuIGlucHV0IGFuZCBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtDcnlwdG9LZXl9IGtleVxuICAgKiBAcGFyYW0ge0J1ZmZlclNvdXJjZX0gZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUlNBU1NBX1BLQ1MxX3YxXzUsIFt7XG4gICAga2V5OiAnc2lnbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oa2V5LCBkYXRhKSB7XG4gICAgICB2YXIgYWxnb3JpdGhtID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vaWYgKCF0aGlzLnN1ZmZpY2llbnRLZXlTaXplKCkpIHtcbiAgICAgIC8vICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAvLyAgICBuZXcgRXJyb3IoXG4gICAgICAvLyAgICAgICdBIGtleSBzaXplIG9mIDIwNDggYml0cyBvciBsYXJnZXIgbXVzdCBiZSB1c2VkIHdpdGggUlNBU1NBLVBLQ1MxLXYxXzUnXG4gICAgICAvLyAgICApXG4gICAgICAvLyAgKVxuICAgICAgLy99XG5cbiAgICAgIGRhdGEgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSk7XG5cbiAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLnNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpLnRoZW4oZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gYmFzZTY0dXJsKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWZXJpZnkgYSBkaWdpdGFsIHNpZ25hdHVyZSBmb3IgYSBnaXZlbiBpbnB1dCBhbmQgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NyeXB0b0tleX0ga2V5XG4gICAgICogQHBhcmFtIHtCdWZmZXJTb3VyY2V9IHNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyU291cmNlfSBkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmVyaWZ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5KGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XG4gICAgICB2YXIgYWxnb3JpdGhtID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzaWduYXR1cmUgPSBVaW50OEFycmF5LmZyb20oYmFzZTY0dXJsLnRvQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSk7XG4gICAgICB9XG4gICAgICAvLyAuLi5cblxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGltcG9ydEtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtKV0t9IGtleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbXBvcnRLZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbXBvcnRLZXkoa2V5KSB7XG4gICAgICB2YXIgandrID0gT2JqZWN0LmFzc2lnbih7fSwga2V5KTtcbiAgICAgIHZhciBhbGdvcml0aG0gPSB0aGlzLnBhcmFtcztcbiAgICAgIHZhciB1c2FnZXMgPSBrZXlbJ2tleV9vcHMnXSB8fCBbXTtcblxuICAgICAgaWYgKGtleS51c2UgPT09ICdzaWcnKSB7XG4gICAgICAgIHVzYWdlcy5wdXNoKCd2ZXJpZnknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleS51c2UgPT09ICdlbmMnKSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBlbmNyeXB0aW9uIGtleXNcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5LmtleV9vcHMpIHtcbiAgICAgICAgdXNhZ2VzID0ga2V5LmtleV9vcHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgnandrJywgandrLCBhbGdvcml0aG0sIHRydWUsIHVzYWdlcykudGhlbihmdW5jdGlvbiAoY3J5cHRvS2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShqd2ssICdjcnlwdG9LZXknLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IGNyeXB0b0tleVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gandrO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJTQVNTQV9QS0NTMV92MV81O1xufSgpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSU0FTU0FfUEtDUzFfdjFfNTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKS5CdWZmZXIpKVxuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbnZhciBOb3RTdXBwb3J0ZWRFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xuXG4vKipcbiAqIE9wZXJhdGlvbnNcbiAqL1xudmFyIG9wZXJhdGlvbnMgPSBbJ3NpZ24nLCAndmVyaWZ5JywgJ2VuY3J5cHQnLCAnZGVjcnlwdCcsICdpbXBvcnRLZXknXTtcblxuLyoqXG4gKiBTdXBwb3J0ZWRBbGdvcml0aG1zXG4gKi9cblxudmFyIFN1cHBvcnRlZEFsZ29yaXRobXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBTdXBwb3J0ZWRBbGdvcml0aG1zKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3VwcG9ydGVkQWxnb3JpdGhtcyk7XG5cbiAgICBvcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7XG4gICAgICBfdGhpc1tvcF0gPSB7fTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdXBwb3J0ZWQgT3BlcmF0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTdXBwb3J0ZWRBbGdvcml0aG1zLCBbe1xuICAgIGtleTogJ2RlZmluZScsXG5cblxuICAgIC8qKlxuICAgICAqIGRlZmluZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVnaXN0ZXIgV2ViIENyeXB0byBBUEkgYWxnb3JpdGhtIHBhcmFtZXRlciBmb3IgYW4gYWxnb3JpdGhtXG4gICAgICogYW5kIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJndW1lbnRcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmaW5lKGFsZywgb3AsIGFyZ3VtZW50KSB7XG4gICAgICB2YXIgcmVnaXN0ZXJlZEFsZ29yaXRobXMgPSB0aGlzW29wXTtcbiAgICAgIHJlZ2lzdGVyZWRBbGdvcml0aG1zW2FsZ10gPSBhcmd1bWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBub3JtYWxpemVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE1hcCBKV0EgYWxnIG5hbWUgdG8gV2ViIENyeXB0byBBUEkgYWxnb3JpdGhtIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFsZ1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbm9ybWFsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKG9wLCBhbGcpIHtcbiAgICAgIHZhciByZWdpc3RlcmVkQWxnb3JpdGhtcyA9IHRoaXNbb3BdO1xuXG4gICAgICBpZiAoIXJlZ2lzdGVyZWRBbGdvcml0aG1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoKTsgLy8gd2hhdCBraW5kIG9mIGVycm9yIHNob3VsZCB0aGlzIGJlP1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJndW1lbnQgPSByZWdpc3RlcmVkQWxnb3JpdGhtc1thbGddO1xuXG4gICAgICBpZiAoIWFyZ3VtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90U3VwcG9ydGVkRXJyb3IoYWxnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3VtZW50O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnb3BlcmF0aW9ucycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gb3BlcmF0aW9ucztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3VwcG9ydGVkQWxnb3JpdGhtcztcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3VwcG9ydGVkQWxnb3JpdGhtcztcblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogTm90U3VwcG9ydGVkRXJyb3JcbiAqL1xudmFyIE5vdFN1cHBvcnRlZEVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoTm90U3VwcG9ydGVkRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gTm90U3VwcG9ydGVkRXJyb3IoYWxnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vdFN1cHBvcnRlZEVycm9yKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOb3RTdXBwb3J0ZWRFcnJvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE5vdFN1cHBvcnRlZEVycm9yKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5tZXNzYWdlID0gYWxnICsgXCIgaXMgbm90IGEgc3VwcG9ydGVkIGFsZ29yaXRobVwiO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBOb3RTdXBwb3J0ZWRFcnJvcjtcbn0oRXJyb3IpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBOb3RTdXBwb3J0ZWRFcnJvcjtcblxuLyoqKi8gfSksXG4vKiA1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRGF0YUVycm9yOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KSxcbiAgTm90U3VwcG9ydGVkRXJyb3I6IF9fd2VicGFja19yZXF1aXJlX18oNTQpXG59O1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBEYXRhRXJyb3JcbiAqL1xudmFyIERhdGFFcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKERhdGFFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBEYXRhRXJyb3IobWVzc2FnZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhRXJyb3IpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEYXRhRXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEYXRhRXJyb3IpKS5jYWxsKHRoaXMsIG1lc3NhZ2UpKTtcbiAgfVxuXG4gIHJldHVybiBEYXRhRXJyb3I7XG59KEVycm9yKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YUVycm9yO1xuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKiBAaWdub3JlXG4gKi9cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09ORG9jdW1lbnQgPSBfcmVxdWlyZS5KU09ORG9jdW1lbnQ7XG5cbnZhciBKV0tTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcbnZhciBKV0EgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxuLyoqXG4gKiBKV0sgQ2xhc3NcbiAqL1xuXG52YXIgSldLID0gZnVuY3Rpb24gKF9KU09ORG9jdW1lbnQpIHtcbiAgX2luaGVyaXRzKEpXSywgX0pTT05Eb2N1bWVudCk7XG5cbiAgZnVuY3Rpb24gSldLKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKV0spO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChKV0suX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihKV0spKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKV0ssIG51bGwsIFt7XG4gICAga2V5OiAnaW1wb3J0S2V5JyxcblxuXG4gICAgLyoqXG4gICAgICogaW1wb3J0S2V5XG4gICAgICpcbiAgICAgKiBUT0RPOlxuICAgICAqIC0gc2hvdWxkIHRoaXMgYmUgb24gSldBP1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpbXBvcnRLZXkoandrKSB7XG4gICAgICByZXR1cm4gSldBLmltcG9ydEtleShqd2spO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NjaGVtYScsXG5cblxuICAgIC8qKlxuICAgICAqIFNjaGVtYVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEpXS1NjaGVtYTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSldLO1xufShKU09ORG9jdW1lbnQpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBKV0s7XG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09OU2NoZW1hID0gX3JlcXVpcmUuSlNPTlNjaGVtYTtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpLFxuICAgIEJBU0U2NF9SRUdFWFAgPSBfcmVxdWlyZTIuQkFTRTY0X1JFR0VYUDtcblxuLyoqXG4gKiBKV0sgU2NoZW1hXG4gKi9cblxuXG52YXIgSldLU2NoZW1hID0gbmV3IEpTT05TY2hlbWEoe1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuXG4gICAga3R5OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIC8vZm9ybWF0OiAnY2FzZS1zZW5zaXRpdmUnLFxuICAgICAgZW51bTogWydSU0EnLCAnRUMnLCAnb2N0J10gLy8gb3RoZXIgdmFsdWVzIE1BWSBiZSB1c2VkXG4gICAgfSxcblxuICAgIHVzZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAvL2Zvcm1hdDogJ2Nhc2Utc2Vuc2l0aXZlJyxcbiAgICAgIGVudW06IFsnc2lnJywgJ2VuYyddIC8vIG90aGVyIHZhbHVlcyBNQVkgYmUgdXNlZFxuICAgIH0sXG5cbiAgICBrZXlfb3BzOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgLy9mb3JtYXQ6ICdjYXNlLXNlbnNpdGl2ZScsXG4gICAgICBpdGVtczoge1xuICAgICAgICBlbnVtOiBbJ3NpZ24nLCAndmVyaWZ5JywgJ2VuY3J5cHQnLCAnZGVjcnlwdCcsICd3cmFwS2V5JywgJ3Vud3JhcEtleScsICdkZXJpdmVLZXknLCAnZGVyaXZlQml0cyddIC8vIG90aGVyIHZhbHVlcyBNQVkgYmUgdXNlZFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhbGc6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgLy9mb3JtYXQ6ICdjYXNlLXNlbnNpdGl2ZScsXG4gICAgICBlbnVtOiBbJ0hTMjU2JywgJ0hTMzg0JywgJ0hTNTEyJywgJ1JTMjU2JywgJ1JTMzg0JywgJ1JTNTEyJywgJ0VTMjU2JywgJ0VTMzg0JywgJ0VTNTEyJywgJ1BTMjU2JywgJ1BTMzg0JywgJ1BTNTEyJywgJ25vbmUnXSAvLyBvdGhlciB2YWx1ZXMgTUFZIGJlIHVzZWRcbiAgICB9LFxuXG4gICAga2lkOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICB4NXU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAvL2Zvcm1hdDogJ3VybCdcbiAgICB9LFxuXG4gICAgeDVjOiB7XG4gICAgICB0eXBlOiAnYXJyYXknXG4gICAgICAvL2Zvcm1hdDogQkFTRTY0X1JFR0VYUFxuICAgIH0sXG5cbiAgICB4NXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAvL2Zvcm1hdDogQkFTRTY0X1JFR0VYUFxuICAgIH1cblxuICAgIC8vJ3g1dCNTMjU2Jzoge1xuICAgIC8vICB0eXBlOiAnc3RyaW5nJyxcbiAgICAvLyAgLy9mb3JtYXQ6IEJBU0U2NF9SRUdFWFBcbiAgICAvL31cbiAgfVxufSk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSldLU2NoZW1hO1xuXG4vKioqLyB9KSxcbi8qIDU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogUGFja2FnZSBkZXBlbmRlbmNpZXNcbiAqL1xudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCksXG4gICAgRm9ybWF0cyA9IF9yZXF1aXJlLkZvcm1hdHM7XG5cbi8qKlxuICogRm9ybWF0IGV4dGVuc2lvbnNcbiAqL1xuXG5cbkZvcm1hdHMucmVnaXN0ZXIoJ1N0cmluZ09yVVJJJywgbmV3IFJlZ0V4cCgpKTtcbkZvcm1hdHMucmVnaXN0ZXIoJ051bWVyaWNEYXRlJywgbmV3IFJlZ0V4cCgpKTtcbkZvcm1hdHMucmVnaXN0ZXIoJ1VSSScsIG5ldyBSZWdFeHAoKSk7XG5Gb3JtYXRzLnJlZ2lzdGVyKCd1cmwnLCBuZXcgUmVnRXhwKCkpO1xuRm9ybWF0cy5yZWdpc3RlcignYmFzZTY0JywgbmV3IFJlZ0V4cCgpKTtcbkZvcm1hdHMucmVnaXN0ZXIoJ2Jhc2U2NHVybCcsIG5ldyBSZWdFeHAoKSk7XG5Gb3JtYXRzLnJlZ2lzdGVyKCdNZWRpYVR5cGUnLCBuZXcgUmVnRXhwKCkpO1xuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09ORG9jdW1lbnQgPSBfcmVxdWlyZS5KU09ORG9jdW1lbnQ7XG5cbnZhciBKV0tTZXRTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcbnZhciBKV0sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcblxuLyoqXG4gKiBKV0tTZXRcbiAqXG4gKiBAY2xhc3NcbiAqIEpXS1NldCByZXByZXNlbnRzIGEgSlNPTiBXZWIgS2V5IFNldCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiA1IG9mIFJGQyA3NTE3OlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTcjc2VjdGlvbi01XG4gKi9cblxudmFyIEpXS1NldCA9IGZ1bmN0aW9uIChfSlNPTkRvY3VtZW50KSB7XG4gIF9pbmhlcml0cyhKV0tTZXQsIF9KU09ORG9jdW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEpXS1NldCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSldLU2V0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSldLU2V0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSldLU2V0KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSldLU2V0LCBudWxsLCBbe1xuICAgIGtleTogJ2ltcG9ydEtleXMnLFxuXG5cbiAgICAvKipcbiAgICAgKiBpbXBvcnRLZXlzXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltcG9ydEtleXMoandrcykge1xuICAgICAgdmFyIHZhbGlkYXRpb24gPSB0aGlzLnNjaGVtYS52YWxpZGF0ZShqd2tzKTtcblxuICAgICAgaWYgKCF2YWxpZGF0aW9uLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0ludmFsaWQgSldLU2V0OiAnICsgSlNPTi5zdHJpbmdpZnkodmFsaWRhdGlvbiwgbnVsbCwgMikpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFqd2tzLmtleXMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ2Fubm90IGltcG9ydCBKV0tTZXQ6IGtleXMgcHJvcGVydHkgaXMgZW1wdHknKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbXBvcnRlZCA9IHZvaWQgMCxcbiAgICAgICAgICBpbXBvcnRpbmcgPSB2b2lkIDA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGltcG9ydGVkID0gbmV3IEpXS1NldChqd2tzKTtcbiAgICAgICAgaW1wb3J0aW5nID0gandrcy5rZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIEpXSy5pbXBvcnRLZXkoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChpbXBvcnRpbmcpLnRoZW4oZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgaW1wb3J0ZWQua2V5cyA9IGtleXM7XG4gICAgICAgIHJldHVybiBpbXBvcnRlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NjaGVtYScsXG5cblxuICAgIC8qKlxuICAgICAqIHNjaGVtYVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEpXS1NldFNjaGVtYTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSldLU2V0O1xufShKU09ORG9jdW1lbnQpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBKV0tTZXQ7XG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09OU2NoZW1hID0gX3JlcXVpcmUuSlNPTlNjaGVtYTtcblxudmFyIEpXS1NjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xuXG4vKipcbiAqIEpXS1NldFNjaGVtYVxuICovXG52YXIgSldLU2V0U2NoZW1hID0gbmV3IEpTT05TY2hlbWEoe1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIGtleXM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczogSldLU2NoZW1hXG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBKV0tTZXRTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbnZhciBiYXNlNjR1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCksXG4gICAgSlNPTkRvY3VtZW50ID0gX3JlcXVpcmUuSlNPTkRvY3VtZW50O1xuXG52YXIgSldUU2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XG52YXIgSldTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG52YXIgRGF0YUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cbi8qKlxuICogSldUXG4gKi9cblxudmFyIEpXVCA9IGZ1bmN0aW9uIChfSlNPTkRvY3VtZW50KSB7XG4gIF9pbmhlcml0cyhKV1QsIF9KU09ORG9jdW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEpXVCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSldUKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSldULl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSldUKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSldULCBbe1xuICAgIGtleTogJ2lzSldFJyxcblxuXG4gICAgLyoqXG4gICAgICogaXNKV0VcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNKV0UoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmhlYWRlci5lbmM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVzb2x2ZUtleXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVzb2x2ZUtleXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlS2V5cyhqd2tzKSB7XG4gICAgICB2YXIga2lkID0gdGhpcy5oZWFkZXIua2lkO1xuICAgICAgdmFyIGtleXMgPSB2b2lkIDAsXG4gICAgICAgICAgbWF0Y2ggPSB2b2lkIDA7XG5cbiAgICAgIC8vIHRyZWF0IGFuIGFycmF5IGFzIHRoZSBcImtleXNcIiBwcm9wZXJ0eSBvZiBhIEpXSyBTZXRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGp3a3MpKSB7XG4gICAgICAgIGtleXMgPSBqd2tzO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmVzZW5jZSBvZiBrZXlzIGluZGljYXRlcyBvYmplY3QgaXMgYSBKV0sgU2V0XG4gICAgICBpZiAoandrcy5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBqd2tzLmtleXM7XG4gICAgICB9XG5cbiAgICAgIC8vIHdyYXAgYSBwbGFpbiBvYmplY3QgdGhleSBpcyBub3QgYSBKV0sgU2V0IGluIEFycmF5XG4gICAgICBpZiAoIWp3a3Mua2V5cyAmJiAodHlwZW9mIGp3a3MgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGp3a3MpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAga2V5cyA9IFtqd2tzXTtcbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIHRoZXJlIGFyZSBrZXlzIHRvIHNlYXJjaFxuICAgICAgaWYgKCFrZXlzKSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRhRXJyb3IoJ0ludmFsaWQgSldLIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1hdGNoIGJ5IFwia2lkXCIgb3IgXCJ1c2VcIiBoZWFkZXJcbiAgICAgIGlmIChraWQpIHtcbiAgICAgICAgbWF0Y2ggPSBrZXlzLmZpbmQoZnVuY3Rpb24gKGp3aykge1xuICAgICAgICAgIHJldHVybiBqd2sua2lkID09PSBraWQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBrZXlzLmZpbmQoZnVuY3Rpb24gKGp3aykge1xuICAgICAgICAgIHJldHVybiBqd2sudXNlID09PSAnc2lnJztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc2lnbiBtYXRjaGluZyBrZXkgdG8gSldUIGFuZCByZXR1cm4gYSBib29sZWFuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBtYXRjaC5jcnlwdG9LZXk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGVuY29kZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRW5jb2RlIGEgSldUIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW5jb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5jb2RlKCkge1xuICAgICAgLy8gdmFsaWRhdGVcbiAgICAgIHZhciB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZSgpO1xuXG4gICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHZhbGlkYXRpb24pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9rZW4gPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5pc0pXRSgpKSB7XG4gICAgICAgIHJldHVybiBKV0UuZW5jcnlwdCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSldTLnNpZ24odG9rZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHZlcmlmeVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVmVyaWZ5IGEgZGVjb2RlZCBKV1QgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoKSB7XG4gICAgICB2YXIgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGUoKTtcblxuICAgICAgaWYgKCF2YWxpZGF0aW9uLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2YWxpZGF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEpXUy52ZXJpZnkodGhpcyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdkZWNvZGUnLFxuXG5cbiAgICAvKipcbiAgICAgKiBkZWNvZGVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIERlY29kZSBhIEpTT04gV2ViIFRva2VuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICAgICAqIEByZXR1cm5zIHtKV1R9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgICB2YXIgRXh0ZW5kZWRKV1QgPSB0aGlzO1xuICAgICAgdmFyIGp3dCA9IHZvaWQgMDtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRGF0YUVycm9yKCdKV1QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICAvLyBKU09OIG9mIEZsYXR0ZW5lZCBKU09OIFNlcmlhbGl6YXRpb25cbiAgICAgIGlmIChkYXRhLnN0YXJ0c1dpdGgoJ3snKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRGF0YUVycm9yKCdJbnZhbGlkIEpXVCBzZXJpYWxpemF0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5zaWduYXR1cmVzIHx8IGRhdGEucmVjaXBpZW50cykge1xuICAgICAgICAgIGRhdGEuc2VyaWFsaXphdGlvbiA9ICdqc29uJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhLnNlcmlhbGl6YXRpb24gPSAnZmxhdHRlbmVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIGp3dCA9IG5ldyBFeHRlbmRlZEpXVChkYXRhLCB7IGZpbHRlcjogZmFsc2UgfSk7XG5cbiAgICAgICAgLy8gQ29tcGFjdCBTZXJpYWxpemF0aW9uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzZXJpYWxpemF0aW9uID0gJ2NvbXBhY3QnO1xuICAgICAgICAgIHZhciBzZWdtZW50cyA9IGRhdGEuc3BsaXQoJy4nKTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aCAhPT0gMyAmJiBsZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIEpXVCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoZWFkZXIgPSBKU09OLnBhcnNlKGJhc2U2NHVybC5kZWNvZGUoc2VnbWVudHNbMF0pKTtcblxuICAgICAgICAgIC8vIEpTT04gV2ViIFNpZ25hdHVyZVxuICAgICAgICAgIGlmIChsZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gJ0pXUyc7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShzZWdtZW50c1sxXSkpO1xuICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHNlZ21lbnRzWzJdO1xuXG4gICAgICAgICAgICBqd3QgPSBuZXcgRXh0ZW5kZWRKV1QoeyB0eXBlOiB0eXBlLCBzZWdtZW50czogc2VnbWVudHMsIGhlYWRlcjogaGVhZGVyLCBwYXlsb2FkOiBwYXlsb2FkLCBzaWduYXR1cmU6IHNpZ25hdHVyZSwgc2VyaWFsaXphdGlvbjogc2VyaWFsaXphdGlvbiB9LCB7IGZpbHRlcjogZmFsc2UgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSlNPTiBXZWIgRW5jcnlwdGlvblxuICAgICAgICAgIGlmIChsZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgIC8vbGV0IHR5cGUgPSAnSldFJ1xuICAgICAgICAgICAgLy9sZXQgW3Byb3RlY3RlZCwgZW5jcnlwdGlvbl9rZXksIGl2LCBjaXBoZXJ0ZXh0LCB0YWddID0gc2VnbWVudHNcblxuICAgICAgICAgICAgLy9qd3QgPSBuZXcgRXh0ZW5kZWRKV1Qoe1xuICAgICAgICAgICAgLy8gIHR5cGUsXG4gICAgICAgICAgICAvLyAgcHJvdGVjdGVkOiBiYXNlNjR1cmwuZGVjb2RlKEpTT04ucGFyc2UocHJvdGVjdGVkKSksXG4gICAgICAgICAgICAvLyAgZW5jcnlwdGlvbl9rZXksXG4gICAgICAgICAgICAvLyAgaXYsXG4gICAgICAgICAgICAvLyAgY2lwaGVydGV4dCxcbiAgICAgICAgICAgIC8vICB0YWcsXG4gICAgICAgICAgICAvLyAgc2VyaWFsaXphdGlvblxuICAgICAgICAgICAgLy99KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRGF0YUVycm9yKCdJbnZhbGlkIEpXVCBjb21wYWN0IHNlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gand0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGVuY29kZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRW5jb2RlIGEgSlNPTiBXZWIgVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5fSBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmNvZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGUoaGVhZGVyLCBwYXlsb2FkLCBrZXkpIHtcbiAgICAgIHZhciBqd3QgPSBuZXcgSldUKGhlYWRlciwgcGF5bG9hZCk7XG4gICAgICByZXR1cm4gand0LmVuY29kZShrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHZlcmlmeVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NyeXB0b0tleX0ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmVyaWZ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5KGtleSwgdG9rZW4pIHtcbiAgICAgIHZhciBqd3QgPSBKV1QuZGVjb2RlKHRva2VuKTtcbiAgICAgIGp3dC5rZXkgPSBrZXk7XG4gICAgICByZXR1cm4gand0LnZlcmlmeSgpLnRoZW4oZnVuY3Rpb24gKHZlcmlmaWVkKSB7XG4gICAgICAgIHJldHVybiBqd3Q7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzY2hlbWEnLFxuXG5cbiAgICAvKipcbiAgICAgKiBzY2hlbWFcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBKV1RTY2hlbWE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpXVDtcbn0oSlNPTkRvY3VtZW50KTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSldUO1xuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbnZhciBCYXNlNjRVUkxTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcbnZhciBKV1RDbGFpbXNTZXRTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcbnZhciBKT1NFSGVhZGVyU2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05TY2hlbWEgPSBfcmVxdWlyZS5KU09OU2NoZW1hO1xuXG4vKipcbiAqIEpXVFNjaGVtYVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzY2hlbWEgcmVwcmVzZW50cyBhbGwgdGhlIHRoaW5ncyBhIGRlc2VyaWFsaXplZCBKV1QgY2FuIGJlLCBpLmUuLFxuICogZWl0aGVyIGEgSldTIG9yIEpXRSwgYW5kIGFueSBzZXJpYWxpemF0aW9uIG9mIHRoZW0uIFZhbGlkYXRpb24gb2Ygd2VsbC1cbiAqIGZvcm1lZG5lc3MgZm9yIGEgZ2l2ZW4gc2VyaWFsaXphdGlvbiBpcyBhY2NvbXBsaXNoZWQgYXQgdGhlIHRpbWUgb2ZcbiAqIGVuY29kaW5nLlxuICovXG5cblxudmFyIEpXVFNjaGVtYSA9IG5ldyBKU09OU2NoZW1hKHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIHR5cGVcbiAgICAgKi9cbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnSldTJywgJ0pXRSddXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNlZ21lbnRzXG4gICAgICovXG4gICAgc2VnbWVudHM6IHtcbiAgICAgIHR5cGU6ICdhcnJheSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGVhZGVyXG4gICAgICovXG4gICAgaGVhZGVyOiBKT1NFSGVhZGVyU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkOiBKT1NFSGVhZGVyU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogdW5wcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1bnByb3RlY3RlZDogSk9TRUhlYWRlclNjaGVtYSxcblxuICAgIC8qKlxuICAgICAqIGl2XG4gICAgICovXG4gICAgaXY6IEJhc2U2NFVSTFNjaGVtYSxcblxuICAgIC8qKlxuICAgICAqIGFhZFxuICAgICAqL1xuICAgIGFhZDogQmFzZTY0VVJMU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogY2lwaGVydGV4dFxuICAgICAqL1xuICAgIGNpcGhlcnRleHQ6IEJhc2U2NFVSTFNjaGVtYSxcblxuICAgIC8qKlxuICAgICAqIHRhZ1xuICAgICAqL1xuICAgIHRhZzogQmFzZTY0VVJMU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogcmVjaXBpZW50c1xuICAgICAqL1xuICAgIHJlY2lwaWVudHM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGhlYWRlcjogSk9TRUhlYWRlclNjaGVtYSxcbiAgICAgICAgICBlbmNyeXB0ZWRfa2V5OiBCYXNlNjRVUkxTY2hlbWFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwYXlsb2FkXG4gICAgICovXG4gICAgcGF5bG9hZDogSldUQ2xhaW1zU2V0U2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogc2lnbmF0dXJlc1xuICAgICAqL1xuICAgIHNpZ25hdHVyZXM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHByb3RlY3RlZDogSk9TRUhlYWRlclNjaGVtYSxcbiAgICAgICAgICBoZWFkZXI6IEpPU0VIZWFkZXJTY2hlbWEsXG4gICAgICAgICAgc2lnbmF0dXJlOiBCYXNlNjRVUkxTY2hlbWEsXG4gICAgICAgICAga2V5OiB7IHR5cGU6ICdvYmplY3QnIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzaWduYXR1cmVcbiAgICAgKi9cbiAgICBzaWduYXR1cmU6IEJhc2U2NFVSTFNjaGVtYSxcblxuICAgIC8qKlxuICAgICAqIHZlcmlmaWVkXG4gICAgICovXG4gICAgdmVyaWZpZWQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGtleVxuICAgICAqL1xuICAgIGtleToge1xuICAgICAgdHlwZTogJ29iamVjdCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2VyaWFsaXphdGlvblxuICAgICAqL1xuICAgIHNlcmlhbGl6YXRpb246IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydjb21wYWN0JywgJ2pzb24nLCAnZmxhdHRlbmVkJ10sXG4gICAgICBkZWZhdWx0OiAnY29tcGFjdCdcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpXVFNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09OU2NoZW1hID0gX3JlcXVpcmUuSlNPTlNjaGVtYTtcblxuLyoqXG4gKiBCYXNlNjRVUkxTY2hlbWFcbiAqL1xuXG5cbnZhciBCYXNlNjRVUkxTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBmb3JtYXQ6ICdiYXNlNjR1cmwnXG59KTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlNjRVUkxTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCksXG4gICAgSlNPTlNjaGVtYSA9IF9yZXF1aXJlLkpTT05TY2hlbWE7XG5cbi8qKlxuICogSldUQ2xhaW1zU2V0U2NoZW1hXG4gKlxuICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE5I3NlY3Rpb24tNFxuICpcbiAqIDQuICBKV1QgQ2xhaW1zXG4gKlxuICogICBUaGUgSldUIENsYWltcyBTZXQgcmVwcmVzZW50cyBhIEpTT04gb2JqZWN0IHdob3NlIG1lbWJlcnMgYXJlIHRoZVxuICogICBjbGFpbXMgY29udmV5ZWQgYnkgdGhlIEpXVC4gIFRoZSBDbGFpbSBOYW1lcyB3aXRoaW4gYSBKV1QgQ2xhaW1zIFNldFxuICogICBNVVNUIGJlIHVuaXF1ZTsgSldUIHBhcnNlcnMgTVVTVCBlaXRoZXIgcmVqZWN0IEpXVHMgd2l0aCBkdXBsaWNhdGVcbiAqICAgQ2xhaW0gTmFtZXMgb3IgdXNlIGEgSlNPTiBwYXJzZXIgdGhhdCByZXR1cm5zIG9ubHkgdGhlIGxleGljYWxseSBsYXN0XG4gKiAgIGR1cGxpY2F0ZSBtZW1iZXIgbmFtZSwgYXMgc3BlY2lmaWVkIGluIFNlY3Rpb24gMTUuMTIgKFwiVGhlIEpTT05cbiAqICAgT2JqZWN0XCIpIG9mIEVDTUFTY3JpcHQgNS4xIFtFQ01BU2NyaXB0XS5cbiAqXG4gKiAgIFRoZSBzZXQgb2YgY2xhaW1zIHRoYXQgYSBKV1QgbXVzdCBjb250YWluIHRvIGJlIGNvbnNpZGVyZWQgdmFsaWQgaXNcbiAqICAgY29udGV4dCBkZXBlbmRlbnQgYW5kIGlzIG91dHNpZGUgdGhlIHNjb3BlIG9mIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAqICAgU3BlY2lmaWMgYXBwbGljYXRpb25zIG9mIEpXVHMgd2lsbCByZXF1aXJlIGltcGxlbWVudGF0aW9ucyB0b1xuICogICB1bmRlcnN0YW5kIGFuZCBwcm9jZXNzIHNvbWUgY2xhaW1zIGluIHBhcnRpY3VsYXIgd2F5cy4gIEhvd2V2ZXIsIGluXG4gKiAgIHRoZSBhYnNlbmNlIG9mIHN1Y2ggcmVxdWlyZW1lbnRzLCBhbGwgY2xhaW1zIHRoYXQgYXJlIG5vdCB1bmRlcnN0b29kXG4gKiAgIGJ5IGltcGxlbWVudGF0aW9ucyBNVVNUIGJlIGlnbm9yZWQuXG4gKlxuICogICBUaGVyZSBhcmUgdGhyZWUgY2xhc3NlcyBvZiBKV1QgQ2xhaW0gTmFtZXM6IFJlZ2lzdGVyZWQgQ2xhaW0gTmFtZXMsXG4gKiAgIFB1YmxpYyBDbGFpbSBOYW1lcywgYW5kIFByaXZhdGUgQ2xhaW0gTmFtZXMuXG4gKi9cblxuXG52YXIgSldUQ2xhaW1zU2V0U2NoZW1hID0gbmV3IEpTT05TY2hlbWEoe1xuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE5I3NlY3Rpb24tNC4xXG4gICAgICpcbiAgICAgKiA0LjEuICBSZWdpc3RlcmVkIENsYWltIE5hbWVzXG4gICAgICpcbiAgICAgKiAgIFRoZSBmb2xsb3dpbmcgQ2xhaW0gTmFtZXMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIElBTkEgXCJKU09OIFdlYiBUb2tlblxuICAgICAqICAgQ2xhaW1zXCIgcmVnaXN0cnkgZXN0YWJsaXNoZWQgYnkgU2VjdGlvbiAxMC4xLiAgTm9uZSBvZiB0aGUgY2xhaW1zXG4gICAgICogICBkZWZpbmVkIGJlbG93IGFyZSBpbnRlbmRlZCB0byBiZSBtYW5kYXRvcnkgdG8gdXNlIG9yIGltcGxlbWVudCBpbiBhbGxcbiAgICAgKiAgIGNhc2VzLCBidXQgcmF0aGVyIHRoZXkgcHJvdmlkZSBhIHN0YXJ0aW5nIHBvaW50IGZvciBhIHNldCBvZiB1c2VmdWwsXG4gICAgICogICBpbnRlcm9wZXJhYmxlIGNsYWltcy4gIEFwcGxpY2F0aW9ucyB1c2luZyBKV1RzIHNob3VsZCBkZWZpbmUgd2hpY2hcbiAgICAgKiAgIHNwZWNpZmljIGNsYWltcyB0aGV5IHVzZSBhbmQgd2hlbiB0aGV5IGFyZSByZXF1aXJlZCBvciBvcHRpb25hbC4gIEFsbFxuICAgICAqICAgdGhlIG5hbWVzIGFyZSBzaG9ydCBiZWNhdXNlIGEgY29yZSBnb2FsIG9mIEpXVHMgaXMgZm9yIHRoZVxuICAgICAqICAgcmVwcmVzZW50YXRpb24gdG8gYmUgY29tcGFjdC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIGlzc1xuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS4xXG4gICAgICpcbiAgICAgKiA0LjEuMS4gIFwiaXNzXCIgKElzc3VlcikgQ2xhaW1cbiAgICAgKlxuICAgICAqICAgVGhlIFwiaXNzXCIgKGlzc3VlcikgY2xhaW0gaWRlbnRpZmllcyB0aGUgcHJpbmNpcGFsIHRoYXQgaXNzdWVkIHRoZVxuICAgICAqICAgSldULiAgVGhlIHByb2Nlc3Npbmcgb2YgdGhpcyBjbGFpbSBpcyBnZW5lcmFsbHkgYXBwbGljYXRpb24gc3BlY2lmaWMuXG4gICAgICogICBUaGUgXCJpc3NcIiB2YWx1ZSBpcyBhIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyBjb250YWluaW5nIGEgU3RyaW5nT3JVUklcbiAgICAgKiAgIHZhbHVlLiAgVXNlIG9mIHRoaXMgY2xhaW0gaXMgT1BUSU9OQUwuXG4gICAgICovXG4gICAgaXNzOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGZvcm1hdDogJ1N0cmluZ09yVVJJJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzdWJcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00LjEuMlxuICAgICAqXG4gICAgICogNC4xLjIuICBcInN1YlwiIChTdWJqZWN0KSBDbGFpbVxuICAgICAqXG4gICAgICogICBUaGUgXCJzdWJcIiAoc3ViamVjdCkgY2xhaW0gaWRlbnRpZmllcyB0aGUgcHJpbmNpcGFsIHRoYXQgaXMgdGhlXG4gICAgICogICBzdWJqZWN0IG9mIHRoZSBKV1QuICBUaGUgY2xhaW1zIGluIGEgSldUIGFyZSBub3JtYWxseSBzdGF0ZW1lbnRzXG4gICAgICogICBhYm91dCB0aGUgc3ViamVjdC4gIFRoZSBzdWJqZWN0IHZhbHVlIE1VU1QgZWl0aGVyIGJlIHNjb3BlZCB0byBiZVxuICAgICAqICAgbG9jYWxseSB1bmlxdWUgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGlzc3VlciBvciBiZSBnbG9iYWxseSB1bmlxdWUuXG4gICAgICogICBUaGUgcHJvY2Vzc2luZyBvZiB0aGlzIGNsYWltIGlzIGdlbmVyYWxseSBhcHBsaWNhdGlvbiBzcGVjaWZpYy4gIFRoZVxuICAgICAqICAgXCJzdWJcIiB2YWx1ZSBpcyBhIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyBjb250YWluaW5nIGEgU3RyaW5nT3JVUklcbiAgICAgKiAgIHZhbHVlLiAgVXNlIG9mIHRoaXMgY2xhaW0gaXMgT1BUSU9OQUwuXG4gICAgICovXG4gICAgc3ViOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGZvcm1hdDogJ1N0cmluZ09yVVJJJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhdWRcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00LjEuM1xuICAgICAqXG4gICAgICogNC4xLjMuICBcImF1ZFwiIChBdWRpZW5jZSkgQ2xhaW1cbiAgICAgKlxuICAgICAqICAgVGhlIFwiYXVkXCIgKGF1ZGllbmNlKSBjbGFpbSBpZGVudGlmaWVzIHRoZSByZWNpcGllbnRzIHRoYXQgdGhlIEpXVCBpc1xuICAgICAqICAgaW50ZW5kZWQgZm9yLiAgRWFjaCBwcmluY2lwYWwgaW50ZW5kZWQgdG8gcHJvY2VzcyB0aGUgSldUIE1VU1RcbiAgICAgKiAgIGlkZW50aWZ5IGl0c2VsZiB3aXRoIGEgdmFsdWUgaW4gdGhlIGF1ZGllbmNlIGNsYWltLiAgSWYgdGhlIHByaW5jaXBhbFxuICAgICAqICAgcHJvY2Vzc2luZyB0aGUgY2xhaW0gZG9lcyBub3QgaWRlbnRpZnkgaXRzZWxmIHdpdGggYSB2YWx1ZSBpbiB0aGVcbiAgICAgKiAgIFwiYXVkXCIgY2xhaW0gd2hlbiB0aGlzIGNsYWltIGlzIHByZXNlbnQsIHRoZW4gdGhlIEpXVCBNVVNUIGJlXG4gICAgICogICByZWplY3RlZC4gIEluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSBcImF1ZFwiIHZhbHVlIGlzIGFuIGFycmF5IG9mIGNhc2UtXG4gICAgICogICBzZW5zaXRpdmUgc3RyaW5ncywgZWFjaCBjb250YWluaW5nIGEgU3RyaW5nT3JVUkkgdmFsdWUuICBJbiB0aGVcbiAgICAgKiAgIHNwZWNpYWwgY2FzZSB3aGVuIHRoZSBKV1QgaGFzIG9uZSBhdWRpZW5jZSwgdGhlIFwiYXVkXCIgdmFsdWUgTUFZIGJlIGFcbiAgICAgKiAgIHNpbmdsZSBjYXNlLXNlbnNpdGl2ZSBzdHJpbmcgY29udGFpbmluZyBhIFN0cmluZ09yVVJJIHZhbHVlLiAgVGhlXG4gICAgICogICBpbnRlcnByZXRhdGlvbiBvZiBhdWRpZW5jZSB2YWx1ZXMgaXMgZ2VuZXJhbGx5IGFwcGxpY2F0aW9uIHNwZWNpZmljLlxuICAgICAqICAgVXNlIG9mIHRoaXMgY2xhaW0gaXMgT1BUSU9OQUwuXG4gICAgICovXG4gICAgYXVkOiB7XG4gICAgICB0eXBlOiBbJ2FycmF5JywgJ3N0cmluZyddLFxuICAgICAgZm9ybWF0OiAnU3RyaW5nT3JVUkknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgZm9ybWF0OiAnU3RyaW5nT3JVUkknXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGV4cFxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS40XG4gICAgICpcbiAgICAgKiA0LjEuNC4gIFwiZXhwXCIgKEV4cGlyYXRpb24gVGltZSkgQ2xhaW1cbiAgICAgKlxuICAgICAqICAgVGhlIFwiZXhwXCIgKGV4cGlyYXRpb24gdGltZSkgY2xhaW0gaWRlbnRpZmllcyB0aGUgZXhwaXJhdGlvbiB0aW1lIG9uXG4gICAgICogICBvciBhZnRlciB3aGljaCB0aGUgSldUIE1VU1QgTk9UIGJlIGFjY2VwdGVkIGZvciBwcm9jZXNzaW5nLiAgVGhlXG4gICAgICogICBwcm9jZXNzaW5nIG9mIHRoZSBcImV4cFwiIGNsYWltIHJlcXVpcmVzIHRoYXQgdGhlIGN1cnJlbnQgZGF0ZS90aW1lXG4gICAgICogICBNVVNUIGJlIGJlZm9yZSB0aGUgZXhwaXJhdGlvbiBkYXRlL3RpbWUgbGlzdGVkIGluIHRoZSBcImV4cFwiIGNsYWltLlxuICAgICAqXG4gICAgICogICBJbXBsZW1lbnRlcnMgTUFZIHByb3ZpZGUgZm9yIHNvbWUgc21hbGwgbGVld2F5LCB1c3VhbGx5IG5vIG1vcmUgdGhhblxuICAgICAqICAgYSBmZXcgbWludXRlcywgdG8gYWNjb3VudCBmb3IgY2xvY2sgc2tldy4gIEl0cyB2YWx1ZSBNVVNUIGJlIGEgbnVtYmVyXG4gICAgICogICBjb250YWluaW5nIGEgTnVtZXJpY0RhdGUgdmFsdWUuICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqL1xuICAgIGV4cDoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBmb3JtYXQ6ICdOdW1lcmljRGF0ZSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbmJmXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE5I3NlY3Rpb24tNC4xLjVcbiAgICAgKlxuICAgICAqIDQuMS41LiAgXCJuYmZcIiAoTm90IEJlZm9yZSkgQ2xhaW1cbiAgICAgKlxuICAgICAqICAgVGhlIFwibmJmXCIgKG5vdCBiZWZvcmUpIGNsYWltIGlkZW50aWZpZXMgdGhlIHRpbWUgYmVmb3JlIHdoaWNoIHRoZSBKV1RcbiAgICAgKiAgIE1VU1QgTk9UIGJlIGFjY2VwdGVkIGZvciBwcm9jZXNzaW5nLiAgVGhlIHByb2Nlc3Npbmcgb2YgdGhlIFwibmJmXCJcbiAgICAgKiAgIGNsYWltIHJlcXVpcmVzIHRoYXQgdGhlIGN1cnJlbnQgZGF0ZS90aW1lIE1VU1QgYmUgYWZ0ZXIgb3IgZXF1YWwgdG9cbiAgICAgKiAgIHRoZSBub3QtYmVmb3JlIGRhdGUvdGltZSBsaXN0ZWQgaW4gdGhlIFwibmJmXCIgY2xhaW0uICBJbXBsZW1lbnRlcnMgTUFZXG4gICAgICogICBwcm92aWRlIGZvciBzb21lIHNtYWxsIGxlZXdheSwgdXN1YWxseSBubyBtb3JlIHRoYW4gYSBmZXcgbWludXRlcywgdG9cbiAgICAgKiAgIGFjY291bnQgZm9yIGNsb2NrIHNrZXcuICBJdHMgdmFsdWUgTVVTVCBiZSBhIG51bWJlciBjb250YWluaW5nIGFcbiAgICAgKiAgIE51bWVyaWNEYXRlIHZhbHVlLiAgVXNlIG9mIHRoaXMgY2xhaW0gaXMgT1BUSU9OQUwuXG4gICAgICovXG4gICAgbmJmOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGZvcm1hdDogJ051bWVyaWNEYXRlJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpYXRcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00LjEuNlxuICAgICAqXG4gICAgICogNC4xLjYuICBcImlhdFwiIChJc3N1ZWQgQXQpIENsYWltXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImlhdFwiIChpc3N1ZWQgYXQpIGNsYWltIGlkZW50aWZpZXMgdGhlIHRpbWUgYXQgd2hpY2ggdGhlIEpXVCB3YXNcbiAgICAgKiAgIGlzc3VlZC4gIFRoaXMgY2xhaW0gY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBhZ2Ugb2YgdGhlIEpXVC4gIEl0c1xuICAgICAqICAgdmFsdWUgTVVTVCBiZSBhIG51bWJlciBjb250YWluaW5nIGEgTnVtZXJpY0RhdGUgdmFsdWUuICBVc2Ugb2YgdGhpc1xuICAgICAqICAgY2xhaW0gaXMgT1BUSU9OQUwuXG4gICAgICovXG4gICAgaWF0OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGZvcm1hdDogJ051bWVyaWNEYXRlJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqdGlcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00LjEuN1xuICAgICAqXG4gICAgICogNC4xLjcuICBcImp0aVwiIChKV1QgSUQpIENsYWltXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImp0aVwiIChKV1QgSUQpIGNsYWltIHByb3ZpZGVzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBKV1QuXG4gICAgICogICBUaGUgaWRlbnRpZmllciB2YWx1ZSBNVVNUIGJlIGFzc2lnbmVkIGluIGEgbWFubmVyIHRoYXQgZW5zdXJlcyB0aGF0XG4gICAgICogICB0aGVyZSBpcyBhIG5lZ2xpZ2libGUgcHJvYmFiaWxpdHkgdGhhdCB0aGUgc2FtZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogICBhY2NpZGVudGFsbHkgYXNzaWduZWQgdG8gYSBkaWZmZXJlbnQgZGF0YSBvYmplY3Q7IGlmIHRoZSBhcHBsaWNhdGlvblxuICAgICAqICAgdXNlcyBtdWx0aXBsZSBpc3N1ZXJzLCBjb2xsaXNpb25zIE1VU1QgYmUgcHJldmVudGVkIGFtb25nIHZhbHVlc1xuICAgICAqICAgcHJvZHVjZWQgYnkgZGlmZmVyZW50IGlzc3VlcnMgYXMgd2VsbC4gIFRoZSBcImp0aVwiIGNsYWltIGNhbiBiZSB1c2VkXG4gICAgICogICB0byBwcmV2ZW50IHRoZSBKV1QgZnJvbSBiZWluZyByZXBsYXllZC4gIFRoZSBcImp0aVwiIHZhbHVlIGlzIGEgY2FzZS1cbiAgICAgKiAgIHNlbnNpdGl2ZSBzdHJpbmcuICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBqdGk6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBKV1RDbGFpbXNTZXRTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIEpXS1NjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09OU2NoZW1hID0gX3JlcXVpcmUuSlNPTlNjaGVtYTtcblxuLyoqXG4gKiBKT1NFSGVhZGVyU2NoZW1hXG4gKlxuICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE5I3NlY3Rpb24tNVxuICpcbiAqIDUuICBKT1NFIEhlYWRlclxuICpcbiAqICAgRm9yIGEgSldUIG9iamVjdCwgdGhlIG1lbWJlcnMgb2YgdGhlIEpTT04gb2JqZWN0IHJlcHJlc2VudGVkIGJ5IHRoZVxuICogICBKT1NFIEhlYWRlciBkZXNjcmliZSB0aGUgY3J5cHRvZ3JhcGhpYyBvcGVyYXRpb25zIGFwcGxpZWQgdG8gdGhlIEpXVFxuICogICBhbmQgb3B0aW9uYWxseSwgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9mIHRoZSBKV1QuICBEZXBlbmRpbmcgdXBvblxuICogICB3aGV0aGVyIHRoZSBKV1QgaXMgYSBKV1Mgb3IgSldFLCB0aGUgY29ycmVzcG9uZGluZyBydWxlcyBmb3IgdGhlIEpPU0VcbiAqICAgSGVhZGVyIHZhbHVlcyBhcHBseS5cbiAqL1xuXG5cbnZhciBKT1NFSGVhZGVyU2NoZW1hID0gbmV3IEpTT05TY2hlbWEoe1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogdHlwXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE5I3NlY3Rpb24tNS4xXG4gICAgICpcbiAgICAgKiA1LjEuICBcInR5cFwiIChUeXBlKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcInR5cFwiICh0eXBlKSBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgYnkgW0pXU10gYW5kIFtKV0VdIGlzIHVzZWRcbiAgICAgKiAgIGJ5IEpXVCBhcHBsaWNhdGlvbnMgdG8gZGVjbGFyZSB0aGUgbWVkaWEgdHlwZSBbSUFOQS5NZWRpYVR5cGVzXSBvZlxuICAgICAqICAgdGhpcyBjb21wbGV0ZSBKV1QuICBUaGlzIGlzIGludGVuZGVkIGZvciB1c2UgYnkgdGhlIEpXVCBhcHBsaWNhdGlvblxuICAgICAqICAgd2hlbiB2YWx1ZXMgdGhhdCBhcmUgbm90IEpXVHMgY291bGQgYWxzbyBiZSBwcmVzZW50IGluIGFuIGFwcGxpY2F0aW9uXG4gICAgICogICBkYXRhIHN0cnVjdHVyZSB0aGF0IGNhbiBjb250YWluIGEgSldUIG9iamVjdDsgdGhlIGFwcGxpY2F0aW9uIGNhbiB1c2VcbiAgICAgKiAgIHRoaXMgdmFsdWUgdG8gZGlzYW1iaWd1YXRlIGFtb25nIHRoZSBkaWZmZXJlbnQga2luZHMgb2Ygb2JqZWN0cyB0aGF0XG4gICAgICogICBtaWdodCBiZSBwcmVzZW50LiAgSXQgd2lsbCB0eXBpY2FsbHkgbm90IGJlIHVzZWQgYnkgYXBwbGljYXRpb25zIHdoZW5cbiAgICAgKiAgIGl0IGlzIGFscmVhZHkga25vd24gdGhhdCB0aGUgb2JqZWN0IGlzIGEgSldULiAgVGhpcyBwYXJhbWV0ZXIgaXNcbiAgICAgKiAgIGlnbm9yZWQgYnkgSldUIGltcGxlbWVudGF0aW9uczsgYW55IHByb2Nlc3Npbmcgb2YgdGhpcyBwYXJhbWV0ZXIgaXNcbiAgICAgKiAgIHBlcmZvcm1lZCBieSB0aGUgSldUIGFwcGxpY2F0aW9uLiAgSWYgcHJlc2VudCwgaXQgaXMgUkVDT01NRU5ERUQgdGhhdFxuICAgICAqICAgaXRzIHZhbHVlIGJlIFwiSldUXCIgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIG9iamVjdCBpcyBhIEpXVC4gIFdoaWxlXG4gICAgICogICBtZWRpYSB0eXBlIG5hbWVzIGFyZSBub3QgY2FzZSBzZW5zaXRpdmUsIGl0IGlzIFJFQ09NTUVOREVEIHRoYXQgXCJKV1RcIlxuICAgICAqICAgYWx3YXlzIGJlIHNwZWxsZWQgdXNpbmcgdXBwZXJjYXNlIGNoYXJhY3RlcnMgZm9yIGNvbXBhdGliaWxpdHkgd2l0aFxuICAgICAqICAgbGVnYWN5IGltcGxlbWVudGF0aW9ucy4gIFVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS45XG4gICAgICpcbiAgICAgKiA0LjEuOS4gIFwidHlwXCIgKFR5cGUpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwidHlwXCIgKHR5cGUpIEhlYWRlciBQYXJhbWV0ZXIgaXMgdXNlZCBieSBKV1MgYXBwbGljYXRpb25zIHRvXG4gICAgICogICBkZWNsYXJlIHRoZSBtZWRpYSB0eXBlIFtJQU5BLk1lZGlhVHlwZXNdIG9mIHRoaXMgY29tcGxldGUgSldTLiAgVGhpc1xuICAgICAqICAgaXMgaW50ZW5kZWQgZm9yIHVzZSBieSB0aGUgYXBwbGljYXRpb24gd2hlbiBtb3JlIHRoYW4gb25lIGtpbmQgb2ZcbiAgICAgKiAgIG9iamVjdCBjb3VsZCBiZSBwcmVzZW50IGluIGFuIGFwcGxpY2F0aW9uIGRhdGEgc3RydWN0dXJlIHRoYXQgY2FuXG4gICAgICogICBjb250YWluIGEgSldTOyB0aGUgYXBwbGljYXRpb24gY2FuIHVzZSB0aGlzIHZhbHVlIHRvIGRpc2FtYmlndWF0ZVxuICAgICAqICAgYW1vbmcgdGhlIGRpZmZlcmVudCBraW5kcyBvZiBvYmplY3RzIHRoYXQgbWlnaHQgYmUgcHJlc2VudC4gIEl0IHdpbGxcbiAgICAgKiAgIHR5cGljYWxseSBub3QgYmUgdXNlZCBieSBhcHBsaWNhdGlvbnMgd2hlbiB0aGUga2luZCBvZiBvYmplY3QgaXNcbiAgICAgKiAgIGFscmVhZHkga25vd24uICBUaGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkIGJ5IEpXUyBpbXBsZW1lbnRhdGlvbnM7IGFueVxuICAgICAqICAgcHJvY2Vzc2luZyBvZiB0aGlzIHBhcmFtZXRlciBpcyBwZXJmb3JtZWQgYnkgdGhlIEpXUyBhcHBsaWNhdGlvbi5cbiAgICAgKiAgIFVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKiAgIFBlciBSRkMgMjA0NSBbUkZDMjA0NV0sIGFsbCBtZWRpYSB0eXBlIHZhbHVlcywgc3VidHlwZSB2YWx1ZXMsIGFuZFxuICAgICAqICAgcGFyYW1ldGVyIG5hbWVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLiAgSG93ZXZlciwgcGFyYW1ldGVyIHZhbHVlcyBhcmVcbiAgICAgKiAgIGNhc2Ugc2Vuc2l0aXZlIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkIGZvciB0aGUgc3BlY2lmaWMgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogICBUbyBrZWVwIG1lc3NhZ2VzIGNvbXBhY3QgaW4gY29tbW9uIHNpdHVhdGlvbnMsIGl0IGlzIFJFQ09NTUVOREVEIHRoYXRcbiAgICAgKiAgIHByb2R1Y2VycyBvbWl0IGFuIFwiYXBwbGljYXRpb24vXCIgcHJlZml4IG9mIGEgbWVkaWEgdHlwZSB2YWx1ZSBpbiBhXG4gICAgICogICBcInR5cFwiIEhlYWRlciBQYXJhbWV0ZXIgd2hlbiBubyBvdGhlciAnLycgYXBwZWFycyBpbiB0aGUgbWVkaWEgdHlwZVxuICAgICAqICAgdmFsdWUuICBBIHJlY2lwaWVudCB1c2luZyB0aGUgbWVkaWEgdHlwZSB2YWx1ZSBNVVNUIHRyZWF0IGl0IGFzIGlmXG4gICAgICogICBcImFwcGxpY2F0aW9uL1wiIHdlcmUgcHJlcGVuZGVkIHRvIGFueSBcInR5cFwiIHZhbHVlIG5vdCBjb250YWluaW5nIGFcbiAgICAgKiAgICcvJy4gIEZvciBpbnN0YW5jZSwgYSBcInR5cFwiIHZhbHVlIG9mIFwiZXhhbXBsZVwiIFNIT1VMRCBiZSB1c2VkIHRvXG4gICAgICogICByZXByZXNlbnQgdGhlIFwiYXBwbGljYXRpb24vZXhhbXBsZVwiIG1lZGlhIHR5cGUsIHdoZXJlYXMgdGhlIG1lZGlhXG4gICAgICogICB0eXBlIFwiYXBwbGljYXRpb24vZXhhbXBsZTtwYXJ0PVwiMS8yXCJcIiBjYW5ub3QgYmUgc2hvcnRlbmVkIHRvXG4gICAgICogICBcImV4YW1wbGU7cGFydD1cIjEvMlwiXCIuXG4gICAgICpcbiAgICAgKiAgIFRoZSBcInR5cFwiIHZhbHVlIFwiSk9TRVwiIGNhbiBiZSB1c2VkIGJ5IGFwcGxpY2F0aW9ucyB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICogICB0aGlzIG9iamVjdCBpcyBhIEpXUyBvciBKV0UgdXNpbmcgdGhlIEpXUyBDb21wYWN0IFNlcmlhbGl6YXRpb24gb3JcbiAgICAgKiAgIHRoZSBKV0UgQ29tcGFjdCBTZXJpYWxpemF0aW9uLiAgVGhlIFwidHlwXCIgdmFsdWUgXCJKT1NFK0pTT05cIiBjYW4gYmVcbiAgICAgKiAgIHVzZWQgYnkgYXBwbGljYXRpb25zIHRvIGluZGljYXRlIHRoYXQgdGhpcyBvYmplY3QgaXMgYSBKV1Mgb3IgSldFXG4gICAgICogICB1c2luZyB0aGUgSldTIEpTT04gU2VyaWFsaXphdGlvbiBvciB0aGUgSldFIEpTT04gU2VyaWFsaXphdGlvbi5cbiAgICAgKiAgIE90aGVyIHR5cGUgdmFsdWVzIGNhbiBhbHNvIGJlIHVzZWQgYnkgYXBwbGljYXRpb25zLlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjExXG4gICAgICpcbiAgICAgKiA0LjEuMTEuICBcInR5cFwiIChUeXBlKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJ0eXBcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuOSBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSB0eXBlIGlzIHRoYXQgb2YgdGhpcyBjb21wbGV0ZSBKV0UuXG4gICAgICovXG4gICAgdHlwOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjdHlcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi01LjJcbiAgICAgKlxuICAgICAqIDUuMi4gIFwiY3R5XCIgKENvbnRlbnQgVHlwZSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJjdHlcIiAoY29udGVudCB0eXBlKSBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgYnkgW0pXU10gYW5kIFtKV0VdXG4gICAgICogICBpcyB1c2VkIGJ5IHRoaXMgc3BlY2lmaWNhdGlvbiB0byBjb252ZXkgc3RydWN0dXJhbCBpbmZvcm1hdGlvbiBhYm91dFxuICAgICAqICAgdGhlIEpXVC5cbiAgICAgKlxuICAgICAqICAgSW4gdGhlIG5vcm1hbCBjYXNlIGluIHdoaWNoIG5lc3RlZCBzaWduaW5nIG9yIGVuY3J5cHRpb24gb3BlcmF0aW9uc1xuICAgICAqICAgYXJlIG5vdCBlbXBsb3llZCwgdGhlIHVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgTk9UXG4gICAgICogICBSRUNPTU1FTkRFRC4gIEluIHRoZSBjYXNlIHRoYXQgbmVzdGVkIHNpZ25pbmcgb3IgZW5jcnlwdGlvbiBpc1xuICAgICAqICAgZW1wbG95ZWQsIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBNVVNUIGJlIHByZXNlbnQ7IGluIHRoaXMgY2FzZSwgdGhlXG4gICAgICogICB2YWx1ZSBNVVNUIGJlIFwiSldUXCIsIHRvIGluZGljYXRlIHRoYXQgYSBOZXN0ZWQgSldUIGlzIGNhcnJpZWQgaW4gdGhpc1xuICAgICAqICAgSldULiAgV2hpbGUgbWVkaWEgdHlwZSBuYW1lcyBhcmUgbm90IGNhc2Ugc2Vuc2l0aXZlLCBpdCBpc1xuICAgICAqICAgUkVDT01NRU5ERUQgdGhhdCBcIkpXVFwiIGFsd2F5cyBiZSBzcGVsbGVkIHVzaW5nIHVwcGVyY2FzZSBjaGFyYWN0ZXJzXG4gICAgICogICBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbnMuICBTZWUgQXBwZW5kaXggQS4yIGZvclxuICAgICAqICAgYW4gZXhhbXBsZSBvZiBhIE5lc3RlZCBKV1QuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjEwXG4gICAgICpcbiAgICAgKiA0LjEuMTAuICBcImN0eVwiIChDb250ZW50IFR5cGUpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwiY3R5XCIgKGNvbnRlbnQgdHlwZSkgSGVhZGVyIFBhcmFtZXRlciBpcyB1c2VkIGJ5IEpXUyBhcHBsaWNhdGlvbnNcbiAgICAgKiAgIHRvIGRlY2xhcmUgdGhlIG1lZGlhIHR5cGUgW0lBTkEuTWVkaWFUeXBlc10gb2YgdGhlIHNlY3VyZWQgY29udGVudFxuICAgICAqICAgKHRoZSBwYXlsb2FkKS4gIFRoaXMgaXMgaW50ZW5kZWQgZm9yIHVzZSBieSB0aGUgYXBwbGljYXRpb24gd2hlbiBtb3JlXG4gICAgICogICB0aGFuIG9uZSBraW5kIG9mIG9iamVjdCBjb3VsZCBiZSBwcmVzZW50IGluIHRoZSBKV1MgUGF5bG9hZDsgdGhlXG4gICAgICogICBhcHBsaWNhdGlvbiBjYW4gdXNlIHRoaXMgdmFsdWUgdG8gZGlzYW1iaWd1YXRlIGFtb25nIHRoZSBkaWZmZXJlbnRcbiAgICAgKiAgIGtpbmRzIG9mIG9iamVjdHMgdGhhdCBtaWdodCBiZSBwcmVzZW50LiAgSXQgd2lsbCB0eXBpY2FsbHkgbm90IGJlXG4gICAgICogICB1c2VkIGJ5IGFwcGxpY2F0aW9ucyB3aGVuIHRoZSBraW5kIG9mIG9iamVjdCBpcyBhbHJlYWR5IGtub3duLiAgVGhpc1xuICAgICAqICAgcGFyYW1ldGVyIGlzIGlnbm9yZWQgYnkgSldTIGltcGxlbWVudGF0aW9uczsgYW55IHByb2Nlc3Npbmcgb2YgdGhpc1xuICAgICAqICAgcGFyYW1ldGVyIGlzIHBlcmZvcm1lZCBieSB0aGUgSldTIGFwcGxpY2F0aW9uLiAgVXNlIG9mIHRoaXMgSGVhZGVyXG4gICAgICogICBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKiAgIFBlciBSRkMgMjA0NSBbUkZDMjA0NV0sIGFsbCBtZWRpYSB0eXBlIHZhbHVlcywgc3VidHlwZSB2YWx1ZXMsIGFuZFxuICAgICAqICAgcGFyYW1ldGVyIG5hbWVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLiAgSG93ZXZlciwgcGFyYW1ldGVyIHZhbHVlcyBhcmVcbiAgICAgKiAgIGNhc2Ugc2Vuc2l0aXZlIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkIGZvciB0aGUgc3BlY2lmaWMgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogICBUbyBrZWVwIG1lc3NhZ2VzIGNvbXBhY3QgaW4gY29tbW9uIHNpdHVhdGlvbnMsIGl0IGlzIFJFQ09NTUVOREVEIHRoYXRcbiAgICAgKiAgIHByb2R1Y2VycyBvbWl0IGFuIFwiYXBwbGljYXRpb24vXCIgcHJlZml4IG9mIGEgbWVkaWEgdHlwZSB2YWx1ZSBpbiBhXG4gICAgICogICBcImN0eVwiIEhlYWRlciBQYXJhbWV0ZXIgd2hlbiBubyBvdGhlciAnLycgYXBwZWFycyBpbiB0aGUgbWVkaWEgdHlwZVxuICAgICAqICAgdmFsdWUuICBBIHJlY2lwaWVudCB1c2luZyB0aGUgbWVkaWEgdHlwZSB2YWx1ZSBNVVNUIHRyZWF0IGl0IGFzIGlmXG4gICAgICogICBcImFwcGxpY2F0aW9uL1wiIHdlcmUgcHJlcGVuZGVkIHRvIGFueSBcImN0eVwiIHZhbHVlIG5vdCBjb250YWluaW5nIGFcbiAgICAgKiAgICcvJy4gIEZvciBpbnN0YW5jZSwgYSBcImN0eVwiIHZhbHVlIG9mIFwiZXhhbXBsZVwiIFNIT1VMRCBiZSB1c2VkIHRvXG4gICAgICogICByZXByZXNlbnQgdGhlIFwiYXBwbGljYXRpb24vZXhhbXBsZVwiIG1lZGlhIHR5cGUsIHdoZXJlYXMgdGhlIG1lZGlhXG4gICAgICogICB0eXBlIFwiYXBwbGljYXRpb24vZXhhbXBsZTtwYXJ0PVwiMS8yXCJcIiBjYW5ub3QgYmUgc2hvcnRlbmVkIHRvXG4gICAgICogICBcImV4YW1wbGU7cGFydD1cIjEvMlwiXCIuXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuMTJcbiAgICAgKlxuICAgICAqIDQuMS4xMi4gIFwiY3R5XCIgKENvbnRlbnQgVHlwZSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwiY3R5XCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjEwIG9mIFtKV1NdLCBleGNlcHRcbiAgICAgKiAgIHRoYXQgdGhlIHR5cGUgaXMgdGhhdCBvZiB0aGUgc2VjdXJlZCBjb250ZW50ICh0aGUgcGxhaW50ZXh0KS5cbiAgICAgKi9cbiAgICBjdHk6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydKV1QnXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhbGdcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjFcbiAgICAgKlxuICAgICAqIDQuMS4xLiAgXCJhbGdcIiAoQWxnb3JpdGhtKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImFsZ1wiIChhbGdvcml0aG0pIEhlYWRlciBQYXJhbWV0ZXIgaWRlbnRpZmllcyB0aGUgY3J5cHRvZ3JhcGhpY1xuICAgICAqICAgYWxnb3JpdGhtIHVzZWQgdG8gc2VjdXJlIHRoZSBKV1MuICBUaGUgSldTIFNpZ25hdHVyZSB2YWx1ZSBpcyBub3RcbiAgICAgKiAgIHZhbGlkIGlmIHRoZSBcImFsZ1wiIHZhbHVlIGRvZXMgbm90IHJlcHJlc2VudCBhIHN1cHBvcnRlZCBhbGdvcml0aG0gb3JcbiAgICAgKiAgIGlmIHRoZXJlIGlzIG5vdCBhIGtleSBmb3IgdXNlIHdpdGggdGhhdCBhbGdvcml0aG0gYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqICAgcGFydHkgdGhhdCBkaWdpdGFsbHkgc2lnbmVkIG9yIE1BQ2VkIHRoZSBjb250ZW50LiAgXCJhbGdcIiB2YWx1ZXNcbiAgICAgKiAgIHNob3VsZCBlaXRoZXIgYmUgcmVnaXN0ZXJlZCBpbiB0aGUgSUFOQSBcIkpTT04gV2ViIFNpZ25hdHVyZSBhbmRcbiAgICAgKiAgIEVuY3J5cHRpb24gQWxnb3JpdGhtc1wiIHJlZ2lzdHJ5IGVzdGFibGlzaGVkIGJ5IFtKV0FdIG9yIGJlIGEgdmFsdWVcbiAgICAgKiAgIHRoYXQgY29udGFpbnMgYSBDb2xsaXNpb24tUmVzaXN0YW50IE5hbWUuICBUaGUgXCJhbGdcIiB2YWx1ZSBpcyBhIGNhc2UtXG4gICAgICogICBzZW5zaXRpdmUgQVNDSUkgc3RyaW5nIGNvbnRhaW5pbmcgYSBTdHJpbmdPclVSSSB2YWx1ZS4gIFRoaXMgSGVhZGVyXG4gICAgICogICBQYXJhbWV0ZXIgTVVTVCBiZSBwcmVzZW50IGFuZCBNVVNUIGJlIHVuZGVyc3Rvb2QgYW5kIHByb2Nlc3NlZCBieVxuICAgICAqICAgaW1wbGVtZW50YXRpb25zLlxuICAgICAqXG4gICAgICogICBBIGxpc3Qgb2YgZGVmaW5lZCBcImFsZ1wiIHZhbHVlcyBmb3IgdGhpcyB1c2UgY2FuIGJlIGZvdW5kIGluIHRoZSBJQU5BXG4gICAgICogICBcIkpTT04gV2ViIFNpZ25hdHVyZSBhbmQgRW5jcnlwdGlvbiBBbGdvcml0aG1zXCIgcmVnaXN0cnkgZXN0YWJsaXNoZWRcbiAgICAgKiAgIGJ5IFtKV0FdOyB0aGUgaW5pdGlhbCBjb250ZW50cyBvZiB0aGlzIHJlZ2lzdHJ5IGFyZSB0aGUgdmFsdWVzXG4gICAgICogICBkZWZpbmVkIGluIFNlY3Rpb24gMy4xIG9mIFtKV0FdLlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjFcbiAgICAgKlxuICAgICAqIDQuMS4xLiAgXCJhbGdcIiAoQWxnb3JpdGhtKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJhbGdcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuMSBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBIZWFkZXIgUGFyYW1ldGVyIGlkZW50aWZpZXMgdGhlIGNyeXB0b2dyYXBoaWMgYWxnb3JpdGhtIHVzZWRcbiAgICAgKiAgIHRvIGVuY3J5cHQgb3IgZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgQ0VLLiAgVGhlIGVuY3J5cHRlZCBjb250ZW50XG4gICAgICogICBpcyBub3QgdXNhYmxlIGlmIHRoZSBcImFsZ1wiIHZhbHVlIGRvZXMgbm90IHJlcHJlc2VudCBhIHN1cHBvcnRlZFxuICAgICAqICAgYWxnb3JpdGhtLCBvciBpZiB0aGUgcmVjaXBpZW50IGRvZXMgbm90IGhhdmUgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZFxuICAgICAqICAgd2l0aCB0aGF0IGFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqICAgQSBsaXN0IG9mIGRlZmluZWQgXCJhbGdcIiB2YWx1ZXMgZm9yIHRoaXMgdXNlIGNhbiBiZSBmb3VuZCBpbiB0aGUgSUFOQVxuICAgICAqICAgXCJKU09OIFdlYiBTaWduYXR1cmUgYW5kIEVuY3J5cHRpb24gQWxnb3JpdGhtc1wiIHJlZ2lzdHJ5IGVzdGFibGlzaGVkXG4gICAgICogICBieSBbSldBXTsgdGhlIGluaXRpYWwgY29udGVudHMgb2YgdGhpcyByZWdpc3RyeSBhcmUgdGhlIHZhbHVlc1xuICAgICAqICAgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMSBvZiBbSldBXS5cbiAgICAgKi9cbiAgICBhbGc6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnU3RyaW5nT3JVUkknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGprdVxuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuMlxuICAgICAqXG4gICAgICogNC4xLjIuICBcImprdVwiIChKV0sgU2V0IFVSTCkgSGVhZGVyIFBhcmFtZXRlciAoSldTKVxuICAgICAqXG4gICAgICogICBUaGUgXCJqa3VcIiAoSldLIFNldCBVUkwpIEhlYWRlciBQYXJhbWV0ZXIgaXMgYSBVUkkgW1JGQzM5ODZdIHRoYXRcbiAgICAgKiAgIHJlZmVycyB0byBhIHJlc291cmNlIGZvciBhIHNldCBvZiBKU09OLWVuY29kZWQgcHVibGljIGtleXMsIG9uZSBvZlxuICAgICAqICAgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGtleSB1c2VkIHRvIGRpZ2l0YWxseSBzaWduIHRoZSBKV1MuICBUaGVcbiAgICAgKiAgIGtleXMgTVVTVCBiZSBlbmNvZGVkIGFzIGEgSldLIFNldCBbSldLXS4gIFRoZSBwcm90b2NvbCB1c2VkIHRvXG4gICAgICogICBhY3F1aXJlIHRoZSByZXNvdXJjZSBNVVNUIHByb3ZpZGUgaW50ZWdyaXR5IHByb3RlY3Rpb247IGFuIEhUVFAgR0VUXG4gICAgICogICByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBKV0sgU2V0IE1VU1QgdXNlIFRyYW5zcG9ydCBMYXllciBTZWN1cml0eVxuICAgICAqICAgKFRMUykgW1JGQzI4MThdIFtSRkM1MjQ2XTsgYW5kIHRoZSBpZGVudGl0eSBvZiB0aGUgc2VydmVyIE1VU1QgYmVcbiAgICAgKiAgIHZhbGlkYXRlZCwgYXMgcGVyIFNlY3Rpb24gNiBvZiBSRkMgNjEyNSBbUkZDNjEyNV0uICBBbHNvLCBzZWVcbiAgICAgKiAgIFNlY3Rpb24gOCBvbiBUTFMgcmVxdWlyZW1lbnRzLiAgVXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpc1xuICAgICAqICAgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuNFxuICAgICAqXG4gICAgICogNC4xLjQuICBcImprdVwiIChKV0sgU2V0IFVSTCkgSGVhZGVyIFBhcmFtZXRlciAoSldFKVxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwiamt1XCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjIgb2YgW0pXU10sIGV4Y2VwdFxuICAgICAqICAgdGhhdCB0aGUgSldLIFNldCByZXNvdXJjZSBjb250YWlucyB0aGUgcHVibGljIGtleSB0byB3aGljaCB0aGUgSldFXG4gICAgICogICB3YXMgZW5jcnlwdGVkOyB0aGlzIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJpdmF0ZSBrZXkgbmVlZGVkXG4gICAgICogICB0byBkZWNyeXB0IHRoZSBKV0UuXG4gICAgICovXG4gICAgamt1OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGZvcm1hdDogJ1VSSSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogandrXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS4zXG4gICAgICpcbiAgICAgKiA0LjEuMy4gIFwiandrXCIgKEpTT04gV2ViIEtleSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJqd2tcIiAoSlNPTiBXZWIgS2V5KSBIZWFkZXIgUGFyYW1ldGVyIGlzIHRoZSBwdWJsaWMga2V5IHRoYXRcbiAgICAgKiAgIGNvcnJlc3BvbmRzIHRvIHRoZSBrZXkgdXNlZCB0byBkaWdpdGFsbHkgc2lnbiB0aGUgSldTLiAgVGhpcyBrZXkgaXNcbiAgICAgKiAgIHJlcHJlc2VudGVkIGFzIGEgSlNPTiBXZWIgS2V5IFtKV0tdLiAgVXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpc1xuICAgICAqICAgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuNVxuICAgICAqXG4gICAgICogNC4xLjUuICBcImp3a1wiIChKU09OIFdlYiBLZXkpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHRoZSBzYW1lIG1lYW5pbmcsIHN5bnRheCwgYW5kIHByb2Nlc3NpbmcgcnVsZXMgYXNcbiAgICAgKiAgIHRoZSBcImp3a1wiIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS4zIG9mIFtKV1NdLCBleGNlcHRcbiAgICAgKiAgIHRoYXQgdGhlIGtleSBpcyB0aGUgcHVibGljIGtleSB0byB3aGljaCB0aGUgSldFIHdhcyBlbmNyeXB0ZWQ7IHRoaXNcbiAgICAgKiAgIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJpdmF0ZSBrZXkgbmVlZGVkIHRvIGRlY3J5cHQgdGhlIEpXRS5cbiAgICAgKi9cbiAgICAvL2p3azogSldLU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICoga2lkXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS40XG4gICAgICpcbiAgICAgKiA0LjEuNC4gIFwia2lkXCIgKEtleSBJRCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJraWRcIiAoa2V5IElEKSBIZWFkZXIgUGFyYW1ldGVyIGlzIGEgaGludCBpbmRpY2F0aW5nIHdoaWNoIGtleVxuICAgICAqICAgd2FzIHVzZWQgdG8gc2VjdXJlIHRoZSBKV1MuICBUaGlzIHBhcmFtZXRlciBhbGxvd3Mgb3JpZ2luYXRvcnMgdG9cbiAgICAgKiAgIGV4cGxpY2l0bHkgc2lnbmFsIGEgY2hhbmdlIG9mIGtleSB0byByZWNpcGllbnRzLiAgVGhlIHN0cnVjdHVyZSBvZlxuICAgICAqICAgdGhlIFwia2lkXCIgdmFsdWUgaXMgdW5zcGVjaWZpZWQuICBJdHMgdmFsdWUgTVVTVCBiZSBhIGNhc2Utc2Vuc2l0aXZlXG4gICAgICogICBzdHJpbmcuICBVc2Ugb2YgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIGlzIE9QVElPTkFMLlxuICAgICAqXG4gICAgICogICBXaGVuIHVzZWQgd2l0aCBhIEpXSywgdGhlIFwia2lkXCIgdmFsdWUgaXMgdXNlZCB0byBtYXRjaCBhIEpXSyBcImtpZFwiXG4gICAgICogICBwYXJhbWV0ZXIgdmFsdWUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS42XG4gICAgICpcbiAgICAgKiA0LjEuNi4gIFwia2lkXCIgKEtleSBJRCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwia2lkXCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjQgb2YgW0pXU10sIGV4Y2VwdFxuICAgICAqICAgdGhhdCB0aGUga2V5IGhpbnQgcmVmZXJlbmNlcyB0aGUgcHVibGljIGtleSB0byB3aGljaCB0aGUgSldFIHdhc1xuICAgICAqICAgZW5jcnlwdGVkOyB0aGlzIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJpdmF0ZSBrZXkgbmVlZGVkIHRvXG4gICAgICogICBkZWNyeXB0IHRoZSBKV0UuICBUaGlzIHBhcmFtZXRlciBhbGxvd3Mgb3JpZ2luYXRvcnMgdG8gZXhwbGljaXRseVxuICAgICAqICAgc2lnbmFsIGEgY2hhbmdlIG9mIGtleSB0byBKV0UgcmVjaXBpZW50cy5cbiAgICAgKi9cbiAgICBraWQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHg1dVxuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuNVxuICAgICAqXG4gICAgICogNC4xLjUuICBcIng1dVwiIChYLjUwOSBVUkwpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwieDV1XCIgKFguNTA5IFVSTCkgSGVhZGVyIFBhcmFtZXRlciBpcyBhIFVSSSBbUkZDMzk4Nl0gdGhhdCByZWZlcnNcbiAgICAgKiAgIHRvIGEgcmVzb3VyY2UgZm9yIHRoZSBYLjUwOSBwdWJsaWMga2V5IGNlcnRpZmljYXRlIG9yIGNlcnRpZmljYXRlXG4gICAgICogICBjaGFpbiBbUkZDNTI4MF0gY29ycmVzcG9uZGluZyB0byB0aGUga2V5IHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24gdGhlXG4gICAgICogICBKV1MuICBUaGUgaWRlbnRpZmllZCByZXNvdXJjZSBNVVNUIHByb3ZpZGUgYSByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICAgKiAgIGNlcnRpZmljYXRlIG9yIGNlcnRpZmljYXRlIGNoYWluIHRoYXQgY29uZm9ybXMgdG8gUkZDIDUyODAgW1JGQzUyODBdXG4gICAgICogICBpbiBQRU0tZW5jb2RlZCBmb3JtLCB3aXRoIGVhY2ggY2VydGlmaWNhdGUgZGVsaW1pdGVkIGFzIHNwZWNpZmllZCBpblxuICAgICAqICAgU2VjdGlvbiA2LjEgb2YgUkZDIDQ5NDUgW1JGQzQ5NDVdLiAgVGhlIGNlcnRpZmljYXRlIGNvbnRhaW5pbmcgdGhlXG4gICAgICogICBwdWJsaWMga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleSB1c2VkIHRvIGRpZ2l0YWxseSBzaWduIHRoZSBKV1NcbiAgICAgKiAgIE1VU1QgYmUgdGhlIGZpcnN0IGNlcnRpZmljYXRlLiAgVGhpcyBNQVkgYmUgZm9sbG93ZWQgYnkgYWRkaXRpb25hbFxuICAgICAqICAgY2VydGlmaWNhdGVzLCB3aXRoIGVhY2ggc3Vic2VxdWVudCBjZXJ0aWZpY2F0ZSBiZWluZyB0aGUgb25lIHVzZWQgdG9cbiAgICAgKiAgIGNlcnRpZnkgdGhlIHByZXZpb3VzIG9uZS4gIFRoZSBwcm90b2NvbCB1c2VkIHRvIGFjcXVpcmUgdGhlIHJlc291cmNlXG4gICAgICogICBNVVNUIHByb3ZpZGUgaW50ZWdyaXR5IHByb3RlY3Rpb247IGFuIEhUVFAgR0VUIHJlcXVlc3QgdG8gcmV0cmlldmVcbiAgICAgKiAgIHRoZSBjZXJ0aWZpY2F0ZSBNVVNUIHVzZSBUTFMgW1JGQzI4MThdIFtSRkM1MjQ2XTsgYW5kIHRoZSBpZGVudGl0eSBvZlxuICAgICAqICAgdGhlIHNlcnZlciBNVVNUIGJlIHZhbGlkYXRlZCwgYXMgcGVyIFNlY3Rpb24gNiBvZiBSRkMgNjEyNSBbUkZDNjEyNV0uXG4gICAgICogICBBbHNvLCBzZWUgU2VjdGlvbiA4IG9uIFRMUyByZXF1aXJlbWVudHMuICBVc2Ugb2YgdGhpcyBIZWFkZXJcbiAgICAgKiAgIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS43XG4gICAgICpcbiAgICAgKiA0LjEuNy4gIFwieDV1XCIgKFguNTA5IFVSTCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwieDV1XCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjUgb2YgW0pXU10sIGV4Y2VwdFxuICAgICAqICAgdGhhdCB0aGUgWC41MDkgcHVibGljIGtleSBjZXJ0aWZpY2F0ZSBvciBjZXJ0aWZpY2F0ZSBjaGFpbiBbUkZDNTI4MF1cbiAgICAgKiAgIGNvbnRhaW5zIHRoZSBwdWJsaWMga2V5IHRvIHdoaWNoIHRoZSBKV0Ugd2FzIGVuY3J5cHRlZDsgdGhpcyBjYW4gYmVcbiAgICAgKiAgIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcml2YXRlIGtleSBuZWVkZWQgdG8gZGVjcnlwdCB0aGUgSldFLlxuICAgICAqL1xuICAgIHg1dToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBmb3JtYXQ6ICdVUkknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHg1Y1xuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuNlxuICAgICAqXG4gICAgICogNC4xLjYuICBcIng1Y1wiIChYLjUwOSBDZXJ0aWZpY2F0ZSBDaGFpbikgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJ4NWNcIiAoWC41MDkgY2VydGlmaWNhdGUgY2hhaW4pIEhlYWRlciBQYXJhbWV0ZXIgY29udGFpbnMgdGhlXG4gICAgICogICBYLjUwOSBwdWJsaWMga2V5IGNlcnRpZmljYXRlIG9yIGNlcnRpZmljYXRlIGNoYWluIFtSRkM1MjgwXVxuICAgICAqICAgY29ycmVzcG9uZGluZyB0byB0aGUga2V5IHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24gdGhlIEpXUy4gIFRoZVxuICAgICAqICAgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGUgY2hhaW4gaXMgcmVwcmVzZW50ZWQgYXMgYSBKU09OIGFycmF5IG9mXG4gICAgICogICBjZXJ0aWZpY2F0ZSB2YWx1ZSBzdHJpbmdzLiAgRWFjaCBzdHJpbmcgaW4gdGhlIGFycmF5IGlzIGFcbiAgICAgKiAgIGJhc2U2NC1lbmNvZGVkIChTZWN0aW9uIDQgb2YgW1JGQzQ2NDhdIC0tIG5vdCBiYXNlNjR1cmwtZW5jb2RlZCkgREVSXG4gICAgICogICBbSVRVLlg2OTAuMjAwOF0gUEtJWCBjZXJ0aWZpY2F0ZSB2YWx1ZS4gIFRoZSBjZXJ0aWZpY2F0ZSBjb250YWluaW5nXG4gICAgICogICB0aGUgcHVibGljIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXkgdXNlZCB0byBkaWdpdGFsbHkgc2lnbiB0aGVcbiAgICAgKiAgIEpXUyBNVVNUIGJlIHRoZSBmaXJzdCBjZXJ0aWZpY2F0ZS4gIFRoaXMgTUFZIGJlIGZvbGxvd2VkIGJ5XG4gICAgICogICBhZGRpdGlvbmFsIGNlcnRpZmljYXRlcywgd2l0aCBlYWNoIHN1YnNlcXVlbnQgY2VydGlmaWNhdGUgYmVpbmcgdGhlXG4gICAgICogICBvbmUgdXNlZCB0byBjZXJ0aWZ5IHRoZSBwcmV2aW91cyBvbmUuICBUaGUgcmVjaXBpZW50IE1VU1QgdmFsaWRhdGVcbiAgICAgKiAgIHRoZSBjZXJ0aWZpY2F0ZSBjaGFpbiBhY2NvcmRpbmcgdG8gUkZDIDUyODAgW1JGQzUyODBdIGFuZCBjb25zaWRlclxuICAgICAqICAgdGhlIGNlcnRpZmljYXRlIG9yIGNlcnRpZmljYXRlIGNoYWluIHRvIGJlIGludmFsaWQgaWYgYW55IHZhbGlkYXRpb25cbiAgICAgKiAgIGZhaWx1cmUgb2NjdXJzLiAgVXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS44XG4gICAgICpcbiAgICAgKiA0LjEuOC4gIFwieDVjXCIgKFguNTA5IENlcnRpZmljYXRlIENoYWluKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJ4NWNcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuNiBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBYLjUwOSBwdWJsaWMga2V5IGNlcnRpZmljYXRlIG9yIGNlcnRpZmljYXRlIGNoYWluIFtSRkM1MjgwXVxuICAgICAqICAgY29udGFpbnMgdGhlIHB1YmxpYyBrZXkgdG8gd2hpY2ggdGhlIEpXRSB3YXMgZW5jcnlwdGVkOyB0aGlzIGNhbiBiZVxuICAgICAqICAgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHByaXZhdGUga2V5IG5lZWRlZCB0byBkZWNyeXB0IHRoZSBKV0UuXG4gICAgICovXG4gICAgeDVjOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIGZvcm1hdDogJ2Jhc2U2NCdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogeDV0XG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS43XG4gICAgICpcbiAgICAgKiA0LjEuNy4gIFwieDV0XCIgKFguNTA5IENlcnRpZmljYXRlIFNIQS0xIFRodW1icHJpbnQpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwieDV0XCIgKFguNTA5IGNlcnRpZmljYXRlIFNIQS0xIHRodW1icHJpbnQpIEhlYWRlciBQYXJhbWV0ZXIgaXMgYVxuICAgICAqICAgYmFzZTY0dXJsLWVuY29kZWQgU0hBLTEgdGh1bWJwcmludCAoYS5rLmEuIGRpZ2VzdCkgb2YgdGhlIERFUlxuICAgICAqICAgZW5jb2Rpbmcgb2YgdGhlIFguNTA5IGNlcnRpZmljYXRlIFtSRkM1MjgwXSBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXlcbiAgICAgKiAgIHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24gdGhlIEpXUy4gIE5vdGUgdGhhdCBjZXJ0aWZpY2F0ZSB0aHVtYnByaW50c1xuICAgICAqICAgYXJlIGFsc28gc29tZXRpbWVzIGtub3duIGFzIGNlcnRpZmljYXRlIGZpbmdlcnByaW50cy4gIFVzZSBvZiB0aGlzXG4gICAgICogICBIZWFkZXIgUGFyYW1ldGVyIGlzIE9QVElPTkFMLlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjlcbiAgICAgKlxuICAgICAqIDQuMS45LiAgXCJ4NXRcIiAoWC41MDkgQ2VydGlmaWNhdGUgU0hBLTEgVGh1bWJwcmludCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwieDV0XCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjcgb2YgW0pXU10sIGV4Y2VwdFxuICAgICAqICAgdGhhdCB0aGUgY2VydGlmaWNhdGUgcmVmZXJlbmNlZCBieSB0aGUgdGh1bWJwcmludCBjb250YWlucyB0aGUgcHVibGljXG4gICAgICogICBrZXkgdG8gd2hpY2ggdGhlIEpXRSB3YXMgZW5jcnlwdGVkOyB0aGlzIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGVcbiAgICAgKiAgIHByaXZhdGUga2V5IG5lZWRlZCB0byBkZWNyeXB0IHRoZSBKV0UuICBOb3RlIHRoYXQgY2VydGlmaWNhdGVcbiAgICAgKiAgIHRodW1icHJpbnRzIGFyZSBhbHNvIHNvbWV0aW1lcyBrbm93biBhcyBjZXJ0aWZpY2F0ZSBmaW5nZXJwcmludHMuXG4gICAgICovXG4gICAgeDV0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGZvcm1hdDogJ2Jhc2U2NHVybCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogeDV0I1MyNTZcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjhcbiAgICAgKlxuICAgICAqIDQuMS44LiAgXCJ4NXQjUzI1NlwiIChYLjUwOSBDZXJ0aWZpY2F0ZSBTSEEtMjU2IFRodW1icHJpbnQpIEhlYWRlclxuICAgICAqICAgICAgICAgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcIng1dCNTMjU2XCIgKFguNTA5IGNlcnRpZmljYXRlIFNIQS0yNTYgdGh1bWJwcmludCkgSGVhZGVyXG4gICAgICogICBQYXJhbWV0ZXIgaXMgYSBiYXNlNjR1cmwtZW5jb2RlZCBTSEEtMjU2IHRodW1icHJpbnQgKGEuay5hLiBkaWdlc3QpXG4gICAgICogICBvZiB0aGUgREVSIGVuY29kaW5nIG9mIHRoZSBYLjUwOSBjZXJ0aWZpY2F0ZSBbUkZDNTI4MF0gY29ycmVzcG9uZGluZ1xuICAgICAqICAgdG8gdGhlIGtleSB1c2VkIHRvIGRpZ2l0YWxseSBzaWduIHRoZSBKV1MuICBOb3RlIHRoYXQgY2VydGlmaWNhdGVcbiAgICAgKiAgIHRodW1icHJpbnRzIGFyZSBhbHNvIHNvbWV0aW1lcyBrbm93biBhcyBjZXJ0aWZpY2F0ZSBmaW5nZXJwcmludHMuXG4gICAgICogICBVc2Ugb2YgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIGlzIE9QVElPTkFMLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuMTBcbiAgICAgKlxuICAgICAqIDQuMS4xMC4gIFwieDV0I1MyNTZcIiAoWC41MDkgQ2VydGlmaWNhdGUgU0hBLTI1NiBUaHVtYnByaW50KSBIZWFkZXJcbiAgICAgKiAgICAgICAgICBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHRoZSBzYW1lIG1lYW5pbmcsIHN5bnRheCwgYW5kIHByb2Nlc3NpbmcgcnVsZXMgYXNcbiAgICAgKiAgIHRoZSBcIng1dCNTMjU2XCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjggb2YgW0pXU10sXG4gICAgICogICBleGNlcHQgdGhhdCB0aGUgY2VydGlmaWNhdGUgcmVmZXJlbmNlZCBieSB0aGUgdGh1bWJwcmludCBjb250YWlucyB0aGVcbiAgICAgKiAgIHB1YmxpYyBrZXkgdG8gd2hpY2ggdGhlIEpXRSB3YXMgZW5jcnlwdGVkOyB0aGlzIGNhbiBiZSB1c2VkIHRvXG4gICAgICogICBkZXRlcm1pbmUgdGhlIHByaXZhdGUga2V5IG5lZWRlZCB0byBkZWNyeXB0IHRoZSBKV0UuICBOb3RlIHRoYXRcbiAgICAgKiAgIGNlcnRpZmljYXRlIHRodW1icHJpbnRzIGFyZSBhbHNvIHNvbWV0aW1lcyBrbm93biBhcyBjZXJ0aWZpY2F0ZVxuICAgICAqICAgZmluZ2VycHJpbnRzLlxuICAgICAqL1xuICAgIC8vJ3g1dCNTMjU2Jzoge1xuICAgIC8vICB0eXBlOiAnc3RyaW5nJyxcbiAgICAvLyAgZm9ybWF0OiAnYmFzZTY0dXJsJ1xuICAgIC8vfSxcblxuICAgIC8qKlxuICAgICAqIGNyaXRcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjExXG4gICAgICpcbiAgICAgKiA0LjEuMTEuICBcImNyaXRcIiAoQ3JpdGljYWwpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwiY3JpdFwiIChjcml0aWNhbCkgSGVhZGVyIFBhcmFtZXRlciBpbmRpY2F0ZXMgdGhhdCBleHRlbnNpb25zIHRvXG4gICAgICogICB0aGlzIHNwZWNpZmljYXRpb24gYW5kL29yIFtKV0FdIGFyZSBiZWluZyB1c2VkIHRoYXQgTVVTVCBiZVxuICAgICAqICAgdW5kZXJzdG9vZCBhbmQgcHJvY2Vzc2VkLiAgSXRzIHZhbHVlIGlzIGFuIGFycmF5IGxpc3RpbmcgdGhlIEhlYWRlclxuICAgICAqICAgUGFyYW1ldGVyIG5hbWVzIHByZXNlbnQgaW4gdGhlIEpPU0UgSGVhZGVyIHRoYXQgdXNlIHRob3NlIGV4dGVuc2lvbnMuXG4gICAgICogICBJZiBhbnkgb2YgdGhlIGxpc3RlZCBleHRlbnNpb24gSGVhZGVyIFBhcmFtZXRlcnMgYXJlIG5vdCB1bmRlcnN0b29kXG4gICAgICogICBhbmQgc3VwcG9ydGVkIGJ5IHRoZSByZWNpcGllbnQsIHRoZW4gdGhlIEpXUyBpcyBpbnZhbGlkLiAgUHJvZHVjZXJzXG4gICAgICogICBNVVNUIE5PVCBpbmNsdWRlIEhlYWRlciBQYXJhbWV0ZXIgbmFtZXMgZGVmaW5lZCBieSB0aGlzIHNwZWNpZmljYXRpb25cbiAgICAgKiAgIG9yIFtKV0FdIGZvciB1c2Ugd2l0aCBKV1MsIGR1cGxpY2F0ZSBuYW1lcywgb3IgbmFtZXMgdGhhdCBkbyBub3RcbiAgICAgKiAgIG9jY3VyIGFzIEhlYWRlciBQYXJhbWV0ZXIgbmFtZXMgd2l0aGluIHRoZSBKT1NFIEhlYWRlciBpbiB0aGUgXCJjcml0XCJcbiAgICAgKiAgIGxpc3QuICBQcm9kdWNlcnMgTVVTVCBOT1QgdXNlIHRoZSBlbXB0eSBsaXN0IFwiW11cIiBhcyB0aGUgXCJjcml0XCJcbiAgICAgKiAgIHZhbHVlLiAgUmVjaXBpZW50cyBNQVkgY29uc2lkZXIgdGhlIEpXUyB0byBiZSBpbnZhbGlkIGlmIHRoZSBjcml0aWNhbFxuICAgICAqICAgbGlzdCBjb250YWlucyBhbnkgSGVhZGVyIFBhcmFtZXRlciBuYW1lcyBkZWZpbmVkIGJ5IHRoaXNcbiAgICAgKiAgIHNwZWNpZmljYXRpb24gb3IgW0pXQV0gZm9yIHVzZSB3aXRoIEpXUyBvciBpZiBhbnkgb3RoZXIgY29uc3RyYWludHNcbiAgICAgKiAgIG9uIGl0cyB1c2UgYXJlIHZpb2xhdGVkLiAgV2hlbiB1c2VkLCB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgTVVTVCBiZVxuICAgICAqICAgaW50ZWdyaXR5IHByb3RlY3RlZDsgdGhlcmVmb3JlLCBpdCBNVVNUIG9jY3VyIG9ubHkgd2l0aGluIHRoZSBKV1NcbiAgICAgKiAgIFByb3RlY3RlZCBIZWFkZXIuICBVc2Ugb2YgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIGlzIE9QVElPTkFMLiAgVGhpc1xuICAgICAqICAgSGVhZGVyIFBhcmFtZXRlciBNVVNUIGJlIHVuZGVyc3Rvb2QgYW5kIHByb2Nlc3NlZCBieSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICpcbiAgICAgKiAgIEFuIGV4YW1wbGUgdXNlLCBhbG9uZyB3aXRoIGEgaHlwb3RoZXRpY2FsIFwiZXhwXCIgKGV4cGlyYXRpb24gdGltZSlcbiAgICAgKiAgIGZpZWxkIGlzOlxuICAgICAqXG4gICAgICogICAgIHtcImFsZ1wiOlwiRVMyNTZcIixcbiAgICAgKiAgICAgXCJjcml0XCI6W1wiZXhwXCJdLFxuICAgICAqICAgICBcImV4cFwiOjEzNjMyODQwMDBcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjEzXG4gICAgICpcbiAgICAgKiAgIDQuMS4xMy4gIFwiY3JpdFwiIChDcml0aWNhbCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwiY3JpdFwiIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS4xMSBvZiBbSldTXSxcbiAgICAgKiAgIGV4Y2VwdCB0aGF0IEhlYWRlciBQYXJhbWV0ZXJzIGZvciBhIEpXRSBhcmUgYmVpbmcgcmVmZXJyZWQgdG8sIHJhdGhlclxuICAgICAqICAgdGhhbiBIZWFkZXIgUGFyYW1ldGVycyBmb3IgYSBKV1MuXG4gICAgICovXG4gICAgY3JpdDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICB9LFxuICAgICAgbWluSXRlbXM6IDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZW5jXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuMlxuICAgICAqXG4gICAgICogNC4xLjIuICBcImVuY1wiIChFbmNyeXB0aW9uIEFsZ29yaXRobSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJlbmNcIiAoZW5jcnlwdGlvbiBhbGdvcml0aG0pIEhlYWRlciBQYXJhbWV0ZXIgaWRlbnRpZmllcyB0aGVcbiAgICAgKiAgIGNvbnRlbnQgZW5jcnlwdGlvbiBhbGdvcml0aG0gdXNlZCB0byBwZXJmb3JtIGF1dGhlbnRpY2F0ZWQgZW5jcnlwdGlvblxuICAgICAqICAgb24gdGhlIHBsYWludGV4dCB0byBwcm9kdWNlIHRoZSBjaXBoZXJ0ZXh0IGFuZCB0aGUgQXV0aGVudGljYXRpb25cbiAgICAgKiAgIFRhZy4gIFRoaXMgYWxnb3JpdGhtIE1VU1QgYmUgYW4gQUVBRCBhbGdvcml0aG0gd2l0aCBhIHNwZWNpZmllZCBrZXlcbiAgICAgKiAgIGxlbmd0aC4gIFRoZSBlbmNyeXB0ZWQgY29udGVudCBpcyBub3QgdXNhYmxlIGlmIHRoZSBcImVuY1wiIHZhbHVlIGRvZXNcbiAgICAgKiAgIG5vdCByZXByZXNlbnQgYSBzdXBwb3J0ZWQgYWxnb3JpdGhtLiAgXCJlbmNcIiB2YWx1ZXMgc2hvdWxkIGVpdGhlciBiZVxuICAgICAqICAgcmVnaXN0ZXJlZCBpbiB0aGUgSUFOQSBcIkpTT04gV2ViIFNpZ25hdHVyZSBhbmQgRW5jcnlwdGlvbiBBbGdvcml0aG1zXCJcbiAgICAgKiAgIHJlZ2lzdHJ5IGVzdGFibGlzaGVkIGJ5IFtKV0FdIG9yIGJlIGEgdmFsdWUgdGhhdCBjb250YWlucyBhXG4gICAgICogICBDb2xsaXNpb24tUmVzaXN0YW50IE5hbWUuICBUaGUgXCJlbmNcIiB2YWx1ZSBpcyBhIGNhc2Utc2Vuc2l0aXZlIEFTQ0lJXG4gICAgICogICBzdHJpbmcgY29udGFpbmluZyBhIFN0cmluZ09yVVJJIHZhbHVlLiAgVGhpcyBIZWFkZXIgUGFyYW1ldGVyIE1VU1QgYmVcbiAgICAgKiAgIHByZXNlbnQgYW5kIE1VU1QgYmUgdW5kZXJzdG9vZCBhbmQgcHJvY2Vzc2VkIGJ5IGltcGxlbWVudGF0aW9ucy5cbiAgICAgKlxuICAgICAqICAgQSBsaXN0IG9mIGRlZmluZWQgXCJlbmNcIiB2YWx1ZXMgZm9yIHRoaXMgdXNlIGNhbiBiZSBmb3VuZCBpbiB0aGUgSUFOQVxuICAgICAqICAgXCJKU09OIFdlYiBTaWduYXR1cmUgYW5kIEVuY3J5cHRpb24gQWxnb3JpdGhtc1wiIHJlZ2lzdHJ5IGVzdGFibGlzaGVkXG4gICAgICogICBieSBbSldBXTsgdGhlIGluaXRpYWwgY29udGVudHMgb2YgdGhpcyByZWdpc3RyeSBhcmUgdGhlIHZhbHVlc1xuICAgICAqICAgZGVmaW5lZCBpbiBTZWN0aW9uIDUuMSBvZiBbSldBXS5cbiAgICAgKi9cbiAgICBlbmM6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnU3RyaW5nT3JVUkknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHppcFxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjNcbiAgICAgKlxuICAgICAqIDQuMS4zLiAgXCJ6aXBcIiAoQ29tcHJlc3Npb24gQWxnb3JpdGhtKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcInppcFwiIChjb21wcmVzc2lvbiBhbGdvcml0aG0pIGFwcGxpZWQgdG8gdGhlIHBsYWludGV4dCBiZWZvcmVcbiAgICAgKiAgIGVuY3J5cHRpb24sIGlmIGFueS4gIFRoZSBcInppcFwiIHZhbHVlIGRlZmluZWQgYnkgdGhpcyBzcGVjaWZpY2F0aW9uXG4gICAgICogICBpczpcbiAgICAgKlxuICAgICAqICAgbyAgXCJERUZcIiAtIENvbXByZXNzaW9uIHdpdGggdGhlIERFRkxBVEUgW1JGQzE5NTFdIGFsZ29yaXRobVxuICAgICAqXG4gICAgICogICBPdGhlciB2YWx1ZXMgTUFZIGJlIHVzZWQuICBDb21wcmVzc2lvbiBhbGdvcml0aG0gdmFsdWVzIGNhbiBiZVxuICAgICAqICAgcmVnaXN0ZXJlZCBpbiB0aGUgSUFOQSBcIkpTT04gV2ViIEVuY3J5cHRpb24gQ29tcHJlc3Npb24gQWxnb3JpdGhtc1wiXG4gICAgICogICByZWdpc3RyeSBlc3RhYmxpc2hlZCBieSBbSldBXS4gIFRoZSBcInppcFwiIHZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmVcbiAgICAgKiAgIHN0cmluZy4gIElmIG5vIFwiemlwXCIgcGFyYW1ldGVyIGlzIHByZXNlbnQsIG5vIGNvbXByZXNzaW9uIGlzIGFwcGxpZWRcbiAgICAgKiAgIHRvIHRoZSBwbGFpbnRleHQgYmVmb3JlIGVuY3J5cHRpb24uICBXaGVuIHVzZWQsIHRoaXMgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqICAgTVVTVCBiZSBpbnRlZ3JpdHkgcHJvdGVjdGVkOyB0aGVyZWZvcmUsIGl0IE1VU1Qgb2NjdXIgb25seSB3aXRoaW4gdGhlXG4gICAgICogICBKV0UgUHJvdGVjdGVkIEhlYWRlci4gIFVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICogICBUaGlzIEhlYWRlciBQYXJhbWV0ZXIgTVVTVCBiZSB1bmRlcnN0b29kIGFuZCBwcm9jZXNzZWQgYnlcbiAgICAgKiAgIGltcGxlbWVudGF0aW9ucy5cbiAgICAgKi9cbiAgICB6aXA6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBKT1NFSGVhZGVyU2NoZW1hO1xuXG4vKioqLyB9KSxcbi8qIDY3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIGJhc2U2NHVybCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xudmFyIEpXQSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KSxcbiAgICBEYXRhRXJyb3IgPSBfcmVxdWlyZS5EYXRhRXJyb3I7XG5cbi8qKlxuICogSldTXG4gKi9cblxuXG52YXIgSldTID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKV1MoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpXUyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSldTLCBudWxsLCBbe1xuICAgIGtleTogJ3NpZ24nLFxuXG5cbiAgICAvKipcbiAgICAgKiBzaWduXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBFbmNvZGUgYSBKV1QgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduKHRva2VuKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IGJhc2U2NHVybChKU09OLnN0cmluZ2lmeSh0b2tlbi5wYXlsb2FkKSk7XG5cbiAgICAgIC8vIGNvbXBhY3Qgc2VyaWFsaXphdGlvblxuICAgICAgaWYgKHRva2VuLnNlcmlhbGl6YXRpb24gPT09ICdjb21wYWN0Jykge1xuICAgICAgICB2YXIga2V5ID0gdG9rZW4ua2V5LFxuICAgICAgICAgICAgYWxnID0gdG9rZW4uaGVhZGVyLmFsZztcblxuICAgICAgICB2YXIgaGVhZGVyID0gYmFzZTY0dXJsKEpTT04uc3RyaW5naWZ5KHRva2VuLmhlYWRlcikpO1xuICAgICAgICB2YXIgZGF0YSA9IGhlYWRlciArICcuJyArIHBheWxvYWQ7XG5cbiAgICAgICAgcmV0dXJuIEpXQS5zaWduKGFsZywga2V5LCBkYXRhKS50aGVuKGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YSArICcuJyArIHNpZ25hdHVyZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEpTT04gc2VyaWFsaXphdGlvblxuICAgICAgaWYgKHRva2VuLnNlcmlhbGl6YXRpb24gPT09ICdqc29uJykge31cblxuICAgICAgLy8gRmxhdHRlbmVkIHNlcmlhbGl6YXRpb25cbiAgICAgIGlmICh0b2tlbi5zZXJpYWxpemF0aW9uID09PSAnZmxhdHRlbmVkJykge31cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBEYXRhRXJyb3IoJ1Vuc3VwcG9ydGVkIHNlcmlhbGl6YXRpb24nKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZlcmlmeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeShqd3QpIHtcbiAgICAgIC8vIG11bHRpcGxlIHNpZ25hdHVyZXNcbiAgICAgIGlmIChqd3Quc2lnbmF0dXJlcykge1xuICAgICAgICAvLyAuLi5cbiAgICAgIH1cblxuICAgICAgdmFyIGtleSA9IGp3dC5rZXksXG4gICAgICAgICAgc2lnbmF0dXJlID0gand0LnNpZ25hdHVyZSxcbiAgICAgICAgICBhbGcgPSBqd3QuaGVhZGVyLmFsZztcblxuICAgICAgLy8gb25lIHNpZ25hdHVyZVxuXG4gICAgICBpZiAoand0LnNpZ25hdHVyZSkge1xuICAgICAgICB2YXIgX2p3dCRzZWdtZW50cyA9IF9zbGljZWRUb0FycmF5KGp3dC5zZWdtZW50cywgMiksXG4gICAgICAgICAgICBoZWFkZXIgPSBfand0JHNlZ21lbnRzWzBdLFxuICAgICAgICAgICAgcGF5bG9hZCA9IF9qd3Qkc2VnbWVudHNbMV07XG5cbiAgICAgICAgdmFyIGRhdGEgPSBoZWFkZXIgKyAnLicgKyBwYXlsb2FkO1xuXG4gICAgICAgIGlmIChhbGcgPT09ICdub25lJykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRGF0YUVycm9yKCdTaWduYXR1cmUgcHJvdmlkZWQgdG8gdmVyaWZ5IHdpdGggYWxnOiBub25lJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpXQS52ZXJpZnkoYWxnLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkudGhlbihmdW5jdGlvbiAodmVyaWZpZWQpIHtcbiAgICAgICAgICBqd3QudmVyaWZpZWQgPSB2ZXJpZmllZDtcbiAgICAgICAgICByZXR1cm4gdmVyaWZpZWQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxnID09PSAnbm9uZScpIHtcbiAgICAgICAgaWYgKCFrZXkgJiYgIXNpZ25hdHVyZSkge1xuICAgICAgICAgIGp3dC52ZXJpZmllZCA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRGF0YUVycm9yKCdLZXkgcHJvdmlkZWQgdG8gdmVyaWZ5IHNpZ25hdHVyZSB3aXRoIGFsZzogbm9uZScpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBubyBzaWduYXR1cmVzIHRvIHZlcmlmeVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBEYXRhRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlKHMpJykpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKV1M7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpXUztcblxuLyoqKi8gfSksXG4vKiA2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oQnVmZmVyKSB7LyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuY29uc3QgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbmNvbnN0IGJhc2U2NHVybCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG5jb25zdCBjcnlwdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcblxuY29uc3Qge1xuICBKV1Rcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxuY29uc3QgRm9ybVVybEVuY29kZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxuY29uc3Qge1xuICBVUkxcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcbi8qKlxuICogQXV0aGVudGljYXRpb24gUmVxdWVzdFxuICovXG5cblxuY2xhc3MgQXV0aGVudGljYXRpb25SZXF1ZXN0IHtcbiAgLyoqXG4gICAqIGNyZWF0ZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlIGEgbmV3IGF1dGhlbnRpY2F0aW9uIHJlcXVlc3Qgd2l0aCBnZW5lcmF0ZWQgc3RhdGUgYW5kIG5vbmNlLFxuICAgKiB2YWxpZGF0ZSBwcmVzZW5jZSBvZiByZXF1aXJlZCBwYXJhbWV0ZXJzLCBzZXJpYWxpemUgdGhlIHJlcXVlc3QgZGF0YSBhbmRcbiAgICogcGVyc2lzdCBpdCB0byB0aGUgc2Vzc2lvbiwgYW5kIHJldHVybiBhIHByb21pc2UgZm9yIGFuIGF1dGhlbnRpY2F0aW9uXG4gICAqIHJlcXVlc3QgVVJJLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlbHlpbmdQYXJ0eX0gcnAg4oCTIGluc3RhbmNlIG9mIFJlbHlpbmdQYXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbmFsIHJlcXVlc3QgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvbiDigJMgcmVmZXJlbmNlIHRvIGxvY2FsU3RvcmFnZSBvciBvdGhlciBzZXNzaW9uIG9iamVjdFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUocnAsIG9wdGlvbnMsIHNlc3Npb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgcmVnaXN0cmF0aW9uXG4gICAgfSA9IHJwO1xuICAgIGxldCBpc3N1ZXIsIGVuZHBvaW50LCBjbGllbnQsIHBhcmFtcztcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAvLyB2YWxpZGF0ZSBwcmVzZW5jZSBvZiBPUCBjb25maWd1cmF0aW9uLCBSUCBjbGllbnQgcmVnaXN0cmF0aW9uLFxuICAgICAgLy8gYW5kIGRlZmF1bHQgcGFyYW1ldGVyc1xuICAgICAgYXNzZXJ0KHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24sICdSZWx5aW5nUGFydHkgcHJvdmlkZXIgT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbWlzc2luZycpO1xuICAgICAgYXNzZXJ0KGRlZmF1bHRzLmF1dGhlbnRpY2F0ZSwgJ1JlbHlpbmdQYXJ0eSBkZWZhdWx0IGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcnKTtcbiAgICAgIGFzc2VydChyZWdpc3RyYXRpb24sICdSZWx5aW5nUGFydHkgY2xpZW50IHJlZ2lzdHJhdGlvbiBpcyBtaXNzaW5nJyk7IC8vIGRlZmluZSBiYXNpYyBlbGVtZW50cyBvZiB0aGUgcmVxdWVzdFxuXG4gICAgICBpc3N1ZXIgPSBwcm92aWRlci5jb25maWd1cmF0aW9uLmlzc3VlcjtcbiAgICAgIGVuZHBvaW50ID0gcHJvdmlkZXIuY29uZmlndXJhdGlvbi5hdXRob3JpemF0aW9uX2VuZHBvaW50O1xuICAgICAgY2xpZW50ID0ge1xuICAgICAgICBjbGllbnRfaWQ6IHJlZ2lzdHJhdGlvbi5jbGllbnRfaWRcbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLmF1dGhlbnRpY2F0ZSwgY2xpZW50LCBvcHRpb25zKTsgLy8gdmFsaWRhdGUgcHJlc2VuY2Ugb2YgcmVxdWlyZWQgY29uZmlndXJhdGlvbiBhbmQgcGFyYW1ldGVyc1xuXG4gICAgICBhc3NlcnQoaXNzdWVyLCAnTWlzc2luZyBpc3N1ZXIgaW4gcHJvdmlkZXIgT3BlbklEIENvbmZpZ3VyYXRpb24nKTtcbiAgICAgIGFzc2VydChlbmRwb2ludCwgJ01pc3NpbmcgYXV0aG9yaXphdGlvbl9lbmRwb2ludCBpbiBwcm92aWRlciBPcGVuSUQgQ29uZmlndXJhdGlvbicpO1xuICAgICAgYXNzZXJ0KHBhcmFtcy5zY29wZSwgJ01pc3Npbmcgc2NvcGUgcGFyYW1ldGVyIGluIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QnKTtcbiAgICAgIGFzc2VydChwYXJhbXMucmVzcG9uc2VfdHlwZSwgJ01pc3NpbmcgcmVzcG9uc2VfdHlwZSBwYXJhbWV0ZXIgaW4gYXV0aGVudGljYXRpb24gcmVxdWVzdCcpO1xuICAgICAgYXNzZXJ0KHBhcmFtcy5jbGllbnRfaWQsICdNaXNzaW5nIGNsaWVudF9pZCBwYXJhbWV0ZXIgaW4gYXV0aGVudGljYXRpb24gcmVxdWVzdCcpO1xuICAgICAgYXNzZXJ0KHBhcmFtcy5yZWRpcmVjdF91cmksICdNaXNzaW5nIHJlZGlyZWN0X3VyaSBwYXJhbWV0ZXIgaW4gYXV0aGVudGljYXRpb24gcmVxdWVzdCcpOyAvLyBnZW5lcmF0ZSBzdGF0ZSBhbmQgbm9uY2UgcmFuZG9tIG9jdGV0c1xuXG4gICAgICBwYXJhbXMuc3RhdGUgPSBBcnJheS5mcm9tKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKSk7XG4gICAgICBwYXJhbXMubm9uY2UgPSBBcnJheS5mcm9tKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKSk7IC8vIGhhc2ggdGhlIHN0YXRlIGFuZCBub25jZSBwYXJhbWV0ZXIgdmFsdWVzXG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbY3J5cHRvLnN1YnRsZS5kaWdlc3Qoe1xuICAgICAgICBuYW1lOiAnU0hBLTI1NidcbiAgICAgIH0sIG5ldyBVaW50OEFycmF5KHBhcmFtcy5zdGF0ZSkpLCBjcnlwdG8uc3VidGxlLmRpZ2VzdCh7XG4gICAgICAgIG5hbWU6ICdTSEEtMjU2J1xuICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkocGFyYW1zLm5vbmNlKSldKTtcbiAgICB9KSAvLyBzZXJpYWxpemUgdGhlIHJlcXVlc3Qgd2l0aCBvcmlnaW5hbCB2YWx1ZXMsIHN0b3JlIGluIHNlc3Npb24gYnlcbiAgICAvLyBlbmNvZGVkIHN0YXRlIHBhcmFtLCBhbmQgcmVwbGFjZSBzdGF0ZS9ub25jZSBvY3RldHMgd2l0aCBlbmNvZGVkXG4gICAgLy8gZGlnZXN0c1xuICAgIC50aGVuKGRpZ2VzdHMgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gYmFzZTY0dXJsKEJ1ZmZlci5mcm9tKGRpZ2VzdHNbMF0pKTtcbiAgICAgIGxldCBub25jZSA9IGJhc2U2NHVybChCdWZmZXIuZnJvbShkaWdlc3RzWzFdKSk7XG4gICAgICBsZXQga2V5ID0gYCR7aXNzdWVyfS9yZXF1ZXN0SGlzdG9yeS8ke3N0YXRlfWA7IC8vIHN0b3JlIHRoZSByZXF1ZXN0IHBhcmFtcyBmb3IgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgLy8gd2l0aCBzZXJpYWxpemVkIG9jdGV0IHZhbHVlcyBmb3Igc3RhdGUgYW5kIG5vbmNlXG5cbiAgICAgIHNlc3Npb25ba2V5XSA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7IC8vIHJlcGxhY2Ugc3RhdGUgYW5kIG5vbmNlIG9jdGV0cyB3aXRoIGJhc2U2NHVybCBlbmNvZGVkIGRpZ2VzdHNcblxuICAgICAgcGFyYW1zLnN0YXRlID0gc3RhdGU7XG4gICAgICBwYXJhbXMubm9uY2UgPSBub25jZTtcbiAgICB9KS50aGVuKCgpID0+IEF1dGhlbnRpY2F0aW9uUmVxdWVzdC5nZW5lcmF0ZVNlc3Npb25LZXlzKCkpLnRoZW4oc2Vzc2lvbktleXMgPT4ge1xuICAgICAgQXV0aGVudGljYXRpb25SZXF1ZXN0LnN0b3JlU2Vzc2lvbktleXMoc2Vzc2lvbktleXMsIHBhcmFtcywgc2Vzc2lvbik7XG4gICAgfSkgLy8gb3B0aW9uYWxseSBlbmNvZGUgYSBKV1Qgd2l0aCB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgLy8gYW5kIHJlcGxhY2UgcGFyYW1zIHdpdGggYHsgcmVxdWVzdDogPGp3dD4gfVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmIChwcm92aWRlci5jb25maWd1cmF0aW9uLnJlcXVlc3RfcGFyYW1ldGVyX3N1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm4gQXV0aGVudGljYXRpb25SZXF1ZXN0LmVuY29kZVJlcXVlc3RQYXJhbXMocGFyYW1zKS50aGVuKGVuY29kZWRQYXJhbXMgPT4ge1xuICAgICAgICAgIHBhcmFtcyA9IGVuY29kZWRQYXJhbXM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pIC8vIHJlbmRlciB0aGUgcmVxdWVzdCBVUkkgYW5kIHRlcm1pbmF0ZSB0aGUgYWxnb3JpdGhtXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwoZW5kcG9pbnQpO1xuICAgICAgdXJsLnNlYXJjaCA9IEZvcm1VcmxFbmNvZGVkLmVuY29kZShwYXJhbXMpO1xuICAgICAgcmV0dXJuIHVybC5ocmVmO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdlbmVyYXRlU2Vzc2lvbktleXMoKSB7XG4gICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoe1xuICAgICAgbmFtZTogXCJSU0FTU0EtUEtDUzEtdjFfNVwiLFxuICAgICAgbW9kdWx1c0xlbmd0aDogMjA0OCxcbiAgICAgIHB1YmxpY0V4cG9uZW50OiBuZXcgVWludDhBcnJheShbMHgwMSwgMHgwMCwgMHgwMV0pLFxuICAgICAgaGFzaDoge1xuICAgICAgICBuYW1lOiBcIlNIQS0yNTZcIlxuICAgICAgfVxuICAgIH0sIHRydWUsIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl0pLnRoZW4oa2V5UGFpciA9PiB7XG4gICAgICAvLyByZXR1cm5zIGEga2V5cGFpciBvYmplY3RcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ2p3aycsIGtleVBhaXIucHVibGljS2V5KSwgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ2p3aycsIGtleVBhaXIucHJpdmF0ZUtleSldKTtcbiAgICB9KS50aGVuKGp3a1BhaXIgPT4ge1xuICAgICAgbGV0IFtwdWJsaWNKd2ssIHByaXZhdGVKd2tdID0gandrUGFpcjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHB1YmxpYzogcHVibGljSndrLFxuICAgICAgICBwcml2YXRlOiBwcml2YXRlSndrXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIHN0b3JlU2Vzc2lvbktleXMoc2Vzc2lvbktleXMsIHBhcmFtcywgc2Vzc2lvbikge1xuICAgIC8vIHN0b3JlIHRoZSBwcml2YXRlIG9uZSBpbiBzZXNzaW9uLCBwdWJsaWMgb25lIGdvZXMgaW50byBwYXJhbXNcbiAgICBzZXNzaW9uWydvaWRjLnNlc3Npb24ucHJpdmF0ZUtleSddID0gSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbktleXMucHJpdmF0ZSk7XG4gICAgcGFyYW1zLmtleSA9IHNlc3Npb25LZXlzLnB1YmxpYztcbiAgfVxuXG4gIHN0YXRpYyBlbmNvZGVSZXF1ZXN0UGFyYW1zKHBhcmFtcykge1xuICAgIGNvbnN0IGV4Y2x1ZGVQYXJhbXMgPSBbJ3Njb3BlJywgJ2NsaWVudF9pZCcsICdyZXNwb25zZV90eXBlJywgJ3N0YXRlJ107XG4gICAgY29uc3Qga2V5c1RvRW5jb2RlID0gT2JqZWN0LmtleXMocGFyYW1zKS5maWx0ZXIoa2V5ID0+ICFleGNsdWRlUGFyYW1zLmluY2x1ZGVzKGtleSkpO1xuICAgIGxldCBwYXlsb2FkID0ge307XG4gICAga2V5c1RvRW5jb2RlLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHBheWxvYWRba2V5XSA9IHBhcmFtc1trZXldO1xuICAgIH0pO1xuICAgIGxldCByZXF1ZXN0UGFyYW1Kd3QgPSBuZXcgSldUKHtcbiAgICAgIGhlYWRlcjoge1xuICAgICAgICBhbGc6ICdub25lJ1xuICAgICAgfSxcbiAgICAgIHBheWxvYWRcbiAgICB9LCB7XG4gICAgICBmaWx0ZXI6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcXVlc3RQYXJhbUp3dC5lbmNvZGUoKS50aGVuKHJlcXVlc3RQYXJhbUNvbXBhY3QgPT4ge1xuICAgICAgbGV0IG5ld1BhcmFtcyA9IHtcbiAgICAgICAgc2NvcGU6IHBhcmFtc1snc2NvcGUnXSxcbiAgICAgICAgY2xpZW50X2lkOiBwYXJhbXNbJ2NsaWVudF9pZCddLFxuICAgICAgICByZXNwb25zZV90eXBlOiBwYXJhbXNbJ3Jlc3BvbnNlX3R5cGUnXSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFBhcmFtQ29tcGFjdCxcbiAgICAgICAgc3RhdGU6IHBhcmFtc1snc3RhdGUnXVxuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfSk7XG4gIH1cblxufVxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aGVudGljYXRpb25SZXF1ZXN0O1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNDEpLkJ1ZmZlcikpXG5cbi8qKiovIH0pLFxuLyogNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuXG4vKipcbiAqIEZvcm1VcmxFbmNvZGVkXG4gKi9cbmNsYXNzIEZvcm1VcmxFbmNvZGVkIHtcbiAgLyoqXG4gICAqIEVuY29kZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVwcmVzZW50IGFuIG9iamVjdCBhcyB4LXd3dy1mb3JtLXVybGVuY29kZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGVuY29kZShkYXRhKSB7XG4gICAgbGV0IHBhaXJzID0gW107XG4gICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFba2V5XSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG4gIH1cbiAgLyoqXG4gICAqIERlY29kZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUGFyc2UgYSB4LXd3dy1mb3JtLXVybGVuY29kZWQgaW50byBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuXG5cbiAgc3RhdGljIGRlY29kZShkYXRhKSB7XG4gICAgbGV0IG9iaiA9IHt9O1xuICAgIGRhdGEuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgbGV0IHBhaXIgPSBwcm9wZXJ0eS5zcGxpdCgnPScpO1xuICAgICAgbGV0IGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKTtcbiAgICAgIGxldCB2YWwgPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbn1cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1VcmxFbmNvZGVkO1xuXG4vKioqLyB9KSxcbi8qIDcwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwsIEJ1ZmZlcikgey8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbmNvbnN0IHtcbiAgVVJMXG59ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbmNvbnN0IGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5jb25zdCBjcnlwdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcblxuY29uc3QgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbmNvbnN0IGZldGNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuY29uc3QgSGVhZGVycyA9IGZldGNoLkhlYWRlcnMgPyBmZXRjaC5IZWFkZXJzIDogZ2xvYmFsLkhlYWRlcnM7XG5cbmNvbnN0IEZvcm1VcmxFbmNvZGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG5cbmNvbnN0IElEVG9rZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuY29uc3QgU2Vzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG5jb25zdCBvbkh0dHBFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5jb25zdCBIdHRwRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcbi8qKlxuICogQXV0aGVudGljYXRpb25SZXNwb25zZVxuICovXG5cblxuY2xhc3MgQXV0aGVudGljYXRpb25SZXNwb25zZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcnAge1JlbHlpbmdQYXJ0eX1cbiAgICogQHBhcmFtIFtyZWRpcmVjdF0ge3N0cmluZ30gcmVxLnF1ZXJ5XG4gICAqIEBwYXJhbSBbYm9keV0ge3N0cmluZ30gcmVxLmJvZHkudGV4dFxuICAgKiBAcGFyYW0gc2Vzc2lvbiB7U2Vzc2lvbnxTdG9yYWdlfSByZXEuc2Vzc2lvbiBvciBsb2NhbFN0b3JhZ2Ugb3Igc2ltaWxhclxuICAgKiBAcGFyYW0gcGFyYW1zIHtvYmplY3R9IGhhc2htYXBcbiAgICogQHBhcmFtIG1vZGUge3N0cmluZ30gJ3F1ZXJ5Jy8nZnJhZ21lbnQnLydmb3JtX3Bvc3QnLFxuICAgKiAgIGRldGVybWluZWQgaW4gYHBhcnNlUmVzcG9uc2UoKWBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBycCxcbiAgICByZWRpcmVjdCxcbiAgICBib2R5LFxuICAgIHNlc3Npb24sXG4gICAgbW9kZSxcbiAgICBwYXJhbXMgPSB7fVxuICB9KSB7XG4gICAgdGhpcy5ycCA9IHJwO1xuICAgIHRoaXMucmVkaXJlY3QgPSByZWRpcmVjdDtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVSZXNwb25zZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQXV0aGVudGljYXRpb24gcmVzcG9uc2UgdmFsaWRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSByZXNwb25zZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXNzaW9uPn1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpLnRoZW4odGhpcy5wYXJzZVJlc3BvbnNlKS50aGVuKHRoaXMuZXJyb3JSZXNwb25zZSkudGhlbih0aGlzLm1hdGNoUmVxdWVzdCkudGhlbih0aGlzLnZhbGlkYXRlU3RhdGVQYXJhbSkudGhlbih0aGlzLnZhbGlkYXRlUmVzcG9uc2VNb2RlKS50aGVuKHRoaXMudmFsaWRhdGVSZXNwb25zZVBhcmFtcykudGhlbih0aGlzLmV4Y2hhbmdlQXV0aG9yaXphdGlvbkNvZGUpLnRoZW4odGhpcy52YWxpZGF0ZUlEVG9rZW4pLnRoZW4oU2Vzc2lvbi5mcm9tQXV0aFJlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogcGFyc2VSZXNwb25zZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2VcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG5cblxuICBzdGF0aWMgcGFyc2VSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGxldCB7XG4gICAgICByZWRpcmVjdCxcbiAgICAgIGJvZHlcbiAgICB9ID0gcmVzcG9uc2U7IC8vIHJlc3BvbnNlIG11c3QgYmUgZWl0aGVyIGEgcmVkaXJlY3QgdXJpIG9yIHJlcXVlc3QgYm9keSwgYnV0IG5vdCBib3RoXG5cbiAgICBpZiAocmVkaXJlY3QgJiYgYm9keSB8fCAhcmVkaXJlY3QgJiYgIWJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IoNDAwLCAnSW52YWxpZCByZXNwb25zZSBtb2RlJyk7XG4gICAgfSAvLyBwYXJzZSByZWRpcmVjdCB1cmlcblxuXG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZWRpcmVjdCk7XG4gICAgICBsZXQge1xuICAgICAgICBzZWFyY2gsXG4gICAgICAgIGhhc2hcbiAgICAgIH0gPSB1cmw7XG5cbiAgICAgIGlmIChzZWFyY2ggJiYgaGFzaCB8fCAhc2VhcmNoICYmICFoYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IoNDAwLCAnSW52YWxpZCByZXNwb25zZSBtb2RlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2gpIHtcbiAgICAgICAgcmVzcG9uc2UucGFyYW1zID0gRm9ybVVybEVuY29kZWQuZGVjb2RlKHNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICByZXNwb25zZS5tb2RlID0gJ3F1ZXJ5JztcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc2gpIHtcbiAgICAgICAgcmVzcG9uc2UucGFyYW1zID0gRm9ybVVybEVuY29kZWQuZGVjb2RlKGhhc2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgcmVzcG9uc2UubW9kZSA9ICdmcmFnbWVudCc7XG4gICAgICB9XG4gICAgfSAvLyBwYXJzZSByZXF1ZXN0IGZvcm0gYm9keVxuXG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgcmVzcG9uc2UucGFyYW1zID0gRm9ybVVybEVuY29kZWQuZGVjb2RlKGJvZHkpO1xuICAgICAgcmVzcG9uc2UubW9kZSA9ICdmb3JtX3Bvc3QnO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogZXJyb3JSZXNwb25zZVxuICAgKlxuICAgKiBAcGFyYW0ge0F1dGhlbnRpY2F0aW9uUmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiByZXNwb25zZSBwYXJhbXMgaW5jbHVkZSB0aGUgT0F1dGgyICdlcnJvcicgcGFyYW0sXG4gICAqICAgdGhyb3dzIGFuIGVycm9yIGJhc2VkIG9uIGl0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXV0aGVudGljYXRpb25SZXNwb25zZX0gQ2hhaW5hYmxlXG4gICAqXG4gICAqIEB0b2RvIEZpZ3VyZSBvdXQgSFRUUCBzdGF0dXMgY29kZSAodHlwaWNhbGx5IDQwMCwgNDAxIG9yIDQwMylcbiAgICogICBiYXNlZCBvbiB0aGUgT0F1dGgyL09JREMgYGVycm9yYCBjb2RlLCBwcm9iYWJseSB1c2luZyBhbiBleHRlcm5hbCBsaWJyYXJ5XG4gICAqL1xuXG5cbiAgc3RhdGljIGVycm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBjb25zdCBlcnJvckNvZGUgPSByZXNwb25zZS5wYXJhbXMuZXJyb3I7XG5cbiAgICBpZiAoZXJyb3JDb2RlKSB7XG4gICAgICBjb25zdCBlcnJvclBhcmFtcyA9IHt9O1xuICAgICAgZXJyb3JQYXJhbXNbJ2Vycm9yJ10gPSBlcnJvckNvZGU7XG4gICAgICBlcnJvclBhcmFtc1snZXJyb3JfZGVzY3JpcHRpb24nXSA9IHJlc3BvbnNlLnBhcmFtc1snZXJyb3JfZGVzY3JpcHRpb24nXTtcbiAgICAgIGVycm9yUGFyYW1zWydlcnJvcl91cmknXSA9IHJlc3BvbnNlLnBhcmFtc1snZXJyb3JfdXJpJ107XG4gICAgICBlcnJvclBhcmFtc1snc3RhdGUnXSA9IHJlc3BvbnNlLnBhcmFtc1snc3RhdGUnXTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBBdXRoZW50aWNhdGlvblJlc3BvbnNlIGVycm9yOiAke2Vycm9yQ29kZX1gKTtcbiAgICAgIGVycm9yLmluZm8gPSBlcnJvclBhcmFtcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogbWF0Y2hSZXF1ZXN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgbWF0Y2hSZXF1ZXN0KHJlc3BvbnNlKSB7XG4gICAgbGV0IHtcbiAgICAgIHJwLFxuICAgICAgcGFyYW1zLFxuICAgICAgc2Vzc2lvblxuICAgIH0gPSByZXNwb25zZTtcbiAgICBsZXQgc3RhdGUgPSBwYXJhbXMuc3RhdGU7XG4gICAgbGV0IGlzc3VlciA9IHJwLnByb3ZpZGVyLmNvbmZpZ3VyYXRpb24uaXNzdWVyO1xuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHN0YXRlIHBhcmFtZXRlciBpbiBhdXRoZW50aWNhdGlvbiByZXNwb25zZScpO1xuICAgIH1cblxuICAgIGxldCBrZXkgPSBgJHtpc3N1ZXJ9L3JlcXVlc3RIaXN0b3J5LyR7c3RhdGV9YDtcbiAgICBsZXQgcmVxdWVzdCA9IHNlc3Npb25ba2V5XTtcblxuICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBzdGF0ZSBwYXJhbWV0ZXIgaW4gYXV0aGVudGljYXRpb24gcmVzcG9uc2UnKTtcbiAgICB9XG5cbiAgICByZXNwb25zZS5yZXF1ZXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlU3RhdGVQYXJhbVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZhbGlkYXRlU3RhdGVQYXJhbShyZXNwb25zZSkge1xuICAgIGxldCBvY3RldHMgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5yZXF1ZXN0LnN0YXRlKTtcbiAgICBsZXQgZW5jb2RlZCA9IHJlc3BvbnNlLnBhcmFtcy5zdGF0ZTtcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kaWdlc3Qoe1xuICAgICAgbmFtZTogJ1NIQS0yNTYnXG4gICAgfSwgb2N0ZXRzKS50aGVuKGRpZ2VzdCA9PiB7XG4gICAgICBpZiAoZW5jb2RlZCAhPT0gYmFzZTY0dXJsKEJ1ZmZlci5mcm9tKGRpZ2VzdCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hpbmcgc3RhdGUgcGFyYW1ldGVyIGluIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVSZXNwb25zZU1vZGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZVJlc3BvbnNlTW9kZShyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5yZXF1ZXN0LnJlc3BvbnNlX3R5cGUgIT09ICdjb2RlJyAmJiByZXNwb25zZS5tb2RlID09PSAncXVlcnknKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgbW9kZScpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVSZXNwb25zZVBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZhbGlkYXRlUmVzcG9uc2VQYXJhbXMocmVzcG9uc2UpIHtcbiAgICBsZXQge1xuICAgICAgcmVxdWVzdCxcbiAgICAgIHBhcmFtc1xuICAgIH0gPSByZXNwb25zZTtcbiAgICBsZXQgZXhwZWN0ZWRQYXJhbXMgPSByZXF1ZXN0LnJlc3BvbnNlX3R5cGUuc3BsaXQoJyAnKTtcblxuICAgIGlmIChleHBlY3RlZFBhcmFtcy5pbmNsdWRlcygnY29kZScpKSB7XG4gICAgICBhc3NlcnQocGFyYW1zLmNvZGUsICdNaXNzaW5nIGF1dGhvcml6YXRpb24gY29kZSBpbiBhdXRoZW50aWNhdGlvbiByZXNwb25zZScpOyAvLyBUT0RPIGFzc2VydCBub3ZlbHR5IG9mIGNvZGVcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0ZWRQYXJhbXMuaW5jbHVkZXMoJ2lkX3Rva2VuJykpIHtcbiAgICAgIGFzc2VydChwYXJhbXMuaWRfdG9rZW4sICdNaXNzaW5nIGlkX3Rva2VuIGluIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlJyk7XG4gICAgfVxuXG4gICAgaWYgKGV4cGVjdGVkUGFyYW1zLmluY2x1ZGVzKCd0b2tlbicpKSB7XG4gICAgICBhc3NlcnQocGFyYW1zLmFjY2Vzc190b2tlbiwgJ01pc3NpbmcgYWNjZXNzX3Rva2VuIGluIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlJyk7XG4gICAgICBhc3NlcnQocGFyYW1zLnRva2VuX3R5cGUsICdNaXNzaW5nIHRva2VuX3R5cGUgaW4gYXV0aGVudGljYXRpb24gcmVzcG9uc2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIGV4Y2hhbmdlQXV0aG9yaXphdGlvbkNvZGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSByZXNwb25zZSBvYmplY3RcbiAgICovXG5cblxuICBzdGF0aWMgZXhjaGFuZ2VBdXRob3JpemF0aW9uQ29kZShyZXNwb25zZSkge1xuICAgIGxldCB7XG4gICAgICBycCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJlcXVlc3RcbiAgICB9ID0gcmVzcG9uc2U7XG4gICAgbGV0IGNvZGUgPSBwYXJhbXMuY29kZTsgLy8gb25seSBleGNoYW5nZSB0aGUgYXV0aG9yaXphdGlvbiBjb2RlIHdoZW4gdGhlIHJlc3BvbnNlIHR5cGUgaXMgXCJjb2RlXCJcblxuICAgIGlmICghY29kZSB8fCByZXF1ZXN0WydyZXNwb25zZV90eXBlJ10gIT09ICdjb2RlJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgbGV0IHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgcmVnaXN0cmF0aW9uXG4gICAgfSA9IHJwO1xuICAgIGxldCBpZCA9IHJlZ2lzdHJhdGlvblsnY2xpZW50X2lkJ107XG4gICAgbGV0IHNlY3JldCA9IHJlZ2lzdHJhdGlvblsnY2xpZW50X3NlY3JldCddOyAvLyB2ZXJpZnkgdGhlIGNsaWVudCBpcyBub3QgcHVibGljXG5cbiAgICBpZiAoIXNlY3JldCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ2xpZW50IGNhbm5vdCBleGNoYW5nZSBhdXRob3JpemF0aW9uIGNvZGUgYmVjYXVzZSAnICsgJ2l0IGlzIG5vdCBhIGNvbmZpZGVudGlhbCBjbGllbnQnKSk7XG4gICAgfSAvLyBpbml0aWFsaXplIHRva2VuIHJlcXVlc3QgYXJndW1lbnRzXG5cblxuICAgIGxldCBlbmRwb2ludCA9IHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24udG9rZW5fZW5kcG9pbnQ7XG4gICAgbGV0IG1ldGhvZCA9ICdQT1NUJzsgLy8gaW5pdGlhbGl6ZSBoZWFkZXJzXG5cbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgIH0pOyAvLyBpbml0aWFsaXplIHRoZSB0b2tlbiByZXF1ZXN0IHBhcmFtZXRlcnNcblxuICAgIGxldCBib2R5Q29udGVudHMgPSB7XG4gICAgICAnZ3JhbnRfdHlwZSc6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgJ2NvZGUnOiBjb2RlLFxuICAgICAgJ3JlZGlyZWN0X3VyaSc6IHJlcXVlc3RbJ3JlZGlyZWN0X3VyaSddIC8vIGRldGVybWluZSBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kXG5cbiAgICB9O1xuICAgIGxldCBhdXRoTWV0aG9kID0gcmVnaXN0cmF0aW9uWyd0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCddIHx8ICdjbGllbnRfc2VjcmV0X2Jhc2ljJzsgLy8gY2xpZW50IHNlY3JldCBiYXNpYyBhdXRoZW50aWNhdGlvblxuXG4gICAgaWYgKGF1dGhNZXRob2QgPT09ICdjbGllbnRfc2VjcmV0X2Jhc2ljJykge1xuICAgICAgbGV0IGNyZWRlbnRpYWxzID0gbmV3IEJ1ZmZlcihgJHtpZH06JHtzZWNyZXR9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmFzaWMgJHtjcmVkZW50aWFsc31gKTtcbiAgICB9IC8vIGNsaWVudCBzZWNyZXQgcG9zdCBhdXRoZW50aWNhdGlvblxuXG5cbiAgICBpZiAoYXV0aE1ldGhvZCA9PT0gJ2NsaWVudF9zZWNyZXRfcG9zdCcpIHtcbiAgICAgIGJvZHlDb250ZW50c1snY2xpZW50X2lkJ10gPSBpZDtcbiAgICAgIGJvZHlDb250ZW50c1snY2xpZW50X3NlY3JldCddID0gc2VjcmV0O1xuICAgIH1cblxuICAgIGxldCBib2R5ID0gRm9ybVVybEVuY29kZWQuZW5jb2RlKGJvZHlDb250ZW50cyk7IC8vIFRPRE9cbiAgICAvLyBjbGllbnRfc2VjcmV0X2p3dCBhdXRoZW50aWNhdGlvblxuICAgIC8vIHByaXZhdGVfa2V5X2p3dFxuICAgIC8vIG1ha2UgdGhlIHRva2VuIHJlcXVlc3RcblxuICAgIHJldHVybiBmZXRjaChlbmRwb2ludCwge1xuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICB9KS50aGVuKG9uSHR0cEVycm9yKCdFcnJvciBleGNoYW5naW5nIGF1dGhvcml6YXRpb24gY29kZScpKS50aGVuKHRva2VuUmVzcG9uc2UgPT4gdG9rZW5SZXNwb25zZS5qc29uKCkpLnRoZW4odG9rZW5SZXNwb25zZSA9PiB7XG4gICAgICBhc3NlcnQodG9rZW5SZXNwb25zZVsnYWNjZXNzX3Rva2VuJ10sICdNaXNzaW5nIGFjY2Vzc190b2tlbiBpbiB0b2tlbiByZXNwb25zZScpO1xuICAgICAgYXNzZXJ0KHRva2VuUmVzcG9uc2VbJ3Rva2VuX3R5cGUnXSwgJ01pc3NpbmcgdG9rZW5fdHlwZSBpbiB0b2tlbiByZXNwb25zZScpO1xuICAgICAgYXNzZXJ0KHRva2VuUmVzcG9uc2VbJ2lkX3Rva2VuJ10sICdNaXNzaW5nIGlkX3Rva2VuIGluIHRva2VuIHJlc3BvbnNlJyk7IC8vIGFueXRoaW5nIGVsc2U/XG4gICAgICAvLyBJUyBUSElTIFRIRSBSSUdIVCBUSElORyBUTyBETyBIRVJFP1xuXG4gICAgICByZXNwb25zZS5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHJlc3BvbnNlLnBhcmFtcywgdG9rZW5SZXNwb25zZSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlSURUb2tlblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZhbGlkYXRlSURUb2tlbihyZXNwb25zZSkge1xuICAgIC8vIG9ubHkgdmFsaWRhdGUgdGhlIElEIFRva2VuIGlmIHByZXNlbnQgaW4gdGhlIHJlc3BvbnNlXG4gICAgaWYgKCFyZXNwb25zZS5wYXJhbXMuaWRfdG9rZW4pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpLnRoZW4oQXV0aGVudGljYXRpb25SZXNwb25zZS5kZWNyeXB0SURUb2tlbikudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLmRlY29kZUlEVG9rZW4pLnRoZW4oQXV0aGVudGljYXRpb25SZXNwb25zZS52YWxpZGF0ZUlzc3VlcikudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlQXVkaWVuY2UpLnRoZW4oQXV0aGVudGljYXRpb25SZXNwb25zZS5yZXNvbHZlS2V5cykudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZlcmlmeVNpZ25hdHVyZSkudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlRXhwaXJlcykudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZlcmlmeU5vbmNlKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmFsaWRhdGVBY3IpLnRoZW4oQXV0aGVudGljYXRpb25SZXNwb25zZS52YWxpZGF0ZUF1dGhUaW1lKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmFsaWRhdGVBY2Nlc3NUb2tlbkhhc2gpLnRoZW4oQXV0aGVudGljYXRpb25SZXNwb25zZS52YWxpZGF0ZUF1dGhvcml6YXRpb25Db2RlSGFzaCk7XG4gIH1cbiAgLyoqXG4gICAqIGRlY3J5cHRJRFRva2VuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgZGVjcnlwdElEVG9rZW4ocmVzcG9uc2UpIHtcbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gIH1cbiAgLyoqXG4gICAqIGRlY29kZUlEVG9rZW5cbiAgICpcbiAgICogTm90ZTogSWYgdGhlIGBpZF90b2tlbmAgaXMgbm90IHByZXNlbnQgaW4gcGFyYW1zLCB0aGlzIG1ldGhvZCBkb2VzIG5vdFxuICAgKiBnZXQgY2FsbGVkIChzaG9ydC1jaXJjdWl0ZWQgaW4gYHZhbGlkYXRlSURUb2tlbigpYCkuXG4gICAqXG4gICAqIEBwYXJhbSByZXNwb25zZSB7QXV0aGVudGljYXRpb25SZXNwb25zZX1cbiAgICogQHBhcmFtIHJlc3BvbnNlLnBhcmFtcyB7b2JqZWN0fVxuICAgKiBAcGFyYW0gW3Jlc3BvbnNlLnBhcmFtcy5pZF90b2tlbl0ge3N0cmluZ30gSURUb2tlbiBlbmNvZGVkIGFzIGEgSldUXG4gICAqXG4gICAqIEByZXR1cm5zIHtBdXRoZW50aWNhdGlvblJlc3BvbnNlfSBDaGFpbmFibGVcbiAgICovXG5cblxuICBzdGF0aWMgZGVjb2RlSURUb2tlbihyZXNwb25zZSkge1xuICAgIGxldCBqd3QgPSByZXNwb25zZS5wYXJhbXMuaWRfdG9rZW47XG5cbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UuZGVjb2RlZCA9IElEVG9rZW4uZGVjb2RlKGp3dCk7XG4gICAgfSBjYXRjaCAoZGVjb2RlRXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEh0dHBFcnJvcig0MDAsICdFcnJvciBkZWNvZGluZyBJRCBUb2tlbicpO1xuICAgICAgZXJyb3IuY2F1c2UgPSBkZWNvZGVFcnJvcjtcbiAgICAgIGVycm9yLmluZm8gPSB7XG4gICAgICAgIGlkX3Rva2VuOiBqd3RcbiAgICAgIH07XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlSXNzdWVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVJc3N1ZXIocmVzcG9uc2UpIHtcbiAgICBsZXQgY29uZmlndXJhdGlvbiA9IHJlc3BvbnNlLnJwLnByb3ZpZGVyLmNvbmZpZ3VyYXRpb247XG4gICAgbGV0IHBheWxvYWQgPSByZXNwb25zZS5kZWNvZGVkLnBheWxvYWQ7IC8vIHZhbGlkYXRlIGlzc3VlciBvZiB0b2tlbiBtYXRjaGVzIHRoaXMgcmVseWluZyBwYXJ0eSdzIHByb3ZpZGVyXG5cbiAgICBpZiAocGF5bG9hZC5pc3MgIT09IGNvbmZpZ3VyYXRpb24uaXNzdWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc21hdGNoaW5nIGlzc3VlciBpbiBJRCBUb2tlbicpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVBdWRpZW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZhbGlkYXRlQXVkaWVuY2UocmVzcG9uc2UpIHtcbiAgICBsZXQgcmVnaXN0cmF0aW9uID0gcmVzcG9uc2UucnAucmVnaXN0cmF0aW9uO1xuICAgIGxldCB7XG4gICAgICBhdWQsXG4gICAgICBhenBcbiAgICB9ID0gcmVzcG9uc2UuZGVjb2RlZC5wYXlsb2FkOyAvLyB2YWxpZGF0ZSBhdWRpZW5jZSBpbmNsdWRlcyB0aGlzIHJlbHlpbmcgcGFydHlcblxuICAgIGlmICh0eXBlb2YgYXVkID09PSAnc3RyaW5nJyAmJiBhdWQgIT09IHJlZ2lzdHJhdGlvblsnY2xpZW50X2lkJ10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hpbmcgYXVkaWVuY2UgaW4gaWRfdG9rZW4nKTtcbiAgICB9IC8vIHZhbGlkYXRlIGF1ZGllbmNlIGluY2x1ZGVzIHRoaXMgcmVseWluZyBwYXJ0eVxuXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhdWQpICYmICFhdWQuaW5jbHVkZXMocmVnaXN0cmF0aW9uWydjbGllbnRfaWQnXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hpbmcgYXVkaWVuY2UgaW4gaWRfdG9rZW4nKTtcbiAgICB9IC8vIHZhbGlkYXRlIGF1dGhvcml6ZWQgcGFydHkgaXMgcHJlc2VudCBpZiByZXF1aXJlZFxuXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhdWQpICYmICFhenApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhenAgY2xhaW0gaW4gaWRfdG9rZW4nKTtcbiAgICB9IC8vIHZhbGlkYXRlIGF1dGhvcml6ZWQgcGFydHkgaXMgdGhpcyByZWx5aW5nIHBhcnR5XG5cblxuICAgIGlmIChhenAgJiYgYXpwICE9PSByZWdpc3RyYXRpb25bJ2NsaWVudF9pZCddKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc21hdGNoaW5nIGF6cCBjbGFpbSBpbiBpZF90b2tlbicpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogcmVzb2x2ZUtleXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyByZXNvbHZlS2V5cyhyZXNwb25zZSkge1xuICAgIGxldCBycCA9IHJlc3BvbnNlLnJwO1xuICAgIGxldCBwcm92aWRlciA9IHJwLnByb3ZpZGVyO1xuICAgIGxldCBkZWNvZGVkID0gcmVzcG9uc2UuZGVjb2RlZDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb3ZpZGVyLmp3a3MpLnRoZW4oandrcyA9PiBqd2tzID8gandrcyA6IHJwLmp3a3MoKSkudGhlbihqd2tzID0+IHtcbiAgICAgIGlmIChkZWNvZGVkLnJlc29sdmVLZXlzKGp3a3MpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzb2x2ZSBzaWduaW5nIGtleSBmb3IgSUQgVG9rZW4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogdmVyaWZ5U2lnbmF0dXJlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmVyaWZ5U2lnbmF0dXJlKHJlc3BvbnNlKSB7XG4gICAgbGV0IGFsZyA9IHJlc3BvbnNlLmRlY29kZWQuaGVhZGVyLmFsZztcbiAgICBsZXQgcmVnaXN0cmF0aW9uID0gcmVzcG9uc2UucnAucmVnaXN0cmF0aW9uO1xuICAgIGxldCBleHBlY3RlZEFsZ29yaXRobSA9IHJlZ2lzdHJhdGlvblsnaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZyddIHx8ICdSUzI1Nic7IC8vIHZhbGlkYXRlIHNpZ25pbmcgYWxnb3JpdGhtIG1hdGNoZXMgZXhwZWN0YXRpb25cblxuICAgIGlmIChhbGcgIT09IGV4cGVjdGVkQWxnb3JpdGhtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIElEIFRva2VuIHRvIGJlIHNpZ25lZCB3aXRoICR7ZXhwZWN0ZWRBbGdvcml0aG19YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRlY29kZWQudmVyaWZ5KCkudGhlbih2ZXJpZmllZCA9PiB7XG4gICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJRCBUb2tlbiBzaWduYXR1cmUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZUV4cGlyZXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZUV4cGlyZXMocmVzcG9uc2UpIHtcbiAgICBsZXQgZXhwID0gcmVzcG9uc2UuZGVjb2RlZC5wYXlsb2FkLmV4cDsgLy8gdmFsaWRhdGUgZXhwaXJhdGlvbiBvZiB0b2tlblxuXG4gICAgaWYgKGV4cCA8PSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBpcmVkIElEIFRva2VuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiB2ZXJpZnlOb25jZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZlcmlmeU5vbmNlKHJlc3BvbnNlKSB7XG4gICAgbGV0IG9jdGV0cyA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLnJlcXVlc3Qubm9uY2UpO1xuICAgIGxldCBub25jZSA9IHJlc3BvbnNlLmRlY29kZWQucGF5bG9hZC5ub25jZTtcblxuICAgIGlmICghbm9uY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBub25jZSBpbiBJRCBUb2tlbicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRpZ2VzdCh7XG4gICAgICBuYW1lOiAnU0hBLTI1NidcbiAgICB9LCBvY3RldHMpLnRoZW4oZGlnZXN0ID0+IHtcbiAgICAgIGlmIChub25jZSAhPT0gYmFzZTY0dXJsKEJ1ZmZlci5mcm9tKGRpZ2VzdCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hpbmcgbm9uY2UgaW4gSUQgVG9rZW4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZUFjclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVBY3IocmVzcG9uc2UpIHtcbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZUF1dGhUaW1lXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVBdXRoVGltZShyZXNwb25zZSkge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlQWNjZXNzVG9rZW5IYXNoXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVBY2Nlc3NUb2tlbkhhc2gocmVzcG9uc2UpIHtcbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZUF1dGhvcml6YXRpb25Db2RlSGFzaFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZhbGlkYXRlQXV0aG9yaXphdGlvbkNvZGVIYXNoKHJlc3BvbnNlKSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG59XG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBBdXRoZW50aWNhdGlvblJlc3BvbnNlO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMjApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKS5CdWZmZXIpKVxuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogTG9jYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmNvbnN0IHtcbiAgSldUXG59ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbmNvbnN0IElEVG9rZW5TY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcbi8qKlxuICogSURUb2tlblxuICovXG5cblxuY2xhc3MgSURUb2tlbiBleHRlbmRzIEpXVCB7XG4gIC8qKlxuICAgKiBTY2hlbWFcbiAgICovXG4gIHN0YXRpYyBnZXQgc2NoZW1hKCkge1xuICAgIHJldHVybiBJRFRva2VuU2NoZW1hO1xuICB9XG5cbn1cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IElEVG9rZW47XG5cbi8qKiovIH0pLFxuLyogNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuY29uc3Qge1xuICBKV1RTY2hlbWFcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbi8qKlxuICogSURUb2tlbiBTY2hlbWFcbiAqL1xuXG5cbmNvbnN0IElEVG9rZW5TY2hlbWEgPSBKV1RTY2hlbWEuZXh0ZW5kKHtcbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIGhlYWRlclxuICAgICAqIGh0dHA6Ly9vcGVuaWQubmV0L3NwZWNzL29wZW5pZC1jb25uZWN0LWNvcmUtMV8wLmh0bWwjSURUb2tlblxuICAgICAqIElEIFRva2VucyBTSE9VTEQgTk9UIHVzZSB0aGUgSldTIG9yIEpXRSB4NXUsIHg1Yywgamt1LCBvciBqd2sgSGVhZGVyXG4gICAgICogUGFyYW1ldGVyIGZpZWxkcy4gSW5zdGVhZCwgcmVmZXJlbmNlcyB0byBrZXlzIHVzZWQgYXJlIGNvbW11bmljYXRlZCBpblxuICAgICAqIGFkdmFuY2UgdXNpbmcgRGlzY292ZXJ5IGFuZCBSZWdpc3RyYXRpb24gcGFyYW1ldGVycywgcGVyIFNlY3Rpb24gMTAuXG4gICAgICovXG4gICAgaGVhZGVyOiB7Ly9ub3Q6IHsgcmVxdWlyZWQ6IFsneDV1JywgJ3g1YycsICdqa3UnLCAnandrJ10gfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwYXlsb2FkXG4gICAgICovXG4gICAgcGF5bG9hZDoge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogaXNzXG4gICAgICAgICAqXG4gICAgICAgICAqIFJFUVVJUkVELiBJc3N1ZXIgSWRlbnRpZmllciBmb3IgdGhlIElzc3VlciBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAqIFRoZSBpc3MgdmFsdWUgaXMgYSBjYXNlIHNlbnNpdGl2ZSBVUkwgdXNpbmcgdGhlIGh0dHBzIHNjaGVtZVxuICAgICAgICAgKiB0aGF0IGNvbnRhaW5zIHNjaGVtZSwgaG9zdCwgYW5kIG9wdGlvbmFsbHksIHBvcnQgbnVtYmVyIGFuZFxuICAgICAgICAgKiBwYXRoIGNvbXBvbmVudHMgYW5kIG5vIHF1ZXJ5IG9yIGZyYWdtZW50IGNvbXBvbmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBpc3M6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBmb3JtYXQ6ICd1cmwnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN1YlxuICAgICAgICAgKlxuICAgICAgICAgKiBSRVFVSVJFRC4gU3ViamVjdCBJZGVudGlmaWVyLiBBIGxvY2FsbHkgdW5pcXVlIGFuZCBuZXZlclxuICAgICAgICAgKiByZWFzc2lnbmVkIGlkZW50aWZpZXIgd2l0aGluIHRoZSBJc3N1ZXIgZm9yIHRoZSBFbmQtVXNlciwgd2hpY2hcbiAgICAgICAgICogaXMgaW50ZW5kZWQgdG8gYmUgY29uc3VtZWQgYnkgdGhlIENsaWVudCwgZS5nLiwgMjQ0MDAzMjAgb3JcbiAgICAgICAgICogQUl0T2F3bXd0V3djVDBrNTFCYXlld052dXRySlVxc3ZsNnFzN0E0LiBJdCBNVVNUIE5PVCBleGNlZWQgMjU1XG4gICAgICAgICAqIEFTQ0lJIGNoYXJhY3RlcnMgaW4gbGVuZ3RoLiBUaGUgc3ViIHZhbHVlIGlzIGEgY2FzZSBzZW5zaXRpdmVcbiAgICAgICAgICogc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc3ViOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgbWF4TGVuZ3RoOiAyNTVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYXVkXG4gICAgICAgICAqXG4gICAgICAgICAqIFJFUVVJUkVELiBBdWRpZW5jZShzKSB0aGF0IHRoaXMgSUQgVG9rZW4gaXMgaW50ZW5kZWQgZm9yLiBJdFxuICAgICAgICAgKiBNVVNUIGNvbnRhaW4gdGhlIE9BdXRoIDIuMCBjbGllbnRfaWQgb2YgdGhlIFJlbHlpbmcgUGFydHkgYXMgYW5cbiAgICAgICAgICogYXVkaWVuY2UgdmFsdWUuIEl0IE1BWSBhbHNvIGNvbnRhaW4gaWRlbnRpZmllcnMgZm9yIG90aGVyIGF1ZGllbmNlcy5cbiAgICAgICAgICogSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIGF1ZCB2YWx1ZSBpcyBhbiBhcnJheSBvZiBjYXNlIHNlbnNpdGl2ZVxuICAgICAgICAgKiBzdHJpbmdzLiBJbiB0aGUgY29tbW9uIHNwZWNpYWwgY2FzZSB3aGVuIHRoZXJlIGlzIG9uZSBhdWRpZW5jZSxcbiAgICAgICAgICogdGhlIGF1ZCB2YWx1ZSBNQVkgYmUgYSBzaW5nbGUgY2FzZSBzZW5zaXRpdmUgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gaW5oZXJpdGVkIGZyb20gSldUQ2xhaW1zU2V0U2NoZW1hXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4cFxuICAgICAgICAgKlxuICAgICAgICAgKiBSRVFVSVJFRC4gRXhwaXJhdGlvbiB0aW1lIG9uIG9yIGFmdGVyIHdoaWNoIHRoZSBJRCBUb2tlbiBNVVNUIE5PVFxuICAgICAgICAgKiBiZSBhY2NlcHRlZCBmb3IgcHJvY2Vzc2luZy4gVGhlIHByb2Nlc3Npbmcgb2YgdGhpcyBwYXJhbWV0ZXJcbiAgICAgICAgICogcmVxdWlyZXMgdGhhdCB0aGUgY3VycmVudCBkYXRlL3RpbWUgTVVTVCBiZSBiZWZvcmUgdGhlIGV4cGlyYXRpb25cbiAgICAgICAgICogZGF0ZS90aW1lIGxpc3RlZCBpbiB0aGUgdmFsdWUuIEltcGxlbWVudGVycyBNQVkgcHJvdmlkZSBmb3Igc29tZVxuICAgICAgICAgKiBzbWFsbCBsZWV3YXksIHVzdWFsbHkgbm8gbW9yZSB0aGFuIGEgZmV3IG1pbnV0ZXMsIHRvIGFjY291bnQgZm9yXG4gICAgICAgICAqIGNsb2NrIHNrZXcuIEl0cyB2YWx1ZSBpcyBhIEpTT04gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mXG4gICAgICAgICAqIHNlY29uZHMgZnJvbSAxOTcwLTAxLTAxVDA6MDowWiBhcyBtZWFzdXJlZCBpbiBVVEMgdW50aWwgdGhlXG4gICAgICAgICAqIGRhdGUvdGltZS4gU2VlIFJGQyAzMzM5IFtSRkMzMzM5XSBmb3IgZGV0YWlscyByZWdhcmRpbmcgZGF0ZS90aW1lc1xuICAgICAgICAgKiBpbiBnZW5lcmFsIGFuZCBVVEMgaW4gcGFydGljdWxhci5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGluaGVyaXRlZCBmcm9tIEpXVENsYWltc1NldFNjaGVtYVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpYXRcbiAgICAgICAgICpcbiAgICAgICAgICogUkVRVUlSRUQuIFRpbWUgYXQgd2hpY2ggdGhlIEpXVCB3YXMgaXNzdWVkLiBJdHMgdmFsdWUgaXMgYVxuICAgICAgICAgKiBKU09OIG51bWJlciByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBzZWNvbmRzIGZyb21cbiAgICAgICAgICogMTk3MC0wMS0wMVQwOjA6MFogYXMgbWVhc3VyZWQgaW4gVVRDIHVudGlsIHRoZSBkYXRlL3RpbWUuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBpbmhlcml0ZWQgZnJvbSBKV1RDbGFpbXNTZXRTY2hlbWFcblxuICAgICAgICAvKipcbiAgICAgICAgICogYXV0aF90aW1lXG4gICAgICAgICAqXG4gICAgICAgICAqIFRpbWUgd2hlbiB0aGUgRW5kLVVzZXIgYXV0aGVudGljYXRpb24gb2NjdXJyZWQuIEl0cyB2YWx1ZSBpcyBhXG4gICAgICAgICAqIEpTT04gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgZnJvbVxuICAgICAgICAgKiAxOTcwLTAxLTAxVDA6MDowWiBhcyBtZWFzdXJlZCBpbiBVVEMgdW50aWwgdGhlIGRhdGUvdGltZS4gV2hlbiBhXG4gICAgICAgICAqIG1heF9hZ2UgcmVxdWVzdCBpcyBtYWRlIG9yIHdoZW4gYXV0aF90aW1lIGlzIHJlcXVlc3RlZCBhcyBhblxuICAgICAgICAgKiBFc3NlbnRpYWwgQ2xhaW0sIHRoZW4gdGhpcyBDbGFpbSBpcyBSRVFVSVJFRDsgb3RoZXJ3aXNlLCBpdHNcbiAgICAgICAgICogaW5jbHVzaW9uIGlzIE9QVElPTkFMLiAoVGhlIGF1dGhfdGltZSBDbGFpbSBzZW1hbnRpY2FsbHlcbiAgICAgICAgICogY29ycmVzcG9uZHMgdG8gdGhlIE9wZW5JRCAyLjAgUEFQRSBbT3BlbklELlBBUEVdIGF1dGhfdGltZVxuICAgICAgICAgKiByZXNwb25zZSBwYXJhbWV0ZXIuKVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0aF90aW1lOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGZvcm1hdDogJ051bWVyaWNEYXRlJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBub25jZVxuICAgICAgICAgKlxuICAgICAgICAgKiBTdHJpbmcgdmFsdWUgdXNlZCB0byBhc3NvY2lhdGUgYSBDbGllbnQgc2Vzc2lvbiB3aXRoIGFuIElEIFRva2VuLFxuICAgICAgICAgKiBhbmQgdG8gbWl0aWdhdGUgcmVwbGF5IGF0dGFja3MuIFRoZSB2YWx1ZSBpcyBwYXNzZWQgdGhyb3VnaFxuICAgICAgICAgKiB1bm1vZGlmaWVkIGZyb20gdGhlIEF1dGhlbnRpY2F0aW9uIFJlcXVlc3QgdG8gdGhlIElEIFRva2VuLiBJZlxuICAgICAgICAgKiBwcmVzZW50IGluIHRoZSBJRCBUb2tlbiwgQ2xpZW50cyBNVVNUIHZlcmlmeSB0aGF0IHRoZSBub25jZSBDbGFpbVxuICAgICAgICAgKiBWYWx1ZSBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgdGhlIG5vbmNlIHBhcmFtZXRlciBzZW50IGluIHRoZVxuICAgICAgICAgKiBBdXRoZW50aWNhdGlvbiBSZXF1ZXN0LiBJZiBwcmVzZW50IGluIHRoZSBBdXRoZW50aWNhdGlvbiBSZXF1ZXN0LFxuICAgICAgICAgKiBBdXRob3JpemF0aW9uIFNlcnZlcnMgTVVTVCBpbmNsdWRlIGEgbm9uY2UgQ2xhaW0gaW4gdGhlIElEIFRva2VuXG4gICAgICAgICAqIHdpdGggdGhlIENsYWltIFZhbHVlIGJlaW5nIHRoZSBub25jZSB2YWx1ZSBzZW50IGluIHRoZVxuICAgICAgICAgKiBBdXRoZW50aWNhdGlvbiBSZXF1ZXN0LiBBdXRob3JpemF0aW9uIFNlcnZlcnMgU0hPVUxEIHBlcmZvcm0gbm9cbiAgICAgICAgICogb3RoZXIgcHJvY2Vzc2luZyBvbiBub25jZSB2YWx1ZXMgdXNlZC4gVGhlIG5vbmNlIHZhbHVlIGlzIGEgY2FzZVxuICAgICAgICAgKiBzZW5zaXRpdmUgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgbm9uY2U6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhY3JcbiAgICAgICAgICpcbiAgICAgICAgICogT1BUSU9OQUwuIEF1dGhlbnRpY2F0aW9uIENvbnRleHQgQ2xhc3MgUmVmZXJlbmNlLiBTdHJpbmdcbiAgICAgICAgICogc3BlY2lmeWluZyBhbiBBdXRoZW50aWNhdGlvbiBDb250ZXh0IENsYXNzIFJlZmVyZW5jZSB2YWx1ZSB0aGF0XG4gICAgICAgICAqIGlkZW50aWZpZXMgdGhlIEF1dGhlbnRpY2F0aW9uIENvbnRleHQgQ2xhc3MgdGhhdCB0aGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICogcGVyZm9ybWVkIHNhdGlzZmllZC4gVGhlIHZhbHVlIFwiMFwiIGluZGljYXRlcyB0aGUgRW5kLVVzZXJcbiAgICAgICAgICogYXV0aGVudGljYXRpb24gZGlkIG5vdCBtZWV0IHRoZSByZXF1aXJlbWVudHMgb2YgSVNPL0lFQyAyOTExNVxuICAgICAgICAgKiBbSVNPMjkxMTVdIGxldmVsIDEuIEF1dGhlbnRpY2F0aW9uIHVzaW5nIGEgbG9uZy1saXZlZCBicm93c2VyXG4gICAgICAgICAqIGNvb2tpZSwgZm9yIGluc3RhbmNlLCBpcyBvbmUgZXhhbXBsZSB3aGVyZSB0aGUgdXNlIG9mIFwibGV2ZWwgMFwiIGlzXG4gICAgICAgICAqIGFwcHJvcHJpYXRlLiBBdXRoZW50aWNhdGlvbnMgd2l0aCBsZXZlbCAwIFNIT1VMRCBOT1QgYmUgdXNlZCB0b1xuICAgICAgICAgKiBhdXRob3JpemUgYWNjZXNzIHRvIGFueSByZXNvdXJjZSBvZiBhbnkgbW9uZXRhcnkgdmFsdWUuIChUaGlzXG4gICAgICAgICAqIGNvcnJlc3BvbmRzIHRvIHRoZSBPcGVuSUQgMi4wIFBBUEUgW09wZW5JRC5QQVBFXSBuaXN0X2F1dGhfbGV2ZWxcbiAgICAgICAgICogMC4pIEFuIGFic29sdXRlIFVSSSBvciBhbiBSRkMgNjcxMSBbUkZDNjcxMV0gcmVnaXN0ZXJlZCBuYW1lXG4gICAgICAgICAqIFNIT1VMRCBiZSB1c2VkIGFzIHRoZSBhY3IgdmFsdWU7IHJlZ2lzdGVyZWQgbmFtZXMgTVVTVCBOT1QgYmUgdXNlZFxuICAgICAgICAgKiB3aXRoIGEgZGlmZmVyZW50IG1lYW5pbmcgdGhhbiB0aGF0IHdoaWNoIGlzIHJlZ2lzdGVyZWQuIFBhcnRpZXNcbiAgICAgICAgICogdXNpbmcgdGhpcyBjbGFpbSB3aWxsIG5lZWQgdG8gYWdyZWUgdXBvbiB0aGUgbWVhbmluZ3Mgb2YgdGhlXG4gICAgICAgICAqIHZhbHVlcyB1c2VkLCB3aGljaCBtYXkgYmUgY29udGV4dC1zcGVjaWZpYy4gVGhlIGFjciB2YWx1ZSBpcyBhXG4gICAgICAgICAqIGNhc2Ugc2Vuc2l0aXZlIHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGFjcjoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFtclxuICAgICAgICAgKiBPUFRJT05BTC4gQXV0aGVudGljYXRpb24gTWV0aG9kcyBSZWZlcmVuY2VzLiBKU09OIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgICAgICogdGhhdCBhcmUgaWRlbnRpZmllcnMgZm9yIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMgdXNlZCBpbiB0aGVcbiAgICAgICAgICogYXV0aGVudGljYXRpb24uIEZvciBpbnN0YW5jZSwgdmFsdWVzIG1pZ2h0IGluZGljYXRlIHRoYXQgYm90aFxuICAgICAgICAgKiBwYXNzd29yZCBhbmQgT1RQIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMgd2VyZSB1c2VkLiBUaGUgZGVmaW5pdGlvblxuICAgICAgICAgKiBvZiBwYXJ0aWN1bGFyIHZhbHVlcyB0byBiZSB1c2VkIGluIHRoZSBhbXIgQ2xhaW0gaXMgYmV5b25kIHRoZVxuICAgICAgICAgKiBzY29wZSBvZiB0aGlzIHNwZWNpZmljYXRpb24uIFBhcnRpZXMgdXNpbmcgdGhpcyBjbGFpbSB3aWxsIG5lZWQgdG9cbiAgICAgICAgICogYWdyZWUgdXBvbiB0aGUgbWVhbmluZ3Mgb2YgdGhlIHZhbHVlcyB1c2VkLCB3aGljaCBtYXkgYmUgY29udGV4dC1cbiAgICAgICAgICogc3BlY2lmaWMuIFRoZSBhbXIgdmFsdWUgaXMgYW4gYXJyYXkgb2YgY2FzZSBzZW5zaXRpdmUgc3RyaW5ncy5cbiAgICAgICAgICovXG4gICAgICAgIGFtcjoge1xuICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhenBcbiAgICAgICAgICogT1BUSU9OQUwuIEF1dGhvcml6ZWQgcGFydHkgLSB0aGUgcGFydHkgdG8gd2hpY2ggdGhlIElEIFRva2VuIHdhc1xuICAgICAgICAgKiBpc3N1ZWQuIElmIHByZXNlbnQsIGl0IE1VU1QgY29udGFpbiB0aGUgT0F1dGggMi4wIENsaWVudCBJRCBvZiB0aGlzXG4gICAgICAgICAqIHBhcnR5LiBUaGlzIENsYWltIGlzIG9ubHkgbmVlZGVkIHdoZW4gdGhlIElEIFRva2VuIGhhcyBhIHNpbmdsZVxuICAgICAgICAgKiBhdWRpZW5jZSB2YWx1ZSBhbmQgdGhhdCBhdWRpZW5jZSBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgYXV0aG9yaXplZFxuICAgICAgICAgKiBwYXJ0eS4gSXQgTUFZIGJlIGluY2x1ZGVkIGV2ZW4gd2hlbiB0aGUgYXV0aG9yaXplZCBwYXJ0eSBpcyB0aGVcbiAgICAgICAgICogc2FtZSBhcyB0aGUgc29sZSBhdWRpZW5jZS4gVGhlIGF6cCB2YWx1ZSBpcyBhIGNhc2Ugc2Vuc2l0aXZlIHN0cmluZ1xuICAgICAgICAgKiBjb250YWluaW5nIGEgU3RyaW5nT3JVUkkgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBhenA6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBmb3JtYXQ6ICdTdHJpbmdPclVSSSdcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXF1aXJlZCBDbGFpbXNcbiAgICAgICAqL1xuICAgICAgcmVxdWlyZWQ6IFsnaXNzJywgJ3N1YicsICdhdWQnLCAnZXhwJywgJ2lhdCddXG4gICAgfVxuICB9XG59KTtcbi8qKlxuICogRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBJRFRva2VuU2NoZW1hO1xuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmNvbnN0IGZldGNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuY29uc3Qgb25IdHRwRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuY29uc3QgUG9QVG9rZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxuY2xhc3MgU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jcmVkZW50aWFsVHlwZSB7c3RyaW5nfSAnYWNjZXNzX3Rva2VuJyBvciAncG9wX3Rva2VuJ1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5pc3N1ZXIge3N0cmluZ30gSWRlbnRpdHkgcHJvdmlkZXIgKGlzc3VlciBvZiBJRC9BY2Nlc3MgVG9rZW4pXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmF1dGhvcml6YXRpb24ge29iamVjdH1cbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aG9yaXphdGlvbi5jbGllbnRfaWQge3N0cmluZ30gT0lEQy9PQXV0aDIgY2xpZW50IGlkXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5hdXRob3JpemF0aW9uLmlkX3Rva2VuXSB7c3RyaW5nfSBDb21wYWN0LXNlcmlhbGl6ZWQgaWRfdG9rZW4gcGFyYW1cbiAgICogQHBhcmFtIFtvcHRpb25zLmF1dGhvcml6YXRpb24uYWNjZXNzX3Rva2VuXSB7c3RyaW5nfSBDb21wYWN0LXNlcmlhbGl6ZWQgYWNjZXNzX3Rva2VuIHBhcmFtXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5hdXRob3JpemF0aW9uLnJlZnJlc2hfdG9rZW5dIHtzdHJpbmd9IENvbXBhY3Qtc2VyaWFsaXplZCByZWZyZXNoX3Rva2VuXG4gICAqXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5zZXNzaW9uS2V5XSB7c3RyaW5nfSBTZXJpYWxpemVkIGNsaWVudCBzZXNzaW9uIGtleSBnZW5lcmF0ZWRcbiAgICogICBkdXJpbmcgdGhlIEF1dGhlbnRpY2F0aW9uIFJlcXVlc3QsIHVzZWQgdG8gaXNzdWUgUG9QVG9rZW5zXG4gICAqXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5pZENsYWltc10ge29iamVjdH0gRGVjb2RlZC92ZXJpZmllZCBJRCBUb2tlbiBKV1QgcGF5bG9hZFxuICAgKlxuICAgKiBAcGFyYW0gW29wdGlvbnMuYWNjZXNzQ2xhaW1zXSB7b2JqZWN0fSBEZWNvZGVkL3ZlcmlmaWVkIEFjY2VzcyBUb2tlbiBKV1QgcGF5bG9hZFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuY3JlZGVudGlhbFR5cGUgPSBvcHRpb25zLmNyZWRlbnRpYWxUeXBlIHx8ICdhY2Nlc3NfdG9rZW4nO1xuICAgIHRoaXMuaXNzdWVyID0gb3B0aW9ucy5pc3N1ZXI7XG4gICAgdGhpcy5hdXRob3JpemF0aW9uID0gb3B0aW9ucy5hdXRob3JpemF0aW9uIHx8IHt9O1xuICAgIHRoaXMuc2Vzc2lvbktleSA9IG9wdGlvbnMuc2Vzc2lvbktleTtcbiAgICB0aGlzLmlkQ2xhaW1zID0gb3B0aW9ucy5pZENsYWltcztcbiAgICB0aGlzLmFjY2Vzc0NsYWltcyA9IG9wdGlvbnMuYWNjZXNzQ2xhaW1zO1xuICB9XG5cbiAgc3RhdGljIGZyb20ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2Vzc2lvbihvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHJlc3BvbnNlIHtBdXRoZW50aWNhdGlvblJlc3BvbnNlfVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2Vzc2lvbn0gUmVseWluZ1BhcnR5IFNlc3Npb24gb2JqZWN0XG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21BdXRoUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBjb25zdCBSZWx5aW5nUGFydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTsgLy8gaW1wb3J0IGhlcmUgZHVlIHRvIGNpcmN1bGFyIGRlcFxuXG5cbiAgICBsZXQgaWRDbGFpbXMgPSByZXNwb25zZS5kZWNvZGVkICYmIHJlc3BvbnNlLmRlY29kZWQucGF5bG9hZCB8fCB7fTtcbiAgICBsZXQge1xuICAgICAgcnBcbiAgICB9ID0gcmVzcG9uc2U7XG4gICAgbGV0IHJlZ2lzdHJhdGlvbiA9IHJwLnJlZ2lzdHJhdGlvbjtcbiAgICBsZXQgcnBBdXRoT3B0aW9ucyA9IHJwLmRlZmF1bHRzLmF1dGhlbnRpY2F0ZSB8fCB7fTtcbiAgICBsZXQgY3JlZGVudGlhbFR5cGUgPSBycEF1dGhPcHRpb25zWydjcmVkZW50aWFsX3R5cGUnXSB8fCBycC5kZWZhdWx0cy5wb3BUb2tlbiA/ICdwb3BfdG9rZW4nIDogJ2FjY2Vzc190b2tlbic7XG4gICAgbGV0IHNlc3Npb25LZXkgPSByZXNwb25zZS5zZXNzaW9uW1JlbHlpbmdQYXJ0eS5TRVNTSU9OX1BSSVZBVEVfS0VZXTtcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgIGNyZWRlbnRpYWxUeXBlLFxuICAgICAgc2Vzc2lvbktleSxcbiAgICAgIGlzc3VlcjogaWRDbGFpbXMuaXNzLFxuICAgICAgaWRDbGFpbXMsXG4gICAgICBhdXRob3JpemF0aW9uOiB7XG4gICAgICAgIGNsaWVudF9pZDogcmVnaXN0cmF0aW9uWydjbGllbnRfaWQnXSxcbiAgICAgICAgYWNjZXNzX3Rva2VuOiByZXNwb25zZS5wYXJhbXNbJ2FjY2Vzc190b2tlbiddLFxuICAgICAgICBpZF90b2tlbjogcmVzcG9uc2UucGFyYW1zWydpZF90b2tlbiddLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiByZXNwb25zZS5wYXJhbXNbJ3JlZnJlc2hfdG9rZW4nXVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlc3Npb24uZnJvbShvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQXV0aGVudGljYXRlZCBmZXRjaCgpIGdldHRlclxuICAgKlxuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gICAqL1xuXG5cbiAgZ2V0IGZldGNoKCkge1xuICAgIC8qKlxuICAgICAqIGZldGNoKCkgZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIHtSZXF1ZXN0SW5mb3xzdHJpbmd9XG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbjxQcm9taXNlPFJlc3BvbnNlPj59XG4gICAgICovXG4gICAgcmV0dXJuICh1cmwsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ3JlZGVudGlhbHMoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoV2l0aENyZWRlbnRpYWxzKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4ob25IdHRwRXJyb3IoJ0Vycm9yIHdoaWxlIGZldGNoaW5nIHJlc291cmNlJykpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIGJlYXJlclRva2VuRm9yXG4gICAqXG4gICAqIEBwYXJhbSB1cmwge3N0cmluZ31cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG5cblxuICBiZWFyZXJUb2tlbkZvcih1cmwpIHtcbiAgICBzd2l0Y2ggKHRoaXMuY3JlZGVudGlhbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3BvcF90b2tlbic6XG4gICAgICAgIHJldHVybiBQb1BUb2tlbi5pc3N1ZUZvcih1cmwsIHRoaXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyAnYWNjZXNzX3Rva2VuJyBldGNcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmF1dGhvcml6YXRpb25bdGhpcy5jcmVkZW50aWFsVHlwZV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogaGFzQ3JlZGVudGlhbHNcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgaGFzQ3JlZGVudGlhbHMoKSB7XG4gICAgc3dpdGNoICh0aGlzLmNyZWRlbnRpYWxUeXBlKSB7XG4gICAgICBjYXNlICdwb3BfdG9rZW4nOlxuICAgICAgICByZXR1cm4gISF0aGlzLmF1dGhvcml6YXRpb25bJ2lkX3Rva2VuJ107XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vICdhY2Nlc3NfdG9rZW4nIGV0Y1xuICAgICAgICByZXR1cm4gISF0aGlzLmF1dGhvcml6YXRpb25bdGhpcy5jcmVkZW50aWFsVHlwZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBmZXRjaFdpdGhDcmVkZW50aWFsc1xuICAgKlxuICAgKiBAcGFyYW0gdXJsIHtSZXF1ZXN0SW5mb3xzdHJpbmd9XG4gICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICovXG5cblxuICBmZXRjaFdpdGhDcmVkZW50aWFscyh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICByZXR1cm4gdGhpcy5iZWFyZXJUb2tlbkZvcih1cmwpLnRoZW4odG9rZW4gPT4ge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXNzaW9uO1xuXG4vKioqLyB9KSxcbi8qIDc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciB3aGVuIGEgZmV0Y2ggcmVzcG9uc2Ugc3RhdHVzIGNvZGUgaW5kaWNhdGVzIGEgNDAwIG9yIDUwMFxuICogSFRUUCBlcnJvci4gKFRoZSB3aGF0d2cgZmV0Y2ggYXBpIGRvZXMgbm90IG5vcm1hbGx5IHJlamVjdCBvbiBodHRwIGVycm9yXG4gKiByZXNwb25zZXMpLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqIGBgYFxuICogcmV0dXJuIGZldGNoKHVybClcbiAqICAgLnRoZW4ob25IdHRwRXJyb3IoJ0Vycm9yIHdoaWxlIGZldGNoaW5nIHJlc291cmNlJylcbiAqICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKVxuICpcbiAqIC8vIC0+ICdFcnJvciB3aGlsZSBmZXRjaGluZyByZXNvdXJjZTogNDA0IE5vdCBGb3VuZCcgZXJyb3JcbiAqIC8vIGlmIGEgNDA0IHJlc3BvbnNlIGlzIGVuY291bnRlcmVkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gW21lc3NhZ2VdIHtzdHJpbmd9IE9wdGlvbmFsIGVycm9yIG1lc3NhZ2UgdG8gY2xhcmlmeSBjb250ZXh0XG4gKlxuICogQHRocm93cyB7RXJyb3J9IEZvciBodHRwIHN0YXR1cyBjb2RlcyA+IDMwMFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZmV0Y2ggcmVzcG9uc2Ugb2JqZWN0IChwYXNzZWQgdGhyb3VnaCBpZiBubyBlcnJvcilcbiAqL1xuXG5mdW5jdGlvbiBvbkh0dHBFcnJvcihtZXNzYWdlID0gJ2ZldGNoIGVycm9yJykge1xuICByZXR1cm4gcmVzcG9uc2UgPT4ge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgJHttZXNzYWdlfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgZXJyb3Iuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbkh0dHBFcnJvcjtcblxuLyoqKi8gfSksXG4vKiA3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5jb25zdCB7XG4gIFVSTFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG5jb25zdCB7XG4gIEpXVCxcbiAgSldLXG59ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbmNvbnN0IERFRkFVTFRfTUFYX0FHRSA9IDM2MDA7IC8vIERlZmF1bHQgdG9rZW4gZXhwaXJhdGlvbiwgaW4gc2Vjb25kc1xuXG5jbGFzcyBQb1BUb2tlbiBleHRlbmRzIEpXVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVzb3VyY2VTZXJ2ZXJVcmkge3N0cmluZ30gUlMgVVJJIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIGludGVuZGVkXG4gICAqXG4gICAqIEBwYXJhbSBzZXNzaW9uIHtTZXNzaW9ufVxuICAgKiBAcGFyYW0gc2Vzc2lvbi5zZXNzaW9uS2V5IHtzdHJpbmd9XG4gICAqIEBwYXJhbSBzZXNzaW9uLmF1dGhvcml6YXRpb24uY2xpZW50X2lkIHtzdHJpbmd9XG4gICAqIEBwYXJhbSBzZXNzaW9uLmF1dGhvcml6YXRpb24uaWRfdG9rZW4ge3N0cmluZ31cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUG9QVG9rZW4sIGVuY29kZWQgYXMgY29tcGFjdCBKV1RcbiAgICovXG4gIHN0YXRpYyBpc3N1ZUZvcihyZXNvdXJjZVNlcnZlclVyaSwgc2Vzc2lvbikge1xuICAgIGlmICghcmVzb3VyY2VTZXJ2ZXJVcmkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGlzc3VlIFBvUFRva2VuIC0gbWlzc2luZyByZXNvdXJjZSBzZXJ2ZXIgVVJJJyk7XG4gICAgfVxuXG4gICAgaWYgKCFzZXNzaW9uLnNlc3Npb25LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGlzc3VlIFBvUFRva2VuIC0gbWlzc2luZyBzZXNzaW9uIGtleScpO1xuICAgIH1cblxuICAgIGlmICghc2Vzc2lvbi5hdXRob3JpemF0aW9uLmlkX3Rva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpc3N1ZSBQb1BUb2tlbiAtIG1pc3NpbmcgaWQgdG9rZW4nKTtcbiAgICB9XG5cbiAgICBsZXQgandrID0gSlNPTi5wYXJzZShzZXNzaW9uLnNlc3Npb25LZXkpO1xuICAgIHJldHVybiBKV0suaW1wb3J0S2V5KGp3aykudGhlbihpbXBvcnRlZFNlc3Npb25Kd2sgPT4ge1xuICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgIGF1ZDogbmV3IFVSTChyZXNvdXJjZVNlcnZlclVyaSkub3JpZ2luLFxuICAgICAgICBrZXk6IGltcG9ydGVkU2Vzc2lvbkp3ayxcbiAgICAgICAgaXNzOiBzZXNzaW9uLmF1dGhvcml6YXRpb24uY2xpZW50X2lkLFxuICAgICAgICBpZF90b2tlbjogc2Vzc2lvbi5hdXRob3JpemF0aW9uLmlkX3Rva2VuXG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBvUFRva2VuLmlzc3VlKG9wdGlvbnMpO1xuICAgIH0pLnRoZW4oand0ID0+IHtcbiAgICAgIHJldHVybiBqd3QuZW5jb2RlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGlzc3VlXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqIEBwYXJhbSBvcHRpb25zLmlzcyB7c3RyaW5nfSBUb2tlbiBpc3N1ZXIgKFJQIGNsaWVudF9pZClcbiAgICogQHBhcmFtIG9wdGlvbnMuYXVkIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gQXVkaWVuY2UgZm9yIHRoZSB0b2tlblxuICAgKiAgIChzdWNoIGFzIHRoZSBSZXNvdXJjZSBTZXJ2ZXIgdXJsKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5rZXkge0pXS30gUHJvb2Ygb2YgUG9zc2Vzc2lvbiAocHJpdmF0ZSkgc2lnbmluZyBrZXksIHNlZVxuICAgKiAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3ODAwI3NlY3Rpb24tMy4xXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmlkX3Rva2VuIHtzdHJpbmd9IEpXVCBjb21wYWN0IGVuY29kZWQgSUQgVG9rZW5cbiAgICpcbiAgICogT3B0aW9uYWw6XG4gICAqIEBwYXJhbSBbb3B0aW9ucy5pYXRdIHtudW1iZXJ9IElzc3VlZCBhdCB0aW1lc3RhbXAgKGluIHNlY29uZHMpXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5tYXhdIHtudW1iZXJ9IE1heCB0b2tlbiBsaWZldGltZSBpbiBzZWNvbmRzXG4gICAqXG4gICAqIEByZXR1cm5zIHtQb1BUb2tlbn0gUHJvb2Ygb2YgUG9zc2Vzc2lvbiBUb2tlbiAoSldUIGluc3RhbmNlKVxuICAgKi9cblxuXG4gIHN0YXRpYyBpc3N1ZShvcHRpb25zKSB7XG4gICAgbGV0IHtcbiAgICAgIGF1ZCxcbiAgICAgIGlzcyxcbiAgICAgIGtleVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGxldCBhbGcgPSBrZXkuYWxnO1xuICAgIGxldCBpYXQgPSBvcHRpb25zLmlhdCB8fCBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICBsZXQgbWF4ID0gb3B0aW9ucy5tYXggfHwgREVGQVVMVF9NQVhfQUdFO1xuICAgIGxldCBleHAgPSBpYXQgKyBtYXg7IC8vIHRva2VuIGV4cGlyYXRpb25cblxuICAgIGxldCBoZWFkZXIgPSB7XG4gICAgICBhbGdcbiAgICB9O1xuICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgaXNzLFxuICAgICAgYXVkLFxuICAgICAgZXhwLFxuICAgICAgaWF0LFxuICAgICAgaWRfdG9rZW46IG9wdGlvbnMuaWRfdG9rZW4sXG4gICAgICB0b2tlbl90eXBlOiAncG9wJ1xuICAgIH07XG4gICAgbGV0IGp3dCA9IG5ldyBQb1BUb2tlbih7XG4gICAgICBoZWFkZXIsXG4gICAgICBwYXlsb2FkLFxuICAgICAga2V5OiBrZXkuY3J5cHRvS2V5XG4gICAgfSwge1xuICAgICAgZmlsdGVyOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBqd3Q7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvUFRva2VuO1xuXG4vKioqLyB9KSxcbi8qIDc2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEh0dHBFcnJvclxudmFyIFN0YW5kYXJkRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KVxudmFyIFNUQVRVU19DT0RFX1RPX05BTUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KVxudmFyIFNUQVRVU19OQU1FX1RPX0NPREUgPSBleHBvcnRzXG5cbmZ1bmN0aW9uIEh0dHBFcnJvcihjb2RlLCBtc2csIHByb3BzKSB7XG4gIGlmICh0eXBlb2YgY29kZSA9PSBcInN0cmluZ1wiKSBjb2RlID0gU1RBVFVTX05BTUVfVE9fQ09ERVtjb2RlXVxuICBpZiAodHlwZW9mIGNvZGUgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vbi1udW1lcmljIEhUVFAgY29kZVwiKVxuICBpZiAodHlwZW9mIG1zZyA9PSBcIm9iamVjdFwiICYmIG1zZyAhPSBudWxsKSB7IHByb3BzID0gbXNnOyBtc2cgPSBudWxsIH1cbiAgU3RhbmRhcmRFcnJvci5jYWxsKHRoaXMsIG1zZyB8fCBTVEFUVVNfQ09ERV9UT19OQU1FW2NvZGVdLCBwcm9wcylcbiAgdGhpcy5jb2RlID0gY29kZVxufVxuXG5IdHRwRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdGFuZGFyZEVycm9yLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBIdHRwRXJyb3IsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWV9XG59KVxuXG4vLyBTZXQgbmFtZSBleHBsaWNpdGx5IGZvciB3aGVuIHRoZSBjb2RlIGdldHMgbWluaWZpZWQuXG5IdHRwRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIkh0dHBFcnJvclwiXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEh0dHBFcnJvci5wcm90b3R5cGUsIHtcbiAgc3RhdHVzQ29kZTogYWxpYXMoXCJjb2RlXCIpLFxuICBzdGF0dXNNZXNzYWdlOiBhbGlhcyhcIm1lc3NhZ2VcIiksXG5cbiAgc3RhdHVzOiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvZGUgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0dXNcIiwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KVxuXG5IdHRwRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLmNvZGUgKyBcIiBcIiArIHRoaXMubWVzc2FnZVxufVxuXG5mb3IgKHZhciBjb2RlIGluIFNUQVRVU19DT0RFX1RPX05BTUUpIHtcbiAgdmFyIG5hbWUgPSBTVEFUVVNfQ09ERV9UT19OQU1FW2NvZGVdXG4gIGV4cG9ydHNbbmFtZS5yZXBsYWNlKFwiJ1wiLCBcIlwiKS5yZXBsYWNlKC9bLSBdL2csIFwiX1wiKS50b1VwcGVyQ2FzZSgpXSA9ICtjb2RlXG59XG5cbmZ1bmN0aW9uIGFsaWFzKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXNbbmFtZV0gfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB0aGlzW25hbWVdID0gdmFsdWUgfVxuICB9XG59XG5cblxuLyoqKi8gfSksXG4vKiA3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaGFzID0gT2JqZWN0Lmhhc093blByb3BlcnR5XG52YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbnZhciB0cmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlXG5tb2R1bGUuZXhwb3J0cyA9IFN0YW5kYXJkRXJyb3JcblxuZnVuY3Rpb24gU3RhbmRhcmRFcnJvcihtc2csIHByb3BzKSB7XG4gIC8vIExldCBhbGwgcHJvcGVydGllcyBiZSBlbnVtZXJhYmxlIGZvciBlYXNpZXIgc2VyaWFsaXphdGlvbi5cbiAgaWYgKG1zZyAmJiB0eXBlb2YgbXNnID09IFwib2JqZWN0XCIpIHByb3BzID0gbXNnLCBtc2cgPSB1bmRlZmluZWRcbiAgZWxzZSB0aGlzLm1lc3NhZ2UgPSBtc2dcblxuICAvLyBOYW1lIGhhcyB0byBiZSBhbiBvd24gcHJvcGVydHkgKG9yIG9uIHRoZSBwcm90b3R5cGUgYSBzaW5nbGUgc3RlcCB1cCkgZm9yXG4gIC8vIHRoZSBzdGFjayB0byBiZSBwcmludGVkIHdpdGggdGhlIGNvcnJlY3QgbmFtZS5cbiAgaWYgKHByb3BzKSBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHRoaXNba2V5XSA9IHByb3BzW2tleV1cbiAgaWYgKCFoYXMuY2FsbCh0aGlzLCBcIm5hbWVcIikpXG4gICAgdGhpcy5uYW1lID0gaGFzLmNhbGwocHJvdG8odGhpcyksIFwibmFtZVwiKT8gdGhpcy5uYW1lIDogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG5cbiAgaWYgKHRyYWNlICYmICEoXCJzdGFja1wiIGluIHRoaXMpKSB0cmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKVxufVxuXG5TdGFuZGFyZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7dmFsdWU6IFN0YW5kYXJkRXJyb3IsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWV9XG59KVxuXG4vLyBTZXQgbmFtZSBleHBsaWNpdGx5IGZvciB3aGVuIHRoZSBjb2RlIGdldHMgbWluaWZpZWQuXG5TdGFuZGFyZEVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJTdGFuZGFyZEVycm9yXCJcblxuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTi5wYXJzZShcIntcXFwiMTAwXFxcIjpcXFwiQ29udGludWVcXFwiLFxcXCIxMDFcXFwiOlxcXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXFxcIixcXFwiMTAyXFxcIjpcXFwiUHJvY2Vzc2luZ1xcXCIsXFxcIjIwMFxcXCI6XFxcIk9LXFxcIixcXFwiMjAxXFxcIjpcXFwiQ3JlYXRlZFxcXCIsXFxcIjIwMlxcXCI6XFxcIkFjY2VwdGVkXFxcIixcXFwiMjAzXFxcIjpcXFwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cXFwiLFxcXCIyMDRcXFwiOlxcXCJObyBDb250ZW50XFxcIixcXFwiMjA1XFxcIjpcXFwiUmVzZXQgQ29udGVudFxcXCIsXFxcIjIwNlxcXCI6XFxcIlBhcnRpYWwgQ29udGVudFxcXCIsXFxcIjIwN1xcXCI6XFxcIk11bHRpLVN0YXR1c1xcXCIsXFxcIjIwOFxcXCI6XFxcIkFscmVhZHkgUmVwb3J0ZWRcXFwiLFxcXCIyMjZcXFwiOlxcXCJJTSBVc2VkXFxcIixcXFwiMzAwXFxcIjpcXFwiTXVsdGlwbGUgQ2hvaWNlc1xcXCIsXFxcIjMwMVxcXCI6XFxcIk1vdmVkIFBlcm1hbmVudGx5XFxcIixcXFwiMzAyXFxcIjpcXFwiRm91bmRcXFwiLFxcXCIzMDNcXFwiOlxcXCJTZWUgT3RoZXJcXFwiLFxcXCIzMDRcXFwiOlxcXCJOb3QgTW9kaWZpZWRcXFwiLFxcXCIzMDVcXFwiOlxcXCJVc2UgUHJveHlcXFwiLFxcXCIzMDdcXFwiOlxcXCJUZW1wb3JhcnkgUmVkaXJlY3RcXFwiLFxcXCIzMDhcXFwiOlxcXCJQZXJtYW5lbnQgUmVkaXJlY3RcXFwiLFxcXCI0MDBcXFwiOlxcXCJCYWQgUmVxdWVzdFxcXCIsXFxcIjQwMVxcXCI6XFxcIlVuYXV0aG9yaXplZFxcXCIsXFxcIjQwMlxcXCI6XFxcIlBheW1lbnQgUmVxdWlyZWRcXFwiLFxcXCI0MDNcXFwiOlxcXCJGb3JiaWRkZW5cXFwiLFxcXCI0MDRcXFwiOlxcXCJOb3QgRm91bmRcXFwiLFxcXCI0MDVcXFwiOlxcXCJNZXRob2QgTm90IEFsbG93ZWRcXFwiLFxcXCI0MDZcXFwiOlxcXCJOb3QgQWNjZXB0YWJsZVxcXCIsXFxcIjQwN1xcXCI6XFxcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXFxcIixcXFwiNDA4XFxcIjpcXFwiUmVxdWVzdCBUaW1lb3V0XFxcIixcXFwiNDA5XFxcIjpcXFwiQ29uZmxpY3RcXFwiLFxcXCI0MTBcXFwiOlxcXCJHb25lXFxcIixcXFwiNDExXFxcIjpcXFwiTGVuZ3RoIFJlcXVpcmVkXFxcIixcXFwiNDEyXFxcIjpcXFwiUHJlY29uZGl0aW9uIEZhaWxlZFxcXCIsXFxcIjQxM1xcXCI6XFxcIlBheWxvYWQgVG9vIExhcmdlXFxcIixcXFwiNDE0XFxcIjpcXFwiVVJJIFRvbyBMb25nXFxcIixcXFwiNDE1XFxcIjpcXFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVxcXCIsXFxcIjQxNlxcXCI6XFxcIlJhbmdlIE5vdCBTYXRpc2ZpYWJsZVxcXCIsXFxcIjQxN1xcXCI6XFxcIkV4cGVjdGF0aW9uIEZhaWxlZFxcXCIsXFxcIjQxOFxcXCI6XFxcIkknbSBhIHRlYXBvdFxcXCIsXFxcIjQyMVxcXCI6XFxcIk1pc2RpcmVjdGVkIFJlcXVlc3RcXFwiLFxcXCI0MjJcXFwiOlxcXCJVbnByb2Nlc3NhYmxlIEVudGl0eVxcXCIsXFxcIjQyM1xcXCI6XFxcIkxvY2tlZFxcXCIsXFxcIjQyNFxcXCI6XFxcIkZhaWxlZCBEZXBlbmRlbmN5XFxcIixcXFwiNDI1XFxcIjpcXFwiVW5vcmRlcmVkIENvbGxlY3Rpb25cXFwiLFxcXCI0MjZcXFwiOlxcXCJVcGdyYWRlIFJlcXVpcmVkXFxcIixcXFwiNDI4XFxcIjpcXFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXFxcIixcXFwiNDI5XFxcIjpcXFwiVG9vIE1hbnkgUmVxdWVzdHNcXFwiLFxcXCI0MzFcXFwiOlxcXCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXFxcIixcXFwiNTAwXFxcIjpcXFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXFxcIixcXFwiNTAxXFxcIjpcXFwiTm90IEltcGxlbWVudGVkXFxcIixcXFwiNTAyXFxcIjpcXFwiQmFkIEdhdGV3YXlcXFwiLFxcXCI1MDNcXFwiOlxcXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXFxcIixcXFwiNTA0XFxcIjpcXFwiR2F0ZXdheSBUaW1lb3V0XFxcIixcXFwiNTA1XFxcIjpcXFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcXFwiLFxcXCI1MDZcXFwiOlxcXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1xcXCIsXFxcIjUwN1xcXCI6XFxcIkluc3VmZmljaWVudCBTdG9yYWdlXFxcIixcXFwiNTA4XFxcIjpcXFwiTG9vcCBEZXRlY3RlZFxcXCIsXFxcIjUwOVxcXCI6XFxcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFxcXCIsXFxcIjUxMFxcXCI6XFxcIk5vdCBFeHRlbmRlZFxcXCIsXFxcIjUxMVxcXCI6XFxcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcXFwifVwiKTtcblxuLyoqKi8gfSksXG4vKiA3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5jb25zdCB7XG4gIEpTT05TY2hlbWFcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbi8qKlxuICogUmVseWluZ1BhcnR5IFNjaGVtYVxuICpcbiAqIFRoaXMgc2NoZW1hIGluaXRpYWxpemVzIGFuZCB2ZXJpZmllcyBSZWx5aW5nIFBhcnR5IGNsaWVudCBjb25maWd1cmF0aW9uLlxuICogUmVseWluZ1BhcnR5IG9iamVjdHMgY2FuIGJlIHBlcnNpc3RlZCBhbmQgcmVoeWRyYXRlZC4gQnkgZW5jYXBzdWxhdGluZyB0aGlzIGRhdGEgaW5cbiAqIGl0J3Mgb3duIGNsYXNzLCBpdCdzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgUlAgY29uZmlndXJhdGlvbnMgcnVubmluZ1xuICogc2ltdWx0YW5lb3VzbHkuXG4gKi9cblxuXG5jb25zdCBSZWx5aW5nUGFydHlTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBwcm92aWRlciwgaW5jbHVkaW5nIGlzc3VlciBVUkwsIGh1bWFuIHJlYWRhYmxlIG5hbWUsXG4gICAgICogYW5kIGFueSBjb25maWd1cmF0aW9uIG9yIHByb3ZpZGVyIG1ldGFkYXRhIHJldHJpZXZlZCBmcm9tIHRoZSBPUC5cbiAgICAgKi9cbiAgICBwcm92aWRlcjoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICB9LFxuICAgICAgICB1cmw6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBmb3JtYXQ6ICd1cmknXG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5PVEU6XG4gICAgICAgIC8vIE9wZW5JRCBDb25maWd1cmF0aW9uIChkaXNjb3ZlcnkgcmVzcG9uc2UpIGFuZCBKU09OIFdlYiBLZXlzIFNldCBmb3IgYW5cbiAgICAgICAgLy8gaXNzdWVyIGNhbiBiZSBjYWNoZWQgaGVyZS4gSG93ZXZlciB0aGUgY2FjaGUgc2hvdWxkIG5vdCBiZSBwZXJzaXN0ZWQgb3JcbiAgICAgICAgLy8gcmVsaWVkIHVwb24uXG4gICAgICAgIC8vXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHt9LFxuICAgICAgICAvLyAud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvblxuICAgICAgICBqd2tzOiB7fSAvLyAvandrc1xuXG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFsndXJsJ11cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVmYXVsdHNcbiAgICAgKlxuICAgICAqIERlZmF1bHQgcmVxdWVzdCBwYXJhbWV0ZXJzIGZvciBhdXRoZW50aWNhdGlvbiBhbmQgZHluYW1pYyByZWdpc3RyYXRpb24gcmVxdWVzdHMuXG4gICAgICogVGhlc2UgdmFsdWVzIGNhbiBiZSBleHRlbmRlZCBvciBvdmVycmlkZGVuIHZpYSBhcmd1bWVudHMgdG8gdGhlIHJlc3BlY3RpdmVcbiAgICAgKiByZXF1ZXN0IG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGVzZSBhcmUgcGFydCBvZiB0aGUgcmVseWluZyBwYXJ0eSBjbGllbnQgY29uZmlndXJhdGlvbiBhbmQgY2FuIGJlIHNlcmlhbGl6ZWRcbiAgICAgKiBhbmQgcGVyc2lzdGVkLlxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBQcm9vZiBvZiBQb3NzZXNzaW9uIHRva2VuIHNlbWFudGljcyBmb3IgdGhlIElEIFRva2VuXG4gICAgICAgICAqL1xuICAgICAgICBwb3BUb2tlbjoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgYXV0aGVudGljYXRlOiB7XG4gICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgcmVkaXJlY3RfdXJpOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICBmb3JtYXQ6ICd1cmknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzcG9uc2VfdHlwZToge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgZGVmYXVsdDogJ2lkX3Rva2VuIHRva2VuJyxcbiAgICAgICAgICAgICAgLy8gYnJvd3NlciBkZXRlY3Rpb25cbiAgICAgICAgICAgICAgZW51bTogWydjb2RlJywgJ3Rva2VuJywgJ2lkX3Rva2VuIHRva2VuJywgJ2lkX3Rva2VuIHRva2VuIGNvZGUnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGRlZmF1bHQ6ICdwYWdlJyxcbiAgICAgICAgICAgICAgZW51bTogWydwYWdlJywgJ3BvcHVwJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICB0eXBlOiBbJ3N0cmluZycsICdhcnJheSddLFxuICAgICAgICAgICAgICBkZWZhdWx0OiBbJ29wZW5pZCddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGNsaWVudCByZWdpc3RyYXRpb24gcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXI6IHt9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlZ2lzdHJhdGlvblxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgY2xpZW50IHJlZ2lzdHJhdGlvbiByZXNwb25zZSBmcm9tIGR5bmFtaWMgcmVnaXN0cmF0aW9uLiBJdCBzaG91bGRcbiAgICAgKiBhbHdheXMgcmVmbGVjdCB0aGUgY2xpZW50IGNvbmZpZ3VyYXRpb24gb24gdGhlIG9wZW5pZCBwcm92aWRlci4gQSBjbGllbnQgYWNjZXNzXG4gICAgICogdG9rZW4gaXMgc3RvcmVkIGhlcmVcbiAgICAgKi9cbiAgICByZWdpc3RyYXRpb246IHt9LFxuICAgIC8vIENsaWVudE1ldGFkYXRhU2NoZW1hXG5cbiAgICAvKipcbiAgICAgKiBzdG9yZVxuICAgICAqL1xuICAgIHN0b3JlOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIGRlZmF1bHQ6IHt9XG4gICAgfVxuICB9XG59KTtcbi8qKlxuICogRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWx5aW5nUGFydHlTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSxcbiAgICBVUkwgPSBfcmVxdWlyZS5VUkw7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSxcbiAgICBKV1QgPSBfcmVxdWlyZTIuSldULFxuICAgIEpXSyA9IF9yZXF1aXJlMi5KV0s7XG5cbnZhciBERUZBVUxUX01BWF9BR0UgPSAzNjAwOyAvLyBEZWZhdWx0IHRva2VuIGV4cGlyYXRpb24sIGluIHNlY29uZHNcblxudmFyIFBvUFRva2VuID0gZnVuY3Rpb24gKF9KV1QpIHtcbiAgX2luaGVyaXRzKFBvUFRva2VuLCBfSldUKTtcblxuICBmdW5jdGlvbiBQb1BUb2tlbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9QVG9rZW4pO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQb1BUb2tlbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvUFRva2VuKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9QVG9rZW4sIG51bGwsIFt7XG4gICAga2V5OiAnaXNzdWVGb3InLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJlc291cmNlU2VydmVyVXJpIHtzdHJpbmd9IFJTIFVSSSBmb3Igd2hpY2ggdGhpcyB0b2tlbiBpcyBpbnRlbmRlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHNlc3Npb24ge1Nlc3Npb259XG4gICAgICogQHBhcmFtIHNlc3Npb24uc2Vzc2lvbktleSB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBzZXNzaW9uLmF1dGhvcml6YXRpb24uY2xpZW50X2lkIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHNlc3Npb24uYXV0aG9yaXphdGlvbi5pZF90b2tlbiB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUG9QVG9rZW4sIGVuY29kZWQgYXMgY29tcGFjdCBKV1RcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNzdWVGb3IocmVzb3VyY2VTZXJ2ZXJVcmksIHNlc3Npb24pIHtcbiAgICAgIGlmICghcmVzb3VyY2VTZXJ2ZXJVcmkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXNzdWUgUG9QVG9rZW4gLSBtaXNzaW5nIHJlc291cmNlIHNlcnZlciBVUkknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZXNzaW9uLnNlc3Npb25LZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXNzdWUgUG9QVG9rZW4gLSBtaXNzaW5nIHNlc3Npb24ga2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2Vzc2lvbi5hdXRob3JpemF0aW9uLmlkX3Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGlzc3VlIFBvUFRva2VuIC0gbWlzc2luZyBpZCB0b2tlbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgandrID0gSlNPTi5wYXJzZShzZXNzaW9uLnNlc3Npb25LZXkpO1xuICAgICAgcmV0dXJuIEpXSy5pbXBvcnRLZXkoandrKS50aGVuKGZ1bmN0aW9uIChpbXBvcnRlZFNlc3Npb25Kd2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgYXVkOiBuZXcgVVJMKHJlc291cmNlU2VydmVyVXJpKS5vcmlnaW4sXG4gICAgICAgICAga2V5OiBpbXBvcnRlZFNlc3Npb25Kd2ssXG4gICAgICAgICAgaXNzOiBzZXNzaW9uLmF1dGhvcml6YXRpb24uY2xpZW50X2lkLFxuICAgICAgICAgIGlkX3Rva2VuOiBzZXNzaW9uLmF1dGhvcml6YXRpb24uaWRfdG9rZW5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBvUFRva2VuLmlzc3VlKG9wdGlvbnMpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoand0KSB7XG4gICAgICAgIHJldHVybiBqd3QuZW5jb2RlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaXNzdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAgICogQHBhcmFtIG9wdGlvbnMuaXNzIHtzdHJpbmd9IFRva2VuIGlzc3VlciAoUlAgY2xpZW50X2lkKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmF1ZCB7c3RyaW5nfEFycmF5PHN0cmluZz59IEF1ZGllbmNlIGZvciB0aGUgdG9rZW5cbiAgICAgKiAgIChzdWNoIGFzIHRoZSBSZXNvdXJjZSBTZXJ2ZXIgdXJsKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmtleSB7SldLfSBQcm9vZiBvZiBQb3NzZXNzaW9uIChwcml2YXRlKSBzaWduaW5nIGtleSwgc2VlXG4gICAgICogICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzgwMCNzZWN0aW9uLTMuMVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWRfdG9rZW4ge3N0cmluZ30gSldUIGNvbXBhY3QgZW5jb2RlZCBJRCBUb2tlblxuICAgICAqXG4gICAgICogT3B0aW9uYWw6XG4gICAgICogQHBhcmFtIFtvcHRpb25zLmlhdF0ge251bWJlcn0gSXNzdWVkIGF0IHRpbWVzdGFtcCAoaW4gc2Vjb25kcylcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMubWF4XSB7bnVtYmVyfSBNYXggdG9rZW4gbGlmZXRpbWUgaW4gc2Vjb25kc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1BvUFRva2VufSBQcm9vZiBvZiBQb3NzZXNzaW9uIFRva2VuIChKV1QgaW5zdGFuY2UpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lzc3VlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNzdWUob3B0aW9ucykge1xuICAgICAgdmFyIGF1ZCA9IG9wdGlvbnMuYXVkLFxuICAgICAgICAgIGlzcyA9IG9wdGlvbnMuaXNzLFxuICAgICAgICAgIGtleSA9IG9wdGlvbnMua2V5O1xuICAgICAgdmFyIGFsZyA9IGtleS5hbGc7XG4gICAgICB2YXIgaWF0ID0gb3B0aW9ucy5pYXQgfHwgTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICB2YXIgbWF4ID0gb3B0aW9ucy5tYXggfHwgREVGQVVMVF9NQVhfQUdFO1xuICAgICAgdmFyIGV4cCA9IGlhdCArIG1heDsgLy8gdG9rZW4gZXhwaXJhdGlvblxuXG4gICAgICB2YXIgaGVhZGVyID0ge1xuICAgICAgICBhbGc6IGFsZ1xuICAgICAgfTtcbiAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICBpc3M6IGlzcyxcbiAgICAgICAgYXVkOiBhdWQsXG4gICAgICAgIGV4cDogZXhwLFxuICAgICAgICBpYXQ6IGlhdCxcbiAgICAgICAgaWRfdG9rZW46IG9wdGlvbnMuaWRfdG9rZW4sXG4gICAgICAgIHRva2VuX3R5cGU6ICdwb3AnXG4gICAgICB9O1xuICAgICAgdmFyIGp3dCA9IG5ldyBQb1BUb2tlbih7XG4gICAgICAgIGhlYWRlcjogaGVhZGVyLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICBrZXk6IGtleS5jcnlwdG9LZXlcbiAgICAgIH0sIHtcbiAgICAgICAgZmlsdGVyOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gand0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb1BUb2tlbjtcbn0oSldUKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb1BUb2tlbjtcblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvcGVuSWRwUG9wdXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvcGVuSWRwUG9wdXA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9idGFpblNlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvYnRhaW5TZXNzaW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwb3B1cEhhbmRsZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwb3B1cEhhbmRsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pcGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91cmxfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXG5mdW5jdGlvbiBvcGVuSWRwUG9wdXAocG9wdXBVcmkpIHtcbiAgY29uc3Qgd2lkdGggPSA2NTA7XG4gIGNvbnN0IGhlaWdodCA9IDQwMDtcbiAgY29uc3QgbGVmdCA9IHdpbmRvdy5zY3JlZW5YICsgKHdpbmRvdy5pbm5lcldpZHRoIC0gd2lkdGgpIC8gMjtcbiAgY29uc3QgdG9wID0gd2luZG93LnNjcmVlblkgKyAod2luZG93LmlubmVySGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gIGNvbnN0IHNldHRpbmdzID0gXCJ3aWR0aD1cIi5jb25jYXQod2lkdGgsIFwiLGhlaWdodD1cIikuY29uY2F0KGhlaWdodCwgXCIsbGVmdD1cIikuY29uY2F0KGxlZnQsIFwiLHRvcD1cIikuY29uY2F0KHRvcCk7XG4gIHJldHVybiB3aW5kb3cub3Blbihwb3B1cFVyaSwgJ3NvbGlkLWF1dGgtY2xpZW50Jywgc2V0dGluZ3MpO1xufVxuZnVuY3Rpb24gb2J0YWluU2Vzc2lvbihzdG9yZSwgcG9wdXAsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBwb3B1cFNlcnZlciA9IG5ldyBfaXBjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJTZXJ2ZXJcIl0ocG9wdXAsIE9iamVjdChfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIm9yaWdpbk9mXCJdKShvcHRpb25zLnBvcHVwVXJpIHx8ICcnKSwgcG9wdXBIYW5kbGVyKHN0b3JlLCBvcHRpb25zLCBzZXNzaW9uID0+IHtcbiAgICAgIHBvcHVwU2VydmVyLnN0b3AoKTtcbiAgICAgIHJlc29sdmUoc2Vzc2lvbik7XG4gICAgfSkpO1xuICAgIHBvcHVwU2VydmVyLnN0YXJ0KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcG9wdXBIYW5kbGVyKHN0b3JlLCBfcmVmLCBmb3VuZFNlc3Npb25DYikge1xuICBsZXQge1xuICAgIHBvcHVwVXJpLFxuICAgIGNhbGxiYWNrVXJpXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAvLyBPcmlnaW5cbiAgICAgIGNhc2UgJ2dldEFwcE9yaWdpbic6XG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgLy8gU3RvcmFnZVxuXG4gICAgICBjYXNlICdzdG9yYWdlL2dldEl0ZW0nOlxuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0SXRlbSguLi5hcmdzKTtcblxuICAgICAgY2FzZSAnc3RvcmFnZS9zZXRJdGVtJzpcbiAgICAgICAgcmV0dXJuIHN0b3JlLnNldEl0ZW0oLi4uYXJncyk7XG5cbiAgICAgIGNhc2UgJ3N0b3JhZ2UvcmVtb3ZlSXRlbSc6XG4gICAgICAgIHJldHVybiBzdG9yZS5yZW1vdmVJdGVtKC4uLmFyZ3MpO1xuICAgICAgLy8gTG9naW5cblxuICAgICAgY2FzZSAnZ2V0TG9naW5PcHRpb25zJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3B1cFVyaSxcbiAgICAgICAgICBjYWxsYmFja1VyaVxuICAgICAgICB9O1xuXG4gICAgICBjYXNlICdmb3VuZFNlc3Npb24nOlxuICAgICAgICBmb3VuZFNlc3Npb25DYiguLi5hcmdzKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///52\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2Jvb3RzdHJhcC9ib290c3RyYXAubWluLmNzcz8xOGU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjUzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzLmNzcz9kYjFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjU0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///54\n")},function(module,exports,__webpack_require__){"use strict";eval("\n__webpack_require__(56);\nvar anObject = __webpack_require__(2);\nvar $flags = __webpack_require__(28);\nvar DESCRIPTORS = __webpack_require__(4);\nvar TO_STRING = 'toString';\nvar $toString = /./[TO_STRING];\n\nvar define = function (fn) {\n  __webpack_require__(10)(RegExp.prototype, TO_STRING, fn, true);\n};\n\n// 21.2.5.14 RegExp.prototype.toString()\nif (__webpack_require__(6)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {\n  define(function toString() {\n    var R = anObject(this);\n    return '/'.concat(R.source, '/',\n      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);\n  });\n// FF44- RegExp#toString has a wrong name\n} else if ($toString.name != TO_STRING) {\n  define(function toString() {\n    return $toString.call(this);\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzPzZiNTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixtQkFBTyxDQUFDLEVBQW9CO0FBQzVCLGVBQWUsbUJBQU8sQ0FBQyxDQUFjO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxFQUFVO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLENBQWdCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLG1CQUFPLENBQUMsRUFBYTtBQUN2Qjs7QUFFQTtBQUNBLElBQUksbUJBQU8sQ0FBQyxDQUFVLGVBQWUsd0JBQXdCLDBCQUEwQixZQUFZLEVBQUU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiI1NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYgKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZiAoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55\n")},function(module,exports,__webpack_require__){eval("// 21.2.5.3 get RegExp.prototype.flags()\nif (__webpack_require__(4) && /./g.flags != 'g') __webpack_require__(7).f(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: __webpack_require__(28)\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanM/Mzg0NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksbUJBQU8sQ0FBQyxDQUFnQix3QkFBd0IsbUJBQU8sQ0FBQyxDQUFjO0FBQzFFO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLEVBQVU7QUFDekIsQ0FBQyIsImZpbGUiOiI1Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///56\n")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(17)('native-function-to-string', Function.toString);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mdW5jdGlvbi10by1zdHJpbmcuanM/ZmE1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFXIiwiZmlsZSI6IjU3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///57\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar addToUnscopables = __webpack_require__(59);\nvar step = __webpack_require__(60);\nvar Iterators = __webpack_require__(30);\nvar toIObject = __webpack_require__(11);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(62)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcz9jYWRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsdUJBQXVCLG1CQUFPLENBQUMsRUFBdUI7QUFDdEQsV0FBVyxtQkFBTyxDQUFDLEVBQWM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsRUFBYztBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLEVBQWdCO0FBQ3pDLGdDQUFnQztBQUNoQyxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///58\n")},function(module,exports,__webpack_require__){eval("// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = __webpack_require__(1)('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(5)(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanM/OWM2YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLENBQVE7QUFDbEM7QUFDQSwwQ0FBMEMsbUJBQU8sQ0FBQyxDQUFTLDZCQUE2QjtBQUN4RjtBQUNBO0FBQ0EiLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59\n")},function(module,exports){eval("module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanM/ZDUzYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFVBQVU7QUFDViIsImZpbGUiOiI2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60\n")},function(module,exports,__webpack_require__){eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(20);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzPzYyNmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///61\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar LIBRARY = __webpack_require__(19);\nvar $export = __webpack_require__(31);\nvar redefine = __webpack_require__(10);\nvar hide = __webpack_require__(5);\nvar Iterators = __webpack_require__(30);\nvar $iterCreate = __webpack_require__(64);\nvar setToStringTag = __webpack_require__(34);\nvar getPrototypeOf = __webpack_require__(69);\nvar ITERATOR = __webpack_require__(1)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcz8wMWY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLEVBQVk7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLEVBQVc7QUFDakMsZUFBZSxtQkFBTyxDQUFDLEVBQWE7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLENBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsRUFBYztBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFnQjtBQUMxQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFzQjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFlO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxDQUFRO0FBQy9CLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLGFBQWE7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0NBQW9DO0FBQzdFLDZDQUE2QyxvQ0FBb0M7QUFDakYsS0FBSyw0QkFBNEIsb0NBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsImZpbGUiOiI2Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///62\n")},function(module,exports,__webpack_require__){eval("// optional / simple context binding\nvar aFunction = __webpack_require__(43);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanM/OWI0MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///63\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar create = __webpack_require__(44);\nvar descriptor = __webpack_require__(16);\nvar setToStringTag = __webpack_require__(34);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(5)(IteratorPrototype, __webpack_require__(1)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcz80MWEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLEVBQWtCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLEVBQWtCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLEVBQXNCO0FBQ25EOztBQUVBO0FBQ0EsbUJBQU8sQ0FBQyxDQUFTLHFCQUFxQixtQkFBTyxDQUFDLENBQVEsNEJBQTRCLGFBQWEsRUFBRTs7QUFFakc7QUFDQSxxREFBcUQsNEJBQTRCO0FBQ2pGO0FBQ0EiLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///64\n")},function(module,exports,__webpack_require__){eval("var dP = __webpack_require__(7);\nvar anObject = __webpack_require__(2);\nvar getKeys = __webpack_require__(22);\n\nmodule.exports = __webpack_require__(4) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzPzE0OTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxtQkFBTyxDQUFDLENBQWM7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLENBQWM7QUFDckMsY0FBYyxtQkFBTyxDQUFDLEVBQWdCOztBQUV0QyxpQkFBaUIsbUJBQU8sQ0FBQyxDQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///65\n")},function(module,exports,__webpack_require__){eval("// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(11);\nvar toLength = __webpack_require__(23);\nvar toAbsoluteIndex = __webpack_require__(67);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcz9jMzY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLEVBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxZQUFZLGVBQWU7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiI2Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///66\n")},function(module,exports,__webpack_require__){eval("var toInteger = __webpack_require__(24);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcz83N2YxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///67\n")},function(module,exports,__webpack_require__){eval("var document = __webpack_require__(3).document;\nmodule.exports = document && document.documentElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzP2ZhYjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLENBQVc7QUFDbEMiLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///68\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(8);\nvar toObject = __webpack_require__(35);\nvar IE_PROTO = __webpack_require__(32)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzPzM4ZmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBUTtBQUMxQixlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsRUFBZTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///69\n")},function(module,exports,__webpack_require__){eval("var META = __webpack_require__(12)('meta');\nvar isObject = __webpack_require__(9);\nvar has = __webpack_require__(8);\nvar setDesc = __webpack_require__(7).f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !__webpack_require__(6)(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzPzY3YWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLEVBQVE7QUFDM0IsZUFBZSxtQkFBTyxDQUFDLENBQWM7QUFDckMsVUFBVSxtQkFBTyxDQUFDLENBQVE7QUFDMUIsY0FBYyxtQkFBTyxDQUFDLENBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsQ0FBVTtBQUNoQyxpREFBaUQ7QUFDakQsQ0FBQztBQUNEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsU0FBUztBQUNULEdBQUcsRUFBRTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3MC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///70\n")},function(module,exports,__webpack_require__){eval("// all enumerable object keys, includes symbols\nvar getKeys = __webpack_require__(22);\nvar gOPS = __webpack_require__(48);\nvar pIE = __webpack_require__(36);\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanM/ZDRjMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUFnQjtBQUN0QyxXQUFXLG1CQUFPLENBQUMsRUFBZ0I7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLEVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjcxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///71\n")},function(module,exports,__webpack_require__){eval("// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(20);\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcz8xMTY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLEVBQVE7QUFDMUI7QUFDQTtBQUNBIiwiZmlsZSI6IjcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///72\n")},function(module,exports,__webpack_require__){eval("// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = __webpack_require__(11);\nvar gOPN = __webpack_require__(49).f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanM/N2JiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkMsV0FBVyxtQkFBTyxDQUFDLEVBQWdCO0FBQ25DLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///73\n")},function(module,exports,__webpack_require__){eval("var pIE = __webpack_require__(36);\nvar createDesc = __webpack_require__(16);\nvar toIObject = __webpack_require__(11);\nvar toPrimitive = __webpack_require__(27);\nvar has = __webpack_require__(8);\nvar IE8_DOM_DEFINE = __webpack_require__(41);\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(4) ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcz8xMWU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxFQUFlO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLEVBQWtCO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsRUFBaUI7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLENBQVE7QUFDMUIscUJBQXFCLG1CQUFPLENBQUMsRUFBbUI7QUFDaEQ7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLENBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZO0FBQ2Y7QUFDQSIsImZpbGUiOiI3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///74\n")},function(module,exports,__webpack_require__){eval("// 7.2.8 IsRegExp(argument)\nvar isObject = __webpack_require__(9);\nvar cof = __webpack_require__(20);\nvar MATCH = __webpack_require__(1)('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanM/YWFlMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxDQUFjO0FBQ3JDLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCLFlBQVksbUJBQU8sQ0FBQyxDQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijc1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///75\n")},function(module,exports,__webpack_require__){eval("// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = __webpack_require__(2);\nvar aFunction = __webpack_require__(43);\nvar SPECIES = __webpack_require__(1)('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzP2ViZDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxDQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76\n")},function(module,exports,__webpack_require__){eval("var toInteger = __webpack_require__(24);\nvar defined = __webpack_require__(21);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanM/MDJmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///77\n")},function(module,exports,__webpack_require__){eval("// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(20);\nvar TAG = __webpack_require__(1)('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzPzIzYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQixVQUFVLG1CQUFPLENBQUMsQ0FBUTtBQUMxQjtBQUNBLDJCQUEyQixrQkFBa0IsRUFBRTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFlBQVk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///78\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar regexpExec = __webpack_require__(39);\n__webpack_require__(31)({\n  target: 'RegExp',\n  proto: true,\n  forced: regexpExec !== /./.exec\n}, {\n  exec: regexpExec\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qcz9iMGM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsRUFBZ0I7QUFDekMsbUJBQU8sQ0FBQyxFQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMiLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5yZXF1aXJlKCcuL19leHBvcnQnKSh7XG4gIHRhcmdldDogJ1JlZ0V4cCcsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IHJlZ2V4cEV4ZWMgIT09IC8uLy5leGVjXG59LCB7XG4gIGV4ZWM6IHJlZ2V4cEV4ZWNcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///79\n")},function(module,exports,__webpack_require__){eval("var BlankNode = __webpack_require__(81)\nvar DefaultGraph = __webpack_require__(50)\nvar Literal = __webpack_require__(82)\nvar NamedNode = __webpack_require__(51)\nvar Quad = __webpack_require__(83)\nvar Variable = __webpack_require__(84)\n\nfunction DataFactory () {}\n\nDataFactory.namedNode = function (value) {\n  return new NamedNode(value)\n}\n\nDataFactory.blankNode = function (value) {\n  return new BlankNode(value)\n}\n\nDataFactory.literal = function (value, languageOrDatatype) {\n  if (typeof languageOrDatatype === 'string') {\n    if (languageOrDatatype.indexOf(':') === -1) {\n      return new Literal(value, languageOrDatatype)\n    }\n\n    return new Literal(value, null, DataFactory.namedNode(languageOrDatatype))\n  }\n\n  return new Literal(value, null, languageOrDatatype)\n}\n\nDataFactory.defaultGraph = function () {\n  return DataFactory.defaultGraphInstance\n}\n\nDataFactory.variable = function (value) {\n  return new Variable(value)\n}\n\nDataFactory.triple = function (subject, predicate, object) {\n  return DataFactory.quad(subject, predicate, object)\n}\n\nDataFactory.quad = function (subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph || DataFactory.defaultGraphInstance)\n}\n\nDataFactory.defaultGraphInstance = new DefaultGraph()\n\nmodule.exports = DataFactory\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL2RhdGEtZmFjdG9yeS5qcz8zY2YxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWM7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsRUFBaUI7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLEVBQVc7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsRUFBYztBQUN0QyxXQUFXLG1CQUFPLENBQUMsRUFBUTtBQUMzQixlQUFlLG1CQUFPLENBQUMsRUFBWTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiODAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQmxhbmtOb2RlID0gcmVxdWlyZSgnLi9ibGFuay1ub2RlJylcbnZhciBEZWZhdWx0R3JhcGggPSByZXF1aXJlKCcuL2RlZmF1bHQtZ3JhcGgnKVxudmFyIExpdGVyYWwgPSByZXF1aXJlKCcuL2xpdGVyYWwnKVxudmFyIE5hbWVkTm9kZSA9IHJlcXVpcmUoJy4vbmFtZWQtbm9kZScpXG52YXIgUXVhZCA9IHJlcXVpcmUoJy4vcXVhZCcpXG52YXIgVmFyaWFibGUgPSByZXF1aXJlKCcuL3ZhcmlhYmxlJylcblxuZnVuY3Rpb24gRGF0YUZhY3RvcnkgKCkge31cblxuRGF0YUZhY3RvcnkubmFtZWROb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgTmFtZWROb2RlKHZhbHVlKVxufVxuXG5EYXRhRmFjdG9yeS5ibGFua05vZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBCbGFua05vZGUodmFsdWUpXG59XG5cbkRhdGFGYWN0b3J5LmxpdGVyYWwgPSBmdW5jdGlvbiAodmFsdWUsIGxhbmd1YWdlT3JEYXRhdHlwZSkge1xuICBpZiAodHlwZW9mIGxhbmd1YWdlT3JEYXRhdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAobGFuZ3VhZ2VPckRhdGF0eXBlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbCh2YWx1ZSwgbGFuZ3VhZ2VPckRhdGF0eXBlKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTGl0ZXJhbCh2YWx1ZSwgbnVsbCwgRGF0YUZhY3RvcnkubmFtZWROb2RlKGxhbmd1YWdlT3JEYXRhdHlwZSkpXG4gIH1cblxuICByZXR1cm4gbmV3IExpdGVyYWwodmFsdWUsIG51bGwsIGxhbmd1YWdlT3JEYXRhdHlwZSlcbn1cblxuRGF0YUZhY3RvcnkuZGVmYXVsdEdyYXBoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0YUZhY3RvcnkuZGVmYXVsdEdyYXBoSW5zdGFuY2Vcbn1cblxuRGF0YUZhY3RvcnkudmFyaWFibGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBWYXJpYWJsZSh2YWx1ZSlcbn1cblxuRGF0YUZhY3RvcnkudHJpcGxlID0gZnVuY3Rpb24gKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KSB7XG4gIHJldHVybiBEYXRhRmFjdG9yeS5xdWFkKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KVxufVxuXG5EYXRhRmFjdG9yeS5xdWFkID0gZnVuY3Rpb24gKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICByZXR1cm4gbmV3IFF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoIHx8IERhdGFGYWN0b3J5LmRlZmF1bHRHcmFwaEluc3RhbmNlKVxufVxuXG5EYXRhRmFjdG9yeS5kZWZhdWx0R3JhcGhJbnN0YW5jZSA9IG5ldyBEZWZhdWx0R3JhcGgoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFGYWN0b3J5XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///80\n")},function(module,exports){eval("function BlankNode (id) {\n  this.value = id || ('b' + (++BlankNode.nextId))\n}\n\nBlankNode.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nBlankNode.prototype.termType = 'BlankNode'\n\nBlankNode.nextId = 0\n\nmodule.exports = BlankNode\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL2JsYW5rLW5vZGUuanM/NDdiNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwiZmlsZSI6IjgxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gQmxhbmtOb2RlIChpZCkge1xuICB0aGlzLnZhbHVlID0gaWQgfHwgKCdiJyArICgrK0JsYW5rTm9kZS5uZXh0SWQpKVxufVxuXG5CbGFua05vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICByZXR1cm4gISFvdGhlciAmJiBvdGhlci50ZXJtVHlwZSA9PT0gdGhpcy50ZXJtVHlwZSAmJiBvdGhlci52YWx1ZSA9PT0gdGhpcy52YWx1ZVxufVxuXG5CbGFua05vZGUucHJvdG90eXBlLnRlcm1UeXBlID0gJ0JsYW5rTm9kZSdcblxuQmxhbmtOb2RlLm5leHRJZCA9IDBcblxubW9kdWxlLmV4cG9ydHMgPSBCbGFua05vZGVcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///81\n")},function(module,exports,__webpack_require__){eval("var NamedNode = __webpack_require__(51)\n\nfunction Literal (value, language, datatype) {\n  this.value = value\n  this.datatype = Literal.stringDatatype\n  this.language = ''\n\n  if (language) {\n    this.language = language\n    this.datatype = Literal.langStringDatatype\n  } else if (datatype) {\n    this.datatype = datatype\n  }\n}\n\nLiteral.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value &&\n    other.language === this.language && other.datatype.equals(this.datatype)\n}\n\nLiteral.prototype.termType = 'Literal'\nLiteral.langStringDatatype = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')\nLiteral.stringDatatype = new NamedNode('http://www.w3.org/2001/XMLSchema#string')\n\nmodule.exports = Literal\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL2xpdGVyYWwuanM/NWFmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFjOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI4Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBOYW1lZE5vZGUgPSByZXF1aXJlKCcuL25hbWVkLW5vZGUnKVxuXG5mdW5jdGlvbiBMaXRlcmFsICh2YWx1ZSwgbGFuZ3VhZ2UsIGRhdGF0eXBlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB0aGlzLmRhdGF0eXBlID0gTGl0ZXJhbC5zdHJpbmdEYXRhdHlwZVxuICB0aGlzLmxhbmd1YWdlID0gJydcblxuICBpZiAobGFuZ3VhZ2UpIHtcbiAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2VcbiAgICB0aGlzLmRhdGF0eXBlID0gTGl0ZXJhbC5sYW5nU3RyaW5nRGF0YXR5cGVcbiAgfSBlbHNlIGlmIChkYXRhdHlwZSkge1xuICAgIHRoaXMuZGF0YXR5cGUgPSBkYXRhdHlwZVxuICB9XG59XG5cbkxpdGVyYWwucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICByZXR1cm4gISFvdGhlciAmJiBvdGhlci50ZXJtVHlwZSA9PT0gdGhpcy50ZXJtVHlwZSAmJiBvdGhlci52YWx1ZSA9PT0gdGhpcy52YWx1ZSAmJlxuICAgIG90aGVyLmxhbmd1YWdlID09PSB0aGlzLmxhbmd1YWdlICYmIG90aGVyLmRhdGF0eXBlLmVxdWFscyh0aGlzLmRhdGF0eXBlKVxufVxuXG5MaXRlcmFsLnByb3RvdHlwZS50ZXJtVHlwZSA9ICdMaXRlcmFsJ1xuTGl0ZXJhbC5sYW5nU3RyaW5nRGF0YXR5cGUgPSBuZXcgTmFtZWROb2RlKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjbGFuZ1N0cmluZycpXG5MaXRlcmFsLnN0cmluZ0RhdGF0eXBlID0gbmV3IE5hbWVkTm9kZSgnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjc3RyaW5nJylcblxubW9kdWxlLmV4cG9ydHMgPSBMaXRlcmFsXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///82\n")},function(module,exports,__webpack_require__){eval("var DefaultGraph = __webpack_require__(50)\n\nfunction Quad (subject, predicate, object, graph) {\n  this.subject = subject\n  this.predicate = predicate\n  this.object = object\n\n  if (graph) {\n    this.graph = graph\n  } else {\n    this.graph = new DefaultGraph()\n  }\n}\n\nQuad.prototype.equals = function (other) {\n  return !!other && other.subject.equals(this.subject) && other.predicate.equals(this.predicate) &&\n    other.object.equals(this.object) && other.graph.equals(this.graph)\n}\n\nmodule.exports = Quad\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL3F1YWQuanM/ZTFjYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiODMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGVmYXVsdEdyYXBoID0gcmVxdWlyZSgnLi9kZWZhdWx0LWdyYXBoJylcblxuZnVuY3Rpb24gUXVhZCAoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gIHRoaXMuc3ViamVjdCA9IHN1YmplY3RcbiAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGVcbiAgdGhpcy5vYmplY3QgPSBvYmplY3RcblxuICBpZiAoZ3JhcGgpIHtcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGhcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdyYXBoID0gbmV3IERlZmF1bHRHcmFwaCgpXG4gIH1cbn1cblxuUXVhZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiAhIW90aGVyICYmIG90aGVyLnN1YmplY3QuZXF1YWxzKHRoaXMuc3ViamVjdCkgJiYgb3RoZXIucHJlZGljYXRlLmVxdWFscyh0aGlzLnByZWRpY2F0ZSkgJiZcbiAgICBvdGhlci5vYmplY3QuZXF1YWxzKHRoaXMub2JqZWN0KSAmJiBvdGhlci5ncmFwaC5lcXVhbHModGhpcy5ncmFwaClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWFkXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///83\n")},function(module,exports){eval("function Variable (name) {\n  this.value = name\n}\n\nVariable.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nVariable.prototype.termType = 'Variable'\n\nmodule.exports = Variable\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL3ZhcmlhYmxlLmpzP2E1NWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiI4NC5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFZhcmlhYmxlIChuYW1lKSB7XG4gIHRoaXMudmFsdWUgPSBuYW1lXG59XG5cblZhcmlhYmxlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuICEhb3RoZXIgJiYgb3RoZXIudGVybVR5cGUgPT09IHRoaXMudGVybVR5cGUgJiYgb3RoZXIudmFsdWUgPT09IHRoaXMudmFsdWVcbn1cblxuVmFyaWFibGUucHJvdG90eXBlLnRlcm1UeXBlID0gJ1ZhcmlhYmxlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhcmlhYmxlXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///84\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar anObject = __webpack_require__(2);\nvar toLength = __webpack_require__(23);\nvar advanceStringIndex = __webpack_require__(37);\nvar regExpExec = __webpack_require__(38);\n\n// @@match logic\n__webpack_require__(40)('match', 1, function (defined, MATCH, $match, maybeCallNative) {\n  return [\n    // `String.prototype.match` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.match\n    function match(regexp) {\n      var O = defined(this);\n      var fn = regexp == undefined ? undefined : regexp[MATCH];\n      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n    },\n    // `RegExp.prototype[@@match]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match\n    function (regexp) {\n      var res = maybeCallNative($match, regexp, this);\n      if (res.done) return res.value;\n      var rx = anObject(regexp);\n      var S = String(this);\n      if (!rx.global) return regExpExec(rx, S);\n      var fullUnicode = rx.unicode;\n      rx.lastIndex = 0;\n      var A = [];\n      var n = 0;\n      var result;\n      while ((result = regExpExec(rx, S)) !== null) {\n        var matchStr = String(result[0]);\n        A[n] = matchStr;\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n        n++;\n      }\n      return n === 0 ? null : A;\n    }\n  ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanM/NDkxNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyx5QkFBeUIsbUJBQU8sQ0FBQyxFQUF5QjtBQUMxRCxpQkFBaUIsbUJBQU8sQ0FBQyxFQUF5Qjs7QUFFbEQ7QUFDQSxtQkFBTyxDQUFDLEVBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ijg1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgICBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQG1hdGNoXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkbWF0Y2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoIXJ4Lmdsb2JhbCkgcmV0dXJuIHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUykpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBBW25dID0gbWF0Y2hTdHI7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuID09PSAwID8gbnVsbCA6IEE7XG4gICAgfVxuICBdO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///85\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/css/bootstrap/bootstrap.min.css\nvar bootstrap_min = __webpack_require__(53);\n\n// EXTERNAL MODULE: ./src/styles.css\nvar src_styles = __webpack_require__(54);\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.to-string.js\nvar es6_regexp_to_string = __webpack_require__(55);\n\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/dom.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * True if the custom elements polyfill is in use.\n */\nconst isCEPolyfill = typeof window !== \'undefined\' &&\n    window.customElements != null &&\n    window.customElements.polyfillWrapFlushCallback !==\n        undefined;\n/**\n * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),\n * into another container (could be the same container), before `before`. If\n * `before` is null, it appends the nodes to the container.\n */\nconst reparentNodes = (container, start, end = null, before = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.insertBefore(start, before);\n        start = n;\n    }\n};\n/**\n * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from\n * `container`.\n */\nconst removeNodes = (container, start, end = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.removeChild(start);\n        start = n;\n    }\n};\n//# sourceMappingURL=dom.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nconst nodeMarker = `\x3c!--${marker}--\x3e`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\nconst boundAttributeSuffix = \'$lit$\';\n/**\n * An updatable Template that tracks the location of dynamic parts.\n */\nclass Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const nodesToRemove = [];\n        const stack = [];\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        // Keeps track of the last index associated with a part. We try to delete\n        // unnecessary nodes, but we never want to associate two different parts\n        // to the same index. They must have a constant node between.\n        let lastPartIndex = 0;\n        let index = -1;\n        let partIndex = 0;\n        const { strings, values: { length } } = result;\n        while (partIndex < length) {\n            const node = walker.nextNode();\n            if (node === null) {\n                // We\'ve exhausted the content inside a nested template element.\n                // Because we still have parts (the outer for-loop), we know:\n                // - There is a template in the stack\n                // - The walker will find a nextNode outside the template\n                walker.currentNode = stack.pop();\n                continue;\n            }\n            index++;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (node.hasAttributes()) {\n                    const attributes = node.attributes;\n                    const { length } = attributes;\n                    // Per\n                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                    // attributes are not guaranteed to be returned in document order.\n                    // In particular, Edge/IE can return them out of order, so we cannot\n                    // assume a correspondence between part index and attribute index.\n                    let count = 0;\n                    for (let i = 0; i < length; i++) {\n                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n                            count++;\n                        }\n                    }\n                    while (count-- > 0) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute\n                        const stringForPart = strings[partIndex];\n                        // Find the attribute name\n                        const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                        // Find the corresponding attribute\n                        // All bound attributes have had a suffix added in\n                        // TemplateResult#getHTML to opt out of special attribute\n                        // handling. To look up the attribute value we also need to add\n                        // the suffix.\n                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n                        const attributeValue = node.getAttribute(attributeLookupName);\n                        node.removeAttribute(attributeLookupName);\n                        const statics = attributeValue.split(markerRegex);\n                        this.parts.push({ type: \'attribute\', index, name, strings: statics });\n                        partIndex += statics.length - 1;\n                    }\n                }\n                if (node.tagName === \'TEMPLATE\') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const data = node.data;\n                if (data.indexOf(marker) >= 0) {\n                    const parent = node.parentNode;\n                    const strings = data.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        let insert;\n                        let s = strings[i];\n                        if (s === \'\') {\n                            insert = createMarker();\n                        }\n                        else {\n                            const match = lastAttributeNameRegex.exec(s);\n                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                                s = s.slice(0, match.index) + match[1] +\n                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];\n                            }\n                            insert = document.createTextNode(s);\n                        }\n                        parent.insertBefore(insert, node);\n                        this.parts.push({ type: \'node\', index: ++index });\n                    }\n                    // If there\'s no text, we must insert a comment to mark our place.\n                    // Else, we can trust it will stick around after cloning.\n                    if (strings[lastIndex] === \'\') {\n                        parent.insertBefore(createMarker(), node);\n                        nodesToRemove.push(node);\n                    }\n                    else {\n                        node.data = strings[lastIndex];\n                    }\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                if (node.data === marker) {\n                    const parent = node.parentNode;\n                    // Add a new marker node to be the startNode of the Part if any of\n                    // the following are true:\n                    //  * We don\'t have a previousSibling\n                    //  * The previousSibling is already the start of a previous part\n                    if (node.previousSibling === null || index === lastPartIndex) {\n                        index++;\n                        parent.insertBefore(createMarker(), node);\n                    }\n                    lastPartIndex = index;\n                    this.parts.push({ type: \'node\', index });\n                    // If we don\'t have a nextSibling, keep this node so we have an end.\n                    // Else, we can remove it to save future costs.\n                    if (node.nextSibling === null) {\n                        node.data = \'\';\n                    }\n                    else {\n                        nodesToRemove.push(node);\n                        index--;\n                    }\n                    partIndex++;\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won\'t work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it\'s even worth it to\n                        // make bindings in comments work\n                        this.parts.push({ type: \'node\', index: -1 });\n                        partIndex++;\n                    }\n                }\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nconst endsWith = (str, suffix) => {\n    const index = str.length - suffix.length;\n    return index >= 0 && str.slice(index) === suffix;\n};\nconst isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment(\'\')` to be renamed for a\n// small manual size-savings.\nconst createMarker = () => document.createComment(\'\');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * " \\x09\\x0a\\x0c\\x0d" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * "\\0-\\x1F\\x7F-\\x9F" are Unicode control characters, which includes every\n * space character except " ".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, (\'),\n *    ("), ">", "=", or "/"\n *  * Followed by zero or more space characters\n *  * Followed by "="\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, (\'), ("), "<", ">", "=", (`), or\n *    * (") then any non-("), or\n *    * (\') then any non-(\')\n */\nconst lastAttributeNameRegex = \n// eslint-disable-next-line no-control-regex\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F "\'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d"\'`<>=]*|"[^"]*|\'[^\']*))$/;\n//# sourceMappingURL=template.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/modify-template.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module shady-render\n */\n\nconst walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\nfunction removeNodesFromTemplate(template, nodesToRemove) {\n    const { element: { content }, parts } = template;\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let part = parts[partIndex];\n    let nodeIndex = -1;\n    let removeCount = 0;\n    const nodesToRemoveInTemplate = [];\n    let currentRemovingNode = null;\n    while (walker.nextNode()) {\n        nodeIndex++;\n        const node = walker.currentNode;\n        // End removal if stepped past the removing node\n        if (node.previousSibling === currentRemovingNode) {\n            currentRemovingNode = null;\n        }\n        // A node to remove was found in the template\n        if (nodesToRemove.has(node)) {\n            nodesToRemoveInTemplate.push(node);\n            // Track node we\'re removing\n            if (currentRemovingNode === null) {\n                currentRemovingNode = node;\n            }\n        }\n        // When removing, increment count by which to adjust subsequent part indices\n        if (currentRemovingNode !== null) {\n            removeCount++;\n        }\n        while (part !== undefined && part.index === nodeIndex) {\n            // If part is in a removed node deactivate it by setting index to -1 or\n            // adjust the index as needed.\n            part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n            // go to the next active part.\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n            part = parts[partIndex];\n        }\n    }\n    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));\n}\nconst countNodes = (node) => {\n    let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;\n    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n    while (walker.nextNode()) {\n        count++;\n    }\n    return count;\n};\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\n    for (let i = startIndex + 1; i < parts.length; i++) {\n        const part = parts[i];\n        if (isTemplatePartActive(part)) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nfunction insertNodeIntoTemplate(template, node, refNode = null) {\n    const { element: { content }, parts } = template;\n    // If there\'s no refNode, then put node at end of template.\n    // No part indices need to be shifted in this case.\n    if (refNode === null || refNode === undefined) {\n        content.appendChild(node);\n        return;\n    }\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let insertCount = 0;\n    let walkerIndex = -1;\n    while (walker.nextNode()) {\n        walkerIndex++;\n        const walkerNode = walker.currentNode;\n        if (walkerNode === refNode) {\n            insertCount = countNodes(node);\n            refNode.parentNode.insertBefore(node, refNode);\n        }\n        while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n            // If we\'ve inserted the node, simply adjust all subsequent parts\n            if (insertCount > 0) {\n                while (partIndex !== -1) {\n                    parts[partIndex].index += insertCount;\n                    partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n                }\n                return;\n            }\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n    }\n}\n//# sourceMappingURL=modify-template.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/directive.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst directives = new WeakMap();\n/**\n * Brands a function as a directive factory function so that lit-html will call\n * the function during template rendering, rather than passing as a value.\n *\n * A _directive_ is a function that takes a Part as an argument. It has the\n * signature: `(part: Part) => void`.\n *\n * A directive _factory_ is a function that takes arguments for data and\n * configuration and returns a directive. Users of directive usually refer to\n * the directive factory as the directive. For example, "The repeat directive".\n *\n * Usually a template author will invoke a directive factory in their template\n * with relevant arguments, which will then return a directive function.\n *\n * Here\'s an example of using the `repeat()` directive factory that takes an\n * array and a function to render an item:\n *\n * ```js\n * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`\n * ```\n *\n * When `repeat` is invoked, it returns a directive function that closes over\n * `items` and the template function. When the outer template is rendered, the\n * return directive function is called with the Part for the expression.\n * `repeat` then performs it\'s custom logic to render multiple items.\n *\n * @param f The directive factory function. Must be a function that returns a\n * function of the signature `(part: Part) => void`. The returned function will\n * be called with the part object.\n *\n * @example\n *\n * import {directive, html} from \'lit-html\';\n *\n * const immutable = directive((v) => (part) => {\n *   if (part.value !== v) {\n *     part.setValue(v)\n *   }\n * });\n */\nconst directive_directive = (f) => ((...args) => {\n    const d = f(...args);\n    directives.set(d, true);\n    return d;\n});\nconst isDirective = (o) => {\n    return typeof o === \'function\' && directives.has(o);\n};\n//# sourceMappingURL=directive.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/part.js\n/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nconst noChange = {};\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\nconst nothing = {};\n//# sourceMappingURL=part.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-instance.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nclass template_instance_TemplateInstance {\n    constructor(template, processor, options) {\n        this.__parts = [];\n        this.template = template;\n        this.processor = processor;\n        this.options = options;\n    }\n    update(values) {\n        let i = 0;\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.setValue(values[i]);\n            }\n            i++;\n        }\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.commit();\n            }\n        }\n    }\n    _clone() {\n        // There are a number of steps in the lifecycle of a template instance\'s\n        // DOM fragment:\n        //  1. Clone - create the instance fragment\n        //  2. Adopt - adopt into the main document\n        //  3. Process - find part markers and create parts\n        //  4. Upgrade - upgrade custom elements\n        //  5. Update - set node, attribute, property, etc., values\n        //  6. Connect - connect to the document. Optional and outside of this\n        //     method.\n        //\n        // We have a few constraints on the ordering of these steps:\n        //  * We need to upgrade before updating, so that property values will pass\n        //    through any property setters.\n        //  * We would like to process before upgrading so that we\'re sure that the\n        //    cloned fragment is inert and not disturbed by self-modifying DOM.\n        //  * We want custom elements to upgrade even in disconnected fragments.\n        //\n        // Given these constraints, with full custom elements support we would\n        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n        //\n        // But Safari does not implement CustomElementRegistry#upgrade, so we\n        // can not implement that order and still have upgrade-before-update and\n        // upgrade disconnected fragments. So we instead sacrifice the\n        // process-before-upgrade constraint, since in Custom Elements v1 elements\n        // must not modify their light DOM in the constructor. We still have issues\n        // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n        // that don\'t strictly adhere to the no-modification rule because shadow\n        // DOM, which may be created in the constructor, is emulated by being placed\n        // in the light DOM.\n        //\n        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n        // in one step.\n        //\n        // The Custom Elements v1 polyfill supports upgrade(), so the order when\n        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n        // Connect.\n        const fragment = isCEPolyfill ?\n            this.template.element.content.cloneNode(true) :\n            document.importNode(this.template.element.content, true);\n        const stack = [];\n        const parts = this.template.parts;\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        let partIndex = 0;\n        let nodeIndex = 0;\n        let part;\n        let node = walker.nextNode();\n        // Loop through all the nodes and parts of a template\n        while (partIndex < parts.length) {\n            part = parts[partIndex];\n            if (!isTemplatePartActive(part)) {\n                this.__parts.push(undefined);\n                partIndex++;\n                continue;\n            }\n            // Progress the tree walker until we find our next part\'s node.\n            // Note that multiple parts may share the same node (attribute parts\n            // on a single element), so this loop may not run at all.\n            while (nodeIndex < part.index) {\n                nodeIndex++;\n                if (node.nodeName === \'TEMPLATE\') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n                if ((node = walker.nextNode()) === null) {\n                    // We\'ve exhausted the content inside a nested template element.\n                    // Because we still have parts (the outer for-loop), we know:\n                    // - There is a template in the stack\n                    // - The walker will find a nextNode outside the template\n                    walker.currentNode = stack.pop();\n                    node = walker.nextNode();\n                }\n            }\n            // We\'ve arrived at our part\'s node.\n            if (part.type === \'node\') {\n                const part = this.processor.handleTextExpression(this.options);\n                part.insertAfterNode(node.previousSibling);\n                this.__parts.push(part);\n            }\n            else {\n                this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n            }\n            partIndex++;\n        }\n        if (isCEPolyfill) {\n            document.adoptNode(fragment);\n            customElements.upgrade(fragment);\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=template-instance.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-result.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\nconst commentMarker = ` ${marker} `;\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nclass template_result_TemplateResult {\n    constructor(strings, values, type, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.processor = processor;\n    }\n    /**\n     * Returns a string of HTML used to create a `<template>` element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = \'\';\n        let isCommentBinding = false;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            // For each binding we want to determine the kind of marker to insert\n            // into the template source before it\'s parsed by the browser\'s HTML\n            // parser. The marker type is based on whether the expression is in an\n            // attribute, text, or comment position.\n            //   * For node-position bindings we insert a comment with the marker\n            //     sentinel as its text content, like \x3c!--{{lit-guid}}--\x3e.\n            //   * For attribute bindings we insert just the marker sentinel for the\n            //     first binding, so that we support unquoted attribute bindings.\n            //     Subsequent bindings can use a comment marker because multi-binding\n            //     attributes must be quoted.\n            //   * For comment bindings we insert just the marker sentinel so we don\'t\n            //     close the comment.\n            //\n            // The following code scans the template source, but is *not* an HTML\n            // parser. We don\'t need to track the tree structure of the HTML, only\n            // whether a binding is inside a comment, and if not, if it appears to be\n            // the first binding in an attribute.\n            const commentOpen = s.lastIndexOf(\'\x3c!--\');\n            // We\'re in comment position if we have a comment open with no following\n            // comment close. Because <-- can appear in an attribute value there can\n            // be false positives.\n            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&\n                s.indexOf(\'--\x3e\', commentOpen + 1) === -1;\n            // Check to see if we have an attribute-like sequence preceding the\n            // expression. This can match "name=value" like structures in text,\n            // comments, and attribute values, so there can be false-positives.\n            const attributeMatch = lastAttributeNameRegex.exec(s);\n            if (attributeMatch === null) {\n                // We\'re only in this branch if we don\'t have a attribute-like\n                // preceding sequence. For comments, this guards against unusual\n                // attribute values like <div foo="\x3c!--${\'bar\'}">. Cases like\n                // \x3c!-- foo=${\'bar\'}--\x3e are handled correctly in the attribute branch\n                // below.\n                html += s + (isCommentBinding ? commentMarker : nodeMarker);\n            }\n            else {\n                // For attributes we use just a marker sentinel, and also append a\n                // $lit$ suffix to the name to opt-out of attribute-specific parsing\n                // that IE and Edge do for style and certain SVG attributes.\n                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +\n                    attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +\n                    marker;\n            }\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement(\'template\');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTML in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nclass template_result_SVGTemplateResult extends template_result_TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n//# sourceMappingURL=template-result.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/parts.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\n\n\n\n\nconst isPrimitive = (value) => {\n    return (value === null ||\n        !(typeof value === \'object\' || typeof value === \'function\'));\n};\nconst isIterable = (value) => {\n    return Array.isArray(value) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        !!(value && value[Symbol.iterator]);\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nclass AttributeCommitter {\n    constructor(element, name, strings) {\n        this.dirty = true;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.parts = [];\n        for (let i = 0; i < strings.length - 1; i++) {\n            this.parts[i] = this._createPart();\n        }\n    }\n    /**\n     * Creates a single part. Override this to create a differnt type of part.\n     */\n    _createPart() {\n        return new parts_AttributePart(this);\n    }\n    _getValue() {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = \'\';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const part = this.parts[i];\n            if (part !== undefined) {\n                const v = part.value;\n                if (isPrimitive(v) || !isIterable(v)) {\n                    text += typeof v === \'string\' ? v : String(v);\n                }\n                else {\n                    for (const t of v) {\n                        text += typeof t === \'string\' ? t : String(t);\n                    }\n                }\n            }\n        }\n        text += strings[l];\n        return text;\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element.setAttribute(this.name, this._getValue());\n        }\n    }\n}\n/**\n * A Part that controls all or part of an attribute value.\n */\nclass parts_AttributePart {\n    constructor(committer) {\n        this.value = undefined;\n        this.committer = committer;\n    }\n    setValue(value) {\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n            this.value = value;\n            // If the value is a not a directive, dirty the committer so that it\'ll\n            // call setAttribute. If the value is a directive, it\'ll dirty the\n            // committer if it calls setValue().\n            if (!isDirective(value)) {\n                this.committer.dirty = true;\n            }\n        }\n    }\n    commit() {\n        while (isDirective(this.value)) {\n            const directive = this.value;\n            this.value = noChange;\n            directive(this);\n        }\n        if (this.value === noChange) {\n            return;\n        }\n        this.committer.commit();\n    }\n}\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nclass parts_NodePart {\n    constructor(options) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.options = options;\n    }\n    /**\n     * Appends this part into a container.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendInto(container) {\n        this.startNode = container.appendChild(createMarker());\n        this.endNode = container.appendChild(createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` node (between `ref` and `ref`\'s next\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n     * such as those that appear in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterNode(ref) {\n        this.startNode = ref;\n        this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendIntoPart(part) {\n        part.__insert(this.startNode = createMarker());\n        part.__insert(this.endNode = createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterPart(ref) {\n        ref.__insert(this.startNode = createMarker());\n        this.endNode = ref.endNode;\n        ref.endNode = this.startNode;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        if (this.startNode.parentNode === null) {\n            return;\n        }\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        const value = this.__pendingValue;\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitive(value)) {\n            if (value !== this.value) {\n                this.__commitText(value);\n            }\n        }\n        else if (value instanceof template_result_TemplateResult) {\n            this.__commitTemplateResult(value);\n        }\n        else if (value instanceof Node) {\n            this.__commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this.__commitIterable(value);\n        }\n        else if (value === nothing) {\n            this.value = nothing;\n            this.clear();\n        }\n        else {\n            // Fallback, will render the string representation\n            this.__commitText(value);\n        }\n    }\n    __insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    __commitNode(value) {\n        if (this.value === value) {\n            return;\n        }\n        this.clear();\n        this.__insert(value);\n        this.value = value;\n    }\n    __commitText(value) {\n        const node = this.startNode.nextSibling;\n        value = value == null ? \'\' : value;\n        // If `value` isn\'t already a string, we explicitly convert it here in case\n        // it can\'t be implicitly converted - i.e. it\'s a symbol.\n        const valueAsString = typeof value === \'string\' ? value : String(value);\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === 3 /* Node.TEXT_NODE */) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\n            node.data = valueAsString;\n        }\n        else {\n            this.__commitNode(document.createTextNode(valueAsString));\n        }\n        this.value = value;\n    }\n    __commitTemplateResult(value) {\n        const template = this.options.templateFactory(value);\n        if (this.value instanceof template_instance_TemplateInstance &&\n            this.value.template === template) {\n            this.value.update(value.values);\n        }\n        else {\n            // Make sure we propagate the template processor from the TemplateResult\n            // so that we use its syntax extension, etc. The template factory comes\n            // from the render function options so that it can control template\n            // caching and preprocessing.\n            const instance = new template_instance_TemplateInstance(template, value.processor, this.options);\n            const fragment = instance._clone();\n            instance.update(value.values);\n            this.__commitNode(fragment);\n            this.value = instance;\n        }\n    }\n    __commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _value is an array, then the previous render was of an\n        // iterable and _value will contain the NodeParts from the previous\n        // render. If _value is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this.value)) {\n            this.value = [];\n            this.clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this.value;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            // Try to reuse an existing part\n            itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                itemPart = new parts_NodePart(this.options);\n                itemParts.push(itemPart);\n                if (partIndex === 0) {\n                    itemPart.appendIntoPart(this);\n                }\n                else {\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\n                }\n            }\n            itemPart.setValue(item);\n            itemPart.commit();\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n            this.clear(itemPart && itemPart.endNode);\n        }\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * \'\'. If the value is falsey, the attribute is removed.\n */\nclass parts_BooleanAttributePart {\n    constructor(element, name, strings) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        if (strings.length !== 2 || strings[0] !== \'\' || strings[1] !== \'\') {\n            throw new Error(\'Boolean attributes can only contain a single expression\');\n        }\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const value = !!this.__pendingValue;\n        if (this.value !== value) {\n            if (value) {\n                this.element.setAttribute(this.name, \'\');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n            this.value = value;\n        }\n        this.__pendingValue = noChange;\n    }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nclass PropertyCommitter extends AttributeCommitter {\n    constructor(element, name, strings) {\n        super(element, name, strings);\n        this.single =\n            (strings.length === 2 && strings[0] === \'\' && strings[1] === \'\');\n    }\n    _createPart() {\n        return new PropertyPart(this);\n    }\n    _getValue() {\n        if (this.single) {\n            return this.parts[0].value;\n        }\n        return super._getValue();\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.element[this.name] = this._getValue();\n        }\n    }\n}\nclass PropertyPart extends parts_AttributePart {\n}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n(() => {\n    try {\n        const options = {\n            get capture() {\n                eventOptionsSupported = true;\n                return false;\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        window.addEventListener(\'test\', options, options);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        window.removeEventListener(\'test\', options, options);\n    }\n    catch (_e) {\n        // event options not supported\n    }\n})();\nclass parts_EventPart {\n    constructor(element, eventName, eventContext) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.element = element;\n        this.eventName = eventName;\n        this.eventContext = eventContext;\n        this.__boundHandleEvent = (e) => this.handleEvent(e);\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const newListener = this.__pendingValue;\n        const oldListener = this.value;\n        const shouldRemoveListener = newListener == null ||\n            oldListener != null &&\n                (newListener.capture !== oldListener.capture ||\n                    newListener.once !== oldListener.once ||\n                    newListener.passive !== oldListener.passive);\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        if (shouldAddListener) {\n            this.__options = getOptions(newListener);\n            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        this.value = newListener;\n        this.__pendingValue = noChange;\n    }\n    handleEvent(event) {\n        if (typeof this.value === \'function\') {\n            this.value.call(this.eventContext || this.element, event);\n        }\n        else {\n            this.value.handleEvent(event);\n        }\n    }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn\'t support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o) => o &&\n    (eventOptionsSupported ?\n        { capture: o.capture, passive: o.passive, once: o.once } :\n        o.capture);\n//# sourceMappingURL=parts.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-factory.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nfunction templateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    // If the TemplateStringsArray is new, generate a key from the strings\n    // This key is shared between all templates with identical content\n    const key = result.strings.join(marker);\n    // Check if we already have a Template for this key\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        // If we have not seen this key before, create a new Template\n        template = new Template(result, result.getTemplateElement());\n        // Cache the Template for this key\n        templateCache.keyString.set(key, template);\n    }\n    // Cache all future queries for this TemplateStringsArray\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n}\nconst templateCaches = new Map();\n//# sourceMappingURL=template-factory.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/render.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\n\nconst render_parts = new WeakMap();\n/**\n * Renders a template result or other value to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result Any value renderable by NodePart - typically a TemplateResult\n *     created by evaluating a template tag like `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nconst render = (result, container, options) => {\n    let part = render_parts.get(container);\n    if (part === undefined) {\n        removeNodes(container, container.firstChild);\n        render_parts.set(container, part = new parts_NodePart(Object.assign({ templateFactory: templateFactory }, options)));\n        part.appendInto(container);\n    }\n    part.setValue(result);\n    part.commit();\n};\n//# sourceMappingURL=render.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/default-template-processor.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Creates Parts when a template is instantiated.\n */\nclass default_template_processor_DefaultTemplateProcessor {\n    /**\n     * Create parts for an attribute-position binding, given the event, attribute\n     * name, and string literals.\n     *\n     * @param element The element containing the binding\n     * @param name  The attribute name\n     * @param strings The string literals. There are always at least two strings,\n     *   event for fully-controlled bindings with a single expression.\n     */\n    handleAttributeExpressions(element, name, strings, options) {\n        const prefix = name[0];\n        if (prefix === \'.\') {\n            const committer = new PropertyCommitter(element, name.slice(1), strings);\n            return committer.parts;\n        }\n        if (prefix === \'@\') {\n            return [new parts_EventPart(element, name.slice(1), options.eventContext)];\n        }\n        if (prefix === \'?\') {\n            return [new parts_BooleanAttributePart(element, name.slice(1), strings)];\n        }\n        const committer = new AttributeCommitter(element, name, strings);\n        return committer.parts;\n    }\n    /**\n     * Create parts for a text-position binding.\n     * @param templateFactory\n     */\n    handleTextExpression(options) {\n        return new parts_NodePart(options);\n    }\n}\nconst defaultTemplateProcessor = new default_template_processor_DefaultTemplateProcessor();\n//# sourceMappingURL=default-template-processor.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lit-html.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n *\n * Main lit-html module.\n *\n * Main exports:\n *\n * -  [[html]]\n * -  [[svg]]\n * -  [[render]]\n *\n * @module lit-html\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\n\n\n\n\n// TODO(justinfagnani): remove line when we get NodePart moving methods\n\n\n\n\n\n\n\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\nif (typeof window !== \'undefined\') {\n    (window[\'litHtmlVersions\'] || (window[\'litHtmlVersions\'] = [])).push(\'1.2.1\');\n}\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nconst lit_html_html = (strings, ...values) => new template_result_TemplateResult(strings, values, \'html\', defaultTemplateProcessor);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nconst svg = (strings, ...values) => new template_result_SVGTemplateResult(strings, values, \'svg\', defaultTemplateProcessor);\n//# sourceMappingURL=lit-html.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/shady-render.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @module shady-render\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\n\n\n\n\n\n\n\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\nlet compatibleShadyCSSVersion = true;\nif (typeof window.ShadyCSS === \'undefined\') {\n    compatibleShadyCSSVersion = false;\n}\nelse if (typeof window.ShadyCSS.prepareTemplateDom === \'undefined\') {\n    console.warn(`Incompatible ShadyCSS version detected. ` +\n        `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +\n        `@webcomponents/shadycss@1.3.1.`);\n    compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nconst shadyTemplateFactory = (scopeName) => (result) => {\n    const cacheKey = getTemplateCacheKey(result.type, scopeName);\n    let templateCache = templateCaches.get(cacheKey);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(cacheKey, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    const key = result.strings.join(marker);\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (compatibleShadyCSSVersion) {\n            window.ShadyCSS.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.keyString.set(key, template);\n    }\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n};\nconst TEMPLATE_TYPES = [\'html\', \'svg\'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = (scopeName) => {\n    TEMPLATE_TYPES.forEach((type) => {\n        const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n        if (templates !== undefined) {\n            templates.keyString.forEach((template) => {\n                const { element: { content } } = template;\n                // IE 11 doesn\'t support the iterable param Set constructor\n                const styles = new Set();\n                Array.from(content.querySelectorAll(\'style\')).forEach((s) => {\n                    styles.add(s);\n                });\n                removeNodesFromTemplate(template, styles);\n            });\n        }\n    });\n};\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles = (scopeName, renderedDOM, template) => {\n    shadyRenderSet.add(scopeName);\n    // If `renderedDOM` is stamped from a Template, then we need to edit that\n    // Template\'s underlying template element. Otherwise, we create one here\n    // to give to ShadyCSS, which still requires one while scoping.\n    const templateElement = !!template ? template.element : document.createElement(\'template\');\n    // Move styles out of rendered DOM and store.\n    const styles = renderedDOM.querySelectorAll(\'style\');\n    const { length } = styles;\n    // If there are no styles, skip unnecessary work\n    if (length === 0) {\n        // Ensure prepareTemplateStyles is called to support adding\n        // styles via `prepareAdoptedCssText` since that requires that\n        // `prepareTemplateStyles` is called.\n        //\n        // ShadyCSS will only update styles containing @apply in the template\n        // given to `prepareTemplateStyles`. If no lit Template was given,\n        // ShadyCSS will not be able to update uses of @apply in any relevant\n        // template. However, this is not a problem because we only create the\n        // template for the purpose of supporting `prepareAdoptedCssText`,\n        // which doesn\'t support @apply at all.\n        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n        return;\n    }\n    const condensedStyle = document.createElement(\'style\');\n    // Collect styles into a single style. This helps us make sure ShadyCSS\n    // manipulations will not prevent us from being able to fix up template\n    // part indices.\n    // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n    // currently does this anyway. When it does not, this should be changed.\n    for (let i = 0; i < length; i++) {\n        const style = styles[i];\n        style.parentNode.removeChild(style);\n        condensedStyle.textContent += style.textContent;\n    }\n    // Remove styles from nested templates in this scope.\n    removeStylesFromLitTemplates(scopeName);\n    // And then put the condensed style into the "root" template passed in as\n    // `template`.\n    const content = templateElement.content;\n    if (!!template) {\n        insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n    }\n    else {\n        content.insertBefore(condensedStyle, content.firstChild);\n    }\n    // Note, it\'s important that ShadyCSS gets the template that `lit-html`\n    // will actually render so that it can update the style inside when\n    // needed (e.g. @apply native Shadow DOM case).\n    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n    const style = content.querySelector(\'style\');\n    if (window.ShadyCSS.nativeShadow && style !== null) {\n        // When in native Shadow DOM, ensure the style created by ShadyCSS is\n        // included in initially rendered output (`renderedDOM`).\n        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n    }\n    else if (!!template) {\n        // When no style is left in the template, parts will be broken as a\n        // result. To fix this, we put back the style node ShadyCSS removed\n        // and then tell lit to remove that node from the template.\n        // There can be no style in the template in 2 cases (1) when Shady DOM\n        // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n        // is in use ShadyCSS removes the style if it contains no content.\n        // NOTE, ShadyCSS creates its own style so we can safely add/remove\n        // `condensedStyle` here.\n        content.insertBefore(condensedStyle, content.firstChild);\n        const removes = new Set();\n        removes.add(condensedStyle);\n        removeNodesFromTemplate(template, removes);\n    }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element\'s\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element\'s `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element\'s\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element\'s `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\nconst shady_render_render = (result, container, options) => {\n    if (!options || typeof options !== \'object\' || !options.scopeName) {\n        throw new Error(\'The `scopeName` option is required.\');\n    }\n    const scopeName = options.scopeName;\n    const hasRendered = render_parts.has(container);\n    const needsScoping = compatibleShadyCSSVersion &&\n        container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&\n        !!container.host;\n    // Handle first render to a scope specially...\n    const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);\n    // On first scope render, render into a fragment; this cannot be a single\n    // fragment that is reused since nested renders can occur synchronously.\n    const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;\n    render(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));\n    // When performing first scope render,\n    // (1) We\'ve rendered into a fragment so that there\'s a chance to\n    // `prepareTemplateStyles` before sub-elements hit the DOM\n    // (which might cause them to render based on a common pattern of\n    // rendering in a custom element\'s `connectedCallback`);\n    // (2) Scope the template with ShadyCSS one time only for this scope.\n    // (3) Render the fragment into the container and make sure the\n    // container knows its `part` is the one we just rendered. This ensures\n    // DOM will be re-used on subsequent renders.\n    if (firstScopeRender) {\n        const part = render_parts.get(renderContainer);\n        render_parts.delete(renderContainer);\n        // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n        // that should apply to `renderContainer` even if the rendered value is\n        // not a TemplateInstance. However, it will only insert scoped styles\n        // into the document if `prepareTemplateStyles` has already been called\n        // for the given scope name.\n        const template = part.value instanceof template_instance_TemplateInstance ?\n            part.value.template :\n            undefined;\n        prepareTemplateStyles(scopeName, renderContainer, template);\n        removeNodes(container, container.firstChild);\n        container.appendChild(renderContainer);\n        render_parts.set(container, part);\n    }\n    // After elements have hit the DOM, update styling if this is the\n    // initial render to this container.\n    // This is needed whenever dynamic changes are made so it would be\n    // safest to do every render; however, this would regress performance\n    // so we leave it up to the user to call `ShadyCSS.styleElement`\n    // for dynamic changes.\n    if (!hasRendered && needsScoping) {\n        window.ShadyCSS.styleElement(container.host);\n    }\n};\n//# sourceMappingURL=shady-render.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lib/updating-element.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nvar _a;\n/**\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\nwindow.JSCompiler_renameProperty =\n    (prop, _obj) => prop;\nconst defaultConverter = {\n    toAttribute(value, type) {\n        switch (type) {\n            case Boolean:\n                return value ? \'\' : null;\n            case Object:\n            case Array:\n                // if the value is `null` or `undefined` pass this through\n                // to allow removing/no change behavior.\n                return value == null ? value : JSON.stringify(value);\n        }\n        return value;\n    },\n    fromAttribute(value, type) {\n        switch (type) {\n            case Boolean:\n                return value !== null;\n            case Number:\n                return value === null ? null : Number(value);\n            case Object:\n            case Array:\n                return JSON.parse(value);\n        }\n        return value;\n    }\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property\'s `hasChanged` function.\n */\nconst notEqual = (value, old) => {\n    // This ensures (old==NaN, value==NaN) always returns false\n    return old !== value && (old === old || value === value);\n};\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: defaultConverter,\n    reflect: false,\n    hasChanged: notEqual\n};\nconst STATE_HAS_UPDATED = 1;\nconst STATE_UPDATE_REQUESTED = 1 << 2;\nconst STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;\nconst STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;\n/**\n * The Closure JS Compiler doesn\'t currently have good support for static\n * property semantics where "this" is dynamic (e.g.\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\n * this hack to bypass any rewriting by the compiler.\n */\nconst finalized = \'finalized\';\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclassers to render updates as desired.\n */\nclass UpdatingElement extends HTMLElement {\n    constructor() {\n        super();\n        this._updateState = 0;\n        this._instanceProperties = undefined;\n        // Initialize to an unresolved Promise so we can make sure the element has\n        // connected before first update.\n        this._updatePromise = new Promise((res) => this._enableUpdatingResolver = res);\n        /**\n         * Map with keys for any properties that have changed since the last\n         * update cycle with previous values.\n         */\n        this._changedProperties = new Map();\n        /**\n         * Map with keys of properties that should be reflected when updated.\n         */\n        this._reflectingProperties = undefined;\n        this.initialize();\n    }\n    /**\n     * Returns a list of attributes corresponding to the registered properties.\n     * @nocollapse\n     */\n    static get observedAttributes() {\n        // note: piggy backing on this to ensure we\'re finalized.\n        this.finalize();\n        const attributes = [];\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this._classProperties.forEach((v, p) => {\n            const attr = this._attributeNameForProperty(p, v);\n            if (attr !== undefined) {\n                this._attributeToPropertyMap.set(attr, p);\n                attributes.push(attr);\n            }\n        });\n        return attributes;\n    }\n    /**\n     * Ensures the private `_classProperties` property metadata is created.\n     * In addition to `finalize` this is also called in `createProperty` to\n     * ensure the `@property` decorator can add property metadata.\n     */\n    /** @nocollapse */\n    static _ensureClassProperties() {\n        // ensure private storage for property declarations.\n        if (!this.hasOwnProperty(JSCompiler_renameProperty(\'_classProperties\', this))) {\n            this._classProperties = new Map();\n            // NOTE: Workaround IE11 not supporting Map constructor argument.\n            const superProperties = Object.getPrototypeOf(this)._classProperties;\n            if (superProperties !== undefined) {\n                superProperties.forEach((v, k) => this._classProperties.set(k, v));\n            }\n        }\n    }\n    /**\n     * Creates a property accessor on the element prototype if one does not exist\n     * and stores a PropertyDeclaration for the property with the given options.\n     * The property setter calls the property\'s `hasChanged` property option\n     * or uses a strict identity check to determine whether or not to request\n     * an update.\n     *\n     * This method may be overridden to customize properties; however,\n     * when doing so, it\'s important to call `super.createProperty` to ensure\n     * the property is setup correctly. This method calls\n     * `getPropertyDescriptor` internally to get a descriptor to install.\n     * To customize what properties do when they are get or set, override\n     * `getPropertyDescriptor`. To customize the options for a property,\n     * implement `createProperty` like this:\n     *\n     * static createProperty(name, options) {\n     *   options = Object.assign(options, {myOption: true});\n     *   super.createProperty(name, options);\n     * }\n     *\n     * @nocollapse\n     */\n    static createProperty(name, options = defaultPropertyDeclaration) {\n        // Note, since this can be called by the `@property` decorator which\n        // is called before `finalize`, we ensure storage exists for property\n        // metadata.\n        this._ensureClassProperties();\n        this._classProperties.set(name, options);\n        // Do not generate an accessor if the prototype already has one, since\n        // it would be lost otherwise and that would never be the user\'s intention;\n        // Instead, we expect users to call `requestUpdate` themselves from\n        // user-defined accessors. Note that if the super has an accessor we will\n        // still overwrite it\n        if (options.noAccessor || this.prototype.hasOwnProperty(name)) {\n            return;\n        }\n        const key = typeof name === \'symbol\' ? Symbol() : `__${name}`;\n        const descriptor = this.getPropertyDescriptor(name, key, options);\n        if (descriptor !== undefined) {\n            Object.defineProperty(this.prototype, name, descriptor);\n        }\n    }\n    /**\n     * Returns a property descriptor to be defined on the given named property.\n     * If no descriptor is returned, the property will not become an accessor.\n     * For example,\n     *\n     *   class MyElement extends LitElement {\n     *     static getPropertyDescriptor(name, key, options) {\n     *       const defaultDescriptor =\n     *           super.getPropertyDescriptor(name, key, options);\n     *       const setter = defaultDescriptor.set;\n     *       return {\n     *         get: defaultDescriptor.get,\n     *         set(value) {\n     *           setter.call(this, value);\n     *           // custom action.\n     *         },\n     *         configurable: true,\n     *         enumerable: true\n     *       }\n     *     }\n     *   }\n     *\n     * @nocollapse\n     */\n    static getPropertyDescriptor(name, key, _options) {\n        return {\n            // tslint:disable-next-line:no-any no symbol in index\n            get() {\n                return this[key];\n            },\n            set(value) {\n                const oldValue = this[name];\n                this[key] = value;\n                this._requestUpdate(name, oldValue);\n            },\n            configurable: true,\n            enumerable: true\n        };\n    }\n    /**\n     * Returns the property options associated with the given property.\n     * These options are defined with a PropertyDeclaration via the `properties`\n     * object or the `@property` decorator and are registered in\n     * `createProperty(...)`.\n     *\n     * Note, this method should be considered "final" and not overridden. To\n     * customize the options for a given property, override `createProperty`.\n     *\n     * @nocollapse\n     * @final\n     */\n    static getPropertyOptions(name) {\n        return this._classProperties && this._classProperties.get(name) ||\n            defaultPropertyDeclaration;\n    }\n    /**\n     * Creates property accessors for registered properties and ensures\n     * any superclasses are also finalized.\n     * @nocollapse\n     */\n    static finalize() {\n        // finalize any superclasses\n        const superCtor = Object.getPrototypeOf(this);\n        if (!superCtor.hasOwnProperty(finalized)) {\n            superCtor.finalize();\n        }\n        this[finalized] = true;\n        this._ensureClassProperties();\n        // initialize Map populated in observedAttributes\n        this._attributeToPropertyMap = new Map();\n        // make any properties\n        // Note, only process "own" properties since this element will inherit\n        // any properties defined on the superClass, and finalization ensures\n        // the entire prototype chain is finalized.\n        if (this.hasOwnProperty(JSCompiler_renameProperty(\'properties\', this))) {\n            const props = this.properties;\n            // support symbols in properties (IE11 does not support this)\n            const propKeys = [\n                ...Object.getOwnPropertyNames(props),\n                ...(typeof Object.getOwnPropertySymbols === \'function\') ?\n                    Object.getOwnPropertySymbols(props) :\n                    []\n            ];\n            // This for/of is ok because propKeys is an array\n            for (const p of propKeys) {\n                // note, use of `any` is due to TypeSript lack of support for symbol in\n                // index types\n                // tslint:disable-next-line:no-any no symbol in index\n                this.createProperty(p, props[p]);\n            }\n        }\n    }\n    /**\n     * Returns the property name for the given attribute `name`.\n     * @nocollapse\n     */\n    static _attributeNameForProperty(name, options) {\n        const attribute = options.attribute;\n        return attribute === false ?\n            undefined :\n            (typeof attribute === \'string\' ?\n                attribute :\n                (typeof name === \'string\' ? name.toLowerCase() : undefined));\n    }\n    /**\n     * Returns true if a property should request an update.\n     * Called when a property value is set and uses the `hasChanged`\n     * option for the property if present or a strict identity check.\n     * @nocollapse\n     */\n    static _valueHasChanged(value, old, hasChanged = notEqual) {\n        return hasChanged(value, old);\n    }\n    /**\n     * Returns the property value for the given attribute value.\n     * Called via the `attributeChangedCallback` and uses the property\'s\n     * `converter` or `converter.fromAttribute` property option.\n     * @nocollapse\n     */\n    static _propertyValueFromAttribute(value, options) {\n        const type = options.type;\n        const converter = options.converter || defaultConverter;\n        const fromAttribute = (typeof converter === \'function\' ? converter : converter.fromAttribute);\n        return fromAttribute ? fromAttribute(value, type) : value;\n    }\n    /**\n     * Returns the attribute value for the given property value. If this\n     * returns undefined, the property will *not* be reflected to an attribute.\n     * If this returns null, the attribute will be removed, otherwise the\n     * attribute will be set to the value.\n     * This uses the property\'s `reflect` and `type.toAttribute` property options.\n     * @nocollapse\n     */\n    static _propertyValueToAttribute(value, options) {\n        if (options.reflect === undefined) {\n            return;\n        }\n        const type = options.type;\n        const converter = options.converter;\n        const toAttribute = converter && converter.toAttribute ||\n            defaultConverter.toAttribute;\n        return toAttribute(value, type);\n    }\n    /**\n     * Performs element initialization. By default captures any pre-set values for\n     * registered properties.\n     */\n    initialize() {\n        this._saveInstanceProperties();\n        // ensures first update will be caught by an early access of\n        // `updateComplete`\n        this._requestUpdate();\n    }\n    /**\n     * Fixes any properties set on the instance before upgrade time.\n     * Otherwise these would shadow the accessor and break these properties.\n     * The properties are stored in a Map which is played back after the\n     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n     * (<=41), properties created for native platform properties like (`id` or\n     * `name`) may not have default values set in the element constructor. On\n     * these browsers native properties appear on instances and therefore their\n     * default value will overwrite any element default (e.g. if the element sets\n     * this.id = \'id\' in the constructor, the \'id\' will become \'\' since this is\n     * the native platform default).\n     */\n    _saveInstanceProperties() {\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this.constructor\n            ._classProperties.forEach((_v, p) => {\n            if (this.hasOwnProperty(p)) {\n                const value = this[p];\n                delete this[p];\n                if (!this._instanceProperties) {\n                    this._instanceProperties = new Map();\n                }\n                this._instanceProperties.set(p, value);\n            }\n        });\n    }\n    /**\n     * Applies previously saved instance properties.\n     */\n    _applyInstanceProperties() {\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        // tslint:disable-next-line:no-any\n        this._instanceProperties.forEach((v, p) => this[p] = v);\n        this._instanceProperties = undefined;\n    }\n    connectedCallback() {\n        // Ensure first connection completes an update. Updates cannot complete\n        // before connection.\n        this.enableUpdating();\n    }\n    enableUpdating() {\n        if (this._enableUpdatingResolver !== undefined) {\n            this._enableUpdatingResolver();\n            this._enableUpdatingResolver = undefined;\n        }\n    }\n    /**\n     * Allows for `super.disconnectedCallback()` in extensions while\n     * reserving the possibility of making non-breaking feature additions\n     * when disconnecting at some point in the future.\n     */\n    disconnectedCallback() {\n    }\n    /**\n     * Synchronizes property values when attributes change.\n     */\n    attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n            this._attributeToProperty(name, value);\n        }\n    }\n    _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {\n        const ctor = this.constructor;\n        const attr = ctor._attributeNameForProperty(name, options);\n        if (attr !== undefined) {\n            const attrValue = ctor._propertyValueToAttribute(value, options);\n            // an undefined value does not change the attribute.\n            if (attrValue === undefined) {\n                return;\n            }\n            // Track if the property is being reflected to avoid\n            // setting the property again via `attributeChangedCallback`. Note:\n            // 1. this takes advantage of the fact that the callback is synchronous.\n            // 2. will behave incorrectly if multiple attributes are in the reaction\n            // stack at time of calling. However, since we process attributes\n            // in `update` this should not be possible (or an extreme corner case\n            // that we\'d like to discover).\n            // mark state reflecting\n            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;\n            if (attrValue == null) {\n                this.removeAttribute(attr);\n            }\n            else {\n                this.setAttribute(attr, attrValue);\n            }\n            // mark state not reflecting\n            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;\n        }\n    }\n    _attributeToProperty(name, value) {\n        // Use tracking info to avoid deserializing attribute value if it was\n        // just set from a property setter.\n        if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {\n            return;\n        }\n        const ctor = this.constructor;\n        // Note, hint this as an `AttributeMap` so closure clearly understands\n        // the type; it has issues with tracking types through statics\n        // tslint:disable-next-line:no-unnecessary-type-assertion\n        const propName = ctor._attributeToPropertyMap.get(name);\n        if (propName !== undefined) {\n            const options = ctor.getPropertyOptions(propName);\n            // mark state reflecting\n            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;\n            this[propName] =\n                // tslint:disable-next-line:no-any\n                ctor._propertyValueFromAttribute(value, options);\n            // mark state not reflecting\n            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;\n        }\n    }\n    /**\n     * This private version of `requestUpdate` does not access or return the\n     * `updateComplete` promise. This promise can be overridden and is therefore\n     * not free to access.\n     */\n    _requestUpdate(name, oldValue) {\n        let shouldRequestUpdate = true;\n        // If we have a property key, perform property update steps.\n        if (name !== undefined) {\n            const ctor = this.constructor;\n            const options = ctor.getPropertyOptions(name);\n            if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {\n                if (!this._changedProperties.has(name)) {\n                    this._changedProperties.set(name, oldValue);\n                }\n                // Add to reflecting properties set.\n                // Note, it\'s important that every change has a chance to add the\n                // property to `_reflectingProperties`. This ensures setting\n                // attribute + property reflects correctly.\n                if (options.reflect === true &&\n                    !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {\n                    if (this._reflectingProperties === undefined) {\n                        this._reflectingProperties = new Map();\n                    }\n                    this._reflectingProperties.set(name, options);\n                }\n            }\n            else {\n                // Abort the request if the property should not be considered changed.\n                shouldRequestUpdate = false;\n            }\n        }\n        if (!this._hasRequestedUpdate && shouldRequestUpdate) {\n            this._updatePromise = this._enqueueUpdate();\n        }\n    }\n    /**\n     * Requests an update which is processed asynchronously. This should\n     * be called when an element should update based on some state not triggered\n     * by setting a property. In this case, pass no arguments. It should also be\n     * called when manually implementing a property setter. In this case, pass the\n     * property `name` and `oldValue` to ensure that any configured property\n     * options are honored. Returns the `updateComplete` Promise which is resolved\n     * when the update completes.\n     *\n     * @param name {PropertyKey} (optional) name of requesting property\n     * @param oldValue {any} (optional) old value of requesting property\n     * @returns {Promise} A Promise that is resolved when the update completes.\n     */\n    requestUpdate(name, oldValue) {\n        this._requestUpdate(name, oldValue);\n        return this.updateComplete;\n    }\n    /**\n     * Sets up the element to asynchronously update.\n     */\n    async _enqueueUpdate() {\n        this._updateState = this._updateState | STATE_UPDATE_REQUESTED;\n        try {\n            // Ensure any previous update has resolved before updating.\n            // This `await` also ensures that property changes are batched.\n            await this._updatePromise;\n        }\n        catch (e) {\n            // Ignore any previous errors. We only care that the previous cycle is\n            // done. Any error should have been handled in the previous update.\n        }\n        const result = this.performUpdate();\n        // If `performUpdate` returns a Promise, we await it. This is done to\n        // enable coordinating updates with a scheduler. Note, the result is\n        // checked to avoid delaying an additional microtask unless we need to.\n        if (result != null) {\n            await result;\n        }\n        return !this._hasRequestedUpdate;\n    }\n    get _hasRequestedUpdate() {\n        return (this._updateState & STATE_UPDATE_REQUESTED);\n    }\n    get hasUpdated() {\n        return (this._updateState & STATE_HAS_UPDATED);\n    }\n    /**\n     * Performs an element update. Note, if an exception is thrown during the\n     * update, `firstUpdated` and `updated` will not be called.\n     *\n     * You can override this method to change the timing of updates. If this\n     * method is overridden, `super.performUpdate()` must be called.\n     *\n     * For instance, to schedule updates to occur just before the next frame:\n     *\n     * ```\n     * protected async performUpdate(): Promise<unknown> {\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n     *   super.performUpdate();\n     * }\n     * ```\n     */\n    performUpdate() {\n        // Mixin instance properties once, if they exist.\n        if (this._instanceProperties) {\n            this._applyInstanceProperties();\n        }\n        let shouldUpdate = false;\n        const changedProperties = this._changedProperties;\n        try {\n            shouldUpdate = this.shouldUpdate(changedProperties);\n            if (shouldUpdate) {\n                this.update(changedProperties);\n            }\n            else {\n                this._markUpdated();\n            }\n        }\n        catch (e) {\n            // Prevent `firstUpdated` and `updated` from running when there\'s an\n            // update exception.\n            shouldUpdate = false;\n            // Ensure element can accept additional updates after an exception.\n            this._markUpdated();\n            throw e;\n        }\n        if (shouldUpdate) {\n            if (!(this._updateState & STATE_HAS_UPDATED)) {\n                this._updateState = this._updateState | STATE_HAS_UPDATED;\n                this.firstUpdated(changedProperties);\n            }\n            this.updated(changedProperties);\n        }\n    }\n    _markUpdated() {\n        this._changedProperties = new Map();\n        this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;\n    }\n    /**\n     * Returns a Promise that resolves when the element has completed updating.\n     * The Promise value is a boolean that is `true` if the element completed the\n     * update without triggering another update. The Promise result is `false` if\n     * a property was set inside `updated()`. If the Promise is rejected, an\n     * exception was thrown during the update.\n     *\n     * To await additional asynchronous work, override the `_getUpdateComplete`\n     * method. For example, it is sometimes useful to await a rendered element\n     * before fulfilling this Promise. To do this, first await\n     * `super._getUpdateComplete()`, then any subsequent state.\n     *\n     * @returns {Promise} The Promise returns a boolean that indicates if the\n     * update resolved without triggering another update.\n     */\n    get updateComplete() {\n        return this._getUpdateComplete();\n    }\n    /**\n     * Override point for the `updateComplete` promise.\n     *\n     * It is not safe to override the `updateComplete` getter directly due to a\n     * limitation in TypeScript which means it is not possible to call a\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n     * This method should be overridden instead. For example:\n     *\n     *   class MyElement extends LitElement {\n     *     async _getUpdateComplete() {\n     *       await super._getUpdateComplete();\n     *       await this._myChild.updateComplete;\n     *     }\n     *   }\n     */\n    _getUpdateComplete() {\n        return this._updatePromise;\n    }\n    /**\n     * Controls whether or not `update` should be called when the element requests\n     * an update. By default, this method always returns `true`, but this can be\n     * customized to control when to update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     */\n    shouldUpdate(_changedProperties) {\n        return true;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes.\n     * It can be overridden to render and keep updated element DOM.\n     * Setting properties inside this method will *not* trigger\n     * another update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     */\n    update(_changedProperties) {\n        if (this._reflectingProperties !== undefined &&\n            this._reflectingProperties.size > 0) {\n            // Use forEach so this works even if for/of loops are compiled to for\n            // loops expecting arrays\n            this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));\n            this._reflectingProperties = undefined;\n        }\n        this._markUpdated();\n    }\n    /**\n     * Invoked whenever the element is updated. Implement to perform\n     * post-updating tasks via DOM APIs, for example, focusing an element.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     */\n    updated(_changedProperties) {\n    }\n    /**\n     * Invoked when the element is first updated. Implement to perform one time\n     * work on the element after update.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     */\n    firstUpdated(_changedProperties) {\n    }\n}\n_a = finalized;\n/**\n * Marks class as having finished creating properties.\n */\nUpdatingElement[_a] = true;\n//# sourceMappingURL=updating-element.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lib/decorators.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst legacyCustomElement = (tagName, clazz) => {\n    window.customElements.define(tagName, clazz);\n    // Cast as any because TS doesn\'t recognize the return type as being a\n    // subtype of the decorated class when clazz is typed as\n    // `Constructor<HTMLElement>` for some reason.\n    // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n    // applied to elements however.\n    // tslint:disable-next-line:no-any\n    return clazz;\n};\nconst standardCustomElement = (tagName, descriptor) => {\n    const { kind, elements } = descriptor;\n    return {\n        kind,\n        elements,\n        // This callback is called once the class is otherwise fully defined\n        finisher(clazz) {\n            window.customElements.define(tagName, clazz);\n        }\n    };\n};\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```\n * @customElement(\'my-element\')\n * class MyElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n *\n * @param tagName The name of the custom element to define.\n */\nconst customElement = (tagName) => (classOrDescriptor) => (typeof classOrDescriptor === \'function\') ?\n    legacyCustomElement(tagName, classOrDescriptor) :\n    standardCustomElement(tagName, classOrDescriptor);\nconst standardProperty = (options, element) => {\n    // When decorating an accessor, pass it through and add property metadata.\n    // Note, the `hasOwnProperty` check in `createProperty` ensures we don\'t\n    // stomp over the user\'s accessor.\n    if (element.kind === \'method\' && element.descriptor &&\n        !(\'value\' in element.descriptor)) {\n        return Object.assign(Object.assign({}, element), { finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            } });\n    }\n    else {\n        // createProperty() takes care of defining the property, but we still\n        // must return some kind of descriptor, so return a descriptor for an\n        // unused prototype field. The finisher calls createProperty().\n        return {\n            kind: \'field\',\n            key: Symbol(),\n            placement: \'own\',\n            descriptor: {},\n            // When @babel/plugin-proposal-decorators implements initializers,\n            // do this instead of the initializer below. See:\n            // https://github.com/babel/babel/issues/9260 extras: [\n            //   {\n            //     kind: \'initializer\',\n            //     placement: \'own\',\n            //     initializer: descriptor.initializer,\n            //   }\n            // ],\n            initializer() {\n                if (typeof element.initializer === \'function\') {\n                    this[element.key] = element.initializer.call(this);\n                }\n            },\n            finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            }\n        };\n    }\n};\nconst legacyProperty = (options, proto, name) => {\n    proto.constructor\n        .createProperty(name, options);\n};\n/**\n * A property decorator which creates a LitElement property which reflects a\n * corresponding attribute value. A `PropertyDeclaration` may optionally be\n * supplied to configure property features.\n *\n * This decorator should only be used for public fields. Private or protected\n * fields should use the internalProperty decorator.\n *\n * @example\n *\n *     class MyElement {\n *       @property({ type: Boolean })\n *       clicked = false;\n *     }\n *\n * @ExportDecoratedItems\n */\nfunction property(options) {\n    // tslint:disable-next-line:no-any decorator\n    return (protoOrDescriptor, name) => (name !== undefined) ?\n        legacyProperty(options, protoOrDescriptor, name) :\n        standardProperty(options, protoOrDescriptor);\n}\n/**\n * Declares a private or protected property that still triggers updates to the\n * element when it changes.\n *\n * Properties declared this way must not be used from HTML or HTML templating\n * systems, they\'re solely for properties internal to the element. These\n * properties may be renamed by optimization tools like closure compiler.\n */\nfunction internalProperty(options) {\n    return property({ attribute: false, hasChanged: options === null || options === void 0 ? void 0 : options.hasChanged });\n}\n/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element\'s renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * @example\n *\n *     class MyElement {\n *       @query(\'#first\')\n *       first;\n *\n *       render() {\n *         return html`\n *           <div id="first"></div>\n *           <div id="second"></div>\n *         `;\n *       }\n *     }\n *\n */\nfunction query(selector) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            get() {\n                return this.renderRoot.querySelector(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\n// Note, in the future, we may extend this decorator to support the use case\n// where the queried element may need to do work to become ready to interact\n// with (e.g. load some implementation code). If so, we might elect to\n// add a second argument defining a function that can be run to make the\n// queried element loaded/updated/ready.\n/**\n * A property decorator that converts a class property into a getter that\n * returns a promise that resolves to the result of a querySelector on the\n * element\'s renderRoot done after the element\'s `updateComplete` promise\n * resolves. When the queried property may change with element state, this\n * decorator can be used instead of requiring users to await the\n * `updateComplete` before accessing the property.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * @example\n *\n *     class MyElement {\n *       @queryAsync(\'#first\')\n *       first;\n *\n *       render() {\n *         return html`\n *           <div id="first"></div>\n *           <div id="second"></div>\n *         `;\n *       }\n *     }\n *\n *     // external usage\n *     async doSomethingWithFirst() {\n *      (await aMyElement.first).doSomething();\n *     }\n */\nfunction queryAsync(selector) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            async get() {\n                await this.updateComplete;\n                return this.renderRoot.querySelector(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\n/**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element\'s renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\n *\n * @example\n *\n *     class MyElement {\n *       @queryAll(\'div\')\n *       divs;\n *\n *       render() {\n *         return html`\n *           <div id="first"></div>\n *           <div id="second"></div>\n *         `;\n *       }\n *     }\n */\nfunction queryAll(selector) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            get() {\n                return this.renderRoot.querySelectorAll(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\nconst legacyQuery = (descriptor, proto, name) => {\n    Object.defineProperty(proto, name, descriptor);\n};\nconst standardQuery = (descriptor, element) => ({\n    kind: \'method\',\n    placement: \'prototype\',\n    key: element.key,\n    descriptor,\n});\nconst standardEventOptions = (options, element) => {\n    return Object.assign(Object.assign({}, element), { finisher(clazz) {\n            Object.assign(clazz.prototype[element.key], options);\n        } });\n};\nconst legacyEventOptions = \n// tslint:disable-next-line:no-any legacy decorator\n(options, proto, name) => {\n    Object.assign(proto[name], options);\n};\n/**\n * Adds event listener options to a method used as an event listener in a\n * lit-html template.\n *\n * @param options An object that specifies event listener options as accepted by\n * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.\n *\n * Current browsers support the `capture`, `passive`, and `once` options. See:\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\n *\n * @example\n *\n *     class MyElement {\n *       clicked = false;\n *\n *       render() {\n *         return html`\n *           <div @click=${this._onClick}`>\n *             <button></button>\n *           </div>\n *         `;\n *       }\n *\n *       @eventOptions({capture: true})\n *       _onClick(e) {\n *         this.clicked = true;\n *       }\n *     }\n */\nfunction eventOptions(options) {\n    // Return value typed as any to prevent TypeScript from complaining that\n    // standard decorator function signature does not match TypeScript decorator\n    // signature\n    // TODO(kschaaf): unclear why it was only failing on this decorator and not\n    // the others\n    return ((protoOrDescriptor, name) => (name !== undefined) ?\n        legacyEventOptions(options, protoOrDescriptor, name) :\n        standardEventOptions(options, protoOrDescriptor));\n}\n/**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedNodes` of the given named `slot`. Note, the type of\n * this property should be annotated as `NodeListOf<HTMLElement>`.\n *\n */\nfunction queryAssignedNodes(slotName = \'\', flatten = false) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            get() {\n                const selector = `slot${slotName ? `[name=${slotName}]` : \'\'}`;\n                const slot = this.renderRoot.querySelector(selector);\n                return slot && slot.assignedNodes({ flatten });\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\n//# sourceMappingURL=decorators.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lib/css-tag.js\n/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nconst supportsAdoptingStyleSheets = (\'adoptedStyleSheets\' in Document.prototype) &&\n    (\'replace\' in CSSStyleSheet.prototype);\nconst constructionToken = Symbol();\nclass CSSResult {\n    constructor(cssText, safeToken) {\n        if (safeToken !== constructionToken) {\n            throw new Error(\'CSSResult is not constructable. Use `unsafeCSS` or `css` instead.\');\n        }\n        this.cssText = cssText;\n    }\n    // Note, this is a getter so that it\'s lazy. In practice, this means\n    // stylesheets are not created until the first element instance is made.\n    get styleSheet() {\n        if (this._styleSheet === undefined) {\n            // Note, if `adoptedStyleSheets` is supported then we assume CSSStyleSheet\n            // is constructable.\n            if (supportsAdoptingStyleSheets) {\n                this._styleSheet = new CSSStyleSheet();\n                this._styleSheet.replaceSync(this.cssText);\n            }\n            else {\n                this._styleSheet = null;\n            }\n        }\n        return this._styleSheet;\n    }\n    toString() {\n        return this.cssText;\n    }\n}\n/**\n * Wrap a value for interpolation in a css tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */\nconst unsafeCSS = (value) => {\n    return new CSSResult(String(value), constructionToken);\n};\nconst textFromCSSResult = (value) => {\n    if (value instanceof CSSResult) {\n        return value.cssText;\n    }\n    else if (typeof value === \'number\') {\n        return value;\n    }\n    else {\n        throw new Error(`Value passed to \'css\' function must be a \'css\' function result: ${value}. Use \'unsafeCSS\' to pass non-literal values, but\n            take care to ensure page security.`);\n    }\n};\n/**\n * Template tag which which can be used with LitElement\'s `style` property to\n * set element styles. For security reasons, only literal string values may be\n * used. To incorporate non-literal values `unsafeCSS` may be used inside a\n * template string part.\n */\nconst css = (strings, ...values) => {\n    const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);\n    return new CSSResult(cssText, constructionToken);\n};\n//# sourceMappingURL=css-tag.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lit-element.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n\n\n\n\n\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n(window[\'litElementVersions\'] || (window[\'litElementVersions\'] = []))\n    .push(\'2.3.1\');\n/**\n * Sentinal value used to avoid calling lit-html\'s render function when\n * subclasses do not implement `render`\n */\nconst renderNotImplemented = {};\nclass lit_element_LitElement extends UpdatingElement {\n    /**\n     * Return the array of styles to apply to the element.\n     * Override this method to integrate into a style management system.\n     *\n     * @nocollapse\n     */\n    static getStyles() {\n        return this.styles;\n    }\n    /** @nocollapse */\n    static _getUniqueStyles() {\n        // Only gather styles once per class\n        if (this.hasOwnProperty(JSCompiler_renameProperty(\'_styles\', this))) {\n            return;\n        }\n        // Take care not to call `this.getStyles()` multiple times since this\n        // generates new CSSResults each time.\n        // TODO(sorvell): Since we do not cache CSSResults by input, any\n        // shared styles will generate new stylesheet objects, which is wasteful.\n        // This should be addressed when a browser ships constructable\n        // stylesheets.\n        const userStyles = this.getStyles();\n        if (userStyles === undefined) {\n            this._styles = [];\n        }\n        else if (Array.isArray(userStyles)) {\n            // De-duplicate styles preserving the _last_ instance in the set.\n            // This is a performance optimization to avoid duplicated styles that can\n            // occur especially when composing via subclassing.\n            // The last item is kept to try to preserve the cascade order with the\n            // assumption that it\'s most important that last added styles override\n            // previous styles.\n            const addStyles = (styles, set) => styles.reduceRight((set, s) => \n            // Note: On IE set.add() does not return the set\n            Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set);\n            // Array.from does not work on Set in IE, otherwise return\n            // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()\n            const set = addStyles(userStyles, new Set());\n            const styles = [];\n            set.forEach((v) => styles.unshift(v));\n            this._styles = styles;\n        }\n        else {\n            this._styles = [userStyles];\n        }\n    }\n    /**\n     * Performs element initialization. By default this calls `createRenderRoot`\n     * to create the element `renderRoot` node and captures any pre-set values for\n     * registered properties.\n     */\n    initialize() {\n        super.initialize();\n        this.constructor._getUniqueStyles();\n        this.renderRoot =\n            this.createRenderRoot();\n        // Note, if renderRoot is not a shadowRoot, styles would/could apply to the\n        // element\'s getRootNode(). While this could be done, we\'re choosing not to\n        // support this now since it would require different logic around de-duping.\n        if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {\n            this.adoptStyles();\n        }\n    }\n    /**\n     * Returns the node into which the element should render and by default\n     * creates and returns an open shadowRoot. Implement to customize where the\n     * element\'s DOM is rendered. For example, to render into the element\'s\n     * childNodes, return `this`.\n     * @returns {Element|DocumentFragment} Returns a node into which to render.\n     */\n    createRenderRoot() {\n        return this.attachShadow({ mode: \'open\' });\n    }\n    /**\n     * Applies styling to the element shadowRoot using the `static get styles`\n     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\n     * available and will fallback otherwise. When Shadow DOM is polyfilled,\n     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\n     * is available but `adoptedStyleSheets` is not, styles are appended to the\n     * end of the `shadowRoot` to [mimic spec\n     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n     */\n    adoptStyles() {\n        const styles = this.constructor._styles;\n        if (styles.length === 0) {\n            return;\n        }\n        // There are three separate cases here based on Shadow DOM support.\n        // (1) shadowRoot polyfilled: use ShadyCSS\n        // (2) shadowRoot.adoptedStyleSheets available: use it.\n        // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\n        // rendering\n        if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\n            window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);\n        }\n        else if (supportsAdoptingStyleSheets) {\n            this.renderRoot.adoptedStyleSheets =\n                styles.map((s) => s.styleSheet);\n        }\n        else {\n            // This must be done after rendering so the actual style insertion is done\n            // in `update`.\n            this._needsShimAdoptedStyleSheets = true;\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        // Note, first update/render handles styleElement so we only call this if\n        // connected after first update.\n        if (this.hasUpdated && window.ShadyCSS !== undefined) {\n            window.ShadyCSS.styleElement(this);\n        }\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes\n     * and calls `render` to render DOM via lit-html. Setting properties inside\n     * this method will *not* trigger another update.\n     * @param _changedProperties Map of changed properties with old values\n     */\n    update(changedProperties) {\n        // Setting properties in `render` should not trigger an update. Since\n        // updates are allowed after super.update, it\'s important to call `render`\n        // before that.\n        const templateResult = this.render();\n        super.update(changedProperties);\n        // If render is not implemented by the component, don\'t call lit-html render\n        if (templateResult !== renderNotImplemented) {\n            this.constructor\n                .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });\n        }\n        // When native Shadow DOM is used but adoptedStyles are not supported,\n        // insert styling after rendering to ensure adoptedStyles have highest\n        // priority.\n        if (this._needsShimAdoptedStyleSheets) {\n            this._needsShimAdoptedStyleSheets = false;\n            this.constructor._styles.forEach((s) => {\n                const style = document.createElement(\'style\');\n                style.textContent = s.cssText;\n                this.renderRoot.appendChild(style);\n            });\n        }\n    }\n    /**\n     * Invoked on each update to perform rendering tasks. This method may return\n     * any value renderable by lit-html\'s NodePart - typically a TemplateResult.\n     * Setting properties inside this method will *not* trigger the element to\n     * update.\n     */\n    render() {\n        return renderNotImplemented;\n    }\n}\n/**\n * Ensure this class is marked as `finalized` as an optimization ensuring\n * it will not needlessly try to `finalize`.\n *\n * Note this property name is a string to prevent breaking Closure JS Compiler\n * optimizations. See updating-element.ts for more information.\n */\nlit_element_LitElement[\'finalized\'] = true;\n/**\n * Render method used to render the value to the element\'s DOM.\n * @param result The value to render.\n * @param container Node into which to render.\n * @param options Element name.\n * @nocollapse\n */\nlit_element_LitElement.render = shady_render_render;\n//# sourceMappingURL=lit-element.js.map\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js\nvar web_dom_iterable = __webpack_require__(29);\n\n// CONCATENATED MODULE: ./src/agents/hello-agent.js\n\n\n//import  eve from \'evejs/dist/eve.custom.js\';\nfunction HelloAgent(id) {\n  // execute super constructor\n  eve.Agent.call(this, id); // connect to all transports configured by the system\n\n  this.connect(eve.system.transports.getAll());\n} // extend the eve.Agent prototype\n\n\nHelloAgent.prototype = Object.create(eve.Agent.prototype);\nHelloAgent.prototype.constructor = HelloAgent;\n\nHelloAgent.prototype.sayHello = function (to) {\n  this.send(to, \'Hello \' + to + \'!\');\n};\n\nHelloAgent.prototype.receive = function (from, message) {\n  //slog(this.id+" received from :"+from + \' this message: \' + JSON.stringify(message));\n  console.log(this.id + " received from :" + from + \' this message: \' + JSON.stringify(message));\n\n  if (JSON.stringify(message).indexOf(\'Hello\') === 0) {\n    // reply to the greeting\n    this.send(from, \'Hi \' + from + \', nice to meet you!\');\n  }\n};\n\nHelloAgent.prototype.broadcast = function (message) {\n  var me = this;\n  var allAgents = Object.keys(this.connections[0].transport.agents);\n  console.log(allAgents);\n  allAgents.forEach(function (agent) {\n    me.send(agent, message);\n  });\n};\n\nHelloAgent.prototype.sendMulti = function (recipients, message) {\n  var me = this;\n  recipients.forEach(function (agent) {\n    //  console.log(agent, message)\n    me.send(agent, message);\n  });\n};\n\n\n// CONCATENATED MODULE: ./src/views/app-view.js\n\n\nfunction _templateObject4() {\n  const data = _taggedTemplateLiteral([" YOU MUST LOGIN TO SHARE\\n        "]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  const data = _taggedTemplateLiteral(["SHARE PANEL   share : ", "<br>"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  const data = _taggedTemplateLiteral(["\\n        <div class=\\"col-md-6\\">\\n        <panel-element name=\\"", "\\" .p=\\"", "\\">Loading ", "</panel-element>\\n        </div>\\n        "]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral(["\\n      <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n      <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n      <fab-element name=\\"Fab\\" ?hidden=\\"", "\\">Loading Fab for ", "</fab-element>\\n      <store-element name=\\"Store\\">Store Loading</store-element>\\n      <div ?hidden = \\"", "\\">\\n      Hello from<b>", "</b><br>\\n      WebId : ", "<br>\\n\\n      </div>\\n\\n      <header>\\n      <button class=\\"btn btn-outline-info\\"  @click=\\"", "\\">Agora</button>\\n      <button class=\\"btn btn-outline-info\\" panel=\\"Info\\" @click=\\"", "\\">Help</button>\\n      <login-element name=\\"Login\\">Loading Login</login-element>\\n      \x3c!--      <nav-element name=\\"Nav\\">Loading Nav</nav-element>--\x3e\\n      v.a2\\n      </header>\\n\\n      <div class=\\"container-fluid\\">\\n      \x3c!--\\n      PANEL : ", " for ", "\\n      --\x3e\\n      \x3c!--\\n\\n      HIDDEN TEMPORARY FOR DEV--\x3e\\n      <flux-element name=\\"Flux\\" agoraPod=\\"", "\\" ?hidden=\\"", "\\">Loading Flux</flux-element>\\n      <friends-view name=\\"Friends\\" ?hidden=\\"", "\\">Loading Organization</friends-view>\\n      <post-element name=\\"Post\\" .share=\\"", "\\" ?hidden=\\"", "\\">Loading Post</post-element>\\n      <config-get-view name=\\"Config\\" webId=\\"", "\\" ?hidden=\\"", "\\">Loading Config for ", "</config-get-view>\\n      <profile-element ?hidden=\\"", "\\" name=\\"Profile\\">Loading Profil</profile-element>\\n      \x3c!----\x3e\\n\\n      \x3c!-- DEFAULT --\x3e\\n      <div class=\\"row\\" ?hidden=\\"", "\\">\\n      ", "\\n      </div>\\n      \x3c!-- --\x3e\\n\\n\\n      \x3c!-- SHARE --\x3e\\n      <div ?hidden=\\"", "\\">\\n      ", "\\n      </div>\\n      \x3c!-- QUERY --\x3e\\n      <div ?hidden=\\"", "\\">\\n      must show activity with uri ", "\\n      </div>\\n\\n      \x3c!-- INFO --\x3e\\n      <info-element name=\\"Info\\" ?hidden=\\"", "\\">Loading Info</info-element>\\n      \x3c!----\x3e\\n\\n      </div>\\n\\n      \x3c!--      <log-element name=\\"Log\\">Loading Log</log-element>--\x3e\\n      "]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass app_view_AppView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      debug: {\n        type: Boolean\n      },\n      share: {\n        type: Object\n      },\n      panel: {\n        type: String\n      },\n      webId: {\n        type: String\n      },\n      query: {\n        type: String\n      },\n      panels: {\n        type: Array\n      },\n      agoraPod: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "App";\n    this.debug = false;\n    this.webId = null;\n    this.query = null;\n    this.share = {};\n    this.agoraPod = "https://agora.solid.community/profile/card#me";\n    this.panel = "Flow";\n    this.panels = [{\n      name: "Flow",\n      image: "./img/flow.png",\n      text: "Show Public, Group & Personnal Activities."\n    }, {\n      name: "Compose",\n      image: "./img/compose.png",\n      text: "Create & compose new Notes, Medias, Triples & Graphs!"\n    }, {\n      name: "Organization",\n      image: "./img/orga.png",\n      text: "Build Teams to collaborate on projects."\n    }, {\n      name: "Talk",\n      image: "./img/talk.png",\n      text: "A space to realtime exchanges! (TODO)"\n    }];\n    this.onLoad();\n  }\n\n  render() {\n    return lit_html_html(_templateObject(), this.webId == null, this.webId, !this.debug, this.name, this.webId, this.showDefault, this.showFromAtt, this.panel, this.webId, this.agoraPod, this.panel != \'Flow\', this.panel != \'Organization\', this.share, this.panel != \'Compose\', this.webId, this.webId == null || this.panel != "Config", this.webId, this.panel != "Profile", this.panel != \'Default\', this.panels.map((p, i) => lit_html_html(_templateObject2(), p.name, p, p.name)), this.panel != \'Share\', this.webId != null ? lit_html_html(_templateObject3(), JSON.stringify(this.share)) : lit_html_html(_templateObject4()), this.query == null, this.query, this.panel != \'Info\');\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          case "initFromStore":\n            app.initFromStore(message.store);\n            break;\n\n          case "showPanel":\n            app.showPanel(message.panel);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  webIdChanged(webId) {\n    this.webId = webId;\n  }\n\n  initFromStore(store) {\n    console.log("STORE in app", store);\n    store.info == true ? this.panel = "Info" : "";\n  }\n\n  showPanel(panel = "Organization") {\n    this.panel = panel; //\n  }\n\n  showFromAtt(e) {\n    this.panel = e.target.getAttribute("panel");\n  }\n\n  showDefault() {\n    this.panel = "Default"; //\n  }\n\n  onLoad() {\n    var parsedUrl = new URL(window.location.toString());\n    console.log(parsedUrl);\n    this.share.title = parsedUrl.searchParams.get("title") || null;\n    this.share.text = parsedUrl.searchParams.get("text") || null;\n    this.share.url = parsedUrl.searchParams.get("url") || null;\n\n    if (this.share.title != null || this.share.text != null || this.share.url != null) {\n      this.share.show = true;\n      this.panel = "Share";\n    } else {\n      this.query = parsedUrl.searchParams.get("query") || null;\n    }\n\n    console.log(this.share);\n\n    if (parsedUrl.searchParams.get("oldapi")) {\n      alert("Your browser is using the deprecated \'url_template\' Web Share " + "Target API.");\n    }\n  }\n\n}\n\ncustomElements.define(\'app-view\', app_view_AppView);\n// CONCATENATED MODULE: ./src/views/base-view.js\n\n\nclass base_view_BaseView extends lit_element_LitElement {\n  createRenderRoot() {\n    return this;\n  }\n\n  firstUpdated() {\n    console.log(this.name);\n\n    if (this.name != null) {\n      var app = this;\n      this.agent = new HelloAgent(this.name);\n      console.log(this.agent);\n\n      this.agent.receive = function (from, message) {\n        //  console.log("messah",message)\n        if (message.hasOwnProperty("action")) {\n          //  console.log(message)\n          switch (message.action) {\n            case "webIdChanged":\n              app.webIdChanged(message.webId);\n              break;\n\n            case "test":\n              app.test(message);\n              break;\n\n            case "pageChanged":\n              app.pageChanged(message.page);\n              break;\n\n            case "panelChanged":\n              app.panelChanged(message.panel);\n              break;\n\n            default:\n              console.log("Unknown action ", message);\n          }\n        }\n      };\n    }\n\n    return this;\n  }\n\n  webIdChanged(webId) {\n    console.log("WIC", this.name, webId);\n    this.webId = webId;\n  }\n\n  pageChanged(page) {\n    page == "default" ? this.page = "flux" : this.page = page;\n  }\n\n  test(message) {\n    console.log(this.name, " received ", message);\n  }\n\n  click(e) {\n    console.log(e);\n  }\n\n}\n// CONCATENATED MODULE: ./src/views/store-element.js\n\n\nfunction store_element_templateObject() {\n  const data = store_element_taggedTemplateLiteral(["\\n\\n    <div ?hidden = \\"", "\\">\\n    Hello from<b>", "</b><br>\\n    store : ", "</br>\\n    <p>\\n    ", " <br>    <button @click=\\"", "\\">Clean</button><br><br>\\n    </p>\\n    </div>\\n    "]);\n\n  store_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction store_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass store_element_StoreElement extends base_view_BaseView {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      store: {\n        type: Object\n      },\n      debug: {\n        type: Boolean\n      },\n      webId: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Store";\n    this.store = {};\n    this.debug = false;\n    this.webId = null;\n  }\n\n  render() {\n    return lit_html_html(store_element_templateObject(), !this.debug, this.name, JSON.stringify(this.store), this.name, this.cleanStorage);\n  }\n\n  firstUpdated() {\n    //  console.log(this.name)\n    super.firstUpdated();\n\n    if (this.name != null) {\n      var app = this; //  this.agent = new HelloAgent(this.name);\n\n      console.log(this.agent);\n\n      this.agent.receive = function (from, message) {\n        //  console.log("messah",message)\n        if (message.hasOwnProperty("action")) {\n          //  console.log(message)\n          switch (message.action) {\n            case "setStorage":\n              app.setStorage(message.values);\n              break;\n\n            case "getConfig":\n              app.getConfig(from);\n              break;\n\n            case "webIdChanged":\n              app.webIdChanged(message.webId);\n              break;\n\n            default:\n              console.log("Unknown action ", message);\n          }\n        }\n      };\n    }\n\n    this.readStorage();\n    this.agent.send("App", {\n      action: "initFromStore",\n      store: this.store\n    });\n  }\n\n  webIdChanged(webId) {\n    console.log("WEBID CHANGED", webId, this.webId); //  this.webId = webId\n\n    if (webId != null) {\n      console.log("WEBID NON NULL", webId, this.webId);\n\n      if (webId == this.store.config.webId) {\n        console.log("WEBID IDENTIQUE");\n        this.store.config.status = "WebId from store : ", +webId;\n        this.agent.send("App", {\n          action: "showPanel",\n          panel: "Flow"\n        });\n      } else {\n        console.log("WEBID DIFFERENT", webId, this.webId);\n        this.store.config.webId = webId;\n        this.store.config.status = "WebId has changed : ", +webId;\n        this.agent.send("App", {\n          action: "showPanel",\n          panel: "Config"\n        });\n        this.agent.send("Config", {\n          action: "newConfig",\n          config: this.store.config\n        });\n      }\n    } else {\n      console.log("WEBID CHANGED IS NULL", this.webId);\n      this.store.config = {};\n      this.agent.send("Friends", {\n        action: "configChanged",\n        config: this.store.config\n      });\n      this.agent.send("Profile", {\n        action: "configChanged",\n        config: this.store.config\n      });\n    }\n\n    console.log(this.webId);\n    this.populateStorage();\n  }\n\n  getConfig(from) {\n    this.agent.sendMulti([from, "PostTabs", "Profile", "Friends", "ProfileCartouche"], {\n      action: "configChanged",\n      config: this.store.config\n    });\n  }\n\n  readStorage() {\n    this.store = JSON.parse(localStorage.getItem("agora")) || {\n      info: true,\n      config: {}\n    };\n    console.log("STORE : ", this.store);\n  }\n\n  setStorage(values) {\n    console.log(values);\n\n    for (let [key, value] of Object.entries(values)) {\n      console.log("".concat(key, ": ").concat(value));\n      this.store[key] = value;\n    }\n\n    console.log(this.store);\n    this.populateStorage();\n  }\n\n  populateStorage() {\n    localStorage.setItem("agora", JSON.stringify(this.store));\n    this.readStorage();\n  }\n\n  updateStorage(data) {\n    this.store = data;\n    this.populateStorage();\n    this.readStorage();\n  }\n\n  cleanStorage() {\n    localStorage.removeItem("agora");\n    this.readStorage();\n  }\n\n}\n\ncustomElements.define(\'store-element\', store_element_StoreElement);\n// CONCATENATED MODULE: ./src/views/panel-element.js\nfunction panel_element_templateObject() {\n  const data = panel_element_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n\\n    <div class=\\"card shadow mb-4\\" >\\n    <div class=\\"card-header py-3\\">\\n    <h6 class=\\"m-0 font-weight-bold text-primary\\">", "</h6>\\n    </div>\\n    <div class=\\"card-body\\">\\n    <div class=\\"text-center\\">\\n    <img class=\\"img-fluid px-3 px-sm-4 mt-3 mb-4\\" style=\\"height: 10rem;\\" src=\\"", "\\" alt=\\"\\">\\n    </div>\\n    <p>", "</p>\\n    <button class=\\"btn btn-outline-info\\"  panel=\\"", "\\" @click=\\"", "\\">", "</button>\\n    </div>\\n    </div>\\n\\n    "]);\n\n  panel_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction panel_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass panel_element_PanelElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      p: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Panel";\n    this.p = {};\n  }\n\n  render() {\n    return lit_html_html(panel_element_templateObject(), this.p.name, this.p.image, this.p.text, this.p.name, this.showPanel, this.p.name);\n  }\n\n  showPanel(e) {\n    let panel = e.target.getAttribute("panel");\n    this.agent.send("App", {\n      action: "showPanel",\n      panel: panel\n    });\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n}\n\ncustomElements.define(\'panel-element\', panel_element_PanelElement);\n// CONCATENATED MODULE: ./src/views/info-element.js\nfunction info_element_templateObject() {\n  const data = info_element_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n\\n\\n    <div class=\\"jumbotron\\">\\n    <h1 class=\\"display-4\\">Agora</h1>\\n    <p class=\\"lead\\">\\n    The DecentraliShare app !<br>\\n    <b>Agora</b> is an POC to use ActivityPub\\n    (<a href=\\"https://en.wikipedia.org/wiki/ActivityPub\\" target=\\"_blank\\">En</a>)\\n    (<a href=\\"https://fr.wikipedia.org/wiki/ActivityPub\\" target=\\"_blank\\">Fr</a>)\\n    on top of the Solid Platform.</p>\\n    <hr class=\\"my-4\\">\\n\\n    <p>If you want to use Agora, you must configure your POD.</p>\\n    <p>\\n    Agora needs HIGH CONTROL to your POD to set authorizations on data created.<br>\\n    Although Agora limits its interaction to a specific folder of your POD,\\n    if you don\'t want Agora to access your entire favorite POD,\\n    you can <a class=\\"btn btn-info btn-sm\\" href=\\"https://solid.inrupt.com/get-a-solid-pod\\" target=\\"_blank\\">create a new POD</a>\\n    </p>\\n\\n    <p>\\n    To conform to ActivityPub, one user (you) must have two folders (inbox & outbox).<br>\\n    We decided to put them in your /public/ folder in a /agora/ (old /shighl_test/) sub-folder (arbitrary for the moment & you can change it in the profil/config panel).<br>\\n    In that /agora/ folders there is an \\"index.ttl\\" file that reference\\n    \\"inbox\\" & \\"outbox\\" folders\\n    & that is referenced in your <b>publicTypeIndex</b> as a <b>Agora</b> instance.<br><br>\\n    Some specials authorizations are set to the /inbox/ & /outbox/ folders:\\n    <ul>\\n    <li>\\n    <b>/inbox/</b> folder where you receive notifications of other users actions.\\n    <br>You keep full CONTROL.\\n    Authenticated Agent (Everyone with a POD) is a Submitter (they can write but not read).\\n    </li>\\n    <li>\\n    <b>/outbox/</b> folder where <b>activities</b> & <b>objects</b> that you create are stored.<br>\\n    You keep full CONTROL. Authorizations for data stored in /activities/ & /objects/ sub-folders\\n    are set when you create that activities/objects,\\n    according to the recipient of that activity (Public, or a specific POD)\\n    </li>\\n    </ul>\\n\\n    <br>\\n    </p>\\n\\n    <p><b>To allow Agora to configure your POD,\\n    you must accept Agora can \\"CONTROL\\" your POD.</b>\\n    </p>\\n    <p>\\n    This can be done when you login for the first time\\n    on an app hosted on https://scenaristeur.github.io/\\n    by checking the last line of the authorization.\\n    <br><br>\\n    <a href=\\"./img/checkControl.png\\"\\n    target=\\"_blank\\">\\n    <img src=\\"./img/checkControl.png\\"\\n    class=\\"img-fluid img-thumbnail\\"\\n    alt=\\"Add https://scenaristeur.github.io to trustedApps\\">\\n    </a>\\n    <br>\\n    <br>\\n    If you miss it or if you have already logged on a https://scenaristeur.github.io/ app\\n    but did not allow \\"CONTROL\\"\\n    you can add it in the preferences (right menu of your POD)\\n    by checking all 4 \\"Access Modes\\" like shown below.\\n    <br><br>\\n    <a href=\\"./img/trustedApps.png\\"\\n    target=\\"_blank\\">\\n    <img src=\\"./img/trustedApps.png\\"\\n    class=\\"img-fluid img-thumbnail\\"\\n    alt=\\"Add https://scenaristeur.github.io to trustedApps\\">\\n    </a>\\n    <br>\\n    </p>\\n\\n    <p>\\n    At the end of the configuration, you should see a structure like this one on your POD (this example show you structure & some data in each )\\n    (shighl_test has been replaced by agora / followers, followning, liked are not ready, WIP).\\n    <br><br>\\n    <a href=\\"./img/agora_folder.png\\"\\n    target=\\"_blank\\"><img src=\\"./img/agora_folder.png\\"\\n    class=\\"img-fluid img-thumbnail\\"\\n    max-height=\\"300px\\"\\n    alt=\\"Add https://scenaristeur.github.io to trustedApps\\">\\n    </a>\\n\\n    <p>\\n    If you have any question or suggestion, feel free to ask on\\n    <a href=\\"https://forum.solidproject.org/\\" target=\\"_blank\\">Solid Community Forum</a>,\\n    or on <a href=\\"https://github.com/scenaristeur/agora/blob/master/README.md\\"\\n    target=\\"_blank\\">Agora project</a> repository.\\n    </p>\\n\\n    <p><b>Last, but not least :</b> if you install Agora on your device, you can use it as a \\"Share with...\\" app... ;-) </p>\\n    <p class=\\"lead\\">\\n    If all is OK for you,\\n    <button class=\\"btn btn-info\\" @click=\\"", "\\">Close Help</button> and Login.\\n    \x3c!--  <a class=\\"btn btn-primary btn-lg\\" href=\\"#\\" role=\\"button\\">Learn more</a>--\x3e\\n    </p>\\n    </div>\\n    "]);\n\n  info_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction info_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass info_element_InfoElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Info";\n  }\n\n  render() {\n    return lit_html_html(info_element_templateObject(), this.showPanel);\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  showPanel() {\n    this.agent.send("App", {\n      action: "showPanel"\n    });\n    console.log("hide");\n    let values = [];\n    values.info = false;\n    this.agent.send("Store", {\n      action: "setStorage",\n      values: values\n    });\n  }\n\n}\n\ncustomElements.define(\'info-element\', info_element_InfoElement);\n// CONCATENATED MODULE: ./src/views/login-element.js\nfunction login_element_templateObject3() {\n  const data = login_element_taggedTemplateLiteral(["\\n      <button type=\\"button\\" class=\\"btn btn-sm btn-outline-danger\\" @click=", ">Logout</button>\\n      "]);\n\n  login_element_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction login_element_templateObject2() {\n  const data = login_element_taggedTemplateLiteral(["\\n      <button type=\\"button\\" class=\\"btn btn-success\\" @click=", ">Login</button>\\n      "]);\n\n  login_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction login_element_templateObject() {\n  const data = login_element_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n\\n    ", "\\n    "]);\n\n  login_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction login_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n //import { BaseView } from \'./base-view.js\';\n//import * as auth from \'solid-auth-client\';\n////let data = solid.data\n//console.log("LDFK+LEX",data)\n\nclass login_element_LoginElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      webId: {\n        type: String\n      },\n      destinataires: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.webId = null; //  this.destinataires = [\'App\',\'Config\', \'ConfigGet\', \'Fab\', \'Post\', \'PostTabs\', \'Profile\', \'ProfileCartouche\', \'Friends\']\n\n    this.destinataires = [\'App\', \'Store\', \'Fab\', \'Post\', \'PostTabs\'];\n  }\n\n  render() {\n    return lit_html_html(login_element_templateObject(), this.webId == null ? lit_html_html(login_element_templateObject2(), this.login) : lit_html_html(login_element_templateObject3(), this.logout));\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      console.log("messah", message);\n\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n\n    solid.auth.trackSession(async function (session) {\n      if (!session) {\n        app.webId = null;\n        console.log("WEBID", app.webId);\n        app.agent.sendMulti(app.destinataires, {\n          action: "webIdChanged",\n          webId: app.webId\n        });\n      } else {\n        app.webId = session.webId;\n        console.log("WEBID", app.webId);\n        app.agent.sendMulti(app.destinataires, {\n          action: "webIdChanged",\n          webId: app.webId\n        });\n      }\n    });\n\n    this.agent.receive = function (from, message) {\n      if (message.hasOwnProperty("action")) {\n        switch (message.action) {\n          case "logout":\n            app.logout(null);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  login() {\n    this.popupLogin();\n  }\n\n  logout() {\n    let wi = this.webId;\n    solid.auth.logout().then(() => alert(\'Goodbye \' + wi + \' !\'));\n  }\n\n  async popupLogin() {\n    let session = await solid.auth.currentSession();\n    let popupUri = \'./dist-popup/popup.html\'; //  let popupUri = \'https://solid.community/common/popup.html\';\n\n    if (!session) session = await solid.auth.popupLogin({\n      popupUri\n    });\n  }\n\n}\n\ncustomElements.define(\'login-element\', login_element_LoginElement);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.symbol.async-iterator.js\nvar es7_symbol_async_iterator = __webpack_require__(13);\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.symbol.js\nvar es6_symbol = __webpack_require__(14);\n\n// CONCATENATED MODULE: ./src/views/flux-element.js\n\n\n\nfunction flux_element_templateObject2() {\n  const data = flux_element_taggedTemplateLiteral(["\\n      <li class=\\"list-group-item\\" id=\\"", "\\">\\n      <notification-line-element id=\\"", "\\"\\n      name = \\"", "\\"\\n      .notification=\\"", "\\">Loading notification...</notification-line-element>\\n      </li>\\n      "]);\n\n  flux_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction flux_element_templateObject() {\n  const data = flux_element_taggedTemplateLiteral(["\\n\\n    <div class=\\"row border\\" style=\\"overflow-y:scroll;position:relative;height: 400px;\\">\\n\\n    <div class=\\"lead\\" ?hidden = \\"", "\\">\\n    Loading<br>Activities<br>from<br>", "\\n    <br>", "\\n    </div>\\n    <ul class=\\"list-group list-group-flush\\">\\n    ", "\\n      </ul>\\n\\n\\n      </div>\\n      "]);\n\n  flux_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction flux_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }\n\n\n ////let data = solid.data\n//console.log("LDFK+LEX",data)\n////import * as auth from \'solid-auth-client\';\n//import \'./notification-line-element.js\'\n//let data = solid.data\n//console.log("LDFK+LEX",data)\n\nclass flux_element_FluxElement extends base_view_BaseView {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      agoraPod: {\n        type: String\n      },\n      notifications: {\n        type: String\n      },\n      log: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Flux";\n    this.agoraPod = "";\n    this.notifications = [];\n    this.log = "";\n  }\n\n  render() {\n    return lit_html_html(flux_element_templateObject(), this.notifications.length != 0, this.agoraPod, this.log, this.notifications.map((n, i) => lit_html_html(flux_element_templateObject2(), this.name, \'Notification\' + i, \'Notification\' + i, n)));\n  }\n\n  firstUpdated() {\n    super.firstUpdated();\n    this.init();\n  }\n\n  async init() {\n    let app = this;\n    this.log = "Agora Pod : " + this.agoraPod; //console.log(this.agoraPod)\n\n    let pti_url = await solid.data[this.agoraPod].solid$publicTypeIndex;\n    this.log = \'Pti url : \' + pti_url; //console.log(`${pti_url}`)\n\n    let instance = await solid.data[pti_url + "#Agora"].solid$instance;\n    this.log = \'Instance url : \' + instance; //console.log(`${instance}`)\n\n    let inbox = await solid.data[instance].as$inbox;\n    this.log = \'Inbox : \' + inbox; //console.log(`${inbox}`)\n\n    let notifications = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(solid.data[inbox].subjects), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const subject = _value;\n\n        //    console.log(`${subject}`)\n        if ("".concat(subject) != inbox) {\n          let n = {};\n          n.url = "".concat(subject) + \'#this\';\n          /* */\n\n          notifications.push(n);\n          app.log = "Notifications : " + notifications.length;\n        }\n      } //console.log(notifications)\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    this.notifications = notifications; //  this.log = "Ready"\n\n    this.notifications.forEach(async function (n) {\n      let published = new Date((await solid.data[n.url].as$published));\n      n.published = "".concat(published);\n      n.timestamp = published.getTime();\n    });\n    /*  console.log(notifications)\r\n      this.log = "Sort Notifications"\r\n      notifications.sort(function(a, b){\r\n        return a.timestamp < b.timestamp;\r\n      });\r\n      this.notifications = notifications*/\n  }\n\n}\n\ncustomElements.define(\'flux-element\', flux_element_FluxElement);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.split.js\nvar es6_regexp_split = __webpack_require__(25);\n\n// CONCATENATED MODULE: ./src/views/notification-line-element.js\n\n\nfunction notification_line_element_templateObject3() {\n  const data = notification_line_element_taggedTemplateLiteral(["<i class=\\"fas fa-user-circle fa-2x\\"\\n    title=\\"", "\\"\\n    webId=\\"", "\\"\\n    @click=\\"", "\\"></i>"]);\n\n  notification_line_element_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction notification_line_element_templateObject2() {\n  const data = notification_line_element_taggedTemplateLiteral(["<img class=\\"rounded-circle ml-0\\" width=\\"32px\\"\\n    src=\\"//images.weserv.nl/?url=", "&w=32&h=32\\"\\n    title=\\"", "\\"\\n    alt=\\"no image\\"\\n    webId=\\"", "\\"\\n    @click=\\"", "\\">"]);\n\n  notification_line_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction notification_line_element_templateObject() {\n  const data = notification_line_element_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n\\n    <div timestamp=\\"", "\\"\\n    url=\\"", "\\">\\n\\n\\n    <div class=\\"row\\">\\n    <div class=\\"col-2\\">\\n    ", "\\n\\n  <p class=\\"text-muted small\\">", "</p>\\n  </div>\\n\\n  <div class=\\"col\\">\\n  <small class=\\"text-muted\\" webId=\\"", "\\"\\n  @click=\\"", "\\">\\n  ", "\\n  </small>\\n  <activity-element name=\\"", "\\"\\n  url=\\"", "\\">Loading activity ", "...\\n  </activity-element>\\n  </div>\\n  </div>\\n\\n\\n  </div>\\n  "]);\n\n  notification_line_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction notification_line_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass notification_line_element_NotificationLineElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      notification: {\n        type: Object\n      },\n      creator: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "NotificationLine";\n    this.notification = {};\n    this.creator = {};\n  }\n\n  render() {\n    return lit_html_html(notification_line_element_templateObject(), this.notification.timestamp, this.notification.url, this.creator.photo != "undefined" ? lit_html_html(notification_line_element_templateObject2(), this.creator.photo, this.creator.name, this.creator.webId, this.showProfile) : lit_html_html(notification_line_element_templateObject3(), this.creator.name, this.creator.webId, this.showProfile), this.delay(this.notification.published), this.notification.attributedTo, this.showProfile, this.creator.name, this.name + \'_activity\', this.notification.link, this.notification.link);\n  }\n\n  showProfile() {\n    this.agent.send("App", {\n      action: "showPanel",\n      panel: "Profile"\n    });\n    this.agent.send("Profile", {\n      action: "profileChanged",\n      profile: this.creator\n    });\n  }\n\n  delay(published) {\n    let diff = new Date().getTime() - new Date(published).getTime();\n    let minute = 1000 * 60;\n    let minutes = Math.floor(diff / minute);\n    let heures = Math.floor(minutes / 60);\n    let jours = Math.floor(heures / 24);\n    let mois = Math.floor(jours / 31);\n    let annees = Math.floor(mois / 12);\n    let duree = "";\n    annees > 0 ? duree += annees + "y" : mois > 0 ? duree += mois + "m" : jours > 0 ? duree += jours + "j" : heures > 0 ? duree += heures + "h" : minutes > 0 ? duree += minutes + "m" : duree = diff / 1000 + "s";\n    return duree;\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name); //  console.log(this.agent)\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n\n    this.init();\n  }\n\n  async init() {\n    //    console.log(this.notification.url)\n    this.creator.webId = await solid.data[this.notification.url].as$attributedTo;\n    this.notification.summary = await solid.data[this.notification.url].as$summary;\n    this.notification.type = await solid.data[this.notification.url].as$type;\n    let link = await solid.data[this.notification.url].as$link;\n    this.notification.link = "".concat(link);\n    this.creator.name = (await solid.data[this.creator.webId].vcard$fn) || "".concat(this.creator.webId).split("/")[2].split(\'.\')[0];\n    let photo = await solid.data[this.creator.webId].vcard$hasPhoto;\n    this.creator.photo = "".concat(photo); //!= "undefined" ? `${photo}` : "https://solid.github.io/solid-ui/src/icons/noun_15059.svg"\n    //  console.log(this.notification)\n\n    this.requestUpdate();\n  }\n\n  localName(strPromise) {\n    let str = "".concat(strPromise);\n    var ln = str.substring(str.lastIndexOf(\'#\') + 1); //console.log(ln)\n\n    ln == str ? ln = str.substring(str.lastIndexOf(\'/\') + 1) : "";\n    return ln;\n  }\n\n}\n\ncustomElements.define(\'notification-line-element\', notification_line_element_NotificationLineElement);\n// CONCATENATED MODULE: ./src/views/activity-element.js\n\n\n\nfunction activity_element_templateObject2() {\n  const data = activity_element_taggedTemplateLiteral(["\\n      <object-element name=\\"", "\\"\\n      url=\\"", "\\">\\n      Loading object\\n      </object-element>\\n      "]);\n\n  activity_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction activity_element_templateObject() {\n  const data = activity_element_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n\\n    <div class=\\"row\\" id=\\"", "\\">\\n      <p class=\\"lead\\">\\n    ", "\\n    </p>\\n    </div>\\n\\n    ", "\\n\\n      <div class=\\"row mt-2\\">\\n      <button class=\\"btn btn-outline-info btn-sm\\"  @click=\\"", "\\">Reply</button>\\n      <button class=\\"btn btn-outline-info btn-sm\\"><i class=\\"fas fa-share-alt\\" @click=\\"", "\\"></i></button>\\n      <button class=\\"btn btn-outline-info btn-sm\\"><i class=\\"far fa-thumbs-up\\" @click=\\"", "\\"></i></button>\\n      <button class=\\"btn btn-outline-info btn-sm\\"><i class=\\"far fa-thumbs-down\\" @click=\\"", "\\"></i></button>\\n      </div>\\n\\n      "]);\n\n  activity_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction activity_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction activity_element_asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }\n\n\n //let data = solid.data\n//console.log("LDFK+LEX",data)\n//import \'./object-element.js\'\n\nclass activity_element_ActivityElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      url: {\n        type: String\n      },\n      activity: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Activity";\n    this.url = "";\n    this.activity = {\n      objects: []\n    };\n  }\n\n  render() {\n    return lit_html_html(activity_element_templateObject(), this.url, this.activity.summary, this.activity.objects.map(object => lit_html_html(activity_element_templateObject2(), this.name + \'_object\', object)), this.replyTo, this.share, this.like, this.dislike);\n  }\n\n  like() {\n    alert("// TODO: come back later ;-) ");\n  }\n\n  dislike() {\n    alert("// TODO: come back later ;-) ");\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name); //  console.log(this.agent)\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    }; //  this.init()\n\n  }\n\n  share() {\n    if (navigator.share) {\n      navigator.share({\n        title: "Take a look at that Agora Spog :\\n\\n",\n        text: this.activity.summary + "\\n\\n",\n        url: \'https://scenaristeur.github.io/agora?activity=\' + this.url + \'\\n\\n\'\n      }).then(() => console.log(\'Successful share\')).catch(error => console.log(\'Error sharing\', error));\n    } else {\n      var to = \'\';\n      var sub = "Agora : " + this.activity.summary;\n      var body = \'I want to share this link with you :   \\n https://scenaristeur.github.io/agora?activity=\' + this.url + \'  \\n \\n \';\n      var mailarr = [];\n\n      if (sub != "") {\n        sub = "subject=" + encodeURIComponent(sub);\n        mailarr.push(sub);\n      }\n\n      if (body != "") {\n        body = "body=" + encodeURIComponent(body);\n        mailarr.push(body);\n      }\n\n      var mailstr = mailarr.join("&");\n\n      if (mailstr != "") {\n        mailstr = "?" + mailstr;\n      }\n\n      window.open("mailto:" + to + mailstr);\n    }\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      //  console.log(`${propName} changed. oldValue: ${oldValue}`);\n      if ("".concat(propName) == "url" && this.url != "undefined") {\n        this.init();\n      }\n    });\n  }\n\n  async init() {\n    //console.log(this.url)\n    let objects = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = activity_element_asyncIterator(solid.data[this.url].as$object), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const object = _value;\n        objects = [...objects, "".concat(object)];\n      } //      console.log("OBJECTS",objects)\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    this.activity.objects = objects; // = await solid.data[this.url].as$object\n\n    this.activity.target = await solid.data[this.url].as$target;\n    this.activity.summary = await solid.data[this.url].as$summary;\n    this.requestUpdate();\n  }\n\n  localName(strPromise) {\n    let str = "".concat(strPromise);\n    var ln = str.substring(str.lastIndexOf(\'#\') + 1);\n    ln == str ? ln = str.substring(str.lastIndexOf(\'/\') + 1) : "";\n    return ln;\n  }\n\n  replyTo() {\n    console.log(this.url);\n    this.agent.send("App", {\n      action: "showPanel",\n      panel: "Compose"\n    });\n    this.agent.send("Post", {\n      action: "toggleWrite"\n    });\n    this.agent.send("PostTabs", {\n      action: "setReplyTo",\n      replyTo: this.url\n    });\n  }\n\n}\n\ncustomElements.define(\'activity-element\', activity_element_ActivityElement);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.replace.js\nvar es6_regexp_replace = __webpack_require__(26);\n\n// CONCATENATED MODULE: ./src/views/object-element.js\n\n\nfunction object_element_templateObject3() {\n  const data = object_element_taggedTemplateLiteral([" "]);\n\n  object_element_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction object_element_templateObject2() {\n  const data = object_element_taggedTemplateLiteral(["<img src=\\"", "\\" style=\'height: auto; width: 75%; max-width: 300px; object-fit: contain\' alt=\\"", "\\"/>"]);\n\n  object_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction object_element_templateObject() {\n  const data = object_element_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <div class=\\"row\\" >\\n    <div class=\\"col\\">\\n\\n    ", "\\n  <small> <div id=\\"content\\">", "</div></small>\\n    </div>\\n    </div>\\n\\n    "]);\n\n  object_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction object_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n //let data = solid.data\n//console.log("LDFK+LEX",data)\n\nclass object_element_ObjectElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      url: {\n        type: String\n      },\n      object: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Object";\n    this.url = "";\n    this.object = {};\n  }\n\n  render() {\n    return lit_html_html(object_element_templateObject(), this.object.ext == "jpg" ? lit_html_html(object_element_templateObject2(), this.url, this.url) : lit_html_html(object_element_templateObject3()), this.object.content);\n  }\n\n  linkify(inputText) {\n    // \x3c!--    ${this.linkify(`${this.object.content}`)}--\x3e\n    //console.log(inputText)\n    //URLs starting with http://, https://, or ftp://\n    var replacePattern1 = /(\\b(https?|ftp):\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/gim;\n    var replacedText = inputText.replace(replacePattern1, \' <small><a href="$1" target="_blank">$1</a></small> \'); //URLs starting with www. (without // before it, or it\'d re-link the ones done above)\n\n    var replacePattern2 = /(^|[^\\/])(www\\.[\\S]+(\\b|$))/gim;\n    var replacedText = replacedText.replace(replacePattern2, \' <small>$1<a href="http://$2" target="_blank">$2</a></small> \'); //Change email addresses to mailto:: links\n\n    var replacePattern3 = /(\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,6})/gim;\n    var replacedText = replacedText.replace(replacePattern3, \'<a href="mailto:$1">$1</a>\');\n    this.shadowRoot.getElementById("content").innerHTML = replacedText;\n    this.requestUpdate(); //    return html`${replacedText}`\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name); //  console.log(this.agent)\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      //  console.log(`${propName} changed. oldValue: ${oldValue}`);\n      if ("".concat(propName) == "url" && this.url != "undefined") {\n        this.init();\n      }\n    });\n  }\n\n  async init() {\n    //console.log(this.url)\n    this.object.ext = this.url.substr(this.url.lastIndexOf(\'.\') + 1);\n\n    if (this.object.ext == "ttl#this") {\n      let as = "https://www.w3.org/ns/activitystreams#"; //  this.object.name = await solid.data[this.url].as$name\n\n      let type = await solid.data[this.url].as$type;\n      this.object.type = "".concat(type);\n\n      switch (this.localName("".concat(type))) {\n        case "Triple":\n          this.object.content = ""; //"[todo parse triples like "+ this.url+"</small>]"\n\n          this.requestUpdate();\n          break;\n\n        case "Note":\n        default:\n          this.object.content = await solid.data[this.url].as$content;\n          this.linkify("".concat(this.object.content));\n      }\n    } else {\n      //  console.log(this.object.ext,this.url)\n      this.requestUpdate();\n    }\n  }\n\n  localName(strPromise) {\n    let str = "".concat(strPromise);\n    var ln = str.substring(str.lastIndexOf(\'#\') + 1);\n    ln == str ? ln = str.substring(str.lastIndexOf(\'/\') + 1) : "";\n    return ln;\n  }\n\n}\n\ncustomElements.define(\'object-element\', object_element_ObjectElement);\n// EXTERNAL MODULE: ./node_modules/solid-file-client/dist/window/solid-file-client.bundle.js\nvar solid_file_client_bundle = __webpack_require__(15);\n\n// EXTERNAL MODULE: ./node_modules/@rdfjs/data-model/index.js\nvar data_model = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/views/config-get-view.js\n\n\n\n\nfunction config_get_view_templateObject2() {\n  const data = config_get_view_taggedTemplateLiteral(["\\n      <li class=\\"list-group-item ", "\\">\\n      ", " : <small><a href=\\"", "\\" target=\\"_blank\\">", "</a></small></li>\\n      "]);\n\n  config_get_view_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction config_get_view_templateObject() {\n  const data = config_get_view_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n\\n    <div ?hidden = \\"", "\\">\\n    Hello from<b>", "</b><br>\\n    config : ", "</br>\\n    </div>\\n\\n    <h4>Configuration</h4>\\n    Log : <span class=\\"", "\\">", "</span><br><br>\\n    <button class=\\"btn btn-danger\\" @click=\\"", "\\">RE-check configuration from POD</button>\\n\\n\\n    <ul class=\\"list-group\\">\\n    ", "\\n      </ul>\\n\\n\\n      <div id=\\"modal1\\" class=\\"modal\\" tabindex=\\"-1\\" role=\\"dialog\\">\\n      <div class=\\"modal-dialog modal-lg\\" role=\\"document\\">\\n      <div class=\\"modal-content\\">\\n      <div class=\\"modal-header\\">\\n      <h5 class=\\"modal-title\\">", "</h5>\\n      <button type=\\"button\\" class=\\"close\\" data-dismiss=\\"modal\\" aria-label=\\"Close\\" @click=\\"", "\\">\\n      <span aria-hidden=\\"true\\">&times;</span>\\n      </button>\\n      </div>\\n      <div class=\\"modal-body\\">\\n      <form>\\n\\n      <div style=\\"overflow-x:auto\\">\\n      <div class=\\"form-group row\\">\\n      <label class=\\"col-sm-2 col-form-label\\" for=\\"pathInput\\">Path</label>\\n      <div class=\\"col-sm-9\\">\\n      <input type=\\"text\\" class=\\"form-control\\" id=\\"pathInput\\"\\n      placeholder=\\"Path\\"\\n      value=\\"", "\\"\\n      @input=\\"", "\\">\\n      </div>\\n      </div>\\n\\n      <div class=\\"form-group row\\">\\n      <label for=\\"staticInbox\\" class=\\"col-sm-2 col-form-label\\">Inbox</label>\\n      <div class=\\"col-sm-9\\">\\n      <input type=\\"text\\" readonly class=\\"form-control-plaintext\\" id=\\"staticInbox\\" >\\n      </div>\\n      </div>\\n\\n      <div class=\\"form-group row\\">\\n      <label for=\\"staticOutbox\\" class=\\"col-sm-2 col-form-label\\">Outbox</label>\\n      <div class=\\"col-sm-9\\">\\n      <input type=\\"text\\" readonly class=\\"form-control-plaintext\\" id=\\"staticOutbox\\" >\\n      </div>\\n      </div>\\n      </div>\\n      </form>\\n\\n      </div>\\n      <div class=\\"modal-footer\\">\\n      <button type=\\"button\\" class=\\"btn btn-primary\\" @click=\\"", "\\">Save changes</button>\\n      <button type=\\"button\\" class=\\"btn btn-secondary\\"\\n      data-dismiss=\\"modal\\" @click=\\"", "\\">Close</button>\\n      </div>\\n      </div>\\n      </div>\\n      </div>\\n      "]);\n\n  config_get_view_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction config_get_view_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction config_get_view_asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }\n\n\n\n\n\n\nclass config_get_view_ConfigGetView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      config: {\n        type: Object\n      },\n      log: {\n        type: String\n      },\n      aclInbox: {\n        type: String\n      },\n      textColor: {\n        type: String\n      },\n      debug: {\n        type: Boolean\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Config GET";\n    this.config = {};\n    this.log = "Init";\n    this.textColor = "text-primary";\n    this.debug = false;\n    this.aclInboxContent = "@prefix : <#>.\\n    @prefix acl: <http://www.w3.org/ns/auth/acl#>.\\n    @prefix inbox: <./>.\\n    @prefix c: </profile/card#>.\\n\\n    :Append\\n    a acl:Authorization;\\n    acl:accessTo <./>;\\n    acl:agentClass acl:AuthenticatedAgent;\\n    acl:default <./>;\\n    acl:mode acl:Append.\\n    :ControlReadWrite\\n    a acl:Authorization;\\n    acl:accessTo <./>;\\n    acl:agent c:me;\\n    acl:default <./>;\\n    acl:mode acl:Control, acl:Read, acl:Write.\\n    :Read\\n    a acl:Authorization;\\n    acl:accessTo <./>;\\n    acl:default <./>;\\n    acl:mode acl:Read.";\n  }\n\n  render() {\n    return lit_html_html(config_get_view_templateObject(), !this.debug, this.name, JSON.stringify(this.config), this.textColor, this.log, this.checkConfig, Object.entries(this.config).map(([key, value]) => lit_html_html(config_get_view_templateObject2(), value == "undefined" ? "list-group-item-danger list-group-item-action" : "list-group-item-success", key, value, value)), this.log, this.hideModal, this.path, this.pathChanged, this.createFolders, this.hideModal);\n  }\n\n  newConfig(config) {\n    console.log("");\n    this.config = config;\n    this.checkConfig();\n  }\n\n  async checkConfig() {\n    this.textColor = "text-primary";\n    this.log = "Checking PublicTypeIndex";\n    this.config.date = new Date();\n    this.config.status = "unknown";\n    this.config.origin = "pod";\n    this.config.pti = "undefined";\n    let pti = await solid.data[this.config.webId].publicTypeIndex;\n    this.config.pti = "".concat(pti);\n    this.log = "Checking Instances";\n    this.config.instance = "undefined";\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = config_get_view_asyncIterator(solid.data[this.config.pti].subjects), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const subject = _value;\n        if (this.config.pti != "".concat(subject))\n          /*let s = `${subject}`\r\n          console.log(s)*/\n          this.log = "Checking Agora Instance";\n\n        if ("".concat(subject).endsWith(\'#Agora\')) {\n          let instance = await solid.data["".concat(subject)].solid$instance;\n          this.config.instance = "".concat(instance);\n          this.log = "Checking Inbox";\n          this.config.inbox = "undefined";\n          let inbox = await solid.data[this.config.instance].as$inbox;\n          this.config.inbox = "".concat(inbox);\n          this.log = "Checking Outbox";\n          this.config.outbox = "undefined";\n          let outbox = await solid.data[this.config.instance].as$outbox;\n          this.config.outbox = "".concat(outbox);\n          this.log = "Checking Followers";\n          this.config.followers = "undefined";\n          let followers = await solid.data[this.config.instance].as$followers;\n          this.config.followers = "".concat(followers);\n          this.log = "Checking Following";\n          this.config.following = "undefined";\n          let following = await solid.data[this.config.instance].as$following;\n          this.config.following = "".concat(following);\n          this.log = "Checking Liked";\n          this.config.liked = "undefined";\n          let liked = await solid.data[this.config.instance].as$liked;\n          this.config.liked = "".concat(liked);\n          this.log = "Cool, your configuration seems OK";\n          await this.checkAcl();\n        }\n      } //  console.log(Object.values(this.config))\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (Object.values(this.config).includes("undefined")) {\n      this.log = this.log + " CONFIGURATION NOT OK";\n      this.textColor = "text-danger";\n      this.config.status = "KO";\n      this.agent.send("App", {\n        action: "showPanel",\n        panel: "Config"\n      });\n      this.openConfigBox();\n    } else {\n      this.log = "CONFIGURATION OK";\n      this.config.status = "OK";\n      this.textColor = "text-success";\n      let friends = [];\n      let followers = [];\n      let following = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = config_get_view_asyncIterator(solid.data[this.config.webId].friends), _step2, _value2; _step2 = await _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = await _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const friend = _value2;\n          let f = "".concat(friend);\n          friends = [...friends, f];\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            await _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.config.friends = friends;\n      this.config.followers_uri = this.config.followers + "index.ttl#this";\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = config_get_view_asyncIterator(solid.data[this.config.followers_uri].as$items), _step3, _value3; _step3 = await _iterator3.next(), _iteratorNormalCompletion3 = _step3.done, _value3 = await _step3.value, !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {\n          const f_er = _value3;\n          let fer = "".concat(f_er);\n          followers = [...followers, fer];\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            await _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      this.config.followersList = followers;\n      this.config.following_uri = this.config.following + "index.ttl#this";\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n\n      var _iteratorError4;\n\n      try {\n        for (var _iterator4 = config_get_view_asyncIterator(solid.data[this.config.following_uri].as$items), _step4, _value4; _step4 = await _iterator4.next(), _iteratorNormalCompletion4 = _step4.done, _value4 = await _step4.value, !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {\n          const f_ing = _value4;\n          let fing = "".concat(f_ing);\n          following = [...following, fing];\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            await _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      this.config.followingList = following;\n      let storage = await solid.data[this.config.webId].publicTypeIndex;\n      this.config.storage = "".concat(storage);\n      this.agent.send("Store", {\n        action: "setStorage",\n        values: {\n          config: this.config\n        }\n      });\n      this.agent.send("App", {\n        action: "showPanel"\n      });\n      this.agent.send("Friends", {\n        action: "configChanged",\n        config: this.config\n      });\n      this.agent.send("Profile", {\n        action: "configChanged",\n        config: this.config\n      });\n    }\n  }\n\n  async checkAcl() {\n    let app = this;\n    this.log = "ACL INBOX & FOLLOWERS VERIFICATION";\n    this.config.acl_inbox = "undefined";\n    this.config.acl_followers = "undefined";\n    let inboxacl = this.config.inbox + ".acl";\n    let followersacl = this.config.followers + ".acl";\n    console.log(inboxacl);\n    console.log(followersacl);\n    let fc = new solid_file_client_bundle(solid.auth);\n    await fc.createFile(inboxacl, this.aclInboxContent, "text/turtle").then(success => {\n      this.log = "Created " + inboxacl;\n      this.config.acl_inbox = inboxacl;\n    }, err => {\n      this.log = err;\n      alert(err + "... Are you sure you grant AGORA to FULL CONTROL ? see HELP !");\n      this.log = err + "... Are you sure you grant AGORA to FULL CONTROL ? Please see HELP !";\n    });\n    await fc.createFile(followersacl, this.aclInboxContent, "text/turtle").then(success => {\n      this.log = "Created " + followersacl;\n      this.config.acl_followers = followersacl;\n    }, err => {\n      this.log = err;\n      alert(err + "... Are you sure you grant AGORA to FULL CONTROL ? see HELP !");\n      this.log = err + "... Are you sure you grant AGORA to FULL CONTROL ? Please see HELP !";\n    });\n  }\n\n  async openConfigBox() {\n    console.log(this.config.pti);\n    this.storage = await solid.data[this.config.webId].storage;\n    console.log("".concat(this.storage));\n    this.path = this.storage + "public/agora/";\n    console.log(this.path);\n    this.showModal();\n    await this.requestUpdate();\n    this.pathChanged();\n  }\n\n  showModal() {\n    console.log("show");\n    this.shadowRoot.getElementById("modal1").style.display = "block";\n  }\n\n  hideModal() {\n    this.shadowRoot.getElementById("modal1").style.display = "none";\n  }\n\n  async createFolders() {\n    if (!this.path.includes(this.storage + "public/")) {\n      alert("Error the path must be in your /public folder");\n      this.path = this.storage + "public/agora/";\n      this.shadowRoot.getElementById("pathInput").value = this.path;\n      console.log(this.path);\n      await this.requestUpdate();\n      this.pathChanged();\n    } else {\n      this.hideModal();\n      this.log = "Creating Folders";\n      let fc = new solid_file_client_bundle(solid.auth);\n      console.log(this.fc);\n      let root = this.path;\n      let inbox = this.shadowRoot.getElementById("staticInbox").value;\n      let outbox = this.shadowRoot.getElementById("staticOutbox").value;\n      console.log(root, inbox, outbox);\n      this.log = "Creating Inbox Folder";\n      let file = inbox + ".acl";\n      await fc.createFile(file, this.aclInboxContent, "text/turtle").then(success => {\n        this.log = "Created " + file;\n      }, err => {\n        this.log = err;\n        alert(err);\n      });\n\n      try {\n        this.log = "outbox Folder creation : " + outbox;\n\n        if (!(await fc.itemExists(outbox))) {\n          await fc.createFolder(outbox); // only create if it doesn\'t already exist\n        }\n\n        this.log = "outbox/objects Folder creation : " + outbox + "objects/";\n\n        if (!(await fc.itemExists(outbox + "objects/"))) {\n          await fc.createFolder(outbox + "objects/"); // only create if it doesn\'t already exist\n        }\n\n        this.log = "outbox/activities Folder creation : " + outbox + "activities/";\n\n        if (!(await fc.itemExists(outbox + "activities/"))) {\n          await fc.createFolder(outbox + "activities/"); // only create if it doesn\'t already exist\n        }\n      } catch (e) {\n        this.log = e;\n        alert(e);\n      }\n\n      try {\n        if (!(await fc.itemExists(root + "followers/"))) {\n          await fc.createFolder(root + "followers/"); // only create if it doesn\'t already exist\n        }\n      } catch (e) {\n        this.log = e;\n        alert(e);\n      }\n\n      try {\n        if (!(await fc.itemExists(root + "following/"))) {\n          await fc.createFolder(root + "following/"); // only create if it doesn\'t already exist\n        }\n      } catch (e) {\n        this.log = e;\n        alert(e);\n      }\n\n      try {\n        if (!(await fc.itemExists(root + "liked/"))) {\n          await fc.createFolder(root + "liked/"); // only create if it doesn\'t already exist\n        }\n      } catch (e) {\n        this.log = e;\n        alert(e);\n      }\n\n      try {\n        let id = "#Agora";\n        let inst_uri = this.config.pti + id;\n        let inst_index = root + \'index.ttl#this\';\n        this.log = "Instance Creation : ", inst_uri;\n        await solid.data[inst_uri].solid$forClass.add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Collection\'));\n        await solid.data[inst_uri].solid$instance.set(Object(data_model["namedNode"])(inst_index)); //  await solid.data[inst_uri].rdfs$label.add("Activity Streams Collection")\n\n        this.log = "Index Creation : ", inst_index;\n        await solid.data[inst_index].as$inbox.add(Object(data_model["namedNode"])(inbox));\n        await solid.data[inst_index].as$outbox.set(Object(data_model["namedNode"])(outbox));\n        await solid.data[inst_index].as$following.set(Object(data_model["namedNode"])(root + \'following/\'));\n        await solid.data[inst_index].as$followers.set(Object(data_model["namedNode"])(root + \'followers/\'));\n        await solid.data[inst_index].as$liked.set(Object(data_model["namedNode"])(root + \'liked/\'));\n        this.log = "YAHOOOOOOOOOOO, AGORA IS READY, AND WELL CONFIGURED !!!";\n      } catch (e) {\n        this.log = "Can not create PublicTypeIndex Instance ";\n        alert(e);\n      }\n    }\n\n    this.checkConfig();\n  }\n\n  pathChanged() {\n    let pathInput = this.shadowRoot.getElementById("pathInput").value;\n    this.path = pathInput.endsWith("/") ? pathInput : pathInput + "/";\n    console.log(this.path);\n    this.shadowRoot.getElementById("staticInbox").value = this.path + "inbox/";\n    this.shadowRoot.getElementById("staticOutbox").value = this.path + "outbox/";\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name); //  console.log(this.agent)\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "newConfig":\n            app.newConfig(message.config);\n            break;\n\n          case "configChanged":\n            app.configChanged(message.config);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    }; //app.agent.send("Store", {action:"getConfig"});\n\n  }\n\n  configChanged(config) {\n    console.log("CONFIG CHANGED", config);\n\n    if (config != undefined && config.webId == this.config.webId) {\n      config.origin = "store";\n      this.config = config;\n\n      if (this.config.status == "OK") {\n        this.agent.send("App", {\n          action: "showPanel"\n        });\n      }\n    } else {\n      this.agent.send("App", {\n        action: "showPanel",\n        panel: "Config"\n      });\n      this.checkConfig();\n    }\n  }\n  /*    webIdChanged(webId){\r\n  console.log("CONFIG GET ",webId)\r\n  this.config.webId = webId\r\n  if (webId != null){\r\n  this.log = "Logged"\r\n  this.agent.send("Store", {action: "getConfig"})\r\n    //  this.checkConfig()\r\n  }else{\r\n  this.config = {}\r\n  this.log = "Not Logged"\r\n  }\r\n  }*/\n\n\n}\n\ncustomElements.define(\'config-get-view\', config_get_view_ConfigGetView);\n// CONCATENATED MODULE: ./src/views/fab-element.js\nfunction fab_element_templateObject3() {\n  const data = fab_element_taggedTemplateLiteral([""]);\n\n  fab_element_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fab_element_templateObject2() {\n  const data = fab_element_taggedTemplateLiteral(["\\n      <button type=\\"button\\"\\n      class=\\"btn btn-write btn-info has-tooltip\\"\\n      data-placement=\\"left\\"\\n      @click=\\"", "\\"\\n      title=\\"Write\\"> <i class=\\"fa fa-pen\\"></i> </button>\\n      "]);\n\n  fab_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fab_element_templateObject() {\n  const data = fab_element_taggedTemplateLiteral(["\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <style>\\n    body { width: 100%; height: 100%; }\\n    .btn-group-fab {\\n      position: fixed;\\n      width: 50px;\\n      height: auto;\\n      right: 20px; bottom: 20px;\\n    }\\n    .btn-group-fab div {\\n      position: relative; width: 100%;\\n      height: auto;\\n    }\\n    .btn-group-fab .btn {\\n      position: absolute;\\n      bottom: 0;\\n      border-radius: 50%;\\n      display: block;\\n      margin-bottom: 4px;\\n      width: 40px; height: 40px;\\n      margin: 4px auto;\\n    }\\n    .btn-group-fab .btn-main {\\n      width: 50px; height: 50px;\\n      right: 50%; margin-right: -25px;\\n      z-index: 9;\\n    }\\n    .btn-group-fab .btn-sub {\\n      bottom: 0; z-index: 8;\\n      right: 50%;\\n      margin-right: -20px;\\n      -webkit-transition: all 2s;\\n      transition: all 0.5s;\\n    }\\n    .btn-write {\\n      position: fixed;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      right: 10px; bottom: 12px;\\n      /*\\n      width: 50px; height: 50px;\\n      right: 100%; margin-right: 0px;*/\\n      z-index: 9;\\n    }\\n    .btn-group-fab.active .btn-sub:nth-child(2) {\\n      bottom: 60px;\\n    }\\n    .btn-group-fab.active .btn-sub:nth-child(3) {\\n      bottom: 110px;\\n    }\\n    .btn-group-fab.active .btn-sub:nth-child(4) {\\n      bottom: 160px;\\n    }\\n    .btn-group-fab .btn-sub:nth-child(5) {\\n      bottom: 210px;\\n    }\\n    </style>\\n\\n\\n    ", "\\n\\n    \x3c!--\\n    <div class=\\"btn-group-fab\\" role=\\"group\\" @click=\\"", "\\" aria-label=\\"FAB Menu\\">\\n    <div>\\n\\n    <button type=\\"button\\" class=\\"btn btn-main btn-primary has-tooltip\\" data-placement=\\"left\\" title=\\"Menu\\"> <i class=\\"fa fa-bars\\"></i> </button>\\n    <button type=\\"button\\" class=\\"btn btn-sub btn-info has-tooltip\\" data-placement=\\"left\\" title=\\"Fullscreen\\"> <i class=\\"fa fa-arrows-alt\\"></i> </button>\\n    <button type=\\"button\\" class=\\"btn btn-sub btn-danger has-tooltip\\" data-placement=\\"left\\" title=\\"Save\\"> <i class=\\"far fa-save\\"></i> </button>\\n    <button type=\\"button\\" class=\\"btn btn-sub btn-warning has-tooltip\\" data-placement=\\"left\\" title=\\"Download\\"> <i class=\\"fa fa-download\\"></i> </button>\\n    </div>\\n    </div>--\x3e\\n\\n    "]);\n\n  fab_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fab_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass fab_element_FabElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      webId: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.webId = null;\n  }\n\n  render() {\n    return lit_html_html(fab_element_templateObject(), this.webId != null ? lit_html_html(fab_element_templateObject2(), this.toggleWrite) : lit_html_html(fab_element_templateObject3()), this.toggleFab);\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n\n    this.agent.receive = function (from, message) {\n      if (message.hasOwnProperty("action")) {\n        switch (message.action) {\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  webIdChanged(webId) {\n    this.webId = webId;\n  }\n\n  toggleFab() {\n    this.shadowRoot.querySelector(".btn-group-fab").classList.toggle(\'active\');\n  }\n\n  toggleWrite() {\n    console.log("toggleWrite");\n    this.agent.send("App", {\n      action: "showPanel",\n      panel: "Compose"\n    });\n    this.agent.send("Post", {\n      action: "toggleWrite"\n    });\n  }\n\n}\n\ncustomElements.define(\'fab-element\', fab_element_FabElement);\n// CONCATENATED MODULE: ./node_modules/lit-html/directives/class-map.js\n/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n// IE11 doesn\'t support classList on SVG elements, so we emulate it with a Set\nclass ClassList {\n    constructor(element) {\n        this.classes = new Set();\n        this.changed = false;\n        this.element = element;\n        const classList = (element.getAttribute(\'class\') || \'\').split(/\\s+/);\n        for (const cls of classList) {\n            this.classes.add(cls);\n        }\n    }\n    add(cls) {\n        this.classes.add(cls);\n        this.changed = true;\n    }\n    remove(cls) {\n        this.classes.delete(cls);\n        this.changed = true;\n    }\n    commit() {\n        if (this.changed) {\n            let classString = \'\';\n            this.classes.forEach((cls) => classString += cls + \' \');\n            this.element.setAttribute(\'class\', classString);\n        }\n    }\n}\n/**\n * Stores the ClassInfo object applied to a given AttributePart.\n * Used to unset existing values when a new ClassInfo object is applied.\n */\nconst previousClassesCache = new WeakMap();\n/**\n * A directive that applies CSS classes. This must be used in the `class`\n * attribute and must be the only part used in the attribute. It takes each\n * property in the `classInfo` argument and adds the property name to the\n * element\'s `class` if the property value is truthy; if the property value is\n * falsey, the property name is removed from the element\'s `class`. For example\n * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.\n * @param classInfo {ClassInfo}\n */\nconst classMap = directive_directive((classInfo) => (part) => {\n    if (!(part instanceof parts_AttributePart) || (part instanceof PropertyPart) ||\n        part.committer.name !== \'class\' || part.committer.parts.length > 1) {\n        throw new Error(\'The `classMap` directive must be used in the `class` attribute \' +\n            \'and must be the only part in the attribute.\');\n    }\n    const { committer } = part;\n    const { element } = committer;\n    let previousClasses = previousClassesCache.get(part);\n    if (previousClasses === undefined) {\n        // Write static classes once\n        // Use setAttribute() because className isn\'t a string on SVG elements\n        element.setAttribute(\'class\', committer.strings.join(\' \'));\n        previousClassesCache.set(part, previousClasses = new Set());\n    }\n    const classList = (element.classList || new ClassList(element));\n    // Remove old classes that no longer apply\n    // We use forEach() instead of for-of so that re don\'t require down-level\n    // iteration.\n    previousClasses.forEach((name) => {\n        if (!(name in classInfo)) {\n            classList.remove(name);\n            previousClasses.delete(name);\n        }\n    });\n    // Add or remove classes based on their classMap value\n    for (const name in classInfo) {\n        const value = classInfo[name];\n        if (value != previousClasses.has(name)) {\n            // We explicitly want a loose truthy check of `value` because it seems\n            // more convenient that \'\' and 0 are skipped.\n            if (value) {\n                classList.add(name);\n                previousClasses.add(name);\n            }\n            else {\n                classList.remove(name);\n                previousClasses.delete(name);\n            }\n        }\n    }\n    if (typeof classList.commit === \'function\') {\n        classList.commit();\n    }\n});\n//# sourceMappingURL=class-map.js.map\n// EXTERNAL MODULE: ./node_modules/solid-auth-client/browser/index.js\nvar browser = __webpack_require__(52);\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto != \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != \'undefined\' && typeof msCrypto.getRandomValues == \'function\' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\nfunction rng() {\n  if (!getRandomValues) {\n    throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/bytesToUuid.js\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var bytesToUuid_i = 0; bytesToUuid_i < 256; ++bytesToUuid_i) {\n  byteToHex[bytesToUuid_i] = (bytesToUuid_i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], \'-\', bth[buf[i++]], bth[buf[i++]], \'-\', bth[buf[i++]], bth[buf[i++]], \'-\', bth[buf[i++]], bth[buf[i++]], \'-\', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join(\'\');\n}\n\n/* harmony default export */ var esm_browser_bytesToUuid = (bytesToUuid);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == \'string\') {\n    buf = options === \'binary\' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || esm_browser_bytesToUuid(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/views/note-element.js\nfunction note_element_templateObject() {\n  const data = note_element_taggedTemplateLiteral(["\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <div class=\\"form-group\\">\\n    \x3c!--    <label class=\\"text-primary\\" for=\\"notearea\\"></label>--\x3e\\n    <textarea class=\\"form-control\\" id=\\"notearea\\"\\n    style=\\"width:100%;height:38vh\\"\\n    placeholder=\\"Write a note on your Pod & share it on Agora\\"></textarea>\\n    </div>\\n    "]);\n\n  note_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction note_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass note_element_NoteElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      share: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.share = {};\n  }\n\n  render() {\n    return lit_html_html(note_element_templateObject());\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n\n    this.agent.receive = function (from, message) {\n      if (message.hasOwnProperty("action")) {\n        switch (message.action) {\n          case "askContent":\n            app.askContent(from, message);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n\n    console.log("SHARE", this.share);\n\n    if (this.share.text != undefined) {\n      this.shadowRoot.getElementById("notearea").innerHTML += this.share.text + "\\n\\n" + this.share.url;\n    }\n  }\n\n  askContent(from, message) {\n    console.log(from, message);\n    var textarea = this.shadowRoot.getElementById(\'notearea\');\n    /*.shadowRoot.querySelector(".form-control")*/\n\n    var note = textarea.value.trim();\n    console.log(note);\n    this.agent.send(from, {\n      action: "reponseContent",\n      content: note,\n      id: message.id,\n      type: "Note"\n    });\n    textarea.value = "";\n  }\n\n}\n\ncustomElements.define(\'note-element\', note_element_NoteElement);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.match.js\nvar es6_regexp_match = __webpack_require__(85);\n\n// CONCATENATED MODULE: ./src/views/media-element.js\n\n\n\nfunction media_element_templateObject3() {\n  const data = media_element_taggedTemplateLiteral(["\\n      "]);\n\n  media_element_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction media_element_templateObject2() {\n  const data = media_element_taggedTemplateLiteral(["\\n      <div class=\\"row\\">\\n      <label class=\\"sr-only\\" for=\\"filename\\">Filename</label>\\n      <div class=\\"input-group mb-2\\">\\n      <input id=\\"filename\\" class=\\"form-control\\" type=\\"text\\" value=\\"", "\\" @change=\\"", "\\" placeholder=\\"Filename\\">\\n      <div class=\\"input-group-append\\">\\n      <div class=\\"input-group-text\\">", "</div>\\n      </div>\\n      </div>\\n      </div>\\n\\n\\n      "]);\n\n  media_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction media_element_templateObject() {\n  const data = media_element_taggedTemplateLiteral(["\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <style>\\n    i {\\n      padding: 10px\\n    }\\n    </style>\\n    \x3c!--  list : ", " --\x3e\\n    <div class=\\"row\\">\\n    <form>\\n    <div class=\\"custom-file\\">\\n    <input type=\\"file\\"\\n    class=\\"custom-file-input\\"\\n    @change=\\"", "\\"\\n    id=\\"mediaFile\\"\\n    accept=\\"image/*;video/*;audio/*\\"\\n    lang=\\"", "\\">\\n    <label class=\\"custom-file-label\\"\\n    for=\\"mediaFile\\">\\n    <i class=\\"fas fa-camera-retro\\"></i>\\n    <i class=\\"fas fa-video\\"></i>\\n    <i class=\\"fas fa-microphone\\"></i>\\n    </label>\\n    </div>\\n    </form>\\n    </div>\\n\\n    ", "\\n\\n      <div class=\\"col-auto\\"><canvas style=\\"max-width: 100%; height: auto;\\" id=\\"canvas\\"/></div>\\n\\n      "]);\n\n  media_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction media_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n// redimensionner l\'image avant envoi http://tech.novapost.fr/redimensionner-une-image-cote-client-avant-lupload.html\n\n\n\nclass media_element_MediaElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      count: {\n        type: Number\n      },\n      extension: {\n        type: String\n      },\n      filename: {\n        type: String\n      },\n      info: {\n        type: String\n      },\n      folders: {\n        type: Array\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.info = "";\n    this.folders = ["public/spoggy/", "public/spoggy/Activity/", "public/spoggy/Image/", "public/spoggy/Video/", "public/spoggy/Audio/", "public/spoggy/Document/"];\n    this.filename = "";\n  }\n\n  render() {\n    return lit_html_html(media_element_templateObject(), this.notesListUrl, this.createTemp, this.lang, this.filename.length > 0 ? lit_html_html(media_element_templateObject2(), this.filename, this.filenameChange, this.extension) : lit_html_html(media_element_templateObject3()));\n  }\n\n  createTemp(e) {\n    this.file = e.target.files[0];\n    this.filename = this.file.name.substring(0, this.file.name.lastIndexOf("."));\n    this.extension = this.file.name.substring(this.file.name.lastIndexOf("."));\n    var canvas = this.shadowRoot.getElementById(\'canvas\');\n    var ctx = canvas.getContext(\'2d\');\n    var cw = canvas.width;\n    var ch = canvas.height;\n    var maxW = cw;\n    var maxH = ch;\n    var image = new Image();\n\n    image.onload = function () {\n      var iw = image.width;\n      var ih = image.height;\n      var scale = Math.min(maxW / iw, maxH / ih);\n      var iwScaled = iw * scale;\n      var ihScaled = ih * scale;\n      canvas.width = iwScaled;\n      canvas.height = ihScaled;\n      ctx.drawImage(image, 0, 0, iwScaled, ihScaled); //  ctx.drawImage(image, 0,0);\n      //  alert(\'the image is drawn\');\n    };\n\n    image.src = URL.createObjectURL(this.file);\n    /*\r\n    canvas.width = this.file.width;\r\n    canvas.height = this.file.height;\r\n    canvas.getContext(\'2d\').drawImage(image, 0, 0);\r\n    // Other browsers will fall back to image/png\r\n    img.src = canvas.toDataURL(\'image/webp\');*/\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n\n    this.agent.receive = function (from, message) {\n      if (message.hasOwnProperty("action")) {\n        switch (message.action) {\n          case "askContent":\n            app.askContent(from, message);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  askContent(from, message) {\n    var app = this;\n    console.log(from, message);\n    this.classe = "Document";\n\n    if (this.file != undefined) {\n      var type = this.file.type;\n\n      switch (type) {\n        case (type.match(/^image/) || {}).input:\n          this.classe = "Image";\n          break;\n\n        case (type.match(/^video/) || {}).input:\n          this.classe = "Video";\n          break;\n\n        case (type.match(/^audio/) || {}).input:\n          this.classe = "Audio";\n          break;\n\n        default:\n          this.classe = "Document";\n          break;\n      }\n    }\n\n    var rep = {\n      action: "reponseContent",\n      content: this.file,\n      id: message.id,\n      type: this.classe\n    };\n\n    if (this.filename.length > 0) {\n      rep.newFilename = this.filename.replace(/ /g, "_") + this.extension;\n    }\n\n    this.agent.send(from, rep);\n    this.filename = "";\n  }\n\n  filenameChange() {\n    var filename = this.shadowRoot.getElementById("filename").value;\n\n    if (filename.length == 0) {\n      alert("Filename must not be blank");\n      this.shadowRoot.getElementById("filename").value = this.filename;\n    } else {\n      this.filename = filename;\n    }\n  }\n\n}\n\ncustomElements.define(\'media-element\', media_element_MediaElement);\n// CONCATENATED MODULE: ./src/views/graph-element.js\nfunction graph_element_templateObject() {\n  const data = graph_element_taggedTemplateLiteral(["\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <p>", "</p>\\n    <button @click=\\"", "\\">Send message</button>\\n    "]);\n\n  graph_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction graph_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass graph_element_GraphElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      count: {\n        type: Number\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.count = 0;\n  }\n\n  render() {\n    return lit_html_html(graph_element_templateObject(), this.name, this.sendMessage);\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n\n    this.agent.receive = function (from, message) {\n      if (message.hasOwnProperty("action")) {\n        switch (message.action) {\n          case "doSomething":\n            app.doSomething(message);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  doSomething(message) {\n    console.log(message);\n  }\n\n  sendMessage() {\n    this.count++;\n    this.agent.send("Messages", {\n      action: "info",\n      info: "Now counter is " + this.count\n    });\n  }\n\n}\n\ncustomElements.define(\'graph-element\', graph_element_GraphElement);\n// CONCATENATED MODULE: ./src/views/triple-element.js\n\n\nfunction _templateObject5() {\n  const data = triple_element_taggedTemplateLiteral(["\\n<small>\\nYou can add triples to your Spog.<br>\\nTo do so, just type 3 words in the above input and :\\n<ul>\\n<li>ends with a comma if you want to keep subject & predicate, </li>\\n<li>ends with a semicolon if you want to keep just the subject,</li>\\n<li>ends with a dot if you don\'t want to keep anything,</li>\\n<li>ends with a dash if you want that the object become the subject of the next triple.</li>\\n</ul>\\nex: Dav a man,\\n</small>\\n"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction triple_element_templateObject4() {\n  const data = triple_element_taggedTemplateLiteral(["  ", ""]);\n\n  triple_element_templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction triple_element_templateObject3() {\n  const data = triple_element_taggedTemplateLiteral(["\\n      <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n      <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n      <div class=\\"row\\">\\n      <div class=\\"input-group mb-3\\">\\n      <input type=\\"text\\"\\n      id=\\"tripleInput\\"\\n      class=\\"form-control\\"\\n      placeholder=\\"ex: Paris type Town.\\"\\n      aria-label=\\"Write some Triples\\"\\n      aria-describedby=\\"basic-addon2\\"\\n      @keydown=", ">\\n      <div class=\\"input-group-append\\">\\n      <button class=\\"btn btn-outline-primary\\" @click=\\"", "\\" type=\\"button\\">Add</button>\\n\\n      </div>\\n      \x3c!--      <div class=\\"input-group-text\\">?</div>--\x3e\\n      </div>\\n      </div>\\n\\n      <div class=\\"row\\">\\n\\n", "\\n\\n\\n      </div>\\n      "]);\n\n  triple_element_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction triple_element_templateObject2() {\n  const data = triple_element_taggedTemplateLiteral(["\\n      <li class=\\"list-group-item\\">\\n      <div class=\\"row\\">\\n      <button class=\\"btn btn-outline-secondary btn-sm\\" type=\\"button\\">", "</button>\\n      <button class=\\"btn btn-outline-secondary btn-sm\\" type=\\"button\\">", "</button>\\n      <button class=\\"btn btn-outline-secondary btn-sm\\" type=\\"button\\">", "</button>\\n      [edit] [delete]\\n      </div>\\n      </li>\\n      "]);\n\n  triple_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction triple_element_templateObject() {\n  const data = triple_element_taggedTemplateLiteral(["\\n    <ul class=\\"list-group list-group-flush\\" style=\\"height: 30vh; width:100%; overflow: auto\\">\\n    ", "\\n      </ul>\\n      "]);\n\n  triple_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction triple_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass triple_element_TripleElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      count: {\n        type: Number\n      },\n      triples: {\n        type: Array\n      },\n      footprint: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.count = 0;\n    this.triples = [];\n    this.footprint = {\n      index: "public/triple.ttl",\n      path: "public/Triple"\n    };\n  }\n\n  render() {\n    const triplesList = triples => lit_html_html(triple_element_templateObject(), triples.map(t => lit_html_html(triple_element_templateObject2(), t.subject, t.predicate, t.object)));\n\n    return lit_html_html(triple_element_templateObject3(), this.keydown, this.add_triple, this.triples.length > 0 ? lit_html_html(triple_element_templateObject4(), triplesList(this.triples)) : lit_html_html(_templateObject5()));\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n\n    this.agent.receive = function (from, message) {\n      if (message.hasOwnProperty("action")) {\n        switch (message.action) {\n          case "askContent":\n            app.askContent(from, message);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  askContent(from, message) {\n    console.log(from, message);\n    this.agent.send(from, {\n      action: "reponseContent",\n      content: this.triples,\n      id: message.id,\n      type: "Triple"\n    });\n  }\n\n  add_triple() {\n    var new_triple = this.shadowRoot.getElementById(\'tripleInput\').value.trim();\n\n    if (new_triple.length == 0) {\n      alert("you can\'t add an empty Triple");\n      return;\n    }\n\n    console.log(new_triple);\n    var res = this.updateInput(new_triple);\n    console.log(res);\n    this.shadowRoot.getElementById(\'tripleInput\').value = res.inputNew;\n\n    if (res.type == "triplet") {\n      var triple = res.value;\n      this.triples.reverse();\n      this.triples = [...this.triples, triple];\n      this.triples.reverse();\n    } else {\n      alert("Triple must end with \',\', or \';\' or \'.\'");\n    } // voir traiteTriplet dans js/spoggy.js de spoggy-simple\n\n  }\n\n  updateInput(message) {\n    var result = {};\n    var inputNew = "";\n    let lastChar = message.slice(-1);\n    let messageCut = message.slice(0, -1).split(" ");\n    let isTriplet = true;\n    console.log(messageCut);\n    let detectLiteral = "";\n    let messageCutTemp = [];\n    messageCut.forEach(function (part) {\n      part = part.trim(); //  console.log(part);\n\n      if (part.startsWith(\'"\')) {\n        detectLiteral = "debut"; //  console.log(detectLiteral);\n\n        messageCutTemp.push(part.substr(1));\n      } else if (part.endsWith(\'"\')) {\n        detectLiteral = "fin"; //console.log(detectLiteral);\n\n        messageCutTemp.push(messageCutTemp.pop() + " " + part.slice(0, -1));\n      } else if (detectLiteral == "debut") {\n        //  console.log("recupere le dernier et lui ajoute part" )\n        messageCutTemp.push(messageCutTemp.pop() + " " + part);\n      } else {\n        messageCutTemp.push(part);\n      }\n    });\n\n    if (messageCutTemp.length > 0) {\n      messageCut = messageCutTemp;\n    }\n\n    switch (lastChar) {\n      case \'.\':\n        inputNew = "";\n        break;\n\n      case \';\':\n        if (messageCut[0].indexOf(" ") > -1) {\n          inputNew = \'"\' + messageCut[0] + \'"\' + \' \';\n        } else {\n          inputNew = messageCut[0] + \' \';\n        }\n\n        break;\n\n      case \',\':\n        if (messageCut[0].indexOf(" ") > -1) {\n          inputNew = \'"\' + messageCut[0] + \'" \';\n        } else {\n          inputNew = messageCut[0] + \' \';\n        }\n\n        if (messageCut[1].indexOf(" ") > -1) {\n          inputNew += \'"\' + messageCut[1] + \'" \';\n        } else {\n          inputNew += messageCut[1] + \' \';\n        }\n\n        break;\n\n      case \'-\':\n        if (messageCut[2].indexOf(" ") > -1) {\n          inputNew = \'"\' + messageCut[2] + \'"\' + \' \';\n        } else {\n          inputNew = messageCut[2] + \' \';\n        }\n\n        break;\n\n      default:\n        console.log("message to chat " + message); //this.sendMessage(message);\n        //  this.agentInput.send(\'agentSocket\', {type: "sendMessage", message:message});\n        //  this.catchTriplet(message.slice(0,-1), this.network); // A REMPLACER PAR CATCHTRIPLETS V2\n\n        inputNew = "";\n        isTriplet = false;\n    }\n\n    if (isTriplet) {\n      //  console.log("est Triplet",messageCut)\n      result.type = "triplet";\n      var tripletvalue = {};\n      tripletvalue.subject = messageCut[0];\n      tripletvalue.predicate = messageCut[1];\n      tripletvalue.object = messageCut[2];\n      result.value = tripletvalue;\n      result.inputNew = inputNew;\n    } else {\n      //  console.log("n\'est pas triplet")\n      result.type = "message";\n      result.value = message;\n      result.inputNew = inputNew;\n    }\n\n    return result;\n  }\n\n  keydown(e) {\n    if (e.which === 13) {\n      this.add_triple();\n      e.preventDefault();\n      return false;\n    }\n  }\n\n}\n\ncustomElements.define(\'triple-element\', triple_element_TripleElement);\n// CONCATENATED MODULE: ./src/views/post-tabs-element.js\n\n\n\n\n\nfunction post_tabs_element_templateObject5() {\n  const data = post_tabs_element_taggedTemplateLiteral(["\\n      <option value=\\"", "\\"> ", " </option>\\n      "]);\n\n  post_tabs_element_templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction post_tabs_element_templateObject4() {\n  const data = post_tabs_element_taggedTemplateLiteral(["\\n      <option\\n\\n      value=\\"", "\\" title=\\"", "\\">\\n      ", "\\n      </option>\\n      "]);\n\n  post_tabs_element_templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction post_tabs_element_templateObject3() {\n  const data = post_tabs_element_taggedTemplateLiteral([""]);\n\n  post_tabs_element_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction post_tabs_element_templateObject2() {\n  const data = post_tabs_element_taggedTemplateLiteral(["\\n      TODO<br>\\n      replyTo url  ", "<br>\\n      replyTo attributedTo  ", " <br>\\n      replyTo name  ", " <br>\\n\\n      <label class=\\"sr-only\\" for=\\"reply\\">Reply to</label>\\n      <div class=\\"input-group mb-2\\">\\n      <div class=\\"input-group-append\\">\\n      <div class=\\"input-group-text\\">Reply to</div>\\n      </div>\\n      <input id=\\"reply\\" class=\\"form-control\\" type=\\"text\\" value=\\"", "\\" style=\\"text-align:right;\\"  placeholder=\\"ReplyTo\\">\\n      </div>\\n      "]);\n\n  post_tabs_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction post_tabs_element_templateObject() {\n  const data = post_tabs_element_taggedTemplateLiteral(["\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <style>\\n    body {font-family: Arial;}\\n\\n    /* Style the tab */\\n    .tab {\\n      overflow: hidden;\\n      border: 1px solid #ccc;\\n      background-color: #f1f1f1;\\n    }\\n\\n    /* Style the buttons inside the tab */\\n    .tab button {\\n      background-color: inherit;\\n      float: left;\\n      border: none;\\n      outline: none;\\n      cursor: pointer;\\n      padding: 5px 8px;\\n      transition: 0.3s;\\n      font-size: 17px;\\n    }\\n\\n    /* Change background color of buttons on hover */\\n    .tab button:hover {\\n      background-color: #ddd;\\n    }\\n\\n    /* Create an active/current tablink class */\\n    .tab button.active {\\n      background-color: #ccc;\\n    }\\n\\n    /* Style the tab content */\\n    .tabcontent {\\n      display: none;\\n      padding: 6px 12px;\\n      border: 1px solid #ccc;\\n      border-top: none;\\n      width: 100%;\\n    }\\n    </style>\\n    <div class=\\"container\\">\\n    <div class=\\"row\\">\\n\\n    ", "\\n\\n    <label class=\\"sr-only\\" for=\\"title\\">Title</label>\\n    <div class=\\"input-group mb-2\\">\\n\\n    <input id=\\"title\\" class=\\"form-control\\" type=\\"text\\" value=\\"", "\\" placeholder=\\"Title\\">\\n\\n    </div>\\n    </div>\\n\\n\\n    <div class=\\"row\\">\x3c!--style=\\"height:50vh\\"--\x3e\\n    <div id=\\"Note\\" class=\\"tabcontent\\" style=\\"display:block;height: 40vh\\">\\n    <note-element name=\\"Note\\" .share=\\"", "\\"></note-element>\\n    </div>\\n\\n    <div id=\\"Media\\" class=\\"tabcontent\\" style=\\"height: 40vh\\">\\n    <media-element name=\\"Media\\"></media-element>\\n    </div>\\n\\n    <div id=\\"Triple\\" class=\\"tabcontent\\" style=\\"height: 40vh\\">\\n    <triple-element name=\\"Triple\\"></triple-element>\\n    </div>\\n\\n    <div id=\\"Graph\\" class=\\"tabcontent\\" style=\\"height: 40vh\\">\\n    <h3 class=\\"text-primary\\">Graph</h3>\\n    <p class=\\"text-primary\\">todo.</p>\\n    <graph-element name=\\"Graph\\"></graph-element>\\n    </div>\\n\\n    <div class=\\"tab\\">\\n    <button class=\\"tablinks active\\" tabName=\'Note\' @click=\\"", "\\"><i class=\\"far fa-sticky-note\\"></i></button>\\n    <button class=\\"tablinks\\" tabName=\'Media\' @click=\\"", "\\"><i class=\\"fas fa-photo-video\\"></i></button>\\n    <button class=\\"tablinks\\" tabName=\'Triple\' @click=\\"", "\\"><i class=\\"fas fa-receipt\\"></i></button>\\n    \x3c!--<button class=\\"tablinks\\" tabName=\'Graph\' @click=\\"", "\\"><i class=\\"fas fa-dice-d20\\"></i></button>--\x3e\\n    </div>\\n\\n    </div>\\n\\n    <div class=\\"row\\">\\n    <label class=\\"sr-only\\" for=\\"title\\">Tags</label>\\n    <div class=\\"input-group mb-2\\">\\n    <div class=\\"input-group-append\\">\\n    <div class=\\"input-group-text\\">Tags</div>\\n    </div>\\n    <input id=\\"tags\\" class=\\"form-control\\" type=\\"text\\" placeholder=\\"tags, comma separated\\">\\n    </div>\\n    </div>\\n\\n\\n    <div class=\\"row\\">\\n\\n    <select id=\\"confid\\" class=\\"custom-select\\" @change=\\"", "\\" @input=\\"", "\\" @select=\\"", "\\"> \x3c!--multiple--\x3e\\n    ", "\\n    </select>\\n    <hr>\\n\\n    <select id=\\"recipients\\" class=\\"custom-select\\" multiple> \x3c!--multiple--\x3e\\n    <option disabled>Select Multi Recipient</option>\\n    \x3c!--  <option  value=\\"#me\\">Personnal (Me)</option>\\n    <option selected value=\\"https://www.w3.org/ns/activitystreams#Public\\">Public (Agora)</option>--\x3e\\n    ", "\\n      \x3c!--      <option value=\\"someone\\" disabled>Someone Else (todo)</option>--\x3e\\n      </select>\\n\\n\\n\\n      </div>\\n\\n\\n      <div class=\\"buttons\\">\\n      <div class=\\"row\\">\\n      <div class=\\"col-4\\">\\n      <div class=\\"form-check\\">\\n      <input class=\\"form-check-input\\" type=\\"checkbox\\" value=\\"\\" id=\\"agora_pub\\" name=\\"agora_pub\\" checked>\\n      <label class=\\"text-primary\\" for=\\"agora_pub\\">\\n      Push to Agora\\n      </label>\\n      </div>\\n      </div>\\n      <div class=\\"col-4\\">\\n      Log : ", "\\n      </div>\\n      <div class=\\"col\\">\\n      <button type=\\"button\\" class=\\"btn btn-primary\\" primary @click=", ">\\n      Send <i class=\\"far fa-paper-plane\\"></i></button>\\n      </div>\\n      \x3c!--\\n      <button type=\\"button\\" class=\\"cancel btn btn-primary\\" @click=\\"", "\\"><i class=\\"fas fa-window-close\\"></i> </button>--\x3e\\n      </div>\\n      </div>\\n\\n\\n\\n\\n\\n\\n      \x3c!--\\n      <div class=\\"buttons\\">\\n\\n      <div class=\\"row\\">\\n      <div class=\\"col-5\\">\\n      <button type=\\"button\\" class=\\"btn btn-primary\\" primary @click=", "><i class=\\"far fa-paper-plane\\"></i></button>\\n      <button type=\\"button\\" class=\\"cancel btn btn-primary\\" @click=\\"", "\\"><i class=\\"fas fa-window-close\\"></i> </button>\\n      </div>\\n      <div class=\\"col\\">\\n\\n      </div>\\n      </div>\\n      </div>--\x3e\\n      </div>\\n      "]);\n\n  post_tabs_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction post_tabs_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction post_tabs_element_asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }\n\n\n //import { PodHelper } from \'../tools/pod-helper.js\';\n\n/*import { fetchDocument } from \'tripledoc\';*/\n//import { solid, schema, rdf, rdfs } from \'rdf-namespaces\';\n\n //import  data  from "@solid/query-ldflex";\n\n\n\n\n\n\n\n\n\nclass post_tabs_element_PostTabsElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      subelements: {\n        type: String\n      },\n      requetes: {\n        type: Object\n      },\n      responses: {\n        type: Array\n      },\n      agoraNotesListUrl: {\n        type: String\n      },\n      webId: {\n        type: String\n      },\n      info: {\n        type: String\n      },\n      replyTo: {\n        type: Object\n      },\n      friends: {\n        type: Array\n      },\n      share: {\n        type: Object\n      },\n      confidentialite: {\n        type: Array\n      },\n      title: {\n        type: String\n      },\n      log: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.fileClient = new solid_file_client_bundle(browser);\n    this.webId = null;\n    this.subelements = ["Note", "Media", "Triple"]; //, "Media", "Triple"] , "Graph"\n\n    this.requetes = {};\n    this.responses = [];\n    this.info = "";\n    this.replyTo = {};\n    this.friends = [];\n    this.share = {};\n    this.confidentialite = [{\n      level: "Public",\n      selected: true,\n      value: "public",\n      description: "Everyone",\n      icon: "fas fa-globe"\n    }, {\n      level: "Not listed",\n      value: "not_listed",\n      description: "Not listed in public ?",\n      icon: "fas fa-lock-open"\n    }, {\n      level: "Followers",\n      value: "followers",\n      description: "Only your followers",\n      icon: "fas fa-lock"\n    }, {\n      level: "Direct",\n      value: "direct",\n      description: "Only listed users",\n      icon: "fas fa-envelop"\n    }];\n    this.log = ""; //  this.agoraNotesListUrl = "https://agora.solid.community/public/notes.ttl"\n  }\n\n  render() {\n    return lit_html_html(post_tabs_element_templateObject(), this.replyTo.url != null ? lit_html_html(post_tabs_element_templateObject2(), this.replyTo.url, this.replyTo.attributedTo, this.replyTo.name, this.replyTo.url) : lit_html_html(post_tabs_element_templateObject3()), this.title, this.share, this.openTab, this.openTab, this.openTab, this.openTab, this.change, this.input, this.select, this.confidentialite.map(c => lit_html_html(post_tabs_element_templateObject4(), c.value, c.description, c.level)), this.friends.map(f => lit_html_html(post_tabs_element_templateObject5(), f.webId, f.name)), this.log, this.addNote, this.toggleWrite, this.addNote, this.toggleWrite);\n  }\n\n  select(e) {\n    console.log(e.target.value);\n  }\n\n  input(e) {\n    console.log(e.target.value);\n  }\n\n  change(e) {\n    console.log(e.target.value);\n  }\n\n  addNote() {\n    this.log = "Add Note";\n    let confid = this.shadowRoot.getElementById("confid").value;\n    console.log(confid);\n    var title = this.shadowRoot.getElementById(\'title\').value.trim();\n\n    if (title.length == 0) {\n      alert("Don\'t you want to provide a  beautiful title to your wonder post ?");\n    } else {\n      var id = new Date().toISOString();\n      this.requetes[id] = this.subelements.length;\n      console.log(this.requetes);\n      this.log = "Ask SubElements Content";\n      var mess = {\n        action: "askContent",\n        id: id\n      };\n      this.agent.sendMulti(this.subelements, mess);\n    }\n  }\n\n  toggleWrite() {\n    this.agent.send("Post", {\n      action: "toggleWrite"\n    });\n  }\n\n  openTab(e) {\n    var node = e.target;\n\n    if (node.nodeName == "I") {\n      node = e.target.parentNode;\n    }\n\n    var tabName = node.getAttribute(\'tabName\');\n    var i, tabcontent, tablinks;\n    tabcontent = this.shadowRoot.querySelectorAll(".tabcontent");\n\n    for (i = 0; i < tabcontent.length; i++) {\n      tabcontent[i].style.display = "none";\n    }\n\n    tablinks = this.shadowRoot.querySelectorAll(".tablinks");\n\n    for (i = 0; i < tablinks.length; i++) {\n      tablinks[i].className = tablinks[i].className.replace(" active", "");\n    }\n\n    this.shadowRoot.getElementById(tabName).style.display = "block";\n    node.className += " active";\n  }\n\n  firstUpdated() {\n    var app = this; //  this.ph = new PodHelper();\n\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      if (message.hasOwnProperty("action")) {\n        switch (message.action) {\n          case "reponseContent":\n            app.reponseContent(from, message);\n            break;\n\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          case "setReplyTo":\n            app.setReplyTo(message);\n            break;\n\n          case "configChanged":\n            app.configChanged(message.config);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n\n    if (this.share.title != undefined) {\n      this.title = this.share.title;\n    }\n\n    this.agent.send("Store", {\n      action: "getConfig"\n    });\n  }\n\n  configChanged(config) {\n    this.config = config;\n    this.friends = config.friends || [];\n  }\n\n  async setReplyTo(message) {\n    if (message.replyTo != undefined) {\n      this.replyTo = {};\n      this.replyTo.url = message.replyTo;\n      let attributedTo = await solid.data[this.replyTo.url].as$attributedTo;\n      let name = (await solid.data["".concat(attributedTo)].vcard$fn) || "".concat(friend).split("/")[2].split(\'.\')[0];\n      this.replyTo.attributedTo = "".concat(attributedTo);\n      this.replyTo.name = "".concat(name);\n      console.log(this.replyTo);\n      this.requestUpdate();\n    } else {\n      this.replyTo = {};\n    }\n  }\n\n  webIdChanged(webId) {\n    console.log(webId);\n    this.webId = webId;\n  }\n\n  reponseContent(from, message) {\n    console.log(from, message);\n    this.requetes[message.id]--; // si toutes reponses\n\n    this.responses.push({\n      from: from,\n      message: message\n    });\n\n    if (this.requetes[message.id] == 0) {\n      console.log("UPDATE");\n      delete this.requetes[message.id];\n      this.preparePost();\n    }\n  }\n\n  async preparePost() {\n    var app = this;\n    console.log("CONFIG", this.config);\n    console.log("OUTBOX", this.config.outbox);\n    let recipient_select = this.shadowRoot.getElementById("recipients");\n    let recipients = Array(...recipient_select.options).reduce((acc, option) => {\n      if (option.selected === true) {\n        acc.push(option.value);\n      }\n\n      return acc;\n    }, []); //  console.log("RECIPIENTS",recipients)\n\n    console.log(this.responses);\n    var title = this.shadowRoot.getElementById(\'title\').value.trim();\n    var tags = this.shadowRoot.getElementById(\'tags\').value.split(\',\');\n    var agora_pub = app.shadowRoot.getElementById(\'agora_pub\').checked;\n    var inReplyTo = null;\n\n    if (this.shadowRoot.getElementById(\'reply\') != null) {\n      inReplyTo = this.shadowRoot.getElementById(\'reply\').value.trim();\n    }\n\n    this.shadowRoot.getElementById(\'title\').value = "";\n    this.shadowRoot.getElementById(\'tags\').value = "";\n    this.storage = await solid.data.user.storage; // TREAT OBJECTS\n\n    let dateObj = new Date();\n    let date = dateObj.toISOString(); //    let to = act.object.target == "Public" ? "https://www.w3.org/ns/activitystreams#Public" : act.object.target;\n\n    let objects = [];\n    this.responses.forEach(async function (r) {\n      //object create\n      let object_Id = esm_browser_v4(); //  \'9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d\'\n      //    let object_uri = outbox+"objects/"+object_Id+"/index.ttl#this"\n\n      let object_file = app.config.outbox + "objects/" + object_Id + ".ttl";\n      let object_uri = object_file + "#this";\n\n      switch (r.message.type) {\n        case "Note":\n          if (r.message.content.length > 0) {\n            objects.push({\n              uri: object_uri,\n              file: object_file\n            });\n            console.log("CREATE NOTE WITH", r.message.content, object_uri);\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#type\'].add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Note\'));\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#name\'].add(title);\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#content\'].add(r.message.content);\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#published\'].add(date);\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#attributedTo\'].add(Object(data_model["namedNode"])(app.config.webId));\n          }\n\n          break;\n\n        case "Image":\n        case "Video":\n        case "Audio":\n        case "Document":\n          // https://www.w3.org/wiki/SocialCG/ActivityPub/MediaUpload must normally be uploaded to recipient endpoint\n          if (r.message.content != undefined) {\n            var file = r.message.content;\n            var contentType = file.contentType;\n            var newFilename = r.message.newFilename;\n            var classe = r.message.type;\n            /*\r\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#type\'].add(namedNode(\'https://www.w3.org/ns/activitystreams#\'+r.message.type))\r\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#name\'].add(title)\r\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#content\'].add(r.message.content)\r\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#published\'].add(date)\r\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#attributedTo\'].add(namedNode(app.config.webId))\r\n            */\n            // no need to create an Object.ttl, replce by file ?\n\n            let object_file = app.config.outbox + "objects/" + classe + "/" + newFilename;\n            let object_uri = object_file; // pas de #this\n            // var object_uri = app.storage+"public/spoggy/"+classe+"/"+newFilename\n\n            console.log("CREATE DOCUMENT WITH", r.message, object_uri);\n            await app.sendFile(object_file, file, contentType); //   await  data[userActivity].as$object.add(namedNode(userMedia))\n\n            objects.push({\n              uri: object_uri,\n              file: object_file\n            });\n          }\n\n          break;\n\n        case "Triple":\n          if (r.message.content.length > 0) {\n            objects.push({\n              uri: object_uri,\n              file: object_file\n            });\n            content = r.message.content;\n            console.log("CREATE DOCUMENT WITH", r.message, object_uri);\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#type\'].add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#\' + r.message.type));\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#name\'].add(title);\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#published\'].add(date);\n            await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#attributedTo\'].add(Object(data_model["namedNode"])(app.config.webId)); //           await solid.data[object_uri][\'https://www.w3.org/ns/activitystreams#content\'].add(r.message.content)\n            //write subject https://github.com/LDflex/LDflex/issues/53\n\n            r.message.content.forEach(async function (triple, i) {\n              //  console.log(triple)\n              let subject = object_file + "#" + triple.subject;\n              let predicate = object_file + "#" + triple.predicate;\n              let object = object_file + "#" + triple.object; //console.log(subject, predicate, object)\n\n              await solid.data[subject][predicate].add(Object(data_model["namedNode"])(object));\n            });\n          }\n\n          break;\n\n        default:\n          console.log(r.message.type, "non traite");\n      }\n    });\n    this.responses = [];\n    console.log("TODO : ACL FILES & REPLYTO");\n    console.log("OBJECTS", objects);\n    /*\r\n    if (to == "https://www.w3.org/ns/activitystreams#Public"){\r\n    console.log("Send to Agora")\r\n    to = "https://agora.solid.community/profile/card#me"\r\n    }\r\n    */\n    //activity create\n\n    let activity_Id = esm_browser_v4(); //      let activity_uri = outbox+"activities/"+activity_Id+"/index.ttl#this"\n\n    let activity_file = app.config.outbox + "activities/" + activity_Id + ".ttl";\n    let activity_uri = activity_file + "#this";\n    await solid.data[activity_uri][\'https://www.w3.org/ns/activitystreams#type\'].add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Create\'));\n    await solid.data[activity_uri][\'https://www.w3.org/ns/activitystreams#summary\'].add(title);\n    await solid.data[activity_uri][\'https://www.w3.org/ns/activitystreams#published\'].add(date);\n    await solid.data[activity_uri].rdfs$label.add(title);\n    /*  if (recipients.length== 0){\r\n    await solid.data[o.uri][\'https://www.w3.org/ns/activitystreams#to\'].add(namedNode(app.config.webId))\r\n    await solid.data[activity_uri][\'https://www.w3.org/ns/activitystreams#target\'].add(namedNode(app.config.webId))\r\n    }*/\n    // ACL OBJECT\n\n    let recipientsWebIds = [];\n    recipients.forEach((r, i) => {\n      recipientsWebIds.push(\'<\' + r + \'>\');\n    });\n    let aclStringWebIds = recipientsWebIds.join(\', \');\n    console.log("ACL STRING", aclStringWebIds);\n    objects.forEach(async function (o, i) {\n      app.setAcl(o, aclStringWebIds, agora_pub);\n      await solid.data[activity_uri][\'https://www.w3.org/ns/activitystreams#object\'].add(Object(data_model["namedNode"])(o.uri));\n      recipients.forEach(async function (to, i) {\n        if (o.uri.endsWith("#this")) {\n          await solid.data[o.uri][\'https://www.w3.org/ns/activitystreams#to\'].add(Object(data_model["namedNode"])(to));\n        }\n      });\n\n      if (agora_pub == true) {\n        await solid.data[o.uri][\'https://www.w3.org/ns/activitystreams#to\'].add(Object(data_model["namedNode"])("https://agora.solid.community/profile/card#me"));\n        await solid.data[o.uri][\'https://www.w3.org/ns/activitystreams#to\'].add(Object(data_model["namedNode"])("https://www.w3.org/ns/activitystreams#Public"));\n      }\n    });\n    this.log = activity_uri + "DONE";\n    console.log("Activity OK", activity_uri);\n    let activity = {\n      url: activity_uri,\n      file: activity_file\n    };\n    app.setAcl(activity, aclStringWebIds, agora_pub);\n    /* ACL pour plusieurs createFolders\r\n    @prefix : <#>.\r\n    @prefix n0: <http://www.w3.org/ns/auth/acl#>.\r\n    @prefix c: </profile/card#>.\r\n    @prefix c0: <https://spoggy-test2.solid.community/profile/card#>.\r\n    @prefix c1: <https://spoggy-test3.solid.community/profile/card#>.\r\n      :ControlReadWrite\r\n    a n0:Authorization;\r\n    n0:accessTo <fa8740cc-8eaf-4ae8-8489-b4d96783d224.ttl>;\r\n    n0:agent c:me;\r\n    n0:mode n0:Control, n0:Read, n0:Write.\r\n    :Read\r\n    a n0:Authorization;\r\n    n0:accessTo <fa8740cc-8eaf-4ae8-8489-b4d96783d224.ttl>;\r\n    n0:agent c0:me, c1:me;\r\n    n0:mode n0:Read.*/\n\n    /* ACL plusieurs readers & public\r\n    @prefix : <#>.\r\n    @prefix n0: <http://www.w3.org/ns/auth/acl#>.\r\n    @prefix c: </profile/card#>.\r\n    @prefix c0: <https://spoggy-test2.solid.community/profile/card#>.\r\n    @prefix c1: <https://spoggy-test3.solid.community/profile/card#>.\r\n    @prefix n1: <http://xmlns.com/foaf/0.1/>.\r\n      :ControlReadWrite\r\n    a n0:Authorization;\r\n    n0:accessTo <fa8740cc-8eaf-4ae8-8489-b4d96783d224.ttl>;\r\n    n0:agent c:me;\r\n    n0:mode n0:Control, n0:Read, n0:Write.\r\n    :Read\r\n    a n0:Authorization;\r\n    n0:accessTo <fa8740cc-8eaf-4ae8-8489-b4d96783d224.ttl>;\r\n    n0:agent c0:me, c1:me;\r\n    n0:agentClass n1:Agent;\r\n    n0:mode n0:Read.\r\n    */\n\n    if (agora_pub == true) {\n      this.log = "Add Public to recipients";\n      console.log("PUBLIC", agora_pub);\n      await solid.data[activity_uri][\'https://www.w3.org/ns/activitystreams#to\'].add(Object(data_model["namedNode"])("https://agora.solid.community/profile/card#me"));\n      await solid.data[activity_uri][\'https://www.w3.org/ns/activitystreams#to\'].add(Object(data_model["namedNode"])("https://www.w3.org/ns/activitystreams#Public"));\n      recipients.push("https://agora.solid.community/profile/card#me");\n    }\n\n    recipients.forEach(async function (to, i) {\n      console.log("TO", to);\n      app.log = "notification to " + to;\n      await solid.data[activity_uri][\'https://www.w3.org/ns/activitystreams#target\'].add(Object(data_model["namedNode"])(to)); // recipient notification\n\n      let notification_Id = esm_browser_v4();\n      let pti = await solid.data[to].publicTypeIndex;\n      console.log(pti);\n      let instanceTrouvee = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = post_tabs_element_asyncIterator(solid.data[pti].subjects), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const subject = _value;\n          let s = "".concat(subject); //  console.log(s)\n\n          if (pti != "".concat(subject)) {\n            //  console.log(s)\n            if ("".concat(subject).endsWith(\'#Agora\')) {\n              instanceTrouvee = true;\n              console.log(s);\n              let instance = await solid.data["".concat(subject)].solid$instance;\n              let ib = await solid.data["".concat(instance)].as$inbox;\n              let recip_inbox = "".concat(ib);\n              let notification_uri = recip_inbox + notification_Id + ".ttl#this";\n              console.log(notification_uri);\n              await solid.data[notification_uri][\'https://www.w3.org/ns/activitystreams#type\'].add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Create\'));\n              await solid.data[notification_uri][\'https://www.w3.org/ns/activitystreams#attributedTo\'].add(Object(data_model["namedNode"])(app.config.webId));\n              await solid.data[notification_uri][\'https://www.w3.org/ns/activitystreams#summary\'].add(title);\n              await solid.data[notification_uri].rdfs$label.add(title);\n              await solid.data[notification_uri][\'https://www.w3.org/ns/activitystreams#published\'].add(date);\n              await solid.data[notification_uri][\'https://www.w3.org/ns/activitystreams#link\'].add(Object(data_model["namedNode"])(activity_uri));\n              app.log = notification_uri + "DONE";\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            await _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      instanceTrouvee == false ? alert("No Agora Instance found in " + to + " Public Type Index ") : "";\n    });\n    this.log = "Send OK";\n    this.toggleWrite();\n  }\n\n  async setAcl(o, aclStringWebIds, agora_pub) {\n    this.log = "Set ACL for ", o.file;\n    let aclString = "\\n  @prefix : <#>.\\n  @prefix acl: <http://www.w3.org/ns/auth/acl#>.\\n  @prefix c: </profile/card#>.\\n\\n  :ControlReadWrite\\n  a acl:Authorization;\\n  acl:accessTo <".concat(o.file, ">;\\n  acl:agent c:me;\\n  acl:mode acl:Control, acl:Read, acl:Write.\\n  :Read\\n  a acl:Authorization;\\n  acl:accessTo <").concat(o.file, ">;\\n  ").concat(aclStringWebIds.length > 0 ? " acl:agent ".concat(aclStringWebIds, ";") : "", "\\n  ").concat(agora_pub == true ? "acl:agentClass <http://xmlns.com/foaf/0.1/Agent> ;" : "", "\\n  acl:mode acl:Read.");\n    console.log(aclString);\n\n    try {\n      await this.fileClient.createFile(o.file + \'.acl\', aclString, "text/turtle");\n      this.log = o.file + \'.acl Created\';\n    } catch (e) {\n      alert(e);\n    }\n  }\n  /*\r\n  async sendFile(uri, file, contentType){\r\n  await this.fileClient.createFile(uri, file, contentType)\r\n  .then(\r\n  success =>{\r\n  console.log(success)\r\n  //  this.agent.send("Messages", {action: "info", status: "Save file OK", file: success})\r\n  },\r\n  err => {\r\n  console.log(err)\r\n  });\r\n  }*/\n\n\n  async preparePost2() {\n    var app = this;\n    console.log(this.responses);\n    var date = new Date(Date.now());\n    var id = date.getTime();\n    var title = this.shadowRoot.getElementById(\'title\').value.trim();\n    var tags = this.shadowRoot.getElementById(\'tags\').value.split(\',\');\n    var agora_pub = app.shadowRoot.getElementById(\'agora_pub\').checked;\n    var inReplyTo = null;\n\n    if (this.shadowRoot.getElementById(\'reply\') != null) {\n      inReplyTo = this.shadowRoot.getElementById(\'reply\').value.trim();\n    }\n\n    this.shadowRoot.getElementById(\'title\').value = "";\n    this.shadowRoot.getElementById(\'tags\').value = "";\n    this.storage = await solid.data.user.storage;\n    var userActivity = this.storage + "public/spoggy/activity.ttl#" + id;\n    console.log("Creation ", userActivity);\n    await solid.data[userActivity].as$name.set(title);\n    await solid.data[userActivity].rdfs$label.set(title);\n    await solid.data[userActivity].schema$dateCreated.set(date.toISOString());\n    await solid.data[userActivity].rdf$type.add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Create\'));\n    inReplyTo != null && inReplyTo.length > 0 ? await solid.data[userActivity].as$inReplyTo.add(Object(data_model["namedNode"])(inReplyTo)) : "";\n\n    if (agora_pub == true) {\n      var agoraActivity = "https://agora.solid.community/public/spoggy/activity.ttl#" + id;\n      await solid.data[agoraActivity].as$name.add(title);\n      await solid.data[agoraActivity].rdfs$label.add(title);\n      await solid.data[agoraActivity].schema$dateCreated.add(date.toISOString());\n      await solid.data[agoraActivity].rdf$type.add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Create\'));\n      await solid.data[agoraActivity].as$actor.add(Object(data_model["namedNode"])(app.webId));\n      await solid.data[agoraActivity].as$target.add(Object(data_model["namedNode"])(userActivity));\n      inReplyTo != null && inReplyTo.length > 0 ? await solid.data[agoraActivity].as$inReplyTo.add(Object(data_model["namedNode"])(inReplyTo)) : "";\n    }\n\n    this.responses.forEach(async function (r) {\n      switch (r.message.type) {\n        case "Note":\n          if (r.message.content.length > 0) {\n            var userNote = app.storage + "public/Notes/" + id + ".ttl";\n            var content = r.message.content;\n            await solid.data[userNote].schema$text.add(content);\n            await solid.data[userNote].rdf$type.add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Note\'));\n            await solid.data[userActivity].schema$text.add(content);\n            await solid.data[userActivity].as$object.add(Object(data_model["namedNode"])(userNote));\n\n            if (agora_pub == true) {\n              await solid.data[agoraActivity].schema$text.add(content);\n              await solid.data[agoraActivity].as$object.add(Object(data_model["namedNode"])(userNote));\n            }\n          }\n\n          break;\n\n        case "Image":\n        case "Video":\n        case "Audio":\n        case "Document":\n          if (r.message.content != undefined) {\n            var file = r.message.content;\n            var contentType = file.contentType;\n            var newFilename = r.message.newFilename;\n            var classe = r.message.type;\n            var userMedia = app.storage + "public/spoggy/" + classe + "/" + newFilename;\n            console.log("creation ", userMedia);\n            await app.sendFile(userMedia, file, contentType);\n            await solid.data[userActivity].as$object.add(Object(data_model["namedNode"])(userMedia));\n            await solid.data[agoraActivity].as$object.add(Object(data_model["namedNode"])(userMedia));\n          }\n\n          break;\n\n        case "Triple":\n          if (r.message.content.length > 0) {\n            content = r.message.content;\n          }\n\n          break;\n\n        default:\n          console.log(r.message.type, "non traite");\n      }\n    });\n    this.responses = [];\n  }\n\n  async preparePost1() {\n    var app = this; //  app.webId = this.ph.getPod("webId")\n    //  console.log(this.webId)\n\n    console.log(this.responses);\n    var date = new Date(Date.now());\n    var id = date.getTime();\n    var title = this.shadowRoot.getElementById(\'title\').value.trim();\n    var tags = this.shadowRoot.getElementById(\'tags\').value.split(\',\');\n    this.shadowRoot.getElementById(\'title\').value = "";\n    this.shadowRoot.getElementById(\'tags\').value = "";\n    this.storage = await solid.data.user.storage;\n    var userActivity = this.storage + "public/spoggy/activity.ttl#" + id;\n    console.log("Creation ", userActivity);\n    await solid.data[userActivity].rdfs$label.add(title);\n    await solid.data[userActivity].schema$dateCreated.add(date.toISOString());\n    await solid.data[userActivity].as$name.add(title);\n    await solid.data[userActivity].as$generator.add(window.location.origin);\n    await solid.data[userActivity].rdf$type.add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Create\'));\n    console.log(userActivity + " -- >created");\n    await solid.data[app.storage + "public/spoggy/tags.ttl"].rdfs$label.add("Tags");\n    var agora_pub = app.shadowRoot.getElementById(\'agora_pub\').checked;\n\n    if (agora_pub == true) {\n      console.log("Creation ", userActivity);\n      var agoraActivity = "https://agora.solid.community/public/spoggy/activity.ttl#" + id;\n      await solid.data[agoraActivity].schema$dateCreated.add(date.toISOString());\n      await solid.data[agoraActivity].rdfs$label.add(title);\n      await solid.data[agoraActivity].as$name.add(title);\n      await solid.data[agoraActivity].as$target.add(Object(data_model["namedNode"])(userActivity));\n      await solid.data[agoraActivity].rdf$type.add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Add\'));\n      await solid.data[agoraActivity].schema$creator.add(Object(data_model["namedNode"])(app.webId));\n      await solid.data[agoraActivity].as$actor.add(Object(data_model["namedNode"])(app.webId));\n      console.log(agoraActivity + " -- >created");\n    }\n\n    tags.forEach(async function (t) {\n      var taguri = app.storage + "public/spoggy/tags.ttl#" + t.trim();\n      await solid.data[userActivity].as$tag.add(Object(data_model["namedNode"])(taguri)); //    console.log(taguri+ " -- >created")\n    }); //  var path = this.storage+"public/Notes/"+id+".ttl"\n    //  console.log(data)\n    //  var tit = await  solid.data[path].rdfs$label.add("title ONE")\n    //  var cont = await solid.data[path].schema$text.add("content ONE");\n\n    this.responses.forEach(async function (r) {\n      switch (r.message.type) {\n        case "Note":\n          var userNote = app.storage + "public/spoggy/Notes/" + id + ".ttl";\n          var content = r.message.content;\n          await solid.data[userNote].rdfs$label.add(title);\n          await solid.data[userNote].schema$text.add(content);\n          await solid.data[userNote].rdf$type.add(Object(data_model["namedNode"])(\'https://www.w3.org/ns/activitystreams#Note\')); //!!! as$Note ne fonctionne pas\n\n          await solid.data[userActivity].as$attachment.add(Object(data_model["namedNode"])(userNote));\n          await solid.data[userActivity].schema$text.add(content);\n          var agora_pub = app.shadowRoot.getElementById(\'agora_pub\').checked;\n\n          if (agora_pub == true) {\n            //!!! as$Note ne fonctionne pas\n            await solid.data[agoraActivity].as$object.add(Object(data_model["namedNode"])(userNote));\n            await solid.data[agoraActivity].schema$text.add(content);\n          }\n\n          break;\n\n        case "Image":\n        case "Video":\n        case "Audio":\n        case "Document":\n          if (r.message.content != undefined) {\n            var file = r.message.content;\n            var contentType = file.contentType;\n            var newFilename = r.message.newFilename;\n            var classe = r.message.type;\n            var userMedia = app.storage + "public/spoggy/" + classe + "/" + newFilename;\n            console.log("creation ", userMedia);\n            await app.sendFile(userMedia, file, contentType);\n            await solid.data[userActivity].as$attachment.add(Object(data_model["namedNode"])(userMedia));\n\n            if (agora_pub == true) {\n              //!!! as$Note ne fonctionne pas\n              await solid.data[agoraActivity].as$object.add(Object(data_model["namedNode"])(userMedia));\n            }\n          }\n\n          break;\n\n        default:\n          console.log(r.message.type, "non traite");\n      }\n    });\n    await solid.data[app.storage + "public/spoggy/tags.ttl"].rdfs$label.add("Tags");\n    tags.forEach(async function (t) {\n      var taguri = app.storage + "public/spoggy/tags.ttl#" + t.trim();\n      await solid.data[userActivity].as$tag.add(Object(data_model["namedNode"])(taguri)); //    console.log(taguri+ " -- >created")\n    });\n    this.responses = []; //  this.updatePod(data)\n  }\n\n  sendFile(uri, file, contentType) {\n    this.fileClient.createFile(uri, file, contentType).then(success => {\n      console.log(success); //  this.agent.send("Messages", {action: "info", status: "Save file OK", file: success})\n    }, err => {\n      console.log(err);\n    });\n  }\n\n}\n\ncustomElements.define(\'post-tabs-element\', post_tabs_element_PostTabsElement);\n// CONCATENATED MODULE: ./src/views/post-dialog-element.js\nfunction post_dialog_element_templateObject() {\n  const data = post_dialog_element_taggedTemplateLiteral(["\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <style>\\n\\n    /* The Modal (background) */\\n    .modal {\\n      display: none; /* Hidden by default */\\n      position: fixed; /* Stay in place */\\n      z-index: 1050; /* Sit on top */\\n      padding-top: 100px; /* Location of the box */\\n      left: -16px;\\n      top: -16px;\\n      width: 100%; /* Full width */\\n      height: 100%; /* Full height */\\n      overflow: auto; /* Enable scroll if needed */\\n      background-color: rgb(0,0,0); /* Fallback color */\\n      background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\\n    }\\n    /* Modal Content */\\n    .modal-content {\\n      background-color: #fefefe;\\n      margin: auto;\\n      padding: 20px;\\n      border: 1px solid #888;\\n      width: 80%;\\n      min-width: 320px\\n    }\\n    .content{\\n      overflow = \'auto\';\\n      maxHeight = \'100px\'\\n    }\\n\\n    /* The Close Button */\\n    .close {\\n      color: #aaaaaa;\\n      float: right;\\n      font-size: 28px;\\n      font-weight: bold;\\n    }\\n\\n    .close:hover,\\n    .close:focus {\\n      color: #000;\\n      text-decoration: none;\\n      cursor: pointer;\\n    }\\n\\n    .opened {\\n      display: flex;\\n    }\\n    .closed {\\n      display: none;\\n    }\\n    .dialog {\\n      flex-direction: column;\\n      border: 2px outset black;\\n      padding: 1em;\\n      margin: 1em;\\n    }\\n    .buttons {\\n      display: flex;\\n      flex-direction: row;\\n    }\\n    .accept {\\n      justify-content: space-around;\\n      align-content: space-around;\\n    }\\n    .cancel {\\n      justify-content: space-around;\\n      align-content: space-around;\\n    }\\n\\n    @media(max-width:767px){\\n      .dialog {\\n        padding: 0em;\\n      }\\n      .modal-content {\\n        padding-top: 20px;\\n        padding-bottom: 20px;\\n        width: 100%;\\n      }\\n    }\\n    </style>\\n\\n\\n    <div class=\\"", "\\">\\n    <div class=\\"modal-content\\">\\n    <h6 class=\\"m-0 font-weight-bold text-primary title\\">New Spog\\n    <i @click=\\"", "\\" class=\\"close fas fa-window-close\\"></i>\\n    </h6>\\n    <div>\\n    <post-tabs-element name=\\"PostTabs\\" .share=\\"", "\\"></post-tabs-element>\\n    </div>\\n    </div>\\n    </div>"]);\n\n  post_dialog_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction post_dialog_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n//https://gist.github.com/ErikHellman/9e17f2ea6a78669294ef2af4bc3f5878\n//https://vaadin.com/learn/tutorials/lit-element/lit-element-templating-properties-and-events\n\n\n\n\nclass post_dialog_element_PostDialogElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      opened: {\n        type: Boolean\n      },\n      share: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.opened = false;\n    this.share = {};\n  }\n\n  render() {\n    return lit_html_html(post_dialog_element_templateObject(), classMap({\n      dialog: true,\n      opened: this.opened,\n      closed: !this.opened,\n      modal: true\n    }), () => this.dispatchEvent(new CustomEvent(\'dialog.cancel\')), this.share);\n  }\n\n}\n\ncustomElements.define(\'post-dialog-element\', post_dialog_element_PostDialogElement);\n// CONCATENATED MODULE: ./src/views/post-element.js\nfunction post_element_templateObject3() {\n  const data = post_element_taggedTemplateLiteral(["\\n      <div class=\\"btn btn-sm btn-outline-info\\">\\n      You must login to post a spog!\\n      </div>\\n      "]);\n\n  post_element_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction post_element_templateObject2() {\n  const data = post_element_taggedTemplateLiteral(["\\n      <div>\\n      <button type=\\"button\\" class=\\"btn btn-primary btn-sm\\" @click=\\"", "\\"><i class=\\"fa fa-pen\\"></i></button>\\n      <post-dialog-element ?opened=\\"", "\\"\\n      @dialog.accept=\\"", "\\"\\n      @dialog.cancel=\\"", "\\"\\n      .share=\\"", "\\">\\n      </post-dialog-element>\\n      </div>\\n      "]);\n\n  post_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction post_element_templateObject() {\n  const data = post_element_taggedTemplateLiteral(["\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/offcanvas.css\\" rel=\\"stylesheet\\">\\n\\n    ", "\\n\\n    "]);\n\n  post_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction post_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n //https://gist.github.com/ErikHellman/9e17f2ea6a78669294ef2af4bc3f5878\n\nclass post_element_PostElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      dialogVisible: {\n        type: Boolean\n      },\n      webId: {\n        type: String\n      },\n      share: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.dialogVisible = false;\n    this.webId = null;\n    this.share = {};\n  }\n\n  render() {\n    console.log(\'Dialog visible:\', this.dialogVisible);\n    return lit_html_html(post_element_templateObject(), this.webId != null ? lit_html_html(post_element_templateObject2(), this.toggleDialog.bind(this), this.dialogVisible, this.closeDialog.bind(this), this.closeDialog.bind(this), this.share) : lit_html_html(post_element_templateObject3()));\n  }\n\n  toggleDialog(e) {\n    this.dialogVisible = !this.dialogVisible; //  console.log(this.dialogVisible)\n\n    var messRep = {\n      action: "setReplyTo"\n    };\n    this.agent.send("PostTabs", messRep);\n  }\n\n  closeDialog(e) {\n    //  console.log(e)\n    this.dialogVisible = false;\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n\n    this.agent.receive = function (from, message) {\n      if (message.hasOwnProperty("action")) {\n        switch (message.action) {\n          case "toggleWrite":\n            app.toggleWrite(message);\n            break;\n\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n\n    this.share.show == true ? this.toggleWrite() : "";\n  }\n\n  toggleWrite(message) {\n    console.log(message);\n    this.toggleDialog(message);\n  }\n\n  webIdChanged(webId) {\n    this.webId = webId;\n  }\n\n}\n\ncustomElements.define(\'post-element\', post_element_PostElement);\n// CONCATENATED MODULE: ./src/views/friends-view.js\nfunction friends_view_templateObject4() {\n  const data = friends_view_taggedTemplateLiteral(["\\n      <friend-view name=\\"", "\\" f_webId=", ">Loading Followers</friend-view>\\n      "]);\n\n  friends_view_templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction friends_view_templateObject3() {\n  const data = friends_view_taggedTemplateLiteral(["\\n      <friend-view name=\\"", "\\" f_webId=", ">Loading Following</friend-view>\\n      "]);\n\n  friends_view_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction friends_view_templateObject2() {\n  const data = friends_view_taggedTemplateLiteral(["\\n      <friend-view name=\\"", "\\" f_webId=", ">Loading Friend</friend-view>\\n      "]);\n\n  friends_view_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction friends_view_templateObject() {\n  const data = friends_view_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <div class=\\"container-fluid\\">\\n\\n    <div class=\\"card text-center\\">\\n    <div class=\\"card-header\\">\\n    <ul class=\\"nav nav-tabs card-header-tabs\\">\\n    <li class=\\"nav-item\\">\\n    <a class=\\"nav-link active\\" tab=\\"friends\\" @click=\\"", "\\" href=\\"#\\">Friends</a>\\n    </li>\\n    <li class=\\"nav-item\\">\\n    <a class=\\"nav-link\\" tab=\\"following\\" @click=\\"", "\\" href=\\"#\\">Following</a>\\n    </li>\\n    <li class=\\"nav-item\\">\\n    <a class=\\"nav-link\\" tab=\\"followers\\" @click=\\"", "\\" href=\\"#\\">Followers</a>\\n    </li>\\n    </ul>\\n    </div>\\n\\n    <div style=\\"overflow-y:scroll;position:relative;height: 80wh;\\">\\n\\n    <div class=\\"card-deck\\" ?hidden=\\"", "\\">\\n    ", "\\n    </div>\\n\\n    <div class=\\"card-deck\\" ?hidden=\\"", "\\">\\n    ", "\\n    </div>\\n\\n    <div class=\\"card-deck\\" ?hidden=\\"", "\\">\\n    ", "\\n    </div>\\n\\n    </div>\\n\\n    </div>\\n    "]);\n\n  friends_view_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction friends_view_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n //let data = solid.data\n//console.log("LDFK+LEX",data)\n\nclass friends_view_FriendsView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      friends: {\n        type: Array\n      },\n      followers: {\n        type: Array\n      },\n      following: {\n        type: Array\n      },\n      tab: {\n        type: String\n      },\n      config: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Friends";\n    this.config = {};\n    this.friends = [];\n    this.followers = [];\n    this.following = [];\n    this.tab = "friends";\n  }\n\n  render() {\n    return lit_html_html(friends_view_templateObject(), this.openTab, this.openTab, this.openTab, this.tab != "friends", this.friends.map((f, i) => lit_html_html(friends_view_templateObject2(), "Friend_" + i, f)), this.tab != "following", this.following.map((f, i) => lit_html_html(friends_view_templateObject3(), "Following_" + i, f)), this.tab != "followers", this.followers.map((f, i) => lit_html_html(friends_view_templateObject4(), "Followers_" + i, f)));\n  }\n\n  openTab(e) {\n    this.tab = e.target.getAttribute("tab"); //console.log(this.tab)\n\n    let tablinks = this.shadowRoot.querySelectorAll(".nav-link");\n\n    for (let i = 0; i < tablinks.length; i++) {\n      tablinks[i].classList.remove("active");\n    }\n\n    e.target.classList.add("active");\n  }\n\n  configChanged(config) {\n    console.log("CONFIG", config);\n    this.config = config; //  this.getFollowers()\n    //  this.getFollowing()\n\n    this.friends = this.config.friends || [];\n    this.followers = this.config.followersList || [];\n    this.following = this.config.followingList || []; //console.log("HIIIHAAAA",this.followers)\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name); //console.log(this.agent)\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "configChanged":\n            app.configChanged(message.config);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n}\n\ncustomElements.define(\'friends-view\', friends_view_FriendsView);\n// CONCATENATED MODULE: ./src/views/friend-view.js\n\n\nfunction friend_view_templateObject4() {\n  const data = friend_view_taggedTemplateLiteral(["<i class=\\"fas fa-user-circle fa-2x\\" title=\\"", "\\"></i>"]);\n\n  friend_view_templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction friend_view_templateObject3() {\n  const data = friend_view_taggedTemplateLiteral(["<img class=\\"rounded-circle card-img-top\\"\\n      src=\\"//images.weserv.nl/?url=", "&w=100&h=100\\"\\n      style=\\"height:5rem,width:5rem\\"\\n      title=\\"", "\\"\\n      alt=\\"no image\\">"]);\n\n  friend_view_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction friend_view_templateObject2() {\n  const data = friend_view_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n\\n    <div class=\\"card bg-light m-3\\" style=\\"width: 8rem;\\">\\n    ", "\\n\\n    \x3c!--    <img class=\\"card-img-top\\" src=\\"//images.weserv.nl/?url=", "&w=150&h=150\\"  alt=\\"", "\\">--\x3e\\n    <div class=\\"card-body p-1\\">\\n    \x3c!--  <h5 class=\\"card-title\\">", "</h5>\\n    <p class=\\"card-text\\"> ", " With supporting text below as a natural lead-in to additional content.</p>--\x3e\\n    <button class=\\"btn btn-outline-info btn-sm\\" webId=\\"", "\\"\\n    @click=\\"", "\\">", "</button>\\n    </div>\\n    </div>\\n    "]);\n\n  friend_view_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction friend_view_templateObject() {\n  const data = friend_view_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n\\n    <div class=\\"card\\" style=\\"width: 18rem;\\">\\n    <img class=\\"card-img-top\\" src=\\"...\\" alt=\\"Card image cap\\">\\n    <div class=\\"card-body\\">\\n    <h5 class=\\"card-title\\">Card title</h5>\\n    <p class=\\"card-text\\">This is a longer card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.</p>\\n    <p class=\\"card-text\\"><small class=\\"text-muted\\">Last updated 3 mins ago</small></p>\\n    </div>\\n    </div>\\n    "]);\n\n  friend_view_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction friend_view_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass friend_view_FriendView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      f_webId: {\n        type: String\n      },\n      friend: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Friend";\n    this.f_webId = "";\n    this.friend = {\n      webId: "",\n      name: "",\n      photo: ""\n    };\n  }\n\n  render1() {\n    return lit_html_html(friend_view_templateObject());\n  }\n\n  render() {\n    return lit_html_html(friend_view_templateObject2(), this.friend.photo.length > 0 ? lit_html_html(friend_view_templateObject3(), this.friend.photo, this.friend.photo) : lit_html_html(friend_view_templateObject4(), this.friend.name), this.friend.photo, this.friend.name, this.friend.name, this.friend.webId, this.friend.webId, this.showProfile, this.friend.name);\n  }\n  /* test photo\r\n  ${this.f_photo.length > 0 ?\r\n  html`<img class="rounded-circle user_img_msg" src="//images.weserv.nl/?url=${this.f_photo}&w=144&h=144" title="${this.f_photo}" alt="no image">`\r\n  :html`<i class="fas fa-user-circle fa-2x" title="${this.f_name}"></i>`\r\n  }\r\n  */\n\n\n  showProfile() {\n    //  let webId = e.target.getAttribute("webId")\n    console.log("CLICKED friend", this.friend);\n    this.agent.send("App", {\n      action: "showPanel",\n      panel: "Profile"\n    });\n    this.agent.send("Profile", {\n      action: "profileChanged",\n      profile: this.friend\n    });\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name); //console.log(this.agent)\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n\n    this.friend.webId = this.f_webId;\n    this.init();\n  }\n\n  async init() {\n    let name = (await solid.data["".concat(this.f_webId)].vcard$fn) || "".concat(this.f_webId).split("/")[2].split(\'.\')[0];\n    let photo = (await solid.data["".concat(this.f_webId)].vcard$hasPhoto) || "https://solid.github.io/solid-ui/src/icons/noun_15059.svg";\n    this.friend.name = "".concat(name);\n    this.friend.photo = "".concat(photo) != "undefined" ? "".concat(photo) : "https://solid.github.io/solid-ui/src/icons/noun_15059.svg"; //  console.log("friend", this.friend, this.f_webId)\n\n    this.requestUpdate();\n  }\n\n}\n\ncustomElements.define(\'friend-view\', friend_view_FriendView);\n// CONCATENATED MODULE: ./src/views/log-element.js\n\n\nfunction log_element_templateObject() {\n  const data = log_element_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <style>\\n    /* The snackbar - position it at the bottom and in the middle of the screen */\\n    #snackbar {\\n      visibility: hidden; /* Hidden by default. Visible on click */\\n      min-width: 250px; /* Set a default minimum width */\\n      margin-left: -125px; /* Divide value of min-width by 2 */\\n      background-color: #333; /* Black background color */\\n      color: #fff; /* White text color */\\n      text-align: center; /* Centered text */\\n      border-radius: 2px; /* Rounded borders */\\n      padding: 16px; /* Padding */\\n      position: fixed; /* Sit on top of the screen */\\n      z-index: 1; /* Add a z-index if needed */\\n      left: 50%; /* Center the snackbar */\\n      bottom: 30px; /* 30px from the bottom */\\n    }\\n\\n    /* Show the snackbar when clicking on a button (class added with JavaScript) */\\n    #snackbar.show {\\n      visibility: visible; /* Show the snackbar */\\n      /* Add animation: Take 0.5 seconds to fade in and out the snackbar.\\n      However, delay the fade out process for 2.5 seconds */\\n      -webkit-animation: fadein 0.5s, fadeout 0.5s 2.5s;\\n      animation: fadein 0.5s, fadeout 0.5s 2.5s;\\n    }\\n\\n    /* Animations to fade the snackbar in and out */\\n    @-webkit-keyframes fadein {\\n      from {bottom: 0; opacity: 0;}\\n      to {bottom: 30px; opacity: 1;}\\n    }\\n\\n    @keyframes fadein {\\n      from {bottom: 0; opacity: 0;}\\n      to {bottom: 30px; opacity: 1;}\\n    }\\n\\n    @-webkit-keyframes fadeout {\\n      from {bottom: 30px; opacity: 1;}\\n      to {bottom: 0; opacity: 0;}\\n    }\\n\\n    @keyframes fadeout {\\n      from {bottom: 30px; opacity: 1;}\\n      to {bottom: 0; opacity: 0;}\\n    }\\n    </style>\\n    \x3c!--  <style>\\n    .myAlert-top{\\n    position: fixed;\\n    top: 5px;\\n    left:2%;\\n    width: 96%;\\n  }\\n\\n  .myAlert-bottom{\\n  position: fixed;\\n  bottom: 5px;\\n  left:2%;\\n  width: 96%;\\n}\\n\\ndiv.fullscreen {\\nposition: absolute;\\nwidth:100%;\\nheight:960px;\\ntop: 0;\\nleft: 0;\\nbackground-color: lightblue;\\n}\\n\\n.alert{\\ndisplay: none;\\n}\\n</style>\\n--\x3e\\n\\n<div class=\\"container-fluid\\">\\nHello <b>", "</b> from app-element\\n\\n\x3c!-- Use a button to open the snackbar --\x3e\\n<button @click=\\"", "\\">Show Snackbar</button>\\n\\n\x3c!-- The actual snackbar --\x3e\\n\x3c!--<div id=\\"snackbar\\">Some text some message..</div>--\x3e\\n\\n\\n\\n\\n<div class=\\"toast\\" id=\\"snackbar\\" role=\\"alert\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n<div class=\\"toast-header\\">\\n<img src=\\"...\\" class=\\"rounded mr-2\\" alt=\\"...\\">\\n<strong class=\\"mr-auto\\">Bootstrap</strong>\\n<small>11 mins ago</small>\\n<button type=\\"button\\" class=\\"ml-2 mb-1 close\\" data-dismiss=\\"toast\\" aria-label=\\"Close\\">\\n<span aria-hidden=\\"true\\">&times;</span>\\n</button>\\n</div>\\n<div class=\\"toast-body\\">\\nHello, world! This is a toast message. Hello, world! This is a toast message. Hello, world! This is a toast message. Hello, world! This is a toast message.\\n</div>\\n</div>\\n\\n\x3c!--<div class=\\"fullscreen\\">\\n<div class=\\"col-sm-6\\">\\n<button class=\\"form-control\\" @click=\\"", "\\">show alert top</button>\\n</div>\\n<div class=\\"col-sm-6\\">\\n<button class=\\"form-control\\" @click=\\"", "\\">show alert bottom</button>\\n</div>\\n</div>\\n<div id=\\"top\\" class=\\"myAlert-top alert alert-success\\">\\n<a href=\\"#\\" class=\\"close\\" data-dismiss=\\"alert\\" aria-label=\\"close\\">&times;</a>\\n<strong>Success!</strong> Indicates a successful or positive action.\\n</div>\\n<div id=\\"bottom\\" class=\\"myAlert-bottom alert alert-danger\\">\\n<a href=\\"#\\" class=\\"close\\" data-dismiss=\\"alert\\" aria-label=\\"close\\">&times;</a>\\n<strong>Danger!</strong> This alert box could indicate a dangerous or potentially negative action.\\n</div>--\x3e\\n\x3c!--\\n<paper-toast text=\\"Hello Take your <a href=\'#t\'>POD</a> and look at help!\\" opened> Boo</paper-toast>--\x3e\\n</div>\\n"]);\n\n  log_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction log_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass log_element_LogElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Log";\n  }\n\n  render() {\n    return lit_html_html(log_element_templateObject(), this.name, this.myFunction, this.myAlertTop, this.myAlertBottom);\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "webIdChanged":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  myFunction() {\n    // Get the snackbar DIV\n    var x = this.shadowRoot.getElementById("snackbar");\n    console.log("X", x); // Add the "show" class to DIV\n\n    x.className = "show"; // After 3 seconds, remove the show class from DIV\n\n    setTimeout(function () {\n      x.className = x.className.replace("show", "");\n    }, 3000);\n  }\n\n}\n\ncustomElements.define(\'log-element\', log_element_LogElement);\n// CONCATENATED MODULE: ./src/views/profile-element.js\n\n\n\nfunction profile_element_templateObject5() {\n  const data = profile_element_taggedTemplateLiteral([""]);\n\n  profile_element_templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction profile_element_templateObject4() {\n  const data = profile_element_taggedTemplateLiteral(["\\n        <button class=\\"brn btn-outline-primary btn-sm\\" @click=\\"", "\\">Edit My Profile (WIP)</button>\\n        "]);\n\n  profile_element_templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction profile_element_templateObject3() {\n  const data = profile_element_taggedTemplateLiteral(["<button class=\\"btn btn-outline-info btn-sm\\" @click=\\"", "\\"><i class=\\"fas fa-user-plus\\"></i>Follow</button>\\n        "]);\n\n  profile_element_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction profile_element_templateObject2() {\n  const data = profile_element_taggedTemplateLiteral(["\\n      ", "\\n        "]);\n\n  profile_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction profile_element_templateObject() {\n  const data = profile_element_taggedTemplateLiteral(["\\n    <link href=\\"css/bootstrap/bootstrap.min.css\\" rel=\\"stylesheet\\">\\n    <link href=\\"css/fontawesome/css/all.css\\" rel=\\"stylesheet\\">\\n    <style>\\n    .close {\\n      color: \\"#aaaaaa\\";\\n      float: right;\\n      font-size: 28px;\\n      font-weight: bold;\\n    }\\n\\n    .close:hover,\\n    .close:focus {\\n      color: \\"#000\\";\\n      text-decoration: none;\\n      cursor: pointer;\\n    }\\n    </style>\\n\\n    <div class=\\"card\\" style=\\"width: 18rem;\\">\\n    <i @click=\\"", "\\" class=\\"close fas fa-window-close\\"></i>\\n\\n    <img class=\\"card-img-top\\" src=\\"", "\\" alt=\\"Card image cap\\">\\n    <div class=\\"card-body\\">\\n    <h5 class=\\"card-title\\"><b>", "</b></h5>\\n\\n    <p class=\\"card-text\\">\\n\\n    User  webId :<b>", "</b><br>\\n    Storage : <a\\n    href=\\"https://scenaristeur.github.io/spoggy-simple/?source=", "\\"\\n    target=\\"_blank\\" >", "</a><br>\\n\x3c!--stringVariable.substring(0, stringVariable.lastIndexOf(\'#\'));--\x3e\\n    Role: ", "<br>\\n    Organisation: ", "<br>\\n    <br>\\n    <br>  Your WebId : ", "<br>\\n    </p>\\n\\n    ", "\\n\\n      </div>\\n      </div>\\n      "]);\n\n  profile_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction profile_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction profile_element_asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }\n\n\n //let data = solid.data\n//console.log("LDFK+LEX",data)\n\n\n\nclass profile_element_ProfileElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      config: {\n        type: Object\n      },\n      // config : current loged user\n      p_config: {\n        type: Object\n      } // p_config : the user that the profile-element shows\n\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = "Profile";\n    this.config = {};\n    this.p_config = {\n      storage: "Loading..."\n    };\n  }\n\n  render() {\n    return lit_html_html(profile_element_templateObject(), this.close, this.p_config.photo, this.p_config.name, this.p_config.webId, this.p_config.storage, this.p_config.storage, this.p_config.role, this.p_config.organization, this.config.webId, this.config.webId != null ? lit_html_html(profile_element_templateObject2(), this.config.webId != this.p_config.webId ? lit_html_html(profile_element_templateObject3(), this.follow) : lit_html_html(profile_element_templateObject4(), this.edit)) : lit_html_html(profile_element_templateObject5()));\n  }\n\n  edit() {\n    alert("// TODO: come back later ;-) ");\n  }\n\n  close() {\n    this.agent.send("App", {\n      action: "showPanel"\n    });\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log("messah",message)\n      if (message.hasOwnProperty("action")) {\n        //  console.log(message)\n        switch (message.action) {\n          case "profileChanged":\n            app.profileChanged(message.profile);\n            break;\n\n          case "configChanged":\n            app.configChanged(message.config);\n            break;\n\n          default:\n            console.log("Unknown action ", message);\n        }\n      }\n    };\n  }\n\n  init() {\n    console.log("TODO check if user webId follow this profile");\n  }\n\n  configChanged(config) {\n    this.config = config;\n  }\n\n  async follow() {\n    // Must create a follow Activity with accept ?\n    //  alert("// TODO: come back later ;-) ")\n    console.log("CONFIG", this.config);\n    console.log("P_CONFIG", this.p_config);\n    let profile_followers = this.p_config.followers + \'index.ttl#this\';\n    console.log(profile_followers);\n    let user_following = this.config.following + \'index.ttl#this\';\n    console.log(user_following);\n    await solid.data[user_following].as$items.add(Object(data_model["namedNode"])(this.p_config.webId));\n    console.log("!!! Must first set authenticated agent to publisher in config");\n    await solid.data[profile_followers].as$items.add(Object(data_model["namedNode"])(this.config.webId));\n  }\n\n  async profileChanged(profile) {\n    console.log("USER", profile);\n    this.p_config = profile;\n    this.p_config.pti = await solid.data[this.p_config.webId].publicTypeIndex;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = profile_element_asyncIterator(solid.data[this.p_config.pti].subjects), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const subject = _value;\n        if (this.p_config.pti != "".concat(subject))\n          /*let s = `${subject}`\r\n          console.log(s)*/\n          if ("".concat(subject).endsWith(\'#Agora\')) {\n            let instance = await solid.data["".concat(subject)].solid$instance;\n            this.p_config.instance = "".concat(instance);\n            let inbox = await solid.data[this.p_config.instance].as$inbox;\n            this.p_config.inbox = "".concat(inbox);\n            let outbox = await solid.data[this.p_config.instance].as$outbox;\n            this.p_config.outbox = "".concat(outbox);\n            let followers = await solid.data[this.p_config.instance].as$followers;\n            this.p_config.followers = "".concat(followers);\n            let following = await solid.data[this.p_config.instance].as$following;\n            this.p_config.following = "".concat(following);\n            let liked = await solid.data[this.p_config.instance].as$liked;\n            this.p_config.liked = "".concat(liked);\n          }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    let storage = await solid.data[this.p_config.webId].storage;\n    this.p_config.storage = "".concat(storage);\n    this.p_config.organization = await solid.data[this.p_config.webId]["http://www.w3.org/2006/vcard/ns#organization-name"];\n    this.p_config.role = await solid.data[this.p_config.webId]["http://www.w3.org/2006/vcard/ns#role"];\n    console.log("P_PROFILE", this.p_config);\n    this.requestUpdate();\n  }\n\n}\n\ncustomElements.define(\'profile-element\', profile_element_ProfileElement);\n// CONCATENATED MODULE: ./src/index.js\n//GENERAL\n\n\n\n\n\n // SOLID\n\n // FLUX\n\n\n\n\n //CONFIG\n\n //POST\n\n\n\n\n\n\n\n\n //ORGANIZATION\n\n\n // LOG\n\n // PROFILE\n\n\n/*\r\nimport \'./views/compose-view.js\';\r\nimport \'./views/orga-view.js\';\r\nimport \'./views/flow-view.js\';\r\nimport \'./views/talk-view.js\';*/\n//import \'./views/config-view.js\';\n//import \'./css/fontawesome/css/all.css\';\n//import \'./views/store-element.js\'\n//import \'./views/friends-view.js\'\n//import \'./views/friend-view.js\'\n//import \'./views/info-element.js\';\n//\n//import \'./views/user-profile-view.js\'\n//import \'./views/config-set-view.js\'\n\n/*import \'./views/todo-view.js\';\r\nimport \'./views/stats-view.js\';\r\nimport \'./views/not-found-view.js\';\r\nimport \'./views/activity-element.js\'\r\nimport \'./views/object-element.js\'\r\nimport \'./views/notification-line-element.js\'\r\n//import \'./views/login-element.js\'\r\nimport \'./views/post-basic-element.js\'\r\nimport \'./views/flux-element.js\'\r\nimport \'./views/menu-element.js\'\r\nimport \'./views/profile-element.js\'\r\n//import \'./views/profile-cartouche-element.js\'\r\n\r\nimport \'./views/config-element.js\'\r\nimport \'./views/fab-element.js\'\r\nimport \'./views/post-element.js\'\r\n//import \'./app-old-element.js\'*///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL2RvbS5qcz9iNDUzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUuanM/ZTMyYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL21vZGlmeS10ZW1wbGF0ZS5qcz83NjZiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvZGlyZWN0aXZlLmpzPzc4MWMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9wYXJ0LmpzP2Q1NTIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi90ZW1wbGF0ZS1pbnN0YW5jZS5qcz9lYWU5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUtcmVzdWx0LmpzPzE4YzAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9wYXJ0cy5qcz81YzhlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUtZmFjdG9yeS5qcz8zZWE5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvcmVuZGVyLmpzP2MyNjgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcz9kMDU4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saXQtaHRtbC5qcz8wMWExIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvc2hhZHktcmVuZGVyLmpzP2E5YzkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpYi91cGRhdGluZy1lbGVtZW50LmpzP2IyMmIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpYi9kZWNvcmF0b3JzLmpzP2Q0OTkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpYi9jc3MtdGFnLmpzPzZiYmIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpdC1lbGVtZW50LmpzPzA5MDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FnZW50cy9oZWxsby1hZ2VudC5qcz9kM2MzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9hcHAtdmlldy5qcz8zZTVmIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9iYXNlLXZpZXcuanM/MDY0ZSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3Mvc3RvcmUtZWxlbWVudC5qcz82NjZmIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9wYW5lbC1lbGVtZW50LmpzPzAxM2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2luZm8tZWxlbWVudC5qcz9hOWNmIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9sb2dpbi1lbGVtZW50LmpzPzBlOTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2ZsdXgtZWxlbWVudC5qcz9mZTM2Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9ub3RpZmljYXRpb24tbGluZS1lbGVtZW50LmpzP2UwZjQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2FjdGl2aXR5LWVsZW1lbnQuanM/Yzk3ZSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3Mvb2JqZWN0LWVsZW1lbnQuanM/NzYyYiIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29uZmlnLWdldC12aWV3LmpzP2YyMDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2ZhYi1lbGVtZW50LmpzPzZiN2EiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2RpcmVjdGl2ZXMvY2xhc3MtbWFwLmpzP2UyYWIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanM/ZDhmOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL2J5dGVzVG9VdWlkLmpzP2I2OTEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9ub3RlLWVsZW1lbnQuanM/YTQyZSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbWVkaWEtZWxlbWVudC5qcz8yN2Y5Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9ncmFwaC1lbGVtZW50LmpzPzQ3MzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3RyaXBsZS1lbGVtZW50LmpzPzNmNDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3Bvc3QtdGFicy1lbGVtZW50LmpzPzY1NjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3Bvc3QtZGlhbG9nLWVsZW1lbnQuanM/ZDY1YyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvcG9zdC1lbGVtZW50LmpzPzQ2MWMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2ZyaWVuZHMtdmlldy5qcz9jNjUwIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9mcmllbmQtdmlldy5qcz9mYjEzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9sb2ctZWxlbWVudC5qcz82ODc3Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9wcm9maWxlLWVsZW1lbnQuanM/MjA0MiIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJIZWxsb0FnZW50IiwiaWQiLCJldmUiLCJBZ2VudCIsImNhbGwiLCJjb25uZWN0Iiwic3lzdGVtIiwidHJhbnNwb3J0cyIsImdldEFsbCIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwic2F5SGVsbG8iLCJ0byIsInNlbmQiLCJyZWNlaXZlIiwiZnJvbSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsImluZGV4T2YiLCJicm9hZGNhc3QiLCJtZSIsImFsbEFnZW50cyIsImtleXMiLCJjb25uZWN0aW9ucyIsInRyYW5zcG9ydCIsImFnZW50cyIsImZvckVhY2giLCJhZ2VudCIsInNlbmRNdWx0aSIsInJlY2lwaWVudHMiLCJBcHBWaWV3IiwiTGl0RWxlbWVudCIsInByb3BlcnRpZXMiLCJuYW1lIiwidHlwZSIsIlN0cmluZyIsImRlYnVnIiwiQm9vbGVhbiIsInNoYXJlIiwicGFuZWwiLCJ3ZWJJZCIsInF1ZXJ5IiwicGFuZWxzIiwiQXJyYXkiLCJhZ29yYVBvZCIsImltYWdlIiwidGV4dCIsIm9uTG9hZCIsInJlbmRlciIsImh0bWwiLCJzaG93RGVmYXVsdCIsInNob3dGcm9tQXR0IiwibWFwIiwicCIsImkiLCJmaXJzdFVwZGF0ZWQiLCJhcHAiLCJoYXNPd25Qcm9wZXJ0eSIsImFjdGlvbiIsIndlYklkQ2hhbmdlZCIsImluaXRGcm9tU3RvcmUiLCJzdG9yZSIsInNob3dQYW5lbCIsImluZm8iLCJlIiwidGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwicGFyc2VkVXJsIiwiVVJMIiwid2luZG93IiwibG9jYXRpb24iLCJ0b1N0cmluZyIsInRpdGxlIiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwidXJsIiwic2hvdyIsImFsZXJ0IiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiLCJCYXNlVmlldyIsImNyZWF0ZVJlbmRlclJvb3QiLCJ0ZXN0IiwicGFnZUNoYW5nZWQiLCJwYWdlIiwicGFuZWxDaGFuZ2VkIiwiY2xpY2siLCJTdG9yZUVsZW1lbnQiLCJjbGVhblN0b3JhZ2UiLCJzZXRTdG9yYWdlIiwidmFsdWVzIiwiZ2V0Q29uZmlnIiwicmVhZFN0b3JhZ2UiLCJjb25maWciLCJzdGF0dXMiLCJwb3B1bGF0ZVN0b3JhZ2UiLCJwYXJzZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJrZXkiLCJ2YWx1ZSIsImVudHJpZXMiLCJzZXRJdGVtIiwidXBkYXRlU3RvcmFnZSIsImRhdGEiLCJyZW1vdmVJdGVtIiwiUGFuZWxFbGVtZW50IiwiSW5mb0VsZW1lbnQiLCJMb2dpbkVsZW1lbnQiLCJkZXN0aW5hdGFpcmVzIiwibG9naW4iLCJsb2dvdXQiLCJzb2xpZCIsImF1dGgiLCJ0cmFja1Nlc3Npb24iLCJzZXNzaW9uIiwicG9wdXBMb2dpbiIsIndpIiwidGhlbiIsImN1cnJlbnRTZXNzaW9uIiwicG9wdXBVcmkiLCJGbHV4RWxlbWVudCIsIm5vdGlmaWNhdGlvbnMiLCJsZW5ndGgiLCJuIiwiaW5pdCIsInB0aV91cmwiLCJzb2xpZCRwdWJsaWNUeXBlSW5kZXgiLCJpbnN0YW5jZSIsInNvbGlkJGluc3RhbmNlIiwiaW5ib3giLCJhcyRpbmJveCIsInN1YmplY3RzIiwic3ViamVjdCIsInB1c2giLCJwdWJsaXNoZWQiLCJEYXRlIiwiYXMkcHVibGlzaGVkIiwidGltZXN0YW1wIiwiZ2V0VGltZSIsIk5vdGlmaWNhdGlvbkxpbmVFbGVtZW50Iiwibm90aWZpY2F0aW9uIiwiY3JlYXRvciIsInBob3RvIiwic2hvd1Byb2ZpbGUiLCJkZWxheSIsImF0dHJpYnV0ZWRUbyIsImxpbmsiLCJwcm9maWxlIiwiZGlmZiIsIm1pbnV0ZSIsIm1pbnV0ZXMiLCJNYXRoIiwiZmxvb3IiLCJoZXVyZXMiLCJqb3VycyIsIm1vaXMiLCJhbm5lZXMiLCJkdXJlZSIsImFzJGF0dHJpYnV0ZWRUbyIsInN1bW1hcnkiLCJhcyRzdW1tYXJ5IiwiYXMkdHlwZSIsImFzJGxpbmsiLCJ2Y2FyZCRmbiIsInNwbGl0IiwidmNhcmQkaGFzUGhvdG8iLCJyZXF1ZXN0VXBkYXRlIiwibG9jYWxOYW1lIiwic3RyUHJvbWlzZSIsInN0ciIsImxuIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJBY3Rpdml0eUVsZW1lbnQiLCJhY3Rpdml0eSIsIm9iamVjdHMiLCJvYmplY3QiLCJyZXBseVRvIiwibGlrZSIsImRpc2xpa2UiLCJuYXZpZ2F0b3IiLCJjYXRjaCIsImVycm9yIiwic3ViIiwiYm9keSIsIm1haWxhcnIiLCJlbmNvZGVVUklDb21wb25lbnQiLCJtYWlsc3RyIiwiam9pbiIsIm9wZW4iLCJ1cGRhdGVkIiwiY2hhbmdlZFByb3BlcnRpZXMiLCJvbGRWYWx1ZSIsInByb3BOYW1lIiwiYXMkb2JqZWN0IiwiYXMkdGFyZ2V0IiwiT2JqZWN0RWxlbWVudCIsImV4dCIsImNvbnRlbnQiLCJsaW5raWZ5IiwiaW5wdXRUZXh0IiwicmVwbGFjZVBhdHRlcm4xIiwicmVwbGFjZWRUZXh0IiwicmVwbGFjZSIsInJlcGxhY2VQYXR0ZXJuMiIsInJlcGxhY2VQYXR0ZXJuMyIsInNoYWRvd1Jvb3QiLCJnZXRFbGVtZW50QnlJZCIsImlubmVySFRNTCIsInN1YnN0ciIsImFzIiwiYXMkY29udGVudCIsIkNvbmZpZ0dldFZpZXciLCJhY2xJbmJveCIsInRleHRDb2xvciIsImFjbEluYm94Q29udGVudCIsImNoZWNrQ29uZmlnIiwiaGlkZU1vZGFsIiwicGF0aCIsInBhdGhDaGFuZ2VkIiwiY3JlYXRlRm9sZGVycyIsIm5ld0NvbmZpZyIsImRhdGUiLCJvcmlnaW4iLCJwdGkiLCJwdWJsaWNUeXBlSW5kZXgiLCJlbmRzV2l0aCIsIm91dGJveCIsImFzJG91dGJveCIsImZvbGxvd2VycyIsImFzJGZvbGxvd2VycyIsImZvbGxvd2luZyIsImFzJGZvbGxvd2luZyIsImxpa2VkIiwiYXMkbGlrZWQiLCJjaGVja0FjbCIsImluY2x1ZGVzIiwib3BlbkNvbmZpZ0JveCIsImZyaWVuZHMiLCJmcmllbmQiLCJmIiwiZm9sbG93ZXJzX3VyaSIsImFzJGl0ZW1zIiwiZl9lciIsImZlciIsImZvbGxvd2Vyc0xpc3QiLCJmb2xsb3dpbmdfdXJpIiwiZl9pbmciLCJmaW5nIiwiZm9sbG93aW5nTGlzdCIsInN0b3JhZ2UiLCJhY2xfaW5ib3giLCJhY2xfZm9sbG93ZXJzIiwiaW5ib3hhY2wiLCJmb2xsb3dlcnNhY2wiLCJmYyIsIlNvbGlkRmlsZUNsaWVudCIsImNyZWF0ZUZpbGUiLCJzdWNjZXNzIiwiZXJyIiwic2hvd01vZGFsIiwic3R5bGUiLCJkaXNwbGF5Iiwicm9vdCIsImZpbGUiLCJpdGVtRXhpc3RzIiwiY3JlYXRlRm9sZGVyIiwiaW5zdF91cmkiLCJpbnN0X2luZGV4Iiwic29saWQkZm9yQ2xhc3MiLCJhZGQiLCJuYW1lZE5vZGUiLCJzZXQiLCJwYXRoSW5wdXQiLCJjb25maWdDaGFuZ2VkIiwidW5kZWZpbmVkIiwiRmFiRWxlbWVudCIsInRvZ2dsZVdyaXRlIiwidG9nZ2xlRmFiIiwicXVlcnlTZWxlY3RvciIsImNsYXNzTGlzdCIsInRvZ2dsZSIsIk5vdGVFbGVtZW50IiwiYXNrQ29udGVudCIsInRleHRhcmVhIiwibm90ZSIsInRyaW0iLCJNZWRpYUVsZW1lbnQiLCJjb3VudCIsIk51bWJlciIsImV4dGVuc2lvbiIsImZpbGVuYW1lIiwiZm9sZGVycyIsIm5vdGVzTGlzdFVybCIsImNyZWF0ZVRlbXAiLCJsYW5nIiwiZmlsZW5hbWVDaGFuZ2UiLCJmaWxlcyIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJjdyIsIndpZHRoIiwiY2giLCJoZWlnaHQiLCJtYXhXIiwibWF4SCIsIkltYWdlIiwib25sb2FkIiwiaXciLCJpaCIsInNjYWxlIiwibWluIiwiaXdTY2FsZWQiLCJpaFNjYWxlZCIsImRyYXdJbWFnZSIsInNyYyIsImNyZWF0ZU9iamVjdFVSTCIsImNsYXNzZSIsIm1hdGNoIiwiaW5wdXQiLCJyZXAiLCJuZXdGaWxlbmFtZSIsIkdyYXBoRWxlbWVudCIsInNlbmRNZXNzYWdlIiwiZG9Tb21ldGhpbmciLCJUcmlwbGVFbGVtZW50IiwidHJpcGxlcyIsImZvb3RwcmludCIsImluZGV4IiwidHJpcGxlc0xpc3QiLCJ0IiwicHJlZGljYXRlIiwia2V5ZG93biIsImFkZF90cmlwbGUiLCJuZXdfdHJpcGxlIiwicmVzIiwidXBkYXRlSW5wdXQiLCJpbnB1dE5ldyIsInRyaXBsZSIsInJldmVyc2UiLCJyZXN1bHQiLCJsYXN0Q2hhciIsInNsaWNlIiwibWVzc2FnZUN1dCIsImlzVHJpcGxldCIsImRldGVjdExpdGVyYWwiLCJtZXNzYWdlQ3V0VGVtcCIsInBhcnQiLCJzdGFydHNXaXRoIiwicG9wIiwidHJpcGxldHZhbHVlIiwid2hpY2giLCJwcmV2ZW50RGVmYXVsdCIsIlBvc3RUYWJzRWxlbWVudCIsInN1YmVsZW1lbnRzIiwicmVxdWV0ZXMiLCJyZXNwb25zZXMiLCJhZ29yYU5vdGVzTGlzdFVybCIsImNvbmZpZGVudGlhbGl0ZSIsImZpbGVDbGllbnQiLCJsZXZlbCIsInNlbGVjdGVkIiwiZGVzY3JpcHRpb24iLCJpY29uIiwib3BlblRhYiIsImNoYW5nZSIsInNlbGVjdCIsImMiLCJhZGROb3RlIiwiY29uZmlkIiwidG9JU09TdHJpbmciLCJtZXNzIiwibm9kZSIsIm5vZGVOYW1lIiwicGFyZW50Tm9kZSIsInRhYk5hbWUiLCJ0YWJjb250ZW50IiwidGFibGlua3MiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2xhc3NOYW1lIiwicmVwb25zZUNvbnRlbnQiLCJzZXRSZXBseVRvIiwicHJlcGFyZVBvc3QiLCJyZWNpcGllbnRfc2VsZWN0Iiwib3B0aW9ucyIsInJlZHVjZSIsImFjYyIsIm9wdGlvbiIsInRhZ3MiLCJhZ29yYV9wdWIiLCJjaGVja2VkIiwiaW5SZXBseVRvIiwidXNlciIsImRhdGVPYmoiLCJyIiwib2JqZWN0X0lkIiwidXVpZHY0Iiwib2JqZWN0X2ZpbGUiLCJvYmplY3RfdXJpIiwidXJpIiwiY29udGVudFR5cGUiLCJzZW5kRmlsZSIsImFjdGl2aXR5X0lkIiwiYWN0aXZpdHlfZmlsZSIsImFjdGl2aXR5X3VyaSIsInJkZnMkbGFiZWwiLCJyZWNpcGllbnRzV2ViSWRzIiwiYWNsU3RyaW5nV2ViSWRzIiwibyIsInNldEFjbCIsIm5vdGlmaWNhdGlvbl9JZCIsImluc3RhbmNlVHJvdXZlZSIsInMiLCJpYiIsInJlY2lwX2luYm94Iiwibm90aWZpY2F0aW9uX3VyaSIsImFjbFN0cmluZyIsInByZXBhcmVQb3N0MiIsIm5vdyIsInVzZXJBY3Rpdml0eSIsImFzJG5hbWUiLCJzY2hlbWEkZGF0ZUNyZWF0ZWQiLCJyZGYkdHlwZSIsImFzJGluUmVwbHlUbyIsImFnb3JhQWN0aXZpdHkiLCJhcyRhY3RvciIsInVzZXJOb3RlIiwic2NoZW1hJHRleHQiLCJ1c2VyTWVkaWEiLCJwcmVwYXJlUG9zdDEiLCJhcyRnZW5lcmF0b3IiLCJzY2hlbWEkY3JlYXRvciIsInRhZ3VyaSIsImFzJHRhZyIsImFzJGF0dGFjaG1lbnQiLCJQb3N0RGlhbG9nRWxlbWVudCIsIm9wZW5lZCIsImNsYXNzTWFwIiwiZGlhbG9nIiwiY2xvc2VkIiwibW9kYWwiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJQb3N0RWxlbWVudCIsImRpYWxvZ1Zpc2libGUiLCJ0b2dnbGVEaWFsb2ciLCJiaW5kIiwiY2xvc2VEaWFsb2ciLCJtZXNzUmVwIiwiRnJpZW5kc1ZpZXciLCJ0YWIiLCJyZW1vdmUiLCJGcmllbmRWaWV3IiwiZl93ZWJJZCIsInJlbmRlcjEiLCJMb2dFbGVtZW50IiwibXlGdW5jdGlvbiIsIm15QWxlcnRUb3AiLCJteUFsZXJ0Qm90dG9tIiwieCIsInNldFRpbWVvdXQiLCJQcm9maWxlRWxlbWVudCIsInBfY29uZmlnIiwiY2xvc2UiLCJyb2xlIiwib3JnYW5pemF0aW9uIiwiZm9sbG93IiwiZWRpdCIsInByb2ZpbGVDaGFuZ2VkIiwicHJvZmlsZV9mb2xsb3dlcnMiLCJ1c2VyX2ZvbGxvd2luZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0I7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyx3QkFBd0IsSUFBSTtBQUM1QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOztBQzdwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLE1BQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQzs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7QUFDTTtBQUNsQjtBQUNOO0FBQ2dEO0FBQ3JCO0FBQzlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxzQkFBVSxTQUFTLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFB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Q0FHQTs7Q0FHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtDQUdBOztBQUNBO0NBR0E7O0NBR0E7O0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiODYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIFRydWUgaWYgdGhlIGN1c3RvbSBlbGVtZW50cyBwb2x5ZmlsbCBpcyBpbiB1c2UuXG4gKi9cbmV4cG9ydCBjb25zdCBpc0NFUG9seWZpbGwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cyAhPSBudWxsICYmXG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2sgIT09XG4gICAgICAgIHVuZGVmaW5lZDtcbi8qKlxuICogUmVwYXJlbnRzIG5vZGVzLCBzdGFydGluZyBmcm9tIGBzdGFydGAgKGluY2x1c2l2ZSkgdG8gYGVuZGAgKGV4Y2x1c2l2ZSksXG4gKiBpbnRvIGFub3RoZXIgY29udGFpbmVyIChjb3VsZCBiZSB0aGUgc2FtZSBjb250YWluZXIpLCBiZWZvcmUgYGJlZm9yZWAuIElmXG4gKiBgYmVmb3JlYCBpcyBudWxsLCBpdCBhcHBlbmRzIHRoZSBub2RlcyB0byB0aGUgY29udGFpbmVyLlxuICovXG5leHBvcnQgY29uc3QgcmVwYXJlbnROb2RlcyA9IChjb250YWluZXIsIHN0YXJ0LCBlbmQgPSBudWxsLCBiZWZvcmUgPSBudWxsKSA9PiB7XG4gICAgd2hpbGUgKHN0YXJ0ICE9PSBlbmQpIHtcbiAgICAgICAgY29uc3QgbiA9IHN0YXJ0Lm5leHRTaWJsaW5nO1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0YXJ0LCBiZWZvcmUpO1xuICAgICAgICBzdGFydCA9IG47XG4gICAgfVxufTtcbi8qKlxuICogUmVtb3ZlcyBub2Rlcywgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIChpbmNsdXNpdmUpIHRvIGBlbmRgIChleGNsdXNpdmUpLCBmcm9tXG4gKiBgY29udGFpbmVyYC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZU5vZGVzID0gKGNvbnRhaW5lciwgc3RhcnQsIGVuZCA9IG51bGwpID0+IHtcbiAgICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICBjb25zdCBuID0gc3RhcnQubmV4dFNpYmxpbmc7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gbjtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQW4gZXhwcmVzc2lvbiBtYXJrZXIgd2l0aCBlbWJlZGRlZCB1bmlxdWUga2V5IHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoXG4gKiBwb3NzaWJsZSB0ZXh0IGluIHRlbXBsYXRlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcmtlciA9IGB7e2xpdC0ke1N0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKX19fWA7XG4vKipcbiAqIEFuIGV4cHJlc3Npb24gbWFya2VyIHVzZWQgdGV4dC1wb3NpdGlvbnMsIG11bHRpLWJpbmRpbmcgYXR0cmlidXRlcywgYW5kXG4gKiBhdHRyaWJ1dGVzIHdpdGggbWFya3VwLWxpa2UgdGV4dCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBub2RlTWFya2VyID0gYDwhLS0ke21hcmtlcn0tLT5gO1xuZXhwb3J0IGNvbnN0IG1hcmtlclJlZ2V4ID0gbmV3IFJlZ0V4cChgJHttYXJrZXJ9fCR7bm9kZU1hcmtlcn1gKTtcbi8qKlxuICogU3VmZml4IGFwcGVuZGVkIHRvIGFsbCBib3VuZCBhdHRyaWJ1dGUgbmFtZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBib3VuZEF0dHJpYnV0ZVN1ZmZpeCA9ICckbGl0JCc7XG4vKipcbiAqIEFuIHVwZGF0YWJsZSBUZW1wbGF0ZSB0aGF0IHRyYWNrcyB0aGUgbG9jYXRpb24gb2YgZHluYW1pYyBwYXJ0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXN1bHQsIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBjb25zdCBub2Rlc1RvUmVtb3ZlID0gW107XG4gICAgICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgICAgIC8vIEVkZ2UgbmVlZHMgYWxsIDQgcGFyYW1ldGVycyBwcmVzZW50OyBJRTExIG5lZWRzIDNyZCBwYXJhbWV0ZXIgdG8gYmUgbnVsbFxuICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsZW1lbnQuY29udGVudCwgMTMzIC8qIE5vZGVGaWx0ZXIuU0hPV197RUxFTUVOVHxDT01NRU5UfFRFWFR9ICovLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBsYXN0IGluZGV4IGFzc29jaWF0ZWQgd2l0aCBhIHBhcnQuIFdlIHRyeSB0byBkZWxldGVcbiAgICAgICAgLy8gdW5uZWNlc3Nhcnkgbm9kZXMsIGJ1dCB3ZSBuZXZlciB3YW50IHRvIGFzc29jaWF0ZSB0d28gZGlmZmVyZW50IHBhcnRzXG4gICAgICAgIC8vIHRvIHRoZSBzYW1lIGluZGV4LiBUaGV5IG11c3QgaGF2ZSBhIGNvbnN0YW50IG5vZGUgYmV0d2Vlbi5cbiAgICAgICAgbGV0IGxhc3RQYXJ0SW5kZXggPSAwO1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncywgdmFsdWVzOiB7IGxlbmd0aCB9IH0gPSByZXN1bHQ7XG4gICAgICAgIHdoaWxlIChwYXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UndmUgZXhoYXVzdGVkIHRoZSBjb250ZW50IGluc2lkZSBhIG5lc3RlZCB0ZW1wbGF0ZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2Ugc3RpbGwgaGF2ZSBwYXJ0cyAodGhlIG91dGVyIGZvci1sb29wKSwgd2Uga25vdzpcbiAgICAgICAgICAgICAgICAvLyAtIFRoZXJlIGlzIGEgdGVtcGxhdGUgaW4gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgd2Fsa2VyIHdpbGwgZmluZCBhIG5leHROb2RlIG91dHNpZGUgdGhlIHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogTm9kZS5FTEVNRU5UX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmFtZWROb2RlTWFwLFxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSByZXR1cm5lZCBpbiBkb2N1bWVudCBvcmRlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFydGljdWxhciwgRWRnZS9JRSBjYW4gcmV0dXJuIHRoZW0gb3V0IG9mIG9yZGVyLCBzbyB3ZSBjYW5ub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIGEgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiBwYXJ0IGluZGV4IGFuZCBhdHRyaWJ1dGUgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRzV2l0aChhdHRyaWJ1dGVzW2ldLm5hbWUsIGJvdW5kQXR0cmlidXRlU3VmZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRlbXBsYXRlIGxpdGVyYWwgc2VjdGlvbiBsZWFkaW5nIHVwIHRvIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiBpbiB0aGlzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nRm9yUGFydCA9IHN0cmluZ3NbcGFydEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gbGFzdEF0dHJpYnV0ZU5hbWVSZWdleC5leGVjKHN0cmluZ0ZvclBhcnQpWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBib3VuZCBhdHRyaWJ1dGVzIGhhdmUgaGFkIGEgc3VmZml4IGFkZGVkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZW1wbGF0ZVJlc3VsdCNnZXRIVE1MIHRvIG9wdCBvdXQgb2Ygc3BlY2lhbCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsaW5nLiBUbyBsb29rIHVwIHRoZSBhdHRyaWJ1dGUgdmFsdWUgd2UgYWxzbyBuZWVkIHRvIGFkZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN1ZmZpeC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZUxvb2t1cE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkgKyBib3VuZEF0dHJpYnV0ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTG9va3VwTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVMb29rdXBOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRpY3MgPSBhdHRyaWJ1dGVWYWx1ZS5zcGxpdChtYXJrZXJSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goeyB0eXBlOiAnYXR0cmlidXRlJywgaW5kZXgsIG5hbWUsIHN0cmluZ3M6IHN0YXRpY3MgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXggKz0gc3RhdGljcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdURU1QTEFURScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMgLyogTm9kZS5URVhUX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmluZGV4T2YobWFya2VyKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5ncyA9IGRhdGEuc3BsaXQobWFya2VyUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IHRleHQgbm9kZSBmb3IgZWFjaCBsaXRlcmFsIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2Ugbm9kZXMgYXJlIGFsc28gdXNlZCBhcyB0aGUgbWFya2VycyBmb3Igbm9kZSBwYXJ0c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBzdHJpbmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gY3JlYXRlTWFya2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXguZXhlYyhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgZW5kc1dpdGgobWF0Y2hbMl0sIGJvdW5kQXR0cmlidXRlU3VmZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBtYXRjaFsxXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXS5zbGljZSgwLCAtYm91bmRBdHRyaWJ1dGVTdWZmaXgubGVuZ3RoKSArIG1hdGNoWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoaW5zZXJ0LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaCh7IHR5cGU6ICdub2RlJywgaW5kZXg6ICsraW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyB0ZXh0LCB3ZSBtdXN0IGluc2VydCBhIGNvbW1lbnQgdG8gbWFyayBvdXIgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIHdlIGNhbiB0cnVzdCBpdCB3aWxsIHN0aWNrIGFyb3VuZCBhZnRlciBjbG9uaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nc1tsYXN0SW5kZXhdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjcmVhdGVNYXJrZXIoKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSBzdHJpbmdzW2xhc3RJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHBhcnQgZm9yIGVhY2ggbWF0Y2ggZm91bmRcbiAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4ICs9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIE5vZGUuQ09NTUVOVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gbWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgbmV3IG1hcmtlciBub2RlIHRvIGJlIHRoZSBzdGFydE5vZGUgb2YgdGhlIFBhcnQgaWYgYW55IG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIHRydWU6XG4gICAgICAgICAgICAgICAgICAgIC8vICAqIFdlIGRvbid0IGhhdmUgYSBwcmV2aW91c1NpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gICogVGhlIHByZXZpb3VzU2libGluZyBpcyBhbHJlYWR5IHRoZSBzdGFydCBvZiBhIHByZXZpb3VzIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucHJldmlvdXNTaWJsaW5nID09PSBudWxsIHx8IGluZGV4ID09PSBsYXN0UGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjcmVhdGVNYXJrZXIoKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFBhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goeyB0eXBlOiAnbm9kZScsIGluZGV4IH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbmV4dFNpYmxpbmcsIGtlZXAgdGhpcyBub2RlIHNvIHdlIGhhdmUgYW4gZW5kLlxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlLCB3ZSBjYW4gcmVtb3ZlIGl0IHRvIHNhdmUgZnV0dXJlIGNvc3RzLlxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChpID0gbm9kZS5kYXRhLmluZGV4T2YobWFya2VyLCBpICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWVudCBub2RlIGhhcyBhIGJpbmRpbmcgbWFya2VyIGluc2lkZSwgbWFrZSBhbiBpbmFjdGl2ZSBwYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmluZGluZyB3b24ndCB3b3JrLCBidXQgc3Vic2VxdWVudCBiaW5kaW5ncyB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIChqdXN0aW5mYWduYW5pKTogY29uc2lkZXIgd2hldGhlciBpdCdzIGV2ZW4gd29ydGggaXQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYmluZGluZ3MgaW4gY29tbWVudHMgd29ya1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKHsgdHlwZTogJ25vZGUnLCBpbmRleDogLTEgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGV4dCBiaW5kaW5nIG5vZGVzIGFmdGVyIHRoZSB3YWxrIHRvIG5vdCBkaXN0dXJiIHRoZSBUcmVlV2Fsa2VyXG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBub2Rlc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBlbmRzV2l0aCA9IChzdHIsIHN1ZmZpeCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGg7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgc3RyLnNsaWNlKGluZGV4KSA9PT0gc3VmZml4O1xufTtcbmV4cG9ydCBjb25zdCBpc1RlbXBsYXRlUGFydEFjdGl2ZSA9IChwYXJ0KSA9PiBwYXJ0LmluZGV4ICE9PSAtMTtcbi8vIEFsbG93cyBgZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJylgIHRvIGJlIHJlbmFtZWQgZm9yIGFcbi8vIHNtYWxsIG1hbnVhbCBzaXplLXNhdmluZ3MuXG5leHBvcnQgY29uc3QgY3JlYXRlTWFya2VyID0gKCkgPT4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4vKipcbiAqIFRoaXMgcmVnZXggZXh0cmFjdHMgdGhlIGF0dHJpYnV0ZSBuYW1lIHByZWNlZGluZyBhbiBhdHRyaWJ1dGUtcG9zaXRpb25cbiAqIGV4cHJlc3Npb24uIEl0IGRvZXMgdGhpcyBieSBtYXRjaGluZyB0aGUgc3ludGF4IGFsbG93ZWQgZm9yIGF0dHJpYnV0ZXNcbiAqIGFnYWluc3QgdGhlIHN0cmluZyBsaXRlcmFsIGRpcmVjdGx5IHByZWNlZGluZyB0aGUgZXhwcmVzc2lvbiwgYXNzdW1pbmcgdGhhdFxuICogdGhlIGV4cHJlc3Npb24gaXMgaW4gYW4gYXR0cmlidXRlLXZhbHVlIHBvc2l0aW9uLlxuICpcbiAqIFNlZSBhdHRyaWJ1dGVzIGluIHRoZSBIVE1MIHNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudHMtYXR0cmlidXRlc1xuICpcbiAqIFwiIFxceDA5XFx4MGFcXHgwY1xceDBkXCIgYXJlIEhUTUwgc3BhY2UgY2hhcmFjdGVyczpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3NwYWNlLWNoYXJhY3RlcnNcbiAqXG4gKiBcIlxcMC1cXHgxRlxceDdGLVxceDlGXCIgYXJlIFVuaWNvZGUgY29udHJvbCBjaGFyYWN0ZXJzLCB3aGljaCBpbmNsdWRlcyBldmVyeVxuICogc3BhY2UgY2hhcmFjdGVyIGV4Y2VwdCBcIiBcIi5cbiAqXG4gKiBTbyBhbiBhdHRyaWJ1dGUgaXM6XG4gKiAgKiBUaGUgbmFtZTogYW55IGNoYXJhY3RlciBleGNlcHQgYSBjb250cm9sIGNoYXJhY3Rlciwgc3BhY2UgY2hhcmFjdGVyLCAoJyksXG4gKiAgICAoXCIpLCBcIj5cIiwgXCI9XCIsIG9yIFwiL1wiXG4gKiAgKiBGb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVyc1xuICogICogRm9sbG93ZWQgYnkgXCI9XCJcbiAqICAqIEZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBzcGFjZSBjaGFyYWN0ZXJzXG4gKiAgKiBGb2xsb3dlZCBieTpcbiAqICAgICogQW55IGNoYXJhY3RlciBleGNlcHQgc3BhY2UsICgnKSwgKFwiKSwgXCI8XCIsIFwiPlwiLCBcIj1cIiwgKGApLCBvclxuICogICAgKiAoXCIpIHRoZW4gYW55IG5vbi0oXCIpLCBvclxuICogICAgKiAoJykgdGhlbiBhbnkgbm9uLSgnKVxuICovXG5leHBvcnQgY29uc3QgbGFzdEF0dHJpYnV0ZU5hbWVSZWdleCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbi8oWyBcXHgwOVxceDBhXFx4MGNcXHgwZF0pKFteXFwwLVxceDFGXFx4N0YtXFx4OUYgXCInPj0vXSspKFsgXFx4MDlcXHgwYVxceDBjXFx4MGRdKj1bIFxceDA5XFx4MGFcXHgwY1xceDBkXSooPzpbXiBcXHgwOVxceDBhXFx4MGNcXHgwZFwiJ2A8Pj1dKnxcIlteXCJdKnwnW14nXSopKSQvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBAbW9kdWxlIHNoYWR5LXJlbmRlclxuICovXG5pbXBvcnQgeyBpc1RlbXBsYXRlUGFydEFjdGl2ZSB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuY29uc3Qgd2Fsa2VyTm9kZUZpbHRlciA9IDEzMyAvKiBOb2RlRmlsdGVyLlNIT1dfe0VMRU1FTlR8Q09NTUVOVHxURVhUfSAqLztcbi8qKlxuICogUmVtb3ZlcyB0aGUgbGlzdCBvZiBub2RlcyBmcm9tIGEgVGVtcGxhdGUgc2FmZWx5LiBJbiBhZGRpdGlvbiB0byByZW1vdmluZ1xuICogbm9kZXMgZnJvbSB0aGUgVGVtcGxhdGUsIHRoZSBUZW1wbGF0ZSBwYXJ0IGluZGljZXMgYXJlIHVwZGF0ZWQgdG8gbWF0Y2hcbiAqIHRoZSBtdXRhdGVkIFRlbXBsYXRlIERPTS5cbiAqXG4gKiBBcyB0aGUgdGVtcGxhdGUgaXMgd2Fsa2VkIHRoZSByZW1vdmFsIHN0YXRlIGlzIHRyYWNrZWQgYW5kXG4gKiBwYXJ0IGluZGljZXMgYXJlIGFkanVzdGVkIGFzIG5lZWRlZC5cbiAqXG4gKiBkaXZcbiAqICAgZGl2IzEgKHJlbW92ZSkgPC0tIHN0YXJ0IHJlbW92aW5nIChyZW1vdmluZyBub2RlIGlzIGRpdiMxKVxuICogICAgIGRpdlxuICogICAgICAgZGl2IzIgKHJlbW92ZSkgIDwtLSBjb250aW51ZSByZW1vdmluZyAocmVtb3Zpbmcgbm9kZSBpcyBzdGlsbCBkaXYjMSlcbiAqICAgICAgICAgZGl2XG4gKiBkaXYgPC0tIHN0b3AgcmVtb3Zpbmcgc2luY2UgcHJldmlvdXMgc2libGluZyBpcyB0aGUgcmVtb3Zpbmcgbm9kZSAoZGl2IzEsXG4gKiByZW1vdmVkIDQgbm9kZXMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2Rlc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgbm9kZXNUb1JlbW92ZSkge1xuICAgIGNvbnN0IHsgZWxlbWVudDogeyBjb250ZW50IH0sIHBhcnRzIH0gPSB0ZW1wbGF0ZTtcbiAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGNvbnRlbnQsIHdhbGtlck5vZGVGaWx0ZXIsIG51bGwsIGZhbHNlKTtcbiAgICBsZXQgcGFydEluZGV4ID0gbmV4dEFjdGl2ZUluZGV4SW5UZW1wbGF0ZVBhcnRzKHBhcnRzKTtcbiAgICBsZXQgcGFydCA9IHBhcnRzW3BhcnRJbmRleF07XG4gICAgbGV0IG5vZGVJbmRleCA9IC0xO1xuICAgIGxldCByZW1vdmVDb3VudCA9IDA7XG4gICAgY29uc3Qgbm9kZXNUb1JlbW92ZUluVGVtcGxhdGUgPSBbXTtcbiAgICBsZXQgY3VycmVudFJlbW92aW5nTm9kZSA9IG51bGw7XG4gICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIG5vZGVJbmRleCsrO1xuICAgICAgICBjb25zdCBub2RlID0gd2Fsa2VyLmN1cnJlbnROb2RlO1xuICAgICAgICAvLyBFbmQgcmVtb3ZhbCBpZiBzdGVwcGVkIHBhc3QgdGhlIHJlbW92aW5nIG5vZGVcbiAgICAgICAgaWYgKG5vZGUucHJldmlvdXNTaWJsaW5nID09PSBjdXJyZW50UmVtb3ZpbmdOb2RlKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVtb3ZpbmdOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIG5vZGUgdG8gcmVtb3ZlIHdhcyBmb3VuZCBpbiB0aGUgdGVtcGxhdGVcbiAgICAgICAgaWYgKG5vZGVzVG9SZW1vdmUuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICBub2Rlc1RvUmVtb3ZlSW5UZW1wbGF0ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgLy8gVHJhY2sgbm9kZSB3ZSdyZSByZW1vdmluZ1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRSZW1vdmluZ05vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVtb3ZpbmdOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHJlbW92aW5nLCBpbmNyZW1lbnQgY291bnQgYnkgd2hpY2ggdG8gYWRqdXN0IHN1YnNlcXVlbnQgcGFydCBpbmRpY2VzXG4gICAgICAgIGlmIChjdXJyZW50UmVtb3ZpbmdOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChwYXJ0ICE9PSB1bmRlZmluZWQgJiYgcGFydC5pbmRleCA9PT0gbm9kZUluZGV4KSB7XG4gICAgICAgICAgICAvLyBJZiBwYXJ0IGlzIGluIGEgcmVtb3ZlZCBub2RlIGRlYWN0aXZhdGUgaXQgYnkgc2V0dGluZyBpbmRleCB0byAtMSBvclxuICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSBpbmRleCBhcyBuZWVkZWQuXG4gICAgICAgICAgICBwYXJ0LmluZGV4ID0gY3VycmVudFJlbW92aW5nTm9kZSAhPT0gbnVsbCA/IC0xIDogcGFydC5pbmRleCAtIHJlbW92ZUNvdW50O1xuICAgICAgICAgICAgLy8gZ28gdG8gdGhlIG5leHQgYWN0aXZlIHBhcnQuXG4gICAgICAgICAgICBwYXJ0SW5kZXggPSBuZXh0QWN0aXZlSW5kZXhJblRlbXBsYXRlUGFydHMocGFydHMsIHBhcnRJbmRleCk7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub2Rlc1RvUmVtb3ZlSW5UZW1wbGF0ZS5mb3JFYWNoKChuKSA9PiBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobikpO1xufVxuY29uc3QgY291bnROb2RlcyA9IChub2RlKSA9PiB7XG4gICAgbGV0IGNvdW50ID0gKG5vZGUubm9kZVR5cGUgPT09IDExIC8qIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAqLykgPyAwIDogMTtcbiAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKG5vZGUsIHdhbGtlck5vZGVGaWx0ZXIsIG51bGwsIGZhbHNlKTtcbiAgICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgY291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufTtcbmNvbnN0IG5leHRBY3RpdmVJbmRleEluVGVtcGxhdGVQYXJ0cyA9IChwYXJ0cywgc3RhcnRJbmRleCA9IC0xKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXggKyAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoaXNUZW1wbGF0ZVBhcnRBY3RpdmUocGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEluc2VydHMgdGhlIGdpdmVuIG5vZGUgaW50byB0aGUgVGVtcGxhdGUsIG9wdGlvbmFsbHkgYmVmb3JlIHRoZSBnaXZlblxuICogcmVmTm9kZS4gSW4gYWRkaXRpb24gdG8gaW5zZXJ0aW5nIHRoZSBub2RlIGludG8gdGhlIFRlbXBsYXRlLCB0aGUgVGVtcGxhdGVcbiAqIHBhcnQgaW5kaWNlcyBhcmUgdXBkYXRlZCB0byBtYXRjaCB0aGUgbXV0YXRlZCBUZW1wbGF0ZSBET00uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnROb2RlSW50b1RlbXBsYXRlKHRlbXBsYXRlLCBub2RlLCByZWZOb2RlID0gbnVsbCkge1xuICAgIGNvbnN0IHsgZWxlbWVudDogeyBjb250ZW50IH0sIHBhcnRzIH0gPSB0ZW1wbGF0ZTtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHJlZk5vZGUsIHRoZW4gcHV0IG5vZGUgYXQgZW5kIG9mIHRlbXBsYXRlLlxuICAgIC8vIE5vIHBhcnQgaW5kaWNlcyBuZWVkIHRvIGJlIHNoaWZ0ZWQgaW4gdGhpcyBjYXNlLlxuICAgIGlmIChyZWZOb2RlID09PSBudWxsIHx8IHJlZk5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoY29udGVudCwgd2Fsa2VyTm9kZUZpbHRlciwgbnVsbCwgZmFsc2UpO1xuICAgIGxldCBwYXJ0SW5kZXggPSBuZXh0QWN0aXZlSW5kZXhJblRlbXBsYXRlUGFydHMocGFydHMpO1xuICAgIGxldCBpbnNlcnRDb3VudCA9IDA7XG4gICAgbGV0IHdhbGtlckluZGV4ID0gLTE7XG4gICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIHdhbGtlckluZGV4Kys7XG4gICAgICAgIGNvbnN0IHdhbGtlck5vZGUgPSB3YWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgIGlmICh3YWxrZXJOb2RlID09PSByZWZOb2RlKSB7XG4gICAgICAgICAgICBpbnNlcnRDb3VudCA9IGNvdW50Tm9kZXMobm9kZSk7XG4gICAgICAgICAgICByZWZOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChwYXJ0SW5kZXggIT09IC0xICYmIHBhcnRzW3BhcnRJbmRleF0uaW5kZXggPT09IHdhbGtlckluZGV4KSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBpbnNlcnRlZCB0aGUgbm9kZSwgc2ltcGx5IGFkanVzdCBhbGwgc3Vic2VxdWVudCBwYXJ0c1xuICAgICAgICAgICAgaWYgKGluc2VydENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzW3BhcnRJbmRleF0uaW5kZXggKz0gaW5zZXJ0Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCA9IG5leHRBY3RpdmVJbmRleEluVGVtcGxhdGVQYXJ0cyhwYXJ0cywgcGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydEluZGV4ID0gbmV4dEFjdGl2ZUluZGV4SW5UZW1wbGF0ZVBhcnRzKHBhcnRzLCBwYXJ0SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kaWZ5LXRlbXBsYXRlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmNvbnN0IGRpcmVjdGl2ZXMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBCcmFuZHMgYSBmdW5jdGlvbiBhcyBhIGRpcmVjdGl2ZSBmYWN0b3J5IGZ1bmN0aW9uIHNvIHRoYXQgbGl0LWh0bWwgd2lsbCBjYWxsXG4gKiB0aGUgZnVuY3Rpb24gZHVyaW5nIHRlbXBsYXRlIHJlbmRlcmluZywgcmF0aGVyIHRoYW4gcGFzc2luZyBhcyBhIHZhbHVlLlxuICpcbiAqIEEgX2RpcmVjdGl2ZV8gaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgUGFydCBhcyBhbiBhcmd1bWVudC4gSXQgaGFzIHRoZVxuICogc2lnbmF0dXJlOiBgKHBhcnQ6IFBhcnQpID0+IHZvaWRgLlxuICpcbiAqIEEgZGlyZWN0aXZlIF9mYWN0b3J5XyBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYXJndW1lbnRzIGZvciBkYXRhIGFuZFxuICogY29uZmlndXJhdGlvbiBhbmQgcmV0dXJucyBhIGRpcmVjdGl2ZS4gVXNlcnMgb2YgZGlyZWN0aXZlIHVzdWFsbHkgcmVmZXIgdG9cbiAqIHRoZSBkaXJlY3RpdmUgZmFjdG9yeSBhcyB0aGUgZGlyZWN0aXZlLiBGb3IgZXhhbXBsZSwgXCJUaGUgcmVwZWF0IGRpcmVjdGl2ZVwiLlxuICpcbiAqIFVzdWFsbHkgYSB0ZW1wbGF0ZSBhdXRob3Igd2lsbCBpbnZva2UgYSBkaXJlY3RpdmUgZmFjdG9yeSBpbiB0aGVpciB0ZW1wbGF0ZVxuICogd2l0aCByZWxldmFudCBhcmd1bWVudHMsIHdoaWNoIHdpbGwgdGhlbiByZXR1cm4gYSBkaXJlY3RpdmUgZnVuY3Rpb24uXG4gKlxuICogSGVyZSdzIGFuIGV4YW1wbGUgb2YgdXNpbmcgdGhlIGByZXBlYXQoKWAgZGlyZWN0aXZlIGZhY3RvcnkgdGhhdCB0YWtlcyBhblxuICogYXJyYXkgYW5kIGEgZnVuY3Rpb24gdG8gcmVuZGVyIGFuIGl0ZW06XG4gKlxuICogYGBganNcbiAqIGh0bWxgPHVsPjwke3JlcGVhdChpdGVtcywgKGl0ZW0pID0+IGh0bWxgPGxpPiR7aXRlbX08L2xpPmApfTwvdWw+YFxuICogYGBgXG4gKlxuICogV2hlbiBgcmVwZWF0YCBpcyBpbnZva2VkLCBpdCByZXR1cm5zIGEgZGlyZWN0aXZlIGZ1bmN0aW9uIHRoYXQgY2xvc2VzIG92ZXJcbiAqIGBpdGVtc2AgYW5kIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbi4gV2hlbiB0aGUgb3V0ZXIgdGVtcGxhdGUgaXMgcmVuZGVyZWQsIHRoZVxuICogcmV0dXJuIGRpcmVjdGl2ZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aGUgUGFydCBmb3IgdGhlIGV4cHJlc3Npb24uXG4gKiBgcmVwZWF0YCB0aGVuIHBlcmZvcm1zIGl0J3MgY3VzdG9tIGxvZ2ljIHRvIHJlbmRlciBtdWx0aXBsZSBpdGVtcy5cbiAqXG4gKiBAcGFyYW0gZiBUaGUgZGlyZWN0aXZlIGZhY3RvcnkgZnVuY3Rpb24uIE11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYVxuICogZnVuY3Rpb24gb2YgdGhlIHNpZ25hdHVyZSBgKHBhcnQ6IFBhcnQpID0+IHZvaWRgLiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gd2lsbFxuICogYmUgY2FsbGVkIHdpdGggdGhlIHBhcnQgb2JqZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHtkaXJlY3RpdmUsIGh0bWx9IGZyb20gJ2xpdC1odG1sJztcbiAqXG4gKiBjb25zdCBpbW11dGFibGUgPSBkaXJlY3RpdmUoKHYpID0+IChwYXJ0KSA9PiB7XG4gKiAgIGlmIChwYXJ0LnZhbHVlICE9PSB2KSB7XG4gKiAgICAgcGFydC5zZXRWYWx1ZSh2KVxuICogICB9XG4gKiB9KTtcbiAqL1xuZXhwb3J0IGNvbnN0IGRpcmVjdGl2ZSA9IChmKSA9PiAoKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBkID0gZiguLi5hcmdzKTtcbiAgICBkaXJlY3RpdmVzLnNldChkLCB0cnVlKTtcbiAgICByZXR1cm4gZDtcbn0pO1xuZXhwb3J0IGNvbnN0IGlzRGlyZWN0aXZlID0gKG8pID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdmdW5jdGlvbicgJiYgZGlyZWN0aXZlcy5oYXMobyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxOCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQSBzZW50aW5lbCB2YWx1ZSB0aGF0IHNpZ25hbHMgdGhhdCBhIHZhbHVlIHdhcyBoYW5kbGVkIGJ5IGEgZGlyZWN0aXZlIGFuZFxuICogc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG4gKi9cbmV4cG9ydCBjb25zdCBub0NoYW5nZSA9IHt9O1xuLyoqXG4gKiBBIHNlbnRpbmVsIHZhbHVlIHRoYXQgc2lnbmFscyBhIE5vZGVQYXJ0IHRvIGZ1bGx5IGNsZWFyIGl0cyBjb250ZW50LlxuICovXG5leHBvcnQgY29uc3Qgbm90aGluZyA9IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIEBtb2R1bGUgbGl0LWh0bWxcbiAqL1xuaW1wb3J0IHsgaXNDRVBvbHlmaWxsIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgaXNUZW1wbGF0ZVBhcnRBY3RpdmUgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgYSBgVGVtcGxhdGVgIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBET00gYW5kIHVwZGF0ZWRcbiAqIHdpdGggbmV3IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlSW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBwcm9jZXNzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fX3BhcnRzID0gW107XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHVwZGF0ZSh2YWx1ZXMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fX3BhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFydC5zZXRWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9fcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LmNvbW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jbG9uZSgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGEgbnVtYmVyIG9mIHN0ZXBzIGluIHRoZSBsaWZlY3ljbGUgb2YgYSB0ZW1wbGF0ZSBpbnN0YW5jZSdzXG4gICAgICAgIC8vIERPTSBmcmFnbWVudDpcbiAgICAgICAgLy8gIDEuIENsb25lIC0gY3JlYXRlIHRoZSBpbnN0YW5jZSBmcmFnbWVudFxuICAgICAgICAvLyAgMi4gQWRvcHQgLSBhZG9wdCBpbnRvIHRoZSBtYWluIGRvY3VtZW50XG4gICAgICAgIC8vICAzLiBQcm9jZXNzIC0gZmluZCBwYXJ0IG1hcmtlcnMgYW5kIGNyZWF0ZSBwYXJ0c1xuICAgICAgICAvLyAgNC4gVXBncmFkZSAtIHVwZ3JhZGUgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgIC8vICA1LiBVcGRhdGUgLSBzZXQgbm9kZSwgYXR0cmlidXRlLCBwcm9wZXJ0eSwgZXRjLiwgdmFsdWVzXG4gICAgICAgIC8vICA2LiBDb25uZWN0IC0gY29ubmVjdCB0byB0aGUgZG9jdW1lbnQuIE9wdGlvbmFsIGFuZCBvdXRzaWRlIG9mIHRoaXNcbiAgICAgICAgLy8gICAgIG1ldGhvZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgaGF2ZSBhIGZldyBjb25zdHJhaW50cyBvbiB0aGUgb3JkZXJpbmcgb2YgdGhlc2Ugc3RlcHM6XG4gICAgICAgIC8vICAqIFdlIG5lZWQgdG8gdXBncmFkZSBiZWZvcmUgdXBkYXRpbmcsIHNvIHRoYXQgcHJvcGVydHkgdmFsdWVzIHdpbGwgcGFzc1xuICAgICAgICAvLyAgICB0aHJvdWdoIGFueSBwcm9wZXJ0eSBzZXR0ZXJzLlxuICAgICAgICAvLyAgKiBXZSB3b3VsZCBsaWtlIHRvIHByb2Nlc3MgYmVmb3JlIHVwZ3JhZGluZyBzbyB0aGF0IHdlJ3JlIHN1cmUgdGhhdCB0aGVcbiAgICAgICAgLy8gICAgY2xvbmVkIGZyYWdtZW50IGlzIGluZXJ0IGFuZCBub3QgZGlzdHVyYmVkIGJ5IHNlbGYtbW9kaWZ5aW5nIERPTS5cbiAgICAgICAgLy8gICogV2Ugd2FudCBjdXN0b20gZWxlbWVudHMgdG8gdXBncmFkZSBldmVuIGluIGRpc2Nvbm5lY3RlZCBmcmFnbWVudHMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIHRoZXNlIGNvbnN0cmFpbnRzLCB3aXRoIGZ1bGwgY3VzdG9tIGVsZW1lbnRzIHN1cHBvcnQgd2Ugd291bGRcbiAgICAgICAgLy8gcHJlZmVyIHRoZSBvcmRlcjogQ2xvbmUsIFByb2Nlc3MsIEFkb3B0LCBVcGdyYWRlLCBVcGRhdGUsIENvbm5lY3RcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQnV0IFNhZmFyaSBkb2VzIG5vdCBpbXBsZW1lbnQgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5I3VwZ3JhZGUsIHNvIHdlXG4gICAgICAgIC8vIGNhbiBub3QgaW1wbGVtZW50IHRoYXQgb3JkZXIgYW5kIHN0aWxsIGhhdmUgdXBncmFkZS1iZWZvcmUtdXBkYXRlIGFuZFxuICAgICAgICAvLyB1cGdyYWRlIGRpc2Nvbm5lY3RlZCBmcmFnbWVudHMuIFNvIHdlIGluc3RlYWQgc2FjcmlmaWNlIHRoZVxuICAgICAgICAvLyBwcm9jZXNzLWJlZm9yZS11cGdyYWRlIGNvbnN0cmFpbnQsIHNpbmNlIGluIEN1c3RvbSBFbGVtZW50cyB2MSBlbGVtZW50c1xuICAgICAgICAvLyBtdXN0IG5vdCBtb2RpZnkgdGhlaXIgbGlnaHQgRE9NIGluIHRoZSBjb25zdHJ1Y3Rvci4gV2Ugc3RpbGwgaGF2ZSBpc3N1ZXNcbiAgICAgICAgLy8gd2hlbiBjby1leGlzdGluZyB3aXRoIENFdjAgZWxlbWVudHMgbGlrZSBQb2x5bWVyIDEsIGFuZCB3aXRoIHBvbHlmaWxsc1xuICAgICAgICAvLyB0aGF0IGRvbid0IHN0cmljdGx5IGFkaGVyZSB0byB0aGUgbm8tbW9kaWZpY2F0aW9uIHJ1bGUgYmVjYXVzZSBzaGFkb3dcbiAgICAgICAgLy8gRE9NLCB3aGljaCBtYXkgYmUgY3JlYXRlZCBpbiB0aGUgY29uc3RydWN0b3IsIGlzIGVtdWxhdGVkIGJ5IGJlaW5nIHBsYWNlZFxuICAgICAgICAvLyBpbiB0aGUgbGlnaHQgRE9NLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcmVzdWx0aW5nIG9yZGVyIGlzIG9uIG5hdGl2ZSBpczogQ2xvbmUsIEFkb3B0LCBVcGdyYWRlLCBQcm9jZXNzLFxuICAgICAgICAvLyBVcGRhdGUsIENvbm5lY3QuIGRvY3VtZW50LmltcG9ydE5vZGUoKSBwZXJmb3JtcyBDbG9uZSwgQWRvcHQsIGFuZCBVcGdyYWRlXG4gICAgICAgIC8vIGluIG9uZSBzdGVwLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgQ3VzdG9tIEVsZW1lbnRzIHYxIHBvbHlmaWxsIHN1cHBvcnRzIHVwZ3JhZGUoKSwgc28gdGhlIG9yZGVyIHdoZW5cbiAgICAgICAgLy8gcG9seWZpbGxlZCBpcyB0aGUgbW9yZSBpZGVhbDogQ2xvbmUsIFByb2Nlc3MsIEFkb3B0LCBVcGdyYWRlLCBVcGRhdGUsXG4gICAgICAgIC8vIENvbm5lY3QuXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gaXNDRVBvbHlmaWxsID9cbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuZWxlbWVudC5jb250ZW50LmNsb25lTm9kZSh0cnVlKSA6XG4gICAgICAgICAgICBkb2N1bWVudC5pbXBvcnROb2RlKHRoaXMudGVtcGxhdGUuZWxlbWVudC5jb250ZW50LCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnRlbXBsYXRlLnBhcnRzO1xuICAgICAgICAvLyBFZGdlIG5lZWRzIGFsbCA0IHBhcmFtZXRlcnMgcHJlc2VudDsgSUUxMSBuZWVkcyAzcmQgcGFyYW1ldGVyIHRvIGJlIG51bGxcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihmcmFnbWVudCwgMTMzIC8qIE5vZGVGaWx0ZXIuU0hPV197RUxFTUVOVHxDT01NRU5UfFRFWFR9ICovLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICAgICAgbGV0IHBhcnQ7XG4gICAgICAgIGxldCBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIG5vZGVzIGFuZCBwYXJ0cyBvZiBhIHRlbXBsYXRlXG4gICAgICAgIHdoaWxlIChwYXJ0SW5kZXggPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpc1RlbXBsYXRlUGFydEFjdGl2ZShwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19wYXJ0cy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9ncmVzcyB0aGUgdHJlZSB3YWxrZXIgdW50aWwgd2UgZmluZCBvdXIgbmV4dCBwYXJ0J3Mgbm9kZS5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBtdWx0aXBsZSBwYXJ0cyBtYXkgc2hhcmUgdGhlIHNhbWUgbm9kZSAoYXR0cmlidXRlIHBhcnRzXG4gICAgICAgICAgICAvLyBvbiBhIHNpbmdsZSBlbGVtZW50KSwgc28gdGhpcyBsb29wIG1heSBub3QgcnVuIGF0IGFsbC5cbiAgICAgICAgICAgIHdoaWxlIChub2RlSW5kZXggPCBwYXJ0LmluZGV4KSB7XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdURU1QTEFURScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgZXhoYXVzdGVkIHRoZSBjb250ZW50IGluc2lkZSBhIG5lc3RlZCB0ZW1wbGF0ZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHdlIHN0aWxsIGhhdmUgcGFydHMgKHRoZSBvdXRlciBmb3ItbG9vcCksIHdlIGtub3c6XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gVGhlcmUgaXMgYSB0ZW1wbGF0ZSBpbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGUgd2Fsa2VyIHdpbGwgZmluZCBhIG5leHROb2RlIG91dHNpZGUgdGhlIHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UndmUgYXJyaXZlZCBhdCBvdXIgcGFydCdzIG5vZGUuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gdGhpcy5wcm9jZXNzb3IuaGFuZGxlVGV4dEV4cHJlc3Npb24odGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBwYXJ0Lmluc2VydEFmdGVyTm9kZShub2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3BhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcGFydHMucHVzaCguLi50aGlzLnByb2Nlc3Nvci5oYW5kbGVBdHRyaWJ1dGVFeHByZXNzaW9ucyhub2RlLCBwYXJ0Lm5hbWUsIHBhcnQuc3RyaW5ncywgdGhpcy5vcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDRVBvbHlmaWxsKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZG9wdE5vZGUoZnJhZ21lbnQpO1xuICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMudXBncmFkZShmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLWluc3RhbmNlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICovXG5pbXBvcnQgeyByZXBhcmVudE5vZGVzIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgYm91bmRBdHRyaWJ1dGVTdWZmaXgsIGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXgsIG1hcmtlciwgbm9kZU1hcmtlciB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuY29uc3QgY29tbWVudE1hcmtlciA9IGAgJHttYXJrZXJ9IGA7XG4vKipcbiAqIFRoZSByZXR1cm4gdHlwZSBvZiBgaHRtbGAsIHdoaWNoIGhvbGRzIGEgVGVtcGxhdGUgYW5kIHRoZSB2YWx1ZXMgZnJvbVxuICogaW50ZXJwb2xhdGVkIGV4cHJlc3Npb25zLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcywgdHlwZSwgcHJvY2Vzc29yKSB7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBvZiBIVE1MIHVzZWQgdG8gY3JlYXRlIGEgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0SFRNTCgpIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgaHRtbCA9ICcnO1xuICAgICAgICBsZXQgaXNDb21tZW50QmluZGluZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMuc3RyaW5nc1tpXTtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGJpbmRpbmcgd2Ugd2FudCB0byBkZXRlcm1pbmUgdGhlIGtpbmQgb2YgbWFya2VyIHRvIGluc2VydFxuICAgICAgICAgICAgLy8gaW50byB0aGUgdGVtcGxhdGUgc291cmNlIGJlZm9yZSBpdCdzIHBhcnNlZCBieSB0aGUgYnJvd3NlcidzIEhUTUxcbiAgICAgICAgICAgIC8vIHBhcnNlci4gVGhlIG1hcmtlciB0eXBlIGlzIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGV4cHJlc3Npb24gaXMgaW4gYW5cbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSwgdGV4dCwgb3IgY29tbWVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgIC8vICAgKiBGb3Igbm9kZS1wb3NpdGlvbiBiaW5kaW5ncyB3ZSBpbnNlcnQgYSBjb21tZW50IHdpdGggdGhlIG1hcmtlclxuICAgICAgICAgICAgLy8gICAgIHNlbnRpbmVsIGFzIGl0cyB0ZXh0IGNvbnRlbnQsIGxpa2UgPCEtLXt7bGl0LWd1aWR9fS0tPi5cbiAgICAgICAgICAgIC8vICAgKiBGb3IgYXR0cmlidXRlIGJpbmRpbmdzIHdlIGluc2VydCBqdXN0IHRoZSBtYXJrZXIgc2VudGluZWwgZm9yIHRoZVxuICAgICAgICAgICAgLy8gICAgIGZpcnN0IGJpbmRpbmcsIHNvIHRoYXQgd2Ugc3VwcG9ydCB1bnF1b3RlZCBhdHRyaWJ1dGUgYmluZGluZ3MuXG4gICAgICAgICAgICAvLyAgICAgU3Vic2VxdWVudCBiaW5kaW5ncyBjYW4gdXNlIGEgY29tbWVudCBtYXJrZXIgYmVjYXVzZSBtdWx0aS1iaW5kaW5nXG4gICAgICAgICAgICAvLyAgICAgYXR0cmlidXRlcyBtdXN0IGJlIHF1b3RlZC5cbiAgICAgICAgICAgIC8vICAgKiBGb3IgY29tbWVudCBiaW5kaW5ncyB3ZSBpbnNlcnQganVzdCB0aGUgbWFya2VyIHNlbnRpbmVsIHNvIHdlIGRvbid0XG4gICAgICAgICAgICAvLyAgICAgY2xvc2UgdGhlIGNvbW1lbnQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIHNjYW5zIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGJ1dCBpcyAqbm90KiBhbiBIVE1MXG4gICAgICAgICAgICAvLyBwYXJzZXIuIFdlIGRvbid0IG5lZWQgdG8gdHJhY2sgdGhlIHRyZWUgc3RydWN0dXJlIG9mIHRoZSBIVE1MLCBvbmx5XG4gICAgICAgICAgICAvLyB3aGV0aGVyIGEgYmluZGluZyBpcyBpbnNpZGUgYSBjb21tZW50LCBhbmQgaWYgbm90LCBpZiBpdCBhcHBlYXJzIHRvIGJlXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgYmluZGluZyBpbiBhbiBhdHRyaWJ1dGUuXG4gICAgICAgICAgICBjb25zdCBjb21tZW50T3BlbiA9IHMubGFzdEluZGV4T2YoJzwhLS0nKTtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGluIGNvbW1lbnQgcG9zaXRpb24gaWYgd2UgaGF2ZSBhIGNvbW1lbnQgb3BlbiB3aXRoIG5vIGZvbGxvd2luZ1xuICAgICAgICAgICAgLy8gY29tbWVudCBjbG9zZS4gQmVjYXVzZSA8LS0gY2FuIGFwcGVhciBpbiBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhlcmUgY2FuXG4gICAgICAgICAgICAvLyBiZSBmYWxzZSBwb3NpdGl2ZXMuXG4gICAgICAgICAgICBpc0NvbW1lbnRCaW5kaW5nID0gKGNvbW1lbnRPcGVuID4gLTEgfHwgaXNDb21tZW50QmluZGluZykgJiZcbiAgICAgICAgICAgICAgICBzLmluZGV4T2YoJy0tPicsIGNvbW1lbnRPcGVuICsgMSkgPT09IC0xO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYW4gYXR0cmlidXRlLWxpa2Ugc2VxdWVuY2UgcHJlY2VkaW5nIHRoZVxuICAgICAgICAgICAgLy8gZXhwcmVzc2lvbi4gVGhpcyBjYW4gbWF0Y2ggXCJuYW1lPXZhbHVlXCIgbGlrZSBzdHJ1Y3R1cmVzIGluIHRleHQsXG4gICAgICAgICAgICAvLyBjb21tZW50cywgYW5kIGF0dHJpYnV0ZSB2YWx1ZXMsIHNvIHRoZXJlIGNhbiBiZSBmYWxzZS1wb3NpdGl2ZXMuXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVNYXRjaCA9IGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXguZXhlYyhzKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIG9ubHkgaW4gdGhpcyBicmFuY2ggaWYgd2UgZG9uJ3QgaGF2ZSBhIGF0dHJpYnV0ZS1saWtlXG4gICAgICAgICAgICAgICAgLy8gcHJlY2VkaW5nIHNlcXVlbmNlLiBGb3IgY29tbWVudHMsIHRoaXMgZ3VhcmRzIGFnYWluc3QgdW51c3VhbFxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSB2YWx1ZXMgbGlrZSA8ZGl2IGZvbz1cIjwhLS0keydiYXInfVwiPi4gQ2FzZXMgbGlrZVxuICAgICAgICAgICAgICAgIC8vIDwhLS0gZm9vPSR7J2Jhcid9LS0+IGFyZSBoYW5kbGVkIGNvcnJlY3RseSBpbiB0aGUgYXR0cmlidXRlIGJyYW5jaFxuICAgICAgICAgICAgICAgIC8vIGJlbG93LlxuICAgICAgICAgICAgICAgIGh0bWwgKz0gcyArIChpc0NvbW1lbnRCaW5kaW5nID8gY29tbWVudE1hcmtlciA6IG5vZGVNYXJrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGF0dHJpYnV0ZXMgd2UgdXNlIGp1c3QgYSBtYXJrZXIgc2VudGluZWwsIGFuZCBhbHNvIGFwcGVuZCBhXG4gICAgICAgICAgICAgICAgLy8gJGxpdCQgc3VmZml4IHRvIHRoZSBuYW1lIHRvIG9wdC1vdXQgb2YgYXR0cmlidXRlLXNwZWNpZmljIHBhcnNpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGF0IElFIGFuZCBFZGdlIGRvIGZvciBzdHlsZSBhbmQgY2VydGFpbiBTVkcgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAgICBodG1sICs9IHMuc3Vic3RyKDAsIGF0dHJpYnV0ZU1hdGNoLmluZGV4KSArIGF0dHJpYnV0ZU1hdGNoWzFdICtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTWF0Y2hbMl0gKyBib3VuZEF0dHJpYnV0ZVN1ZmZpeCArIGF0dHJpYnV0ZU1hdGNoWzNdICtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gdGhpcy5zdHJpbmdzW2xdO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgZ2V0VGVtcGxhdGVFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRoaXMuZ2V0SFRNTCgpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxufVxuLyoqXG4gKiBBIFRlbXBsYXRlUmVzdWx0IGZvciBTVkcgZnJhZ21lbnRzLlxuICpcbiAqIFRoaXMgY2xhc3Mgd3JhcHMgSFRNTCBpbiBhbiBgPHN2Zz5gIHRhZyBpbiBvcmRlciB0byBwYXJzZSBpdHMgY29udGVudHMgaW4gdGhlXG4gKiBTVkcgbmFtZXNwYWNlLCB0aGVuIG1vZGlmaWVzIHRoZSB0ZW1wbGF0ZSB0byByZW1vdmUgdGhlIGA8c3ZnPmAgdGFnIHNvIHRoYXRcbiAqIGNsb25lcyBvbmx5IGNvbnRhaW5lciB0aGUgb3JpZ2luYWwgZnJhZ21lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTVkdUZW1wbGF0ZVJlc3VsdCBleHRlbmRzIFRlbXBsYXRlUmVzdWx0IHtcbiAgICBnZXRIVE1MKCkge1xuICAgICAgICByZXR1cm4gYDxzdmc+JHtzdXBlci5nZXRIVE1MKCl9PC9zdmc+YDtcbiAgICB9XG4gICAgZ2V0VGVtcGxhdGVFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHN1cGVyLmdldFRlbXBsYXRlRWxlbWVudCgpO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGVtcGxhdGUuY29udGVudDtcbiAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgY29udGVudC5yZW1vdmVDaGlsZChzdmdFbGVtZW50KTtcbiAgICAgICAgcmVwYXJlbnROb2Rlcyhjb250ZW50LCBzdmdFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUtcmVzdWx0LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICovXG5pbXBvcnQgeyBpc0RpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7IHJlbW92ZU5vZGVzIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgbm9DaGFuZ2UsIG5vdGhpbmcgfSBmcm9tICcuL3BhcnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZSB9IGZyb20gJy4vdGVtcGxhdGUtaW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICcuL3RlbXBsYXRlLXJlc3VsdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVNYXJrZXIgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbmV4cG9ydCBjb25zdCBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAodmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgISh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykpO1xufTtcbmV4cG9ydCBjb25zdCBpc0l0ZXJhYmxlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICEhKHZhbHVlICYmIHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0pO1xufTtcbi8qKlxuICogV3JpdGVzIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gdGhlIERPTSBmb3IgYSBncm91cCBvZiBBdHRyaWJ1dGVQYXJ0cyBib3VuZCB0byBhXG4gKiBzaW5nbGUgYXR0cmlidXRlLiBUaGUgdmFsdWUgaXMgb25seSBzZXQgb25jZSBldmVuIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXJ0c1xuICogZm9yIGFuIGF0dHJpYnV0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZUNvbW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmFtZSwgc3RyaW5ncykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRzW2ldID0gdGhpcy5fY3JlYXRlUGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaW5nbGUgcGFydC4gT3ZlcnJpZGUgdGhpcyB0byBjcmVhdGUgYSBkaWZmZXJudCB0eXBlIG9mIHBhcnQuXG4gICAgICovXG4gICAgX2NyZWF0ZVBhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlUGFydCh0aGlzKTtcbiAgICB9XG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgICBjb25zdCBzdHJpbmdzID0gdGhpcy5zdHJpbmdzO1xuICAgICAgICBjb25zdCBsID0gc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGV4dCArPSBzdHJpbmdzW2ldO1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHRoaXMucGFydHNbaV07XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHBhcnQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHYpIHx8ICFpc0l0ZXJhYmxlKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdiA6IFN0cmluZyh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHR5cGVvZiB0ID09PSAnc3RyaW5nJyA/IHQgOiBTdHJpbmcodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCArPSBzdHJpbmdzW2xdO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm5hbWUsIHRoaXMuX2dldFZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIFBhcnQgdGhhdCBjb250cm9scyBhbGwgb3IgcGFydCBvZiBhbiBhdHRyaWJ1dGUgdmFsdWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb21taXR0ZXIpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb21taXR0ZXIgPSBjb21taXR0ZXI7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbm9DaGFuZ2UgJiYgKCFpc1ByaW1pdGl2ZSh2YWx1ZSkgfHwgdmFsdWUgIT09IHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBub3QgYSBkaXJlY3RpdmUsIGRpcnR5IHRoZSBjb21taXR0ZXIgc28gdGhhdCBpdCdsbFxuICAgICAgICAgICAgLy8gY2FsbCBzZXRBdHRyaWJ1dGUuIElmIHRoZSB2YWx1ZSBpcyBhIGRpcmVjdGl2ZSwgaXQnbGwgZGlydHkgdGhlXG4gICAgICAgICAgICAvLyBjb21taXR0ZXIgaWYgaXQgY2FsbHMgc2V0VmFsdWUoKS5cbiAgICAgICAgICAgIGlmICghaXNEaXJlY3RpdmUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXR0ZXIuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgd2hpbGUgKGlzRGlyZWN0aXZlKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5vQ2hhbmdlO1xuICAgICAgICAgICAgZGlyZWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBub0NoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWl0dGVyLmNvbW1pdCgpO1xuICAgIH1cbn1cbi8qKlxuICogQSBQYXJ0IHRoYXQgY29udHJvbHMgYSBsb2NhdGlvbiB3aXRoaW4gYSBOb2RlIHRyZWUuIExpa2UgYSBSYW5nZSwgTm9kZVBhcnRcbiAqIGhhcyBzdGFydCBhbmQgZW5kIGxvY2F0aW9ucyBhbmQgY2FuIHNldCBhbmQgdXBkYXRlIHRoZSBOb2RlcyBiZXR3ZWVuIHRob3NlXG4gKiBsb2NhdGlvbnMuXG4gKlxuICogTm9kZVBhcnRzIHN1cHBvcnQgc2V2ZXJhbCB2YWx1ZSB0eXBlczogcHJpbWl0aXZlcywgTm9kZXMsIFRlbXBsYXRlUmVzdWx0cyxcbiAqIGFzIHdlbGwgYXMgYXJyYXlzIGFuZCBpdGVyYWJsZXMgb2YgdGhvc2UgdHlwZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlUGFydCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoaXMgcGFydCBpbnRvIGEgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogVGhpcyBwYXJ0IG11c3QgYmUgZW1wdHksIGFzIGl0cyBjb250ZW50cyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgbW92ZWQuXG4gICAgICovXG4gICAgYXBwZW5kSW50byhjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5zdGFydE5vZGUgPSBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlTWFya2VyKCkpO1xuICAgICAgICB0aGlzLmVuZE5vZGUgPSBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlTWFya2VyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoaXMgcGFydCBhZnRlciB0aGUgYHJlZmAgbm9kZSAoYmV0d2VlbiBgcmVmYCBhbmQgYHJlZmAncyBuZXh0XG4gICAgICogc2libGluZykuIEJvdGggYHJlZmAgYW5kIGl0cyBuZXh0IHNpYmxpbmcgbXVzdCBiZSBzdGF0aWMsIHVuY2hhbmdpbmcgbm9kZXNcbiAgICAgKiBzdWNoIGFzIHRob3NlIHRoYXQgYXBwZWFyIGluIGEgbGl0ZXJhbCBzZWN0aW9uIG9mIGEgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhcnQgbXVzdCBiZSBlbXB0eSwgYXMgaXRzIGNvbnRlbnRzIGFyZSBub3QgYXV0b21hdGljYWxseSBtb3ZlZC5cbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlck5vZGUocmVmKSB7XG4gICAgICAgIHRoaXMuc3RhcnROb2RlID0gcmVmO1xuICAgICAgICB0aGlzLmVuZE5vZGUgPSByZWYubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhpcyBwYXJ0IGludG8gYSBwYXJlbnQgcGFydC5cbiAgICAgKlxuICAgICAqIFRoaXMgcGFydCBtdXN0IGJlIGVtcHR5LCBhcyBpdHMgY29udGVudHMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IG1vdmVkLlxuICAgICAqL1xuICAgIGFwcGVuZEludG9QYXJ0KHBhcnQpIHtcbiAgICAgICAgcGFydC5fX2luc2VydCh0aGlzLnN0YXJ0Tm9kZSA9IGNyZWF0ZU1hcmtlcigpKTtcbiAgICAgICAgcGFydC5fX2luc2VydCh0aGlzLmVuZE5vZGUgPSBjcmVhdGVNYXJrZXIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhpcyBwYXJ0IGFmdGVyIHRoZSBgcmVmYCBwYXJ0LlxuICAgICAqXG4gICAgICogVGhpcyBwYXJ0IG11c3QgYmUgZW1wdHksIGFzIGl0cyBjb250ZW50cyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgbW92ZWQuXG4gICAgICovXG4gICAgaW5zZXJ0QWZ0ZXJQYXJ0KHJlZikge1xuICAgICAgICByZWYuX19pbnNlcnQodGhpcy5zdGFydE5vZGUgPSBjcmVhdGVNYXJrZXIoKSk7XG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IHJlZi5lbmROb2RlO1xuICAgICAgICByZWYuZW5kTm9kZSA9IHRoaXMuc3RhcnROb2RlO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnROb2RlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXNEaXJlY3RpdmUodGhpcy5fX3BlbmRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gbm9DaGFuZ2U7XG4gICAgICAgICAgICBkaXJlY3RpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT09IG5vQ2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbW1pdFRleHQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXRUZW1wbGF0ZVJlc3VsdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9fY29tbWl0Tm9kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG5vdGhpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBub3RoaW5nO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2ssIHdpbGwgcmVuZGVyIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIHRoaXMuX19jb21taXRUZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfX2luc2VydChub2RlKSB7XG4gICAgICAgIHRoaXMuZW5kTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0aGlzLmVuZE5vZGUpO1xuICAgIH1cbiAgICBfX2NvbW1pdE5vZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9faW5zZXJ0KHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBfX2NvbW1pdFRleHQodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICAvLyBJZiBgdmFsdWVgIGlzbid0IGFscmVhZHkgYSBzdHJpbmcsIHdlIGV4cGxpY2l0bHkgY29udmVydCBpdCBoZXJlIGluIGNhc2VcbiAgICAgICAgLy8gaXQgY2FuJ3QgYmUgaW1wbGljaXRseSBjb252ZXJ0ZWQgLSBpLmUuIGl0J3MgYSBzeW1ib2wuXG4gICAgICAgIGNvbnN0IHZhbHVlQXNTdHJpbmcgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBTdHJpbmcodmFsdWUpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5lbmROb2RlLnByZXZpb3VzU2libGluZyAmJlxuICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBOb2RlLlRFWFRfTk9ERSAqLykge1xuICAgICAgICAgICAgLy8gSWYgd2Ugb25seSBoYXZlIGEgc2luZ2xlIHRleHQgbm9kZSBiZXR3ZWVuIHRoZSBtYXJrZXJzLCB3ZSBjYW4ganVzdFxuICAgICAgICAgICAgLy8gc2V0IGl0cyB2YWx1ZSwgcmF0aGVyIHRoYW4gcmVwbGFjaW5nIGl0LlxuICAgICAgICAgICAgLy8gVE9ETyhqdXN0aW5mYWduYW5pKTogQ2FuIHdlIGp1c3QgY2hlY2sgaWYgdGhpcy52YWx1ZSBpcyBwcmltaXRpdmU/XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2YWx1ZUFzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdE5vZGUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWVBc1N0cmluZykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgX19jb21taXRUZW1wbGF0ZVJlc3VsdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZUZhY3RvcnkodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlSW5zdGFuY2UgJiZcbiAgICAgICAgICAgIHRoaXMudmFsdWUudGVtcGxhdGUgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnVwZGF0ZSh2YWx1ZS52YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHByb3BhZ2F0ZSB0aGUgdGVtcGxhdGUgcHJvY2Vzc29yIGZyb20gdGhlIFRlbXBsYXRlUmVzdWx0XG4gICAgICAgICAgICAvLyBzbyB0aGF0IHdlIHVzZSBpdHMgc3ludGF4IGV4dGVuc2lvbiwgZXRjLiBUaGUgdGVtcGxhdGUgZmFjdG9yeSBjb21lc1xuICAgICAgICAgICAgLy8gZnJvbSB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9wdGlvbnMgc28gdGhhdCBpdCBjYW4gY29udHJvbCB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gY2FjaGluZyBhbmQgcHJlcHJvY2Vzc2luZy5cbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFRlbXBsYXRlSW5zdGFuY2UodGVtcGxhdGUsIHZhbHVlLnByb2Nlc3NvciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gaW5zdGFuY2UuX2Nsb25lKCk7XG4gICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUodmFsdWUudmFsdWVzKTtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXROb2RlKGZyYWdtZW50KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfX2NvbW1pdEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICAgIC8vIEZvciBhbiBJdGVyYWJsZSwgd2UgY3JlYXRlIGEgbmV3IEluc3RhbmNlUGFydCBwZXIgaXRlbSwgdGhlbiBzZXQgaXRzXG4gICAgICAgIC8vIHZhbHVlIHRvIHRoZSBpdGVtLiBUaGlzIGlzIGEgbGl0dGxlIGJpdCBvZiBvdmVyaGVhZCBmb3IgZXZlcnkgaXRlbSBpblxuICAgICAgICAvLyBhbiBJdGVyYWJsZSwgYnV0IGl0IGxldHMgdXMgcmVjdXJzZSBlYXNpbHkgYW5kIGVmZmljaWVudGx5IHVwZGF0ZSBBcnJheXNcbiAgICAgICAgLy8gb2YgVGVtcGxhdGVSZXN1bHRzIHRoYXQgd2lsbCBiZSBjb21tb25seSByZXR1cm5lZCBmcm9tIGV4cHJlc3Npb25zIGxpa2U6XG4gICAgICAgIC8vIGFycmF5Lm1hcCgoaSkgPT4gaHRtbGAke2l9YCksIGJ5IHJldXNpbmcgZXhpc3RpbmcgVGVtcGxhdGVJbnN0YW5jZXMuXG4gICAgICAgIC8vIElmIF92YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiB0aGUgcHJldmlvdXMgcmVuZGVyIHdhcyBvZiBhblxuICAgICAgICAvLyBpdGVyYWJsZSBhbmQgX3ZhbHVlIHdpbGwgY29udGFpbiB0aGUgTm9kZVBhcnRzIGZyb20gdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIHJlbmRlci4gSWYgX3ZhbHVlIGlzIG5vdCBhbiBhcnJheSwgY2xlYXIgdGhpcyBwYXJ0IGFuZCBtYWtlIGEgbmV3XG4gICAgICAgIC8vIGFycmF5IGZvciBOb2RlUGFydHMuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExldHMgdXMga2VlcCB0cmFjayBvZiBob3cgbWFueSBpdGVtcyB3ZSBzdGFtcGVkIHNvIHdlIGNhbiBjbGVhciBsZWZ0b3ZlclxuICAgICAgICAvLyBpdGVtcyBmcm9tIGEgcHJldmlvdXMgcmVuZGVyXG4gICAgICAgIGNvbnN0IGl0ZW1QYXJ0cyA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICBsZXQgaXRlbVBhcnQ7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHJldXNlIGFuIGV4aXN0aW5nIHBhcnRcbiAgICAgICAgICAgIGl0ZW1QYXJ0ID0gaXRlbVBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAvLyBJZiBubyBleGlzdGluZyBwYXJ0LCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgICAgICBpZiAoaXRlbVBhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW1QYXJ0ID0gbmV3IE5vZGVQYXJ0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaXRlbVBhcnRzLnB1c2goaXRlbVBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVBhcnQuYXBwZW5kSW50b1BhcnQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtUGFydC5pbnNlcnRBZnRlclBhcnQoaXRlbVBhcnRzW3BhcnRJbmRleCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtUGFydC5zZXRWYWx1ZShpdGVtKTtcbiAgICAgICAgICAgIGl0ZW1QYXJ0LmNvbW1pdCgpO1xuICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRJbmRleCA8IGl0ZW1QYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRydW5jYXRlIHRoZSBwYXJ0cyBhcnJheSBzbyBfdmFsdWUgcmVmbGVjdHMgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICAgIGl0ZW1QYXJ0cy5sZW5ndGggPSBwYXJ0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKGl0ZW1QYXJ0ICYmIGl0ZW1QYXJ0LmVuZE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKHN0YXJ0Tm9kZSA9IHRoaXMuc3RhcnROb2RlKSB7XG4gICAgICAgIHJlbW92ZU5vZGVzKHRoaXMuc3RhcnROb2RlLnBhcmVudE5vZGUsIHN0YXJ0Tm9kZS5uZXh0U2libGluZywgdGhpcy5lbmROb2RlKTtcbiAgICB9XG59XG4vKipcbiAqIEltcGxlbWVudHMgYSBib29sZWFuIGF0dHJpYnV0ZSwgcm91Z2hseSBhcyBkZWZpbmVkIGluIHRoZSBIVE1MXG4gKiBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyB0cnV0aHksIHRoZW4gdGhlIGF0dHJpYnV0ZSBpcyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvZlxuICogJycuIElmIHRoZSB2YWx1ZSBpcyBmYWxzZXksIHRoZSBhdHRyaWJ1dGUgaXMgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5BdHRyaWJ1dGVQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzdHJpbmdzLmxlbmd0aCAhPT0gMiB8fCBzdHJpbmdzWzBdICE9PSAnJyB8fCBzdHJpbmdzWzFdICE9PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb29sZWFuIGF0dHJpYnV0ZXMgY2FuIG9ubHkgY29udGFpbiBhIHNpbmdsZSBleHByZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIHdoaWxlIChpc0RpcmVjdGl2ZSh0aGlzLl9fcGVuZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX3BlbmRpbmdWYWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9ICEhdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICB9XG59XG4vKipcbiAqIFNldHMgYXR0cmlidXRlIHZhbHVlcyBmb3IgUHJvcGVydHlQYXJ0cywgc28gdGhhdCB0aGUgdmFsdWUgaXMgb25seSBzZXQgb25jZVxuICogZXZlbiBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgcGFydHMgZm9yIGEgcHJvcGVydHkuXG4gKlxuICogSWYgYW4gZXhwcmVzc2lvbiBjb250cm9scyB0aGUgd2hvbGUgcHJvcGVydHkgdmFsdWUsIHRoZW4gdGhlIHZhbHVlIGlzIHNpbXBseVxuICogYXNzaWduZWQgdG8gdGhlIHByb3BlcnR5IHVuZGVyIGNvbnRyb2wuIElmIHRoZXJlIGFyZSBzdHJpbmcgbGl0ZXJhbHMgb3JcbiAqIG11bHRpcGxlIGV4cHJlc3Npb25zLCB0aGVuIHRoZSBzdHJpbmdzIGFyZSBleHByZXNzaW9ucyBhcmUgaW50ZXJwb2xhdGVkIGludG9cbiAqIGEgc3RyaW5nIGZpcnN0LlxuICovXG5leHBvcnQgY2xhc3MgUHJvcGVydHlDb21taXR0ZXIgZXh0ZW5kcyBBdHRyaWJ1dGVDb21taXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudCwgbmFtZSwgc3RyaW5ncyk7XG4gICAgICAgIHRoaXMuc2luZ2xlID1cbiAgICAgICAgICAgIChzdHJpbmdzLmxlbmd0aCA9PT0gMiAmJiBzdHJpbmdzWzBdID09PSAnJyAmJiBzdHJpbmdzWzFdID09PSAnJyk7XG4gICAgfVxuICAgIF9jcmVhdGVQYXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UGFydCh0aGlzKTtcbiAgICB9XG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5zaW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnRzWzBdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFt0aGlzLm5hbWVdID0gdGhpcy5fZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eVBhcnQgZXh0ZW5kcyBBdHRyaWJ1dGVQYXJ0IHtcbn1cbi8vIERldGVjdCBldmVudCBsaXN0ZW5lciBvcHRpb25zIHN1cHBvcnQuIElmIHRoZSBgY2FwdHVyZWAgcHJvcGVydHkgaXMgcmVhZFxuLy8gZnJvbSB0aGUgb3B0aW9ucyBvYmplY3QsIHRoZW4gb3B0aW9ucyBhcmUgc3VwcG9ydGVkLiBJZiBub3QsIHRoZW4gdGhlIHRoaXJkXG4vLyBhcmd1bWVudCB0byBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lciBpcyBpbnRlcnByZXRlZCBhcyB0aGUgYm9vbGVhbiBjYXB0dXJlXG4vLyB2YWx1ZSBzbyB3ZSBzaG91bGQgb25seSBwYXNzIHRoZSBgY2FwdHVyZWAgcHJvcGVydHkuXG5sZXQgZXZlbnRPcHRpb25zU3VwcG9ydGVkID0gZmFsc2U7XG4vLyBXcmFwIGludG8gYW4gSUlGRSBiZWNhdXNlIE1TIEVkZ2UgPD0gdjQxIGRvZXMgbm90IHN1cHBvcnQgaGF2aW5nIHRyeS9jYXRjaFxuLy8gYmxvY2tzIHJpZ2h0IGludG8gdGhlIGJvZHkgb2YgYSBtb2R1bGVcbigoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGdldCBjYXB0dXJlKCkge1xuICAgICAgICAgICAgICAgIGV2ZW50T3B0aW9uc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgLy8gZXZlbnQgb3B0aW9ucyBub3Qgc3VwcG9ydGVkXG4gICAgfVxufSkoKTtcbmV4cG9ydCBjbGFzcyBFdmVudFBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGV2ZW50TmFtZSwgZXZlbnRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLmV2ZW50Q29udGV4dCA9IGV2ZW50Q29udGV4dDtcbiAgICAgICAgdGhpcy5fX2JvdW5kSGFuZGxlRXZlbnQgPSAoZSkgPT4gdGhpcy5oYW5kbGVFdmVudChlKTtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIHdoaWxlIChpc0RpcmVjdGl2ZSh0aGlzLl9fcGVuZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX3BlbmRpbmdWYWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMaXN0ZW5lciA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgIGNvbnN0IG9sZExpc3RlbmVyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlTGlzdGVuZXIgPSBuZXdMaXN0ZW5lciA9PSBudWxsIHx8XG4gICAgICAgICAgICBvbGRMaXN0ZW5lciAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgKG5ld0xpc3RlbmVyLmNhcHR1cmUgIT09IG9sZExpc3RlbmVyLmNhcHR1cmUgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV3TGlzdGVuZXIub25jZSAhPT0gb2xkTGlzdGVuZXIub25jZSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXdMaXN0ZW5lci5wYXNzaXZlICE9PSBvbGRMaXN0ZW5lci5wYXNzaXZlKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkQWRkTGlzdGVuZXIgPSBuZXdMaXN0ZW5lciAhPSBudWxsICYmIChvbGRMaXN0ZW5lciA9PSBudWxsIHx8IHNob3VsZFJlbW92ZUxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHNob3VsZFJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy5fX2JvdW5kSGFuZGxlRXZlbnQsIHRoaXMuX19vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX19vcHRpb25zID0gZ2V0T3B0aW9ucyhuZXdMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy5fX2JvdW5kSGFuZGxlRXZlbnQsIHRoaXMuX19vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gbmV3TGlzdGVuZXI7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmNhbGwodGhpcy5ldmVudENvbnRleHQgfHwgdGhpcy5lbGVtZW50LCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFdlIGNvcHkgb3B0aW9ucyBiZWNhdXNlIG9mIHRoZSBpbmNvbnNpc3RlbnQgYmVoYXZpb3Igb2YgYnJvd3NlcnMgd2hlbiByZWFkaW5nXG4vLyB0aGUgdGhpcmQgYXJndW1lbnQgb2YgYWRkL3JlbW92ZUV2ZW50TGlzdGVuZXIuIElFMTEgZG9lc24ndCBzdXBwb3J0IG9wdGlvbnNcbi8vIGF0IGFsbC4gQ2hyb21lIDQxIG9ubHkgcmVhZHMgYGNhcHR1cmVgIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBvYmplY3QuXG5jb25zdCBnZXRPcHRpb25zID0gKG8pID0+IG8gJiZcbiAgICAoZXZlbnRPcHRpb25zU3VwcG9ydGVkID9cbiAgICAgICAgeyBjYXB0dXJlOiBvLmNhcHR1cmUsIHBhc3NpdmU6IG8ucGFzc2l2ZSwgb25jZTogby5vbmNlIH0gOlxuICAgICAgICBvLmNhcHR1cmUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydHMuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuaW1wb3J0IHsgbWFya2VyLCBUZW1wbGF0ZSB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBUZW1wbGF0ZUZhY3Rvcnkgd2hpY2ggY2FjaGVzIFRlbXBsYXRlcyBrZXllZCBvblxuICogcmVzdWx0LnR5cGUgYW5kIHJlc3VsdC5zdHJpbmdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVGYWN0b3J5KHJlc3VsdCkge1xuICAgIGxldCB0ZW1wbGF0ZUNhY2hlID0gdGVtcGxhdGVDYWNoZXMuZ2V0KHJlc3VsdC50eXBlKTtcbiAgICBpZiAodGVtcGxhdGVDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRlbXBsYXRlQ2FjaGUgPSB7XG4gICAgICAgICAgICBzdHJpbmdzQXJyYXk6IG5ldyBXZWFrTWFwKCksXG4gICAgICAgICAgICBrZXlTdHJpbmc6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICB0ZW1wbGF0ZUNhY2hlcy5zZXQocmVzdWx0LnR5cGUsIHRlbXBsYXRlQ2FjaGUpO1xuICAgIH1cbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNhY2hlLnN0cmluZ3NBcnJheS5nZXQocmVzdWx0LnN0cmluZ3MpO1xuICAgIGlmICh0ZW1wbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIFRlbXBsYXRlU3RyaW5nc0FycmF5IGlzIG5ldywgZ2VuZXJhdGUgYSBrZXkgZnJvbSB0aGUgc3RyaW5nc1xuICAgIC8vIFRoaXMga2V5IGlzIHNoYXJlZCBiZXR3ZWVuIGFsbCB0ZW1wbGF0ZXMgd2l0aCBpZGVudGljYWwgY29udGVudFxuICAgIGNvbnN0IGtleSA9IHJlc3VsdC5zdHJpbmdzLmpvaW4obWFya2VyKTtcbiAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBUZW1wbGF0ZSBmb3IgdGhpcyBrZXlcbiAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ2FjaGUua2V5U3RyaW5nLmdldChrZXkpO1xuICAgIGlmICh0ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbm90IHNlZW4gdGhpcyBrZXkgYmVmb3JlLCBjcmVhdGUgYSBuZXcgVGVtcGxhdGVcbiAgICAgICAgdGVtcGxhdGUgPSBuZXcgVGVtcGxhdGUocmVzdWx0LCByZXN1bHQuZ2V0VGVtcGxhdGVFbGVtZW50KCkpO1xuICAgICAgICAvLyBDYWNoZSB0aGUgVGVtcGxhdGUgZm9yIHRoaXMga2V5XG4gICAgICAgIHRlbXBsYXRlQ2FjaGUua2V5U3RyaW5nLnNldChrZXksIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgLy8gQ2FjaGUgYWxsIGZ1dHVyZSBxdWVyaWVzIGZvciB0aGlzIFRlbXBsYXRlU3RyaW5nc0FycmF5XG4gICAgdGVtcGxhdGVDYWNoZS5zdHJpbmdzQXJyYXkuc2V0KHJlc3VsdC5zdHJpbmdzLCB0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufVxuZXhwb3J0IGNvbnN0IHRlbXBsYXRlQ2FjaGVzID0gbmV3IE1hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUtZmFjdG9yeS5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIEBtb2R1bGUgbGl0LWh0bWxcbiAqL1xuaW1wb3J0IHsgcmVtb3ZlTm9kZXMgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBOb2RlUGFydCB9IGZyb20gJy4vcGFydHMuanMnO1xuaW1wb3J0IHsgdGVtcGxhdGVGYWN0b3J5IH0gZnJvbSAnLi90ZW1wbGF0ZS1mYWN0b3J5LmpzJztcbmV4cG9ydCBjb25zdCBwYXJ0cyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFJlbmRlcnMgYSB0ZW1wbGF0ZSByZXN1bHQgb3Igb3RoZXIgdmFsdWUgdG8gYSBjb250YWluZXIuXG4gKlxuICogVG8gdXBkYXRlIGEgY29udGFpbmVyIHdpdGggbmV3IHZhbHVlcywgcmVldmFsdWF0ZSB0aGUgdGVtcGxhdGUgbGl0ZXJhbCBhbmRcbiAqIGNhbGwgYHJlbmRlcmAgd2l0aCB0aGUgbmV3IHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gcmVzdWx0IEFueSB2YWx1ZSByZW5kZXJhYmxlIGJ5IE5vZGVQYXJ0IC0gdHlwaWNhbGx5IGEgVGVtcGxhdGVSZXN1bHRcbiAqICAgICBjcmVhdGVkIGJ5IGV2YWx1YXRpbmcgYSB0ZW1wbGF0ZSB0YWcgbGlrZSBgaHRtbGAgb3IgYHN2Z2AuXG4gKiBAcGFyYW0gY29udGFpbmVyIEEgRE9NIHBhcmVudCB0byByZW5kZXIgdG8uIFRoZSBlbnRpcmUgY29udGVudHMgYXJlIGVpdGhlclxuICogICAgIHJlcGxhY2VkLCBvciBlZmZpY2llbnRseSB1cGRhdGVkIGlmIHRoZSBzYW1lIHJlc3VsdCB0eXBlIHdhcyBwcmV2aW91c1xuICogICAgIHJlbmRlcmVkIHRoZXJlLlxuICogQHBhcmFtIG9wdGlvbnMgUmVuZGVyT3B0aW9ucyBmb3IgdGhlIGVudGlyZSByZW5kZXIgdHJlZSByZW5kZXJlZCB0byB0aGlzXG4gKiAgICAgY29udGFpbmVyLiBSZW5kZXIgb3B0aW9ucyBtdXN0ICpub3QqIGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMgdG8gdGhlIHNhbWVcbiAqICAgICBjb250YWluZXIsIGFzIHRob3NlIGNoYW5nZXMgd2lsbCBub3QgZWZmZWN0IHByZXZpb3VzbHkgcmVuZGVyZWQgRE9NLlxuICovXG5leHBvcnQgY29uc3QgcmVuZGVyID0gKHJlc3VsdCwgY29udGFpbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgbGV0IHBhcnQgPSBwYXJ0cy5nZXQoY29udGFpbmVyKTtcbiAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbW92ZU5vZGVzKGNvbnRhaW5lciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICBwYXJ0cy5zZXQoY29udGFpbmVyLCBwYXJ0ID0gbmV3IE5vZGVQYXJ0KE9iamVjdC5hc3NpZ24oeyB0ZW1wbGF0ZUZhY3RvcnkgfSwgb3B0aW9ucykpKTtcbiAgICAgICAgcGFydC5hcHBlbmRJbnRvKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHBhcnQuc2V0VmFsdWUocmVzdWx0KTtcbiAgICBwYXJ0LmNvbW1pdCgpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5pbXBvcnQgeyBBdHRyaWJ1dGVDb21taXR0ZXIsIEJvb2xlYW5BdHRyaWJ1dGVQYXJ0LCBFdmVudFBhcnQsIE5vZGVQYXJ0LCBQcm9wZXJ0eUNvbW1pdHRlciB9IGZyb20gJy4vcGFydHMuanMnO1xuLyoqXG4gKiBDcmVhdGVzIFBhcnRzIHdoZW4gYSB0ZW1wbGF0ZSBpcyBpbnN0YW50aWF0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwYXJ0cyBmb3IgYW4gYXR0cmlidXRlLXBvc2l0aW9uIGJpbmRpbmcsIGdpdmVuIHRoZSBldmVudCwgYXR0cmlidXRlXG4gICAgICogbmFtZSwgYW5kIHN0cmluZyBsaXRlcmFscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGJpbmRpbmdcbiAgICAgKiBAcGFyYW0gbmFtZSAgVGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHBhcmFtIHN0cmluZ3MgVGhlIHN0cmluZyBsaXRlcmFscy4gVGhlcmUgYXJlIGFsd2F5cyBhdCBsZWFzdCB0d28gc3RyaW5ncyxcbiAgICAgKiAgIGV2ZW50IGZvciBmdWxseS1jb250cm9sbGVkIGJpbmRpbmdzIHdpdGggYSBzaW5nbGUgZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICBoYW5kbGVBdHRyaWJ1dGVFeHByZXNzaW9ucyhlbGVtZW50LCBuYW1lLCBzdHJpbmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWVbMF07XG4gICAgICAgIGlmIChwcmVmaXggPT09ICcuJykge1xuICAgICAgICAgICAgY29uc3QgY29tbWl0dGVyID0gbmV3IFByb3BlcnR5Q29tbWl0dGVyKGVsZW1lbnQsIG5hbWUuc2xpY2UoMSksIHN0cmluZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1pdHRlci5wYXJ0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZml4ID09PSAnQCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IEV2ZW50UGFydChlbGVtZW50LCBuYW1lLnNsaWNlKDEpLCBvcHRpb25zLmV2ZW50Q29udGV4dCldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmaXggPT09ICc/Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgQm9vbGVhbkF0dHJpYnV0ZVBhcnQoZWxlbWVudCwgbmFtZS5zbGljZSgxKSwgc3RyaW5ncyldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbW1pdHRlciA9IG5ldyBBdHRyaWJ1dGVDb21taXR0ZXIoZWxlbWVudCwgbmFtZSwgc3RyaW5ncyk7XG4gICAgICAgIHJldHVybiBjb21taXR0ZXIucGFydHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwYXJ0cyBmb3IgYSB0ZXh0LXBvc2l0aW9uIGJpbmRpbmcuXG4gICAgICogQHBhcmFtIHRlbXBsYXRlRmFjdG9yeVxuICAgICAqL1xuICAgIGhhbmRsZVRleHRFeHByZXNzaW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUGFydChvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yID0gbmV3IERlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvcigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC10ZW1wbGF0ZS1wcm9jZXNzb3IuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKlxuICogTWFpbiBsaXQtaHRtbCBtb2R1bGUuXG4gKlxuICogTWFpbiBleHBvcnRzOlxuICpcbiAqIC0gIFtbaHRtbF1dXG4gKiAtICBbW3N2Z11dXG4gKiAtICBbW3JlbmRlcl1dXG4gKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICogQHByZWZlcnJlZFxuICovXG4vKipcbiAqIERvIG5vdCByZW1vdmUgdGhpcyBjb21tZW50OyBpdCBrZWVwcyB0eXBlZG9jIGZyb20gbWlzcGxhY2luZyB0aGUgbW9kdWxlXG4gKiBkb2NzLlxuICovXG5pbXBvcnQgeyBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IgfSBmcm9tICcuL2xpYi9kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcyc7XG5pbXBvcnQgeyBTVkdUZW1wbGF0ZVJlc3VsdCwgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICcuL2xpYi90ZW1wbGF0ZS1yZXN1bHQuanMnO1xuZXhwb3J0IHsgRGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yLCBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IgfSBmcm9tICcuL2xpYi9kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcyc7XG5leHBvcnQgeyBkaXJlY3RpdmUsIGlzRGlyZWN0aXZlIH0gZnJvbSAnLi9saWIvZGlyZWN0aXZlLmpzJztcbi8vIFRPRE8oanVzdGluZmFnbmFuaSk6IHJlbW92ZSBsaW5lIHdoZW4gd2UgZ2V0IE5vZGVQYXJ0IG1vdmluZyBtZXRob2RzXG5leHBvcnQgeyByZW1vdmVOb2RlcywgcmVwYXJlbnROb2RlcyB9IGZyb20gJy4vbGliL2RvbS5qcyc7XG5leHBvcnQgeyBub0NoYW5nZSwgbm90aGluZyB9IGZyb20gJy4vbGliL3BhcnQuanMnO1xuZXhwb3J0IHsgQXR0cmlidXRlQ29tbWl0dGVyLCBBdHRyaWJ1dGVQYXJ0LCBCb29sZWFuQXR0cmlidXRlUGFydCwgRXZlbnRQYXJ0LCBpc0l0ZXJhYmxlLCBpc1ByaW1pdGl2ZSwgTm9kZVBhcnQsIFByb3BlcnR5Q29tbWl0dGVyLCBQcm9wZXJ0eVBhcnQgfSBmcm9tICcuL2xpYi9wYXJ0cy5qcyc7XG5leHBvcnQgeyBwYXJ0cywgcmVuZGVyIH0gZnJvbSAnLi9saWIvcmVuZGVyLmpzJztcbmV4cG9ydCB7IHRlbXBsYXRlQ2FjaGVzLCB0ZW1wbGF0ZUZhY3RvcnkgfSBmcm9tICcuL2xpYi90ZW1wbGF0ZS1mYWN0b3J5LmpzJztcbmV4cG9ydCB7IFRlbXBsYXRlSW5zdGFuY2UgfSBmcm9tICcuL2xpYi90ZW1wbGF0ZS1pbnN0YW5jZS5qcyc7XG5leHBvcnQgeyBTVkdUZW1wbGF0ZVJlc3VsdCwgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICcuL2xpYi90ZW1wbGF0ZS1yZXN1bHQuanMnO1xuZXhwb3J0IHsgY3JlYXRlTWFya2VyLCBpc1RlbXBsYXRlUGFydEFjdGl2ZSwgVGVtcGxhdGUgfSBmcm9tICcuL2xpYi90ZW1wbGF0ZS5qcyc7XG4vLyBJTVBPUlRBTlQ6IGRvIG5vdCBjaGFuZ2UgdGhlIHByb3BlcnR5IG5hbWUgb3IgdGhlIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cbi8vIFRoaXMgbGluZSB3aWxsIGJlIHVzZWQgaW4gcmVnZXhlcyB0byBzZWFyY2ggZm9yIGxpdC1odG1sIHVzYWdlLlxuLy8gVE9ETyhqdXN0aW5mYWduYW5pKTogaW5qZWN0IHZlcnNpb24gbnVtYmVyIGF0IGJ1aWxkIHRpbWVcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICh3aW5kb3dbJ2xpdEh0bWxWZXJzaW9ucyddIHx8ICh3aW5kb3dbJ2xpdEh0bWxWZXJzaW9ucyddID0gW10pKS5wdXNoKCcxLjIuMScpO1xufVxuLyoqXG4gKiBJbnRlcnByZXRzIGEgdGVtcGxhdGUgbGl0ZXJhbCBhcyBhbiBIVE1MIHRlbXBsYXRlIHRoYXQgY2FuIGVmZmljaWVudGx5XG4gKiByZW5kZXIgdG8gYW5kIHVwZGF0ZSBhIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGNvbnN0IGh0bWwgPSAoc3RyaW5ncywgLi4udmFsdWVzKSA9PiBuZXcgVGVtcGxhdGVSZXN1bHQoc3RyaW5ncywgdmFsdWVzLCAnaHRtbCcsIGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3Nvcik7XG4vKipcbiAqIEludGVycHJldHMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGFuIFNWRyB0ZW1wbGF0ZSB0aGF0IGNhbiBlZmZpY2llbnRseVxuICogcmVuZGVyIHRvIGFuZCB1cGRhdGUgYSBjb250YWluZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBzdmcgPSAoc3RyaW5ncywgLi4udmFsdWVzKSA9PiBuZXcgU1ZHVGVtcGxhdGVSZXN1bHQoc3RyaW5ncywgdmFsdWVzLCAnc3ZnJywgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdC1odG1sLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogTW9kdWxlIHRvIGFkZCBzaGFkeSBET00vc2hhZHkgQ1NTIHBvbHlmaWxsIHN1cHBvcnQgdG8gbGl0LWh0bWwgdGVtcGxhdGVcbiAqIHJlbmRlcmluZy4gU2VlIHRoZSBbW3JlbmRlcl1dIG1ldGhvZCBmb3IgZGV0YWlscy5cbiAqXG4gKiBAbW9kdWxlIHNoYWR5LXJlbmRlclxuICogQHByZWZlcnJlZFxuICovXG4vKipcbiAqIERvIG5vdCByZW1vdmUgdGhpcyBjb21tZW50OyBpdCBrZWVwcyB0eXBlZG9jIGZyb20gbWlzcGxhY2luZyB0aGUgbW9kdWxlXG4gKiBkb2NzLlxuICovXG5pbXBvcnQgeyByZW1vdmVOb2RlcyB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IGluc2VydE5vZGVJbnRvVGVtcGxhdGUsIHJlbW92ZU5vZGVzRnJvbVRlbXBsYXRlIH0gZnJvbSAnLi9tb2RpZnktdGVtcGxhdGUuanMnO1xuaW1wb3J0IHsgcGFydHMsIHJlbmRlciBhcyBsaXRSZW5kZXIgfSBmcm9tICcuL3JlbmRlci5qcyc7XG5pbXBvcnQgeyB0ZW1wbGF0ZUNhY2hlcyB9IGZyb20gJy4vdGVtcGxhdGUtZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlIH0gZnJvbSAnLi90ZW1wbGF0ZS1pbnN0YW5jZS5qcyc7XG5pbXBvcnQgeyBtYXJrZXIsIFRlbXBsYXRlIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG5leHBvcnQgeyBodG1sLCBzdmcsIFRlbXBsYXRlUmVzdWx0IH0gZnJvbSAnLi4vbGl0LWh0bWwuanMnO1xuLy8gR2V0IGEga2V5IHRvIGxvb2t1cCBpbiBgdGVtcGxhdGVDYWNoZXNgLlxuY29uc3QgZ2V0VGVtcGxhdGVDYWNoZUtleSA9ICh0eXBlLCBzY29wZU5hbWUpID0+IGAke3R5cGV9LS0ke3Njb3BlTmFtZX1gO1xubGV0IGNvbXBhdGlibGVTaGFkeUNTU1ZlcnNpb24gPSB0cnVlO1xuaWYgKHR5cGVvZiB3aW5kb3cuU2hhZHlDU1MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29tcGF0aWJsZVNoYWR5Q1NTVmVyc2lvbiA9IGZhbHNlO1xufVxuZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVEb20gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKGBJbmNvbXBhdGlibGUgU2hhZHlDU1MgdmVyc2lvbiBkZXRlY3RlZC4gYCArXG4gICAgICAgIGBQbGVhc2UgdXBkYXRlIHRvIGF0IGxlYXN0IEB3ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqc0AyLjAuMiBhbmQgYCArXG4gICAgICAgIGBAd2ViY29tcG9uZW50cy9zaGFkeWNzc0AxLjMuMS5gKTtcbiAgICBjb21wYXRpYmxlU2hhZHlDU1NWZXJzaW9uID0gZmFsc2U7XG59XG4vKipcbiAqIFRlbXBsYXRlIGZhY3Rvcnkgd2hpY2ggc2NvcGVzIHRlbXBsYXRlIERPTSB1c2luZyBTaGFkeUNTUy5cbiAqIEBwYXJhbSBzY29wZU5hbWUge3N0cmluZ31cbiAqL1xuY29uc3Qgc2hhZHlUZW1wbGF0ZUZhY3RvcnkgPSAoc2NvcGVOYW1lKSA9PiAocmVzdWx0KSA9PiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRUZW1wbGF0ZUNhY2hlS2V5KHJlc3VsdC50eXBlLCBzY29wZU5hbWUpO1xuICAgIGxldCB0ZW1wbGF0ZUNhY2hlID0gdGVtcGxhdGVDYWNoZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAodGVtcGxhdGVDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRlbXBsYXRlQ2FjaGUgPSB7XG4gICAgICAgICAgICBzdHJpbmdzQXJyYXk6IG5ldyBXZWFrTWFwKCksXG4gICAgICAgICAgICBrZXlTdHJpbmc6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICB0ZW1wbGF0ZUNhY2hlcy5zZXQoY2FjaGVLZXksIHRlbXBsYXRlQ2FjaGUpO1xuICAgIH1cbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNhY2hlLnN0cmluZ3NBcnJheS5nZXQocmVzdWx0LnN0cmluZ3MpO1xuICAgIGlmICh0ZW1wbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gcmVzdWx0LnN0cmluZ3Muam9pbihtYXJrZXIpO1xuICAgIHRlbXBsYXRlID0gdGVtcGxhdGVDYWNoZS5rZXlTdHJpbmcuZ2V0KGtleSk7XG4gICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlc3VsdC5nZXRUZW1wbGF0ZUVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGNvbXBhdGlibGVTaGFkeUNTU1ZlcnNpb24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVEb20oZWxlbWVudCwgc2NvcGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZSA9IG5ldyBUZW1wbGF0ZShyZXN1bHQsIGVsZW1lbnQpO1xuICAgICAgICB0ZW1wbGF0ZUNhY2hlLmtleVN0cmluZy5zZXQoa2V5LCB0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIHRlbXBsYXRlQ2FjaGUuc3RyaW5nc0FycmF5LnNldChyZXN1bHQuc3RyaW5ncywgdGVtcGxhdGUpO1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbn07XG5jb25zdCBURU1QTEFURV9UWVBFUyA9IFsnaHRtbCcsICdzdmcnXTtcbi8qKlxuICogUmVtb3ZlcyBhbGwgc3R5bGUgZWxlbWVudHMgZnJvbSBUZW1wbGF0ZXMgZm9yIHRoZSBnaXZlbiBzY29wZU5hbWUuXG4gKi9cbmNvbnN0IHJlbW92ZVN0eWxlc0Zyb21MaXRUZW1wbGF0ZXMgPSAoc2NvcGVOYW1lKSA9PiB7XG4gICAgVEVNUExBVEVfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZXMgPSB0ZW1wbGF0ZUNhY2hlcy5nZXQoZ2V0VGVtcGxhdGVDYWNoZUtleSh0eXBlLCBzY29wZU5hbWUpKTtcbiAgICAgICAgaWYgKHRlbXBsYXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXMua2V5U3RyaW5nLmZvckVhY2goKHRlbXBsYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbGVtZW50OiB7IGNvbnRlbnQgfSB9ID0gdGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgLy8gSUUgMTEgZG9lc24ndCBzdXBwb3J0IHRoZSBpdGVyYWJsZSBwYXJhbSBTZXQgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbShjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJykpLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLmFkZChzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2Rlc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgc3R5bGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3Qgc2hhZHlSZW5kZXJTZXQgPSBuZXcgU2V0KCk7XG4vKipcbiAqIEZvciB0aGUgZ2l2ZW4gc2NvcGUgbmFtZSwgZW5zdXJlcyB0aGF0IFNoYWR5Q1NTIHN0eWxlIHNjb3BpbmcgaXMgcGVyZm9ybWVkLlxuICogVGhpcyBpcyBkb25lIGp1c3Qgb25jZSBwZXIgc2NvcGUgbmFtZSBzbyB0aGUgZnJhZ21lbnQgYW5kIHRlbXBsYXRlIGNhbm5vdFxuICogYmUgbW9kaWZpZWQuXG4gKiAoMSkgZXh0cmFjdHMgc3R5bGVzIGZyb20gdGhlIHJlbmRlcmVkIGZyYWdtZW50IGFuZCBoYW5kcyB0aGVtIHRvIFNoYWR5Q1NTXG4gKiB0byBiZSBzY29wZWQgYW5kIGFwcGVuZGVkIHRvIHRoZSBkb2N1bWVudFxuICogKDIpIHJlbW92ZXMgc3R5bGUgZWxlbWVudHMgZnJvbSBhbGwgbGl0LWh0bWwgVGVtcGxhdGVzIGZvciB0aGlzIHNjb3BlIG5hbWUuXG4gKlxuICogTm90ZSwgPHN0eWxlPiBlbGVtZW50cyBjYW4gb25seSBiZSBwbGFjZWQgaW50byB0ZW1wbGF0ZXMgZm9yIHRoZVxuICogaW5pdGlhbCByZW5kZXJpbmcgb2YgdGhlIHNjb3BlLiBJZiA8c3R5bGU+IGVsZW1lbnRzIGFyZSBpbmNsdWRlZCBpbiB0ZW1wbGF0ZXNcbiAqIGR5bmFtaWNhbGx5IHJlbmRlcmVkIHRvIHRoZSBzY29wZSAoYWZ0ZXIgdGhlIGZpcnN0IHNjb3BlIHJlbmRlciksIHRoZXkgd2lsbFxuICogbm90IGJlIHNjb3BlZCBhbmQgdGhlIDxzdHlsZT4gd2lsbCBiZSBsZWZ0IGluIHRoZSB0ZW1wbGF0ZSBhbmQgcmVuZGVyZWRcbiAqIG91dHB1dC5cbiAqL1xuY29uc3QgcHJlcGFyZVRlbXBsYXRlU3R5bGVzID0gKHNjb3BlTmFtZSwgcmVuZGVyZWRET00sIHRlbXBsYXRlKSA9PiB7XG4gICAgc2hhZHlSZW5kZXJTZXQuYWRkKHNjb3BlTmFtZSk7XG4gICAgLy8gSWYgYHJlbmRlcmVkRE9NYCBpcyBzdGFtcGVkIGZyb20gYSBUZW1wbGF0ZSwgdGhlbiB3ZSBuZWVkIHRvIGVkaXQgdGhhdFxuICAgIC8vIFRlbXBsYXRlJ3MgdW5kZXJseWluZyB0ZW1wbGF0ZSBlbGVtZW50LiBPdGhlcndpc2UsIHdlIGNyZWF0ZSBvbmUgaGVyZVxuICAgIC8vIHRvIGdpdmUgdG8gU2hhZHlDU1MsIHdoaWNoIHN0aWxsIHJlcXVpcmVzIG9uZSB3aGlsZSBzY29waW5nLlxuICAgIGNvbnN0IHRlbXBsYXRlRWxlbWVudCA9ICEhdGVtcGxhdGUgPyB0ZW1wbGF0ZS5lbGVtZW50IDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAvLyBNb3ZlIHN0eWxlcyBvdXQgb2YgcmVuZGVyZWQgRE9NIGFuZCBzdG9yZS5cbiAgICBjb25zdCBzdHlsZXMgPSByZW5kZXJlZERPTS5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZScpO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdHlsZXM7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHN0eWxlcywgc2tpcCB1bm5lY2Vzc2FyeSB3b3JrXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBFbnN1cmUgcHJlcGFyZVRlbXBsYXRlU3R5bGVzIGlzIGNhbGxlZCB0byBzdXBwb3J0IGFkZGluZ1xuICAgICAgICAvLyBzdHlsZXMgdmlhIGBwcmVwYXJlQWRvcHRlZENzc1RleHRgIHNpbmNlIHRoYXQgcmVxdWlyZXMgdGhhdFxuICAgICAgICAvLyBgcHJlcGFyZVRlbXBsYXRlU3R5bGVzYCBpcyBjYWxsZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNoYWR5Q1NTIHdpbGwgb25seSB1cGRhdGUgc3R5bGVzIGNvbnRhaW5pbmcgQGFwcGx5IGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAvLyBnaXZlbiB0byBgcHJlcGFyZVRlbXBsYXRlU3R5bGVzYC4gSWYgbm8gbGl0IFRlbXBsYXRlIHdhcyBnaXZlbixcbiAgICAgICAgLy8gU2hhZHlDU1Mgd2lsbCBub3QgYmUgYWJsZSB0byB1cGRhdGUgdXNlcyBvZiBAYXBwbHkgaW4gYW55IHJlbGV2YW50XG4gICAgICAgIC8vIHRlbXBsYXRlLiBIb3dldmVyLCB0aGlzIGlzIG5vdCBhIHByb2JsZW0gYmVjYXVzZSB3ZSBvbmx5IGNyZWF0ZSB0aGVcbiAgICAgICAgLy8gdGVtcGxhdGUgZm9yIHRoZSBwdXJwb3NlIG9mIHN1cHBvcnRpbmcgYHByZXBhcmVBZG9wdGVkQ3NzVGV4dGAsXG4gICAgICAgIC8vIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBAYXBwbHkgYXQgYWxsLlxuICAgICAgICB3aW5kb3cuU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlU3R5bGVzKHRlbXBsYXRlRWxlbWVudCwgc2NvcGVOYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25kZW5zZWRTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgLy8gQ29sbGVjdCBzdHlsZXMgaW50byBhIHNpbmdsZSBzdHlsZS4gVGhpcyBoZWxwcyB1cyBtYWtlIHN1cmUgU2hhZHlDU1NcbiAgICAvLyBtYW5pcHVsYXRpb25zIHdpbGwgbm90IHByZXZlbnQgdXMgZnJvbSBiZWluZyBhYmxlIHRvIGZpeCB1cCB0ZW1wbGF0ZVxuICAgIC8vIHBhcnQgaW5kaWNlcy5cbiAgICAvLyBOT1RFOiBjb2xsZWN0aW5nIHN0eWxlcyBpcyBpbmVmZmljaWVudCBmb3IgYnJvd3NlcnMgYnV0IFNoYWR5Q1NTXG4gICAgLy8gY3VycmVudGx5IGRvZXMgdGhpcyBhbnl3YXkuIFdoZW4gaXQgZG9lcyBub3QsIHRoaXMgc2hvdWxkIGJlIGNoYW5nZWQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgICAgICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICAgIGNvbmRlbnNlZFN0eWxlLnRleHRDb250ZW50ICs9IHN0eWxlLnRleHRDb250ZW50O1xuICAgIH1cbiAgICAvLyBSZW1vdmUgc3R5bGVzIGZyb20gbmVzdGVkIHRlbXBsYXRlcyBpbiB0aGlzIHNjb3BlLlxuICAgIHJlbW92ZVN0eWxlc0Zyb21MaXRUZW1wbGF0ZXMoc2NvcGVOYW1lKTtcbiAgICAvLyBBbmQgdGhlbiBwdXQgdGhlIGNvbmRlbnNlZCBzdHlsZSBpbnRvIHRoZSBcInJvb3RcIiB0ZW1wbGF0ZSBwYXNzZWQgaW4gYXNcbiAgICAvLyBgdGVtcGxhdGVgLlxuICAgIGNvbnN0IGNvbnRlbnQgPSB0ZW1wbGF0ZUVsZW1lbnQuY29udGVudDtcbiAgICBpZiAoISF0ZW1wbGF0ZSkge1xuICAgICAgICBpbnNlcnROb2RlSW50b1RlbXBsYXRlKHRlbXBsYXRlLCBjb25kZW5zZWRTdHlsZSwgY29udGVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRlbnQuaW5zZXJ0QmVmb3JlKGNvbmRlbnNlZFN0eWxlLCBjb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvLyBOb3RlLCBpdCdzIGltcG9ydGFudCB0aGF0IFNoYWR5Q1NTIGdldHMgdGhlIHRlbXBsYXRlIHRoYXQgYGxpdC1odG1sYFxuICAgIC8vIHdpbGwgYWN0dWFsbHkgcmVuZGVyIHNvIHRoYXQgaXQgY2FuIHVwZGF0ZSB0aGUgc3R5bGUgaW5zaWRlIHdoZW5cbiAgICAvLyBuZWVkZWQgKGUuZy4gQGFwcGx5IG5hdGl2ZSBTaGFkb3cgRE9NIGNhc2UpLlxuICAgIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVTdHlsZXModGVtcGxhdGVFbGVtZW50LCBzY29wZU5hbWUpO1xuICAgIGNvbnN0IHN0eWxlID0gY29udGVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpO1xuICAgIGlmICh3aW5kb3cuU2hhZHlDU1MubmF0aXZlU2hhZG93ICYmIHN0eWxlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdoZW4gaW4gbmF0aXZlIFNoYWRvdyBET00sIGVuc3VyZSB0aGUgc3R5bGUgY3JlYXRlZCBieSBTaGFkeUNTUyBpc1xuICAgICAgICAvLyBpbmNsdWRlZCBpbiBpbml0aWFsbHkgcmVuZGVyZWQgb3V0cHV0IChgcmVuZGVyZWRET01gKS5cbiAgICAgICAgcmVuZGVyZWRET00uaW5zZXJ0QmVmb3JlKHN0eWxlLmNsb25lTm9kZSh0cnVlKSwgcmVuZGVyZWRET00uZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEhdGVtcGxhdGUpIHtcbiAgICAgICAgLy8gV2hlbiBubyBzdHlsZSBpcyBsZWZ0IGluIHRoZSB0ZW1wbGF0ZSwgcGFydHMgd2lsbCBiZSBicm9rZW4gYXMgYVxuICAgICAgICAvLyByZXN1bHQuIFRvIGZpeCB0aGlzLCB3ZSBwdXQgYmFjayB0aGUgc3R5bGUgbm9kZSBTaGFkeUNTUyByZW1vdmVkXG4gICAgICAgIC8vIGFuZCB0aGVuIHRlbGwgbGl0IHRvIHJlbW92ZSB0aGF0IG5vZGUgZnJvbSB0aGUgdGVtcGxhdGUuXG4gICAgICAgIC8vIFRoZXJlIGNhbiBiZSBubyBzdHlsZSBpbiB0aGUgdGVtcGxhdGUgaW4gMiBjYXNlcyAoMSkgd2hlbiBTaGFkeSBET01cbiAgICAgICAgLy8gaXMgaW4gdXNlLCBTaGFkeUNTUyByZW1vdmVzIGFsbCBzdHlsZXMsICgyKSB3aGVuIG5hdGl2ZSBTaGFkb3cgRE9NXG4gICAgICAgIC8vIGlzIGluIHVzZSBTaGFkeUNTUyByZW1vdmVzIHRoZSBzdHlsZSBpZiBpdCBjb250YWlucyBubyBjb250ZW50LlxuICAgICAgICAvLyBOT1RFLCBTaGFkeUNTUyBjcmVhdGVzIGl0cyBvd24gc3R5bGUgc28gd2UgY2FuIHNhZmVseSBhZGQvcmVtb3ZlXG4gICAgICAgIC8vIGBjb25kZW5zZWRTdHlsZWAgaGVyZS5cbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUoY29uZGVuc2VkU3R5bGUsIGNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIGNvbnN0IHJlbW92ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHJlbW92ZXMuYWRkKGNvbmRlbnNlZFN0eWxlKTtcbiAgICAgICAgcmVtb3ZlTm9kZXNGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHJlbW92ZXMpO1xuICAgIH1cbn07XG4vKipcbiAqIEV4dGVuc2lvbiB0byB0aGUgc3RhbmRhcmQgYHJlbmRlcmAgbWV0aG9kIHdoaWNoIHN1cHBvcnRzIHJlbmRlcmluZ1xuICogdG8gU2hhZG93Um9vdHMgd2hlbiB0aGUgU2hhZHlET00gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5ZG9tKVxuICogYW5kIFNoYWR5Q1NTIChodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9zaGFkeWNzcykgcG9seWZpbGxzIGFyZSB1c2VkXG4gKiBvciB3aGVuIHRoZSB3ZWJjb21wb25lbnRzanNcbiAqIChodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMpIHBvbHlmaWxsIGlzIHVzZWQuXG4gKlxuICogQWRkcyBhIGBzY29wZU5hbWVgIG9wdGlvbiB3aGljaCBpcyB1c2VkIHRvIHNjb3BlIGVsZW1lbnQgRE9NIGFuZCBzdHlsZXNoZWV0c1xuICogd2hlbiBuYXRpdmUgU2hhZG93RE9NIGlzIHVuYXZhaWxhYmxlLiBUaGUgYHNjb3BlTmFtZWAgd2lsbCBiZSBhZGRlZCB0b1xuICogdGhlIGNsYXNzIGF0dHJpYnV0ZSBvZiBhbGwgcmVuZGVyZWQgRE9NLiBJbiBhZGRpdGlvbiwgYW55IHN0eWxlIGVsZW1lbnRzIHdpbGxcbiAqIGJlIGF1dG9tYXRpY2FsbHkgcmUtd3JpdHRlbiB3aXRoIHRoaXMgYHNjb3BlTmFtZWAgc2VsZWN0b3IgYW5kIG1vdmVkIG91dFxuICogb2YgdGhlIHJlbmRlcmVkIERPTSBhbmQgaW50byB0aGUgZG9jdW1lbnQgYDxoZWFkPmAuXG4gKlxuICogSXQgaXMgY29tbW9uIHRvIHVzZSB0aGlzIHJlbmRlciBtZXRob2QgaW4gY29uanVuY3Rpb24gd2l0aCBhIGN1c3RvbSBlbGVtZW50XG4gKiB3aGljaCByZW5kZXJzIGEgc2hhZG93Um9vdC4gV2hlbiB0aGlzIGlzIGRvbmUsIHR5cGljYWxseSB0aGUgZWxlbWVudCdzXG4gKiBgbG9jYWxOYW1lYCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgYHNjb3BlTmFtZWAuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gRE9NIHNjb3BpbmcsIFNoYWR5Q1NTIGFsc28gc3VwcG9ydHMgYSBiYXNpYyBzaGltIGZvciBjc3NcbiAqIGN1c3RvbSBwcm9wZXJ0aWVzIChuZWVkZWQgb25seSBvbiBvbGRlciBicm93c2VycyBsaWtlIElFMTEpIGFuZCBhIHNoaW0gZm9yXG4gKiBhIGRlcHJlY2F0ZWQgZmVhdHVyZSBjYWxsZWQgYEBhcHBseWAgdGhhdCBzdXBwb3J0cyBhcHBseWluZyBhIHNldCBvZiBjc3NcbiAqIGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGEgZ2l2ZW4gbG9jYXRpb24uXG4gKlxuICogVXNhZ2UgY29uc2lkZXJhdGlvbnM6XG4gKlxuICogKiBQYXJ0IHZhbHVlcyBpbiBgPHN0eWxlPmAgZWxlbWVudHMgYXJlIG9ubHkgYXBwbGllZCB0aGUgZmlyc3QgdGltZSBhIGdpdmVuXG4gKiBgc2NvcGVOYW1lYCByZW5kZXJzLiBTdWJzZXF1ZW50IGNoYW5nZXMgdG8gcGFydHMgaW4gc3R5bGUgZWxlbWVudHMgd2lsbCBoYXZlXG4gKiBubyBlZmZlY3QuIEJlY2F1c2Ugb2YgdGhpcywgcGFydHMgaW4gc3R5bGUgZWxlbWVudHMgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3JcbiAqIHZhbHVlcyB0aGF0IHdpbGwgbmV2ZXIgY2hhbmdlLCBmb3IgZXhhbXBsZSBwYXJ0cyB0aGF0IHNldCBzY29wZS13aWRlIHRoZW1lXG4gKiB2YWx1ZXMgb3IgcGFydHMgd2hpY2ggcmVuZGVyIHNoYXJlZCBzdHlsZSBlbGVtZW50cy5cbiAqXG4gKiAqIE5vdGUsIGR1ZSB0byBhIGxpbWl0YXRpb24gb2YgdGhlIFNoYWR5RE9NIHBvbHlmaWxsLCByZW5kZXJpbmcgaW4gYVxuICogY3VzdG9tIGVsZW1lbnQncyBgY29uc3RydWN0b3JgIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQgcmVuZGVyaW5nIHNob3VsZFxuICogZWl0aGVyIGRvbmUgYXN5bmNocm9ub3VzbHksIGZvciBleGFtcGxlIGF0IG1pY3JvdGFzayB0aW1pbmcgKGZvciBleGFtcGxlXG4gKiBgUHJvbWlzZS5yZXNvbHZlKClgKSwgb3IgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGZpcnN0IHRpbWUgdGhlIGVsZW1lbnQnc1xuICogYGNvbm5lY3RlZENhbGxiYWNrYCBydW5zLlxuICpcbiAqIFVzYWdlIGNvbnNpZGVyYXRpb25zIHdoZW4gdXNpbmcgc2hpbW1lZCBjdXN0b20gcHJvcGVydGllcyBvciBgQGFwcGx5YDpcbiAqXG4gKiAqIFdoZW5ldmVyIGFueSBkeW5hbWljIGNoYW5nZXMgYXJlIG1hZGUgd2hpY2ggYWZmZWN0XG4gKiBjc3MgY3VzdG9tIHByb3BlcnRpZXMsIGBTaGFkeUNTUy5zdHlsZUVsZW1lbnQoZWxlbWVudClgIG11c3QgYmUgY2FsbGVkXG4gKiB0byB1cGRhdGUgdGhlIGVsZW1lbnQuIFRoZXJlIGFyZSB0d28gY2FzZXMgd2hlbiB0aGlzIGlzIG5lZWRlZDpcbiAqICgxKSB0aGUgZWxlbWVudCBpcyBjb25uZWN0ZWQgdG8gYSBuZXcgcGFyZW50LCAoMikgYSBjbGFzcyBpcyBhZGRlZCB0byB0aGVcbiAqIGVsZW1lbnQgdGhhdCBjYXVzZXMgaXQgdG8gbWF0Y2ggZGlmZmVyZW50IGN1c3RvbSBwcm9wZXJ0aWVzLlxuICogVG8gYWRkcmVzcyB0aGUgZmlyc3QgY2FzZSB3aGVuIHJlbmRlcmluZyBhIGN1c3RvbSBlbGVtZW50LCBgc3R5bGVFbGVtZW50YFxuICogc2hvdWxkIGJlIGNhbGxlZCBpbiB0aGUgZWxlbWVudCdzIGBjb25uZWN0ZWRDYWxsYmFja2AuXG4gKlxuICogKiBTaGltbWVkIGN1c3RvbSBwcm9wZXJ0aWVzIG1heSBvbmx5IGJlIGRlZmluZWQgZWl0aGVyIGZvciBhbiBlbnRpcmVcbiAqIHNoYWRvd1Jvb3QgKGZvciBleGFtcGxlLCBpbiBhIGA6aG9zdGAgcnVsZSkgb3IgdmlhIGEgcnVsZSB0aGF0IGRpcmVjdGx5XG4gKiBtYXRjaGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNoYWRvd1Jvb3QuIEluIG90aGVyIHdvcmRzLCBpbnN0ZWFkIG9mIGZsb3dpbmcgZnJvbVxuICogcGFyZW50IHRvIGNoaWxkIGFzIGRvIG5hdGl2ZSBjc3MgY3VzdG9tIHByb3BlcnRpZXMsIHNoaW1tZWQgY3VzdG9tIHByb3BlcnRpZXNcbiAqIGZsb3cgb25seSBmcm9tIHNoYWRvd1Jvb3RzIHRvIG5lc3RlZCBzaGFkb3dSb290cy5cbiAqXG4gKiAqIFdoZW4gdXNpbmcgYEBhcHBseWAgbWl4aW5nIGNzcyBzaG9ydGhhbmQgcHJvcGVydHkgbmFtZXMgd2l0aFxuICogbm9uLXNob3J0aGFuZCBuYW1lcyAoZm9yIGV4YW1wbGUgYGJvcmRlcmAgYW5kIGBib3JkZXItd2lkdGhgKSBpcyBub3RcbiAqIHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbmRlciA9IChyZXN1bHQsIGNvbnRhaW5lciwgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgIW9wdGlvbnMuc2NvcGVOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBzY29wZU5hbWVgIG9wdGlvbiBpcyByZXF1aXJlZC4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVOYW1lID0gb3B0aW9ucy5zY29wZU5hbWU7XG4gICAgY29uc3QgaGFzUmVuZGVyZWQgPSBwYXJ0cy5oYXMoY29udGFpbmVyKTtcbiAgICBjb25zdCBuZWVkc1Njb3BpbmcgPSBjb21wYXRpYmxlU2hhZHlDU1NWZXJzaW9uICYmXG4gICAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMTEgLyogTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICovICYmXG4gICAgICAgICEhY29udGFpbmVyLmhvc3Q7XG4gICAgLy8gSGFuZGxlIGZpcnN0IHJlbmRlciB0byBhIHNjb3BlIHNwZWNpYWxseS4uLlxuICAgIGNvbnN0IGZpcnN0U2NvcGVSZW5kZXIgPSBuZWVkc1Njb3BpbmcgJiYgIXNoYWR5UmVuZGVyU2V0LmhhcyhzY29wZU5hbWUpO1xuICAgIC8vIE9uIGZpcnN0IHNjb3BlIHJlbmRlciwgcmVuZGVyIGludG8gYSBmcmFnbWVudDsgdGhpcyBjYW5ub3QgYmUgYSBzaW5nbGVcbiAgICAvLyBmcmFnbWVudCB0aGF0IGlzIHJldXNlZCBzaW5jZSBuZXN0ZWQgcmVuZGVycyBjYW4gb2NjdXIgc3luY2hyb25vdXNseS5cbiAgICBjb25zdCByZW5kZXJDb250YWluZXIgPSBmaXJzdFNjb3BlUmVuZGVyID8gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpIDogY29udGFpbmVyO1xuICAgIGxpdFJlbmRlcihyZXN1bHQsIHJlbmRlckNvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7IHRlbXBsYXRlRmFjdG9yeTogc2hhZHlUZW1wbGF0ZUZhY3Rvcnkoc2NvcGVOYW1lKSB9LCBvcHRpb25zKSk7XG4gICAgLy8gV2hlbiBwZXJmb3JtaW5nIGZpcnN0IHNjb3BlIHJlbmRlcixcbiAgICAvLyAoMSkgV2UndmUgcmVuZGVyZWQgaW50byBhIGZyYWdtZW50IHNvIHRoYXQgdGhlcmUncyBhIGNoYW5jZSB0b1xuICAgIC8vIGBwcmVwYXJlVGVtcGxhdGVTdHlsZXNgIGJlZm9yZSBzdWItZWxlbWVudHMgaGl0IHRoZSBET01cbiAgICAvLyAod2hpY2ggbWlnaHQgY2F1c2UgdGhlbSB0byByZW5kZXIgYmFzZWQgb24gYSBjb21tb24gcGF0dGVybiBvZlxuICAgIC8vIHJlbmRlcmluZyBpbiBhIGN1c3RvbSBlbGVtZW50J3MgYGNvbm5lY3RlZENhbGxiYWNrYCk7XG4gICAgLy8gKDIpIFNjb3BlIHRoZSB0ZW1wbGF0ZSB3aXRoIFNoYWR5Q1NTIG9uZSB0aW1lIG9ubHkgZm9yIHRoaXMgc2NvcGUuXG4gICAgLy8gKDMpIFJlbmRlciB0aGUgZnJhZ21lbnQgaW50byB0aGUgY29udGFpbmVyIGFuZCBtYWtlIHN1cmUgdGhlXG4gICAgLy8gY29udGFpbmVyIGtub3dzIGl0cyBgcGFydGAgaXMgdGhlIG9uZSB3ZSBqdXN0IHJlbmRlcmVkLiBUaGlzIGVuc3VyZXNcbiAgICAvLyBET00gd2lsbCBiZSByZS11c2VkIG9uIHN1YnNlcXVlbnQgcmVuZGVycy5cbiAgICBpZiAoZmlyc3RTY29wZVJlbmRlcikge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHMuZ2V0KHJlbmRlckNvbnRhaW5lcik7XG4gICAgICAgIHBhcnRzLmRlbGV0ZShyZW5kZXJDb250YWluZXIpO1xuICAgICAgICAvLyBTaGFkeUNTUyBtaWdodCBoYXZlIHN0eWxlIHNoZWV0cyAoZS5nLiBmcm9tIGBwcmVwYXJlQWRvcHRlZENzc1RleHRgKVxuICAgICAgICAvLyB0aGF0IHNob3VsZCBhcHBseSB0byBgcmVuZGVyQ29udGFpbmVyYCBldmVuIGlmIHRoZSByZW5kZXJlZCB2YWx1ZSBpc1xuICAgICAgICAvLyBub3QgYSBUZW1wbGF0ZUluc3RhbmNlLiBIb3dldmVyLCBpdCB3aWxsIG9ubHkgaW5zZXJ0IHNjb3BlZCBzdHlsZXNcbiAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQgaWYgYHByZXBhcmVUZW1wbGF0ZVN0eWxlc2AgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICAgICAgLy8gZm9yIHRoZSBnaXZlbiBzY29wZSBuYW1lLlxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHBhcnQudmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZUluc3RhbmNlID9cbiAgICAgICAgICAgIHBhcnQudmFsdWUudGVtcGxhdGUgOlxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICBwcmVwYXJlVGVtcGxhdGVTdHlsZXMoc2NvcGVOYW1lLCByZW5kZXJDb250YWluZXIsIHRlbXBsYXRlKTtcbiAgICAgICAgcmVtb3ZlTm9kZXMoY29udGFpbmVyLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyZW5kZXJDb250YWluZXIpO1xuICAgICAgICBwYXJ0cy5zZXQoY29udGFpbmVyLCBwYXJ0KTtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgZWxlbWVudHMgaGF2ZSBoaXQgdGhlIERPTSwgdXBkYXRlIHN0eWxpbmcgaWYgdGhpcyBpcyB0aGVcbiAgICAvLyBpbml0aWFsIHJlbmRlciB0byB0aGlzIGNvbnRhaW5lci5cbiAgICAvLyBUaGlzIGlzIG5lZWRlZCB3aGVuZXZlciBkeW5hbWljIGNoYW5nZXMgYXJlIG1hZGUgc28gaXQgd291bGQgYmVcbiAgICAvLyBzYWZlc3QgdG8gZG8gZXZlcnkgcmVuZGVyOyBob3dldmVyLCB0aGlzIHdvdWxkIHJlZ3Jlc3MgcGVyZm9ybWFuY2VcbiAgICAvLyBzbyB3ZSBsZWF2ZSBpdCB1cCB0byB0aGUgdXNlciB0byBjYWxsIGBTaGFkeUNTUy5zdHlsZUVsZW1lbnRgXG4gICAgLy8gZm9yIGR5bmFtaWMgY2hhbmdlcy5cbiAgICBpZiAoIWhhc1JlbmRlcmVkICYmIG5lZWRzU2NvcGluZykge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KGNvbnRhaW5lci5ob3N0KTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZHktcmVuZGVyLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbnZhciBfYTtcbi8qKlxuICogV2hlbiB1c2luZyBDbG9zdXJlIENvbXBpbGVyLCBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KHByb3BlcnR5LCBvYmplY3QpIGlzXG4gKiByZXBsYWNlZCBhdCBjb21waWxlIHRpbWUgYnkgdGhlIG11bmdlZCBuYW1lIGZvciBvYmplY3RbcHJvcGVydHldLiBXZSBjYW5ub3RcbiAqIGFsaWFzIHRoaXMgZnVuY3Rpb24sIHNvIHdlIGhhdmUgdG8gdXNlIGEgc21hbGwgc2hpbSB0aGF0IGhhcyB0aGUgc2FtZVxuICogYmVoYXZpb3Igd2hlbiBub3QgY29tcGlsaW5nLlxuICovXG53aW5kb3cuSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSA9XG4gICAgKHByb3AsIF9vYmopID0+IHByb3A7XG5leHBvcnQgY29uc3QgZGVmYXVsdENvbnZlcnRlciA9IHtcbiAgICB0b0F0dHJpYnV0ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAnJyA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCBwYXNzIHRoaXMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIHRvIGFsbG93IHJlbW92aW5nL25vIGNoYW5nZSBiZWhhdmlvci5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGZyb21BdHRyaWJ1dGUodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsO1xuICAgICAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gbnVsbCA6IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuLyoqXG4gKiBDaGFuZ2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBkaWZmZXJlbnQgZnJvbSBgb2xkVmFsdWVgLlxuICogVGhpcyBtZXRob2QgaXMgdXNlZCBhcyB0aGUgZGVmYXVsdCBmb3IgYSBwcm9wZXJ0eSdzIGBoYXNDaGFuZ2VkYCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vdEVxdWFsID0gKHZhbHVlLCBvbGQpID0+IHtcbiAgICAvLyBUaGlzIGVuc3VyZXMgKG9sZD09TmFOLCB2YWx1ZT09TmFOKSBhbHdheXMgcmV0dXJucyBmYWxzZVxuICAgIHJldHVybiBvbGQgIT09IHZhbHVlICYmIChvbGQgPT09IG9sZCB8fCB2YWx1ZSA9PT0gdmFsdWUpO1xufTtcbmNvbnN0IGRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uID0ge1xuICAgIGF0dHJpYnV0ZTogdHJ1ZSxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY29udmVydGVyOiBkZWZhdWx0Q29udmVydGVyLFxuICAgIHJlZmxlY3Q6IGZhbHNlLFxuICAgIGhhc0NoYW5nZWQ6IG5vdEVxdWFsXG59O1xuY29uc3QgU1RBVEVfSEFTX1VQREFURUQgPSAxO1xuY29uc3QgU1RBVEVfVVBEQVRFX1JFUVVFU1RFRCA9IDEgPDwgMjtcbmNvbnN0IFNUQVRFX0lTX1JFRkxFQ1RJTkdfVE9fQVRUUklCVVRFID0gMSA8PCAzO1xuY29uc3QgU1RBVEVfSVNfUkVGTEVDVElOR19UT19QUk9QRVJUWSA9IDEgPDwgNDtcbi8qKlxuICogVGhlIENsb3N1cmUgSlMgQ29tcGlsZXIgZG9lc24ndCBjdXJyZW50bHkgaGF2ZSBnb29kIHN1cHBvcnQgZm9yIHN0YXRpY1xuICogcHJvcGVydHkgc2VtYW50aWNzIHdoZXJlIFwidGhpc1wiIGlzIGR5bmFtaWMgKGUuZy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMzE3NyBhbmQgb3RoZXJzKSBzbyB3ZSB1c2VcbiAqIHRoaXMgaGFjayB0byBieXBhc3MgYW55IHJld3JpdGluZyBieSB0aGUgY29tcGlsZXIuXG4gKi9cbmNvbnN0IGZpbmFsaXplZCA9ICdmaW5hbGl6ZWQnO1xuLyoqXG4gKiBCYXNlIGVsZW1lbnQgY2xhc3Mgd2hpY2ggbWFuYWdlcyBlbGVtZW50IHByb3BlcnRpZXMgYW5kIGF0dHJpYnV0ZXMuIFdoZW5cbiAqIHByb3BlcnRpZXMgY2hhbmdlLCB0aGUgYHVwZGF0ZWAgbWV0aG9kIGlzIGFzeW5jaHJvbm91c2x5IGNhbGxlZC4gVGhpcyBtZXRob2RcbiAqIHNob3VsZCBiZSBzdXBwbGllZCBieSBzdWJjbGFzc2VycyB0byByZW5kZXIgdXBkYXRlcyBhcyBkZXNpcmVkLlxuICovXG5leHBvcnQgY2xhc3MgVXBkYXRpbmdFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSA9IDA7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byBhbiB1bnJlc29sdmVkIFByb21pc2Ugc28gd2UgY2FuIG1ha2Ugc3VyZSB0aGUgZWxlbWVudCBoYXNcbiAgICAgICAgLy8gY29ubmVjdGVkIGJlZm9yZSBmaXJzdCB1cGRhdGUuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzKSA9PiB0aGlzLl9lbmFibGVVcGRhdGluZ1Jlc29sdmVyID0gcmVzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCB3aXRoIGtleXMgZm9yIGFueSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0XG4gICAgICAgICAqIHVwZGF0ZSBjeWNsZSB3aXRoIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NoYW5nZWRQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIHdpdGgga2V5cyBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHJlZmxlY3RlZCB3aGVuIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGF0dHJpYnV0ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIC8vIG5vdGU6IHBpZ2d5IGJhY2tpbmcgb24gdGhpcyB0byBlbnN1cmUgd2UncmUgZmluYWxpemVkLlxuICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgLy8gVXNlIGZvckVhY2ggc28gdGhpcyB3b3JrcyBldmVuIGlmIGZvci9vZiBsb29wcyBhcmUgY29tcGlsZWQgdG8gZm9yIGxvb3BzXG4gICAgICAgIC8vIGV4cGVjdGluZyBhcnJheXNcbiAgICAgICAgdGhpcy5fY2xhc3NQcm9wZXJ0aWVzLmZvckVhY2goKHYsIHApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLl9hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkocCwgdik7XG4gICAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcC5zZXQoYXR0ciwgcCk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIHByaXZhdGUgYF9jbGFzc1Byb3BlcnRpZXNgIHByb3BlcnR5IG1ldGFkYXRhIGlzIGNyZWF0ZWQuXG4gICAgICogSW4gYWRkaXRpb24gdG8gYGZpbmFsaXplYCB0aGlzIGlzIGFsc28gY2FsbGVkIGluIGBjcmVhdGVQcm9wZXJ0eWAgdG9cbiAgICAgKiBlbnN1cmUgdGhlIGBAcHJvcGVydHlgIGRlY29yYXRvciBjYW4gYWRkIHByb3BlcnR5IG1ldGFkYXRhLlxuICAgICAqL1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIHN0YXRpYyBfZW5zdXJlQ2xhc3NQcm9wZXJ0aWVzKCkge1xuICAgICAgICAvLyBlbnN1cmUgcHJpdmF0ZSBzdG9yYWdlIGZvciBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMuXG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfY2xhc3NQcm9wZXJ0aWVzJywgdGhpcykpKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGFzc1Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyBOT1RFOiBXb3JrYXJvdW5kIElFMTEgbm90IHN1cHBvcnRpbmcgTWFwIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlxuICAgICAgICAgICAgY29uc3Qgc3VwZXJQcm9wZXJ0aWVzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9jbGFzc1Byb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAoc3VwZXJQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdXBlclByb3BlcnRpZXMuZm9yRWFjaCgodiwgaykgPT4gdGhpcy5fY2xhc3NQcm9wZXJ0aWVzLnNldChrLCB2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByb3BlcnR5IGFjY2Vzc29yIG9uIHRoZSBlbGVtZW50IHByb3RvdHlwZSBpZiBvbmUgZG9lcyBub3QgZXhpc3RcbiAgICAgKiBhbmQgc3RvcmVzIGEgUHJvcGVydHlEZWNsYXJhdGlvbiBmb3IgdGhlIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAgICogVGhlIHByb3BlcnR5IHNldHRlciBjYWxscyB0aGUgcHJvcGVydHkncyBgaGFzQ2hhbmdlZGAgcHJvcGVydHkgb3B0aW9uXG4gICAgICogb3IgdXNlcyBhIHN0cmljdCBpZGVudGl0eSBjaGVjayB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gcmVxdWVzdFxuICAgICAqIGFuIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGN1c3RvbWl6ZSBwcm9wZXJ0aWVzOyBob3dldmVyLFxuICAgICAqIHdoZW4gZG9pbmcgc28sIGl0J3MgaW1wb3J0YW50IHRvIGNhbGwgYHN1cGVyLmNyZWF0ZVByb3BlcnR5YCB0byBlbnN1cmVcbiAgICAgKiB0aGUgcHJvcGVydHkgaXMgc2V0dXAgY29ycmVjdGx5LiBUaGlzIG1ldGhvZCBjYWxsc1xuICAgICAqIGBnZXRQcm9wZXJ0eURlc2NyaXB0b3JgIGludGVybmFsbHkgdG8gZ2V0IGEgZGVzY3JpcHRvciB0byBpbnN0YWxsLlxuICAgICAqIFRvIGN1c3RvbWl6ZSB3aGF0IHByb3BlcnRpZXMgZG8gd2hlbiB0aGV5IGFyZSBnZXQgb3Igc2V0LCBvdmVycmlkZVxuICAgICAqIGBnZXRQcm9wZXJ0eURlc2NyaXB0b3JgLiBUbyBjdXN0b21pemUgdGhlIG9wdGlvbnMgZm9yIGEgcHJvcGVydHksXG4gICAgICogaW1wbGVtZW50IGBjcmVhdGVQcm9wZXJ0eWAgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogc3RhdGljIGNyZWF0ZVByb3BlcnR5KG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgKiAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtteU9wdGlvbjogdHJ1ZX0pO1xuICAgICAqICAgc3VwZXIuY3JlYXRlUHJvcGVydHkobmFtZSwgb3B0aW9ucyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvcGVydHkobmFtZSwgb3B0aW9ucyA9IGRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uKSB7XG4gICAgICAgIC8vIE5vdGUsIHNpbmNlIHRoaXMgY2FuIGJlIGNhbGxlZCBieSB0aGUgYEBwcm9wZXJ0eWAgZGVjb3JhdG9yIHdoaWNoXG4gICAgICAgIC8vIGlzIGNhbGxlZCBiZWZvcmUgYGZpbmFsaXplYCwgd2UgZW5zdXJlIHN0b3JhZ2UgZXhpc3RzIGZvciBwcm9wZXJ0eVxuICAgICAgICAvLyBtZXRhZGF0YS5cbiAgICAgICAgdGhpcy5fZW5zdXJlQ2xhc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMuX2NsYXNzUHJvcGVydGllcy5zZXQobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIERvIG5vdCBnZW5lcmF0ZSBhbiBhY2Nlc3NvciBpZiB0aGUgcHJvdG90eXBlIGFscmVhZHkgaGFzIG9uZSwgc2luY2VcbiAgICAgICAgLy8gaXQgd291bGQgYmUgbG9zdCBvdGhlcndpc2UgYW5kIHRoYXQgd291bGQgbmV2ZXIgYmUgdGhlIHVzZXIncyBpbnRlbnRpb247XG4gICAgICAgIC8vIEluc3RlYWQsIHdlIGV4cGVjdCB1c2VycyB0byBjYWxsIGByZXF1ZXN0VXBkYXRlYCB0aGVtc2VsdmVzIGZyb21cbiAgICAgICAgLy8gdXNlci1kZWZpbmVkIGFjY2Vzc29ycy4gTm90ZSB0aGF0IGlmIHRoZSBzdXBlciBoYXMgYW4gYWNjZXNzb3Igd2Ugd2lsbFxuICAgICAgICAvLyBzdGlsbCBvdmVyd3JpdGUgaXRcbiAgICAgICAgaWYgKG9wdGlvbnMubm9BY2Nlc3NvciB8fCB0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHR5cGVvZiBuYW1lID09PSAnc3ltYm9sJyA/IFN5bWJvbCgpIDogYF9fJHtuYW1lfWA7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldFByb3BlcnR5RGVzY3JpcHRvcihuYW1lLCBrZXksIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGJlIGRlZmluZWQgb24gdGhlIGdpdmVuIG5hbWVkIHByb3BlcnR5LlxuICAgICAqIElmIG5vIGRlc2NyaXB0b3IgaXMgcmV0dXJuZWQsIHRoZSBwcm9wZXJ0eSB3aWxsIG5vdCBiZWNvbWUgYW4gYWNjZXNzb3IuXG4gICAgICogRm9yIGV4YW1wbGUsXG4gICAgICpcbiAgICAgKiAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xuICAgICAqICAgICBzdGF0aWMgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG5hbWUsIGtleSwgb3B0aW9ucykge1xuICAgICAqICAgICAgIGNvbnN0IGRlZmF1bHREZXNjcmlwdG9yID1cbiAgICAgKiAgICAgICAgICAgc3VwZXIuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG5hbWUsIGtleSwgb3B0aW9ucyk7XG4gICAgICogICAgICAgY29uc3Qgc2V0dGVyID0gZGVmYXVsdERlc2NyaXB0b3Iuc2V0O1xuICAgICAqICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICBnZXQ6IGRlZmF1bHREZXNjcmlwdG9yLmdldCxcbiAgICAgKiAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAqICAgICAgICAgICBzZXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICogICAgICAgICAgIC8vIGN1c3RvbSBhY3Rpb24uXG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAqICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG5hbWUsIGtleSwgX29wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgbm8gc3ltYm9sIGluIGluZGV4XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFVwZGF0ZShuYW1lLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBvcHRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICogVGhlc2Ugb3B0aW9ucyBhcmUgZGVmaW5lZCB3aXRoIGEgUHJvcGVydHlEZWNsYXJhdGlvbiB2aWEgdGhlIGBwcm9wZXJ0aWVzYFxuICAgICAqIG9iamVjdCBvciB0aGUgYEBwcm9wZXJ0eWAgZGVjb3JhdG9yIGFuZCBhcmUgcmVnaXN0ZXJlZCBpblxuICAgICAqIGBjcmVhdGVQcm9wZXJ0eSguLi4pYC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBjb25zaWRlcmVkIFwiZmluYWxcIiBhbmQgbm90IG92ZXJyaWRkZW4uIFRvXG4gICAgICogY3VzdG9taXplIHRoZSBvcHRpb25zIGZvciBhIGdpdmVuIHByb3BlcnR5LCBvdmVycmlkZSBgY3JlYXRlUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJvcGVydHlPcHRpb25zKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzUHJvcGVydGllcyAmJiB0aGlzLl9jbGFzc1Byb3BlcnRpZXMuZ2V0KG5hbWUpIHx8XG4gICAgICAgICAgICBkZWZhdWx0UHJvcGVydHlEZWNsYXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIHJlZ2lzdGVyZWQgcHJvcGVydGllcyBhbmQgZW5zdXJlc1xuICAgICAqIGFueSBzdXBlcmNsYXNzZXMgYXJlIGFsc28gZmluYWxpemVkLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgICAvLyBmaW5hbGl6ZSBhbnkgc3VwZXJjbGFzc2VzXG4gICAgICAgIGNvbnN0IHN1cGVyQ3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgaWYgKCFzdXBlckN0b3IuaGFzT3duUHJvcGVydHkoZmluYWxpemVkKSkge1xuICAgICAgICAgICAgc3VwZXJDdG9yLmZpbmFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tmaW5hbGl6ZWRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZW5zdXJlQ2xhc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIGluaXRpYWxpemUgTWFwIHBvcHVsYXRlZCBpbiBvYnNlcnZlZEF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gbWFrZSBhbnkgcHJvcGVydGllc1xuICAgICAgICAvLyBOb3RlLCBvbmx5IHByb2Nlc3MgXCJvd25cIiBwcm9wZXJ0aWVzIHNpbmNlIHRoaXMgZWxlbWVudCB3aWxsIGluaGVyaXRcbiAgICAgICAgLy8gYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGUgc3VwZXJDbGFzcywgYW5kIGZpbmFsaXphdGlvbiBlbnN1cmVzXG4gICAgICAgIC8vIHRoZSBlbnRpcmUgcHJvdG90eXBlIGNoYWluIGlzIGZpbmFsaXplZC5cbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgncHJvcGVydGllcycsIHRoaXMpKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IHN5bWJvbHMgaW4gcHJvcGVydGllcyAoSUUxMSBkb2VzIG5vdCBzdXBwb3J0IHRoaXMpXG4gICAgICAgICAgICBjb25zdCBwcm9wS2V5cyA9IFtcbiAgICAgICAgICAgICAgICAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wcyksXG4gICAgICAgICAgICAgICAgLi4uKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSA/XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvcHMpIDpcbiAgICAgICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICAvLyBUaGlzIGZvci9vZiBpcyBvayBiZWNhdXNlIHByb3BLZXlzIGlzIGFuIGFycmF5XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcHJvcEtleXMpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlLCB1c2Ugb2YgYGFueWAgaXMgZHVlIHRvIFR5cGVTcmlwdCBsYWNrIG9mIHN1cHBvcnQgZm9yIHN5bWJvbCBpblxuICAgICAgICAgICAgICAgIC8vIGluZGV4IHR5cGVzXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBubyBzeW1ib2wgaW4gaW5kZXhcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVByb3BlcnR5KHAsIHByb3BzW3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgZ2l2ZW4gYXR0cmlidXRlIGBuYW1lYC5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfYXR0cmlidXRlTmFtZUZvclByb3BlcnR5KG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gb3B0aW9ucy5hdHRyaWJ1dGU7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGUgPT09IGZhbHNlID9cbiAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAodHlwZW9mIGF0dHJpYnV0ZSA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSA6XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IG5hbWUudG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBwcm9wZXJ0eSBzaG91bGQgcmVxdWVzdCBhbiB1cGRhdGUuXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwcm9wZXJ0eSB2YWx1ZSBpcyBzZXQgYW5kIHVzZXMgdGhlIGBoYXNDaGFuZ2VkYFxuICAgICAqIG9wdGlvbiBmb3IgdGhlIHByb3BlcnR5IGlmIHByZXNlbnQgb3IgYSBzdHJpY3QgaWRlbnRpdHkgY2hlY2suXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX3ZhbHVlSGFzQ2hhbmdlZCh2YWx1ZSwgb2xkLCBoYXNDaGFuZ2VkID0gbm90RXF1YWwpIHtcbiAgICAgICAgcmV0dXJuIGhhc0NoYW5nZWQodmFsdWUsIG9sZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGZvciB0aGUgZ2l2ZW4gYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIENhbGxlZCB2aWEgdGhlIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIGFuZCB1c2VzIHRoZSBwcm9wZXJ0eSdzXG4gICAgICogYGNvbnZlcnRlcmAgb3IgYGNvbnZlcnRlci5mcm9tQXR0cmlidXRlYCBwcm9wZXJ0eSBvcHRpb24uXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX3Byb3BlcnR5VmFsdWVGcm9tQXR0cmlidXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG9wdGlvbnMuY29udmVydGVyIHx8IGRlZmF1bHRDb252ZXJ0ZXI7XG4gICAgICAgIGNvbnN0IGZyb21BdHRyaWJ1dGUgPSAodHlwZW9mIGNvbnZlcnRlciA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnZlcnRlciA6IGNvbnZlcnRlci5mcm9tQXR0cmlidXRlKTtcbiAgICAgICAgcmV0dXJuIGZyb21BdHRyaWJ1dGUgPyBmcm9tQXR0cmlidXRlKHZhbHVlLCB0eXBlKSA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhdHRyaWJ1dGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB2YWx1ZS4gSWYgdGhpc1xuICAgICAqIHJldHVybnMgdW5kZWZpbmVkLCB0aGUgcHJvcGVydHkgd2lsbCAqbm90KiBiZSByZWZsZWN0ZWQgdG8gYW4gYXR0cmlidXRlLlxuICAgICAqIElmIHRoaXMgcmV0dXJucyBudWxsLCB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZCwgb3RoZXJ3aXNlIHRoZVxuICAgICAqIGF0dHJpYnV0ZSB3aWxsIGJlIHNldCB0byB0aGUgdmFsdWUuXG4gICAgICogVGhpcyB1c2VzIHRoZSBwcm9wZXJ0eSdzIGByZWZsZWN0YCBhbmQgYHR5cGUudG9BdHRyaWJ1dGVgIHByb3BlcnR5IG9wdGlvbnMuXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX3Byb3BlcnR5VmFsdWVUb0F0dHJpYnV0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5yZWZsZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBvcHRpb25zLmNvbnZlcnRlcjtcbiAgICAgICAgY29uc3QgdG9BdHRyaWJ1dGUgPSBjb252ZXJ0ZXIgJiYgY29udmVydGVyLnRvQXR0cmlidXRlIHx8XG4gICAgICAgICAgICBkZWZhdWx0Q29udmVydGVyLnRvQXR0cmlidXRlO1xuICAgICAgICByZXR1cm4gdG9BdHRyaWJ1dGUodmFsdWUsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBlbGVtZW50IGluaXRpYWxpemF0aW9uLiBCeSBkZWZhdWx0IGNhcHR1cmVzIGFueSBwcmUtc2V0IHZhbHVlcyBmb3JcbiAgICAgKiByZWdpc3RlcmVkIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5fc2F2ZUluc3RhbmNlUHJvcGVydGllcygpO1xuICAgICAgICAvLyBlbnN1cmVzIGZpcnN0IHVwZGF0ZSB3aWxsIGJlIGNhdWdodCBieSBhbiBlYXJseSBhY2Nlc3Mgb2ZcbiAgICAgICAgLy8gYHVwZGF0ZUNvbXBsZXRlYFxuICAgICAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpeGVzIGFueSBwcm9wZXJ0aWVzIHNldCBvbiB0aGUgaW5zdGFuY2UgYmVmb3JlIHVwZ3JhZGUgdGltZS5cbiAgICAgKiBPdGhlcndpc2UgdGhlc2Ugd291bGQgc2hhZG93IHRoZSBhY2Nlc3NvciBhbmQgYnJlYWsgdGhlc2UgcHJvcGVydGllcy5cbiAgICAgKiBUaGUgcHJvcGVydGllcyBhcmUgc3RvcmVkIGluIGEgTWFwIHdoaWNoIGlzIHBsYXllZCBiYWNrIGFmdGVyIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yIHJ1bnMuIE5vdGUsIG9uIHZlcnkgb2xkIHZlcnNpb25zIG9mIFNhZmFyaSAoPD05KSBvciBDaHJvbWVcbiAgICAgKiAoPD00MSksIHByb3BlcnRpZXMgY3JlYXRlZCBmb3IgbmF0aXZlIHBsYXRmb3JtIHByb3BlcnRpZXMgbGlrZSAoYGlkYCBvclxuICAgICAqIGBuYW1lYCkgbWF5IG5vdCBoYXZlIGRlZmF1bHQgdmFsdWVzIHNldCBpbiB0aGUgZWxlbWVudCBjb25zdHJ1Y3Rvci4gT25cbiAgICAgKiB0aGVzZSBicm93c2VycyBuYXRpdmUgcHJvcGVydGllcyBhcHBlYXIgb24gaW5zdGFuY2VzIGFuZCB0aGVyZWZvcmUgdGhlaXJcbiAgICAgKiBkZWZhdWx0IHZhbHVlIHdpbGwgb3ZlcndyaXRlIGFueSBlbGVtZW50IGRlZmF1bHQgKGUuZy4gaWYgdGhlIGVsZW1lbnQgc2V0c1xuICAgICAqIHRoaXMuaWQgPSAnaWQnIGluIHRoZSBjb25zdHJ1Y3RvciwgdGhlICdpZCcgd2lsbCBiZWNvbWUgJycgc2luY2UgdGhpcyBpc1xuICAgICAqIHRoZSBuYXRpdmUgcGxhdGZvcm0gZGVmYXVsdCkuXG4gICAgICovXG4gICAgX3NhdmVJbnN0YW5jZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIC8vIFVzZSBmb3JFYWNoIHNvIHRoaXMgd29ya3MgZXZlbiBpZiBmb3Ivb2YgbG9vcHMgYXJlIGNvbXBpbGVkIHRvIGZvciBsb29wc1xuICAgICAgICAvLyBleHBlY3RpbmcgYXJyYXlzXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3JcbiAgICAgICAgICAgIC5fY2xhc3NQcm9wZXJ0aWVzLmZvckVhY2goKF92LCBwKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1twXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1twXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlUHJvcGVydGllcy5zZXQocCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBwcmV2aW91c2x5IHNhdmVkIGluc3RhbmNlIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgX2FwcGx5SW5zdGFuY2VQcm9wZXJ0aWVzKCkge1xuICAgICAgICAvLyBVc2UgZm9yRWFjaCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgZm9yL29mIGxvb3BzIGFyZSBjb21waWxlZCB0byBmb3IgbG9vcHNcbiAgICAgICAgLy8gZXhwZWN0aW5nIGFycmF5c1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgIHRoaXMuX2luc3RhbmNlUHJvcGVydGllcy5mb3JFYWNoKCh2LCBwKSA9PiB0aGlzW3BdID0gdik7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIC8vIEVuc3VyZSBmaXJzdCBjb25uZWN0aW9uIGNvbXBsZXRlcyBhbiB1cGRhdGUuIFVwZGF0ZXMgY2Fubm90IGNvbXBsZXRlXG4gICAgICAgIC8vIGJlZm9yZSBjb25uZWN0aW9uLlxuICAgICAgICB0aGlzLmVuYWJsZVVwZGF0aW5nKCk7XG4gICAgfVxuICAgIGVuYWJsZVVwZGF0aW5nKCkge1xuICAgICAgICBpZiAodGhpcy5fZW5hYmxlVXBkYXRpbmdSZXNvbHZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVVcGRhdGluZ1Jlc29sdmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVVcGRhdGluZ1Jlc29sdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBmb3IgYHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKClgIGluIGV4dGVuc2lvbnMgd2hpbGVcbiAgICAgKiByZXNlcnZpbmcgdGhlIHBvc3NpYmlsaXR5IG9mIG1ha2luZyBub24tYnJlYWtpbmcgZmVhdHVyZSBhZGRpdGlvbnNcbiAgICAgKiB3aGVuIGRpc2Nvbm5lY3RpbmcgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbml6ZXMgcHJvcGVydHkgdmFsdWVzIHdoZW4gYXR0cmlidXRlcyBjaGFuZ2UuXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcm9wZXJ0eVRvQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBvcHRpb25zID0gZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb24pIHtcbiAgICAgICAgY29uc3QgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBjdG9yLl9hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IGN0b3IuX3Byb3BlcnR5VmFsdWVUb0F0dHJpYnV0ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBhbiB1bmRlZmluZWQgdmFsdWUgZG9lcyBub3QgY2hhbmdlIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAgICBpZiAoYXR0clZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUcmFjayBpZiB0aGUgcHJvcGVydHkgaXMgYmVpbmcgcmVmbGVjdGVkIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBhZ2FpbiB2aWEgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuIE5vdGU6XG4gICAgICAgICAgICAvLyAxLiB0aGlzIHRha2VzIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IHRoZSBjYWxsYmFjayBpcyBzeW5jaHJvbm91cy5cbiAgICAgICAgICAgIC8vIDIuIHdpbGwgYmVoYXZlIGluY29ycmVjdGx5IGlmIG11bHRpcGxlIGF0dHJpYnV0ZXMgYXJlIGluIHRoZSByZWFjdGlvblxuICAgICAgICAgICAgLy8gc3RhY2sgYXQgdGltZSBvZiBjYWxsaW5nLiBIb3dldmVyLCBzaW5jZSB3ZSBwcm9jZXNzIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC8vIGluIGB1cGRhdGVgIHRoaXMgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSAob3IgYW4gZXh0cmVtZSBjb3JuZXIgY2FzZVxuICAgICAgICAgICAgLy8gdGhhdCB3ZSdkIGxpa2UgdG8gZGlzY292ZXIpLlxuICAgICAgICAgICAgLy8gbWFyayBzdGF0ZSByZWZsZWN0aW5nXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSA9IHRoaXMuX3VwZGF0ZVN0YXRlIHwgU1RBVEVfSVNfUkVGTEVDVElOR19UT19BVFRSSUJVVEU7XG4gICAgICAgICAgICBpZiAoYXR0clZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJrIHN0YXRlIG5vdCByZWZsZWN0aW5nXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSA9IHRoaXMuX3VwZGF0ZVN0YXRlICYgflNUQVRFX0lTX1JFRkxFQ1RJTkdfVE9fQVRUUklCVVRFO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vIFVzZSB0cmFja2luZyBpbmZvIHRvIGF2b2lkIGRlc2VyaWFsaXppbmcgYXR0cmlidXRlIHZhbHVlIGlmIGl0IHdhc1xuICAgICAgICAvLyBqdXN0IHNldCBmcm9tIGEgcHJvcGVydHkgc2V0dGVyLlxuICAgICAgICBpZiAodGhpcy5fdXBkYXRlU3RhdGUgJiBTVEFURV9JU19SRUZMRUNUSU5HX1RPX0FUVFJJQlVURSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAvLyBOb3RlLCBoaW50IHRoaXMgYXMgYW4gYEF0dHJpYnV0ZU1hcGAgc28gY2xvc3VyZSBjbGVhcmx5IHVuZGVyc3RhbmRzXG4gICAgICAgIC8vIHRoZSB0eXBlOyBpdCBoYXMgaXNzdWVzIHdpdGggdHJhY2tpbmcgdHlwZXMgdGhyb3VnaCBzdGF0aWNzXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgICAgICBjb25zdCBwcm9wTmFtZSA9IGN0b3IuX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocHJvcE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGN0b3IuZ2V0UHJvcGVydHlPcHRpb25zKHByb3BOYW1lKTtcbiAgICAgICAgICAgIC8vIG1hcmsgc3RhdGUgcmVmbGVjdGluZ1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUgPSB0aGlzLl91cGRhdGVTdGF0ZSB8IFNUQVRFX0lTX1JFRkxFQ1RJTkdfVE9fUFJPUEVSVFk7XG4gICAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgICAgIGN0b3IuX3Byb3BlcnR5VmFsdWVGcm9tQXR0cmlidXRlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIG1hcmsgc3RhdGUgbm90IHJlZmxlY3RpbmdcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlID0gdGhpcy5fdXBkYXRlU3RhdGUgJiB+U1RBVEVfSVNfUkVGTEVDVElOR19UT19QUk9QRVJUWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHByaXZhdGUgdmVyc2lvbiBvZiBgcmVxdWVzdFVwZGF0ZWAgZG9lcyBub3QgYWNjZXNzIG9yIHJldHVybiB0aGVcbiAgICAgKiBgdXBkYXRlQ29tcGxldGVgIHByb21pc2UuIFRoaXMgcHJvbWlzZSBjYW4gYmUgb3ZlcnJpZGRlbiBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICogbm90IGZyZWUgdG8gYWNjZXNzLlxuICAgICAqL1xuICAgIF9yZXF1ZXN0VXBkYXRlKG5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBzaG91bGRSZXF1ZXN0VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHByb3BlcnR5IGtleSwgcGVyZm9ybSBwcm9wZXJ0eSB1cGRhdGUgc3RlcHMuXG4gICAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGN0b3IuZ2V0UHJvcGVydHlPcHRpb25zKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGN0b3IuX3ZhbHVlSGFzQ2hhbmdlZCh0aGlzW25hbWVdLCBvbGRWYWx1ZSwgb3B0aW9ucy5oYXNDaGFuZ2VkKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2hhbmdlZFByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRQcm9wZXJ0aWVzLnNldChuYW1lLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byByZWZsZWN0aW5nIHByb3BlcnRpZXMgc2V0LlxuICAgICAgICAgICAgICAgIC8vIE5vdGUsIGl0J3MgaW1wb3J0YW50IHRoYXQgZXZlcnkgY2hhbmdlIGhhcyBhIGNoYW5jZSB0byBhZGQgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgdG8gYF9yZWZsZWN0aW5nUHJvcGVydGllc2AuIFRoaXMgZW5zdXJlcyBzZXR0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlICsgcHJvcGVydHkgcmVmbGVjdHMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlZmxlY3QgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAgICAgISh0aGlzLl91cGRhdGVTdGF0ZSAmIFNUQVRFX0lTX1JFRkxFQ1RJTkdfVE9fUFJPUEVSVFkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcy5zZXQobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgdGhlIHJlcXVlc3QgaWYgdGhlIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIHNob3VsZFJlcXVlc3RVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2hhc1JlcXVlc3RlZFVwZGF0ZSAmJiBzaG91bGRSZXF1ZXN0VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9taXNlID0gdGhpcy5fZW5xdWV1ZVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGFuIHVwZGF0ZSB3aGljaCBpcyBwcm9jZXNzZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgc2hvdWxkXG4gICAgICogYmUgY2FsbGVkIHdoZW4gYW4gZWxlbWVudCBzaG91bGQgdXBkYXRlIGJhc2VkIG9uIHNvbWUgc3RhdGUgbm90IHRyaWdnZXJlZFxuICAgICAqIGJ5IHNldHRpbmcgYSBwcm9wZXJ0eS4gSW4gdGhpcyBjYXNlLCBwYXNzIG5vIGFyZ3VtZW50cy4gSXQgc2hvdWxkIGFsc28gYmVcbiAgICAgKiBjYWxsZWQgd2hlbiBtYW51YWxseSBpbXBsZW1lbnRpbmcgYSBwcm9wZXJ0eSBzZXR0ZXIuIEluIHRoaXMgY2FzZSwgcGFzcyB0aGVcbiAgICAgKiBwcm9wZXJ0eSBgbmFtZWAgYW5kIGBvbGRWYWx1ZWAgdG8gZW5zdXJlIHRoYXQgYW55IGNvbmZpZ3VyZWQgcHJvcGVydHlcbiAgICAgKiBvcHRpb25zIGFyZSBob25vcmVkLiBSZXR1cm5zIHRoZSBgdXBkYXRlQ29tcGxldGVgIFByb21pc2Ugd2hpY2ggaXMgcmVzb2x2ZWRcbiAgICAgKiB3aGVuIHRoZSB1cGRhdGUgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUge1Byb3BlcnR5S2V5fSAob3B0aW9uYWwpIG5hbWUgb2YgcmVxdWVzdGluZyBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZSB7YW55fSAob3B0aW9uYWwpIG9sZCB2YWx1ZSBvZiByZXF1ZXN0aW5nIHByb3BlcnR5XG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHVwZGF0ZSBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgcmVxdWVzdFVwZGF0ZShuYW1lLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKG5hbWUsIG9sZFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ29tcGxldGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGVsZW1lbnQgdG8gYXN5bmNocm9ub3VzbHkgdXBkYXRlLlxuICAgICAqL1xuICAgIGFzeW5jIF9lbnF1ZXVlVXBkYXRlKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSA9IHRoaXMuX3VwZGF0ZVN0YXRlIHwgU1RBVEVfVVBEQVRFX1JFUVVFU1RFRDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbnkgcHJldmlvdXMgdXBkYXRlIGhhcyByZXNvbHZlZCBiZWZvcmUgdXBkYXRpbmcuXG4gICAgICAgICAgICAvLyBUaGlzIGBhd2FpdGAgYWxzbyBlbnN1cmVzIHRoYXQgcHJvcGVydHkgY2hhbmdlcyBhcmUgYmF0Y2hlZC5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgcHJldmlvdXMgZXJyb3JzLiBXZSBvbmx5IGNhcmUgdGhhdCB0aGUgcHJldmlvdXMgY3ljbGUgaXNcbiAgICAgICAgICAgIC8vIGRvbmUuIEFueSBlcnJvciBzaG91bGQgaGF2ZSBiZWVuIGhhbmRsZWQgaW4gdGhlIHByZXZpb3VzIHVwZGF0ZS5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBlcmZvcm1VcGRhdGUoKTtcbiAgICAgICAgLy8gSWYgYHBlcmZvcm1VcGRhdGVgIHJldHVybnMgYSBQcm9taXNlLCB3ZSBhd2FpdCBpdC4gVGhpcyBpcyBkb25lIHRvXG4gICAgICAgIC8vIGVuYWJsZSBjb29yZGluYXRpbmcgdXBkYXRlcyB3aXRoIGEgc2NoZWR1bGVyLiBOb3RlLCB0aGUgcmVzdWx0IGlzXG4gICAgICAgIC8vIGNoZWNrZWQgdG8gYXZvaWQgZGVsYXlpbmcgYW4gYWRkaXRpb25hbCBtaWNyb3Rhc2sgdW5sZXNzIHdlIG5lZWQgdG8uXG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy5faGFzUmVxdWVzdGVkVXBkYXRlO1xuICAgIH1cbiAgICBnZXQgX2hhc1JlcXVlc3RlZFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl91cGRhdGVTdGF0ZSAmIFNUQVRFX1VQREFURV9SRVFVRVNURUQpO1xuICAgIH1cbiAgICBnZXQgaGFzVXBkYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl91cGRhdGVTdGF0ZSAmIFNUQVRFX0hBU19VUERBVEVEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW4gZWxlbWVudCB1cGRhdGUuIE5vdGUsIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZHVyaW5nIHRoZVxuICAgICAqIHVwZGF0ZSwgYGZpcnN0VXBkYXRlZGAgYW5kIGB1cGRhdGVkYCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgdGltaW5nIG9mIHVwZGF0ZXMuIElmIHRoaXNcbiAgICAgKiBtZXRob2QgaXMgb3ZlcnJpZGRlbiwgYHN1cGVyLnBlcmZvcm1VcGRhdGUoKWAgbXVzdCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRvIHNjaGVkdWxlIHVwZGF0ZXMgdG8gb2NjdXIganVzdCBiZWZvcmUgdGhlIG5leHQgZnJhbWU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBwcm90ZWN0ZWQgYXN5bmMgcGVyZm9ybVVwZGF0ZSgpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICAgKiAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcmVzb2x2ZSgpKSk7XG4gICAgICogICBzdXBlci5wZXJmb3JtVXBkYXRlKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHBlcmZvcm1VcGRhdGUoKSB7XG4gICAgICAgIC8vIE1peGluIGluc3RhbmNlIHByb3BlcnRpZXMgb25jZSwgaWYgdGhleSBleGlzdC5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlUHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlJbnN0YW5jZVByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRQcm9wZXJ0aWVzID0gdGhpcy5fY2hhbmdlZFByb3BlcnRpZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzaG91bGRVcGRhdGUgPSB0aGlzLnNob3VsZFVwZGF0ZShjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya1VwZGF0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBgZmlyc3RVcGRhdGVkYCBhbmQgYHVwZGF0ZWRgIGZyb20gcnVubmluZyB3aGVuIHRoZXJlJ3MgYW5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBleGNlcHRpb24uXG4gICAgICAgICAgICBzaG91bGRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBlbGVtZW50IGNhbiBhY2NlcHQgYWRkaXRpb25hbCB1cGRhdGVzIGFmdGVyIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX21hcmtVcGRhdGVkKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3VwZGF0ZVN0YXRlICYgU1RBVEVfSEFTX1VQREFURUQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUgPSB0aGlzLl91cGRhdGVTdGF0ZSB8IFNUQVRFX0hBU19VUERBVEVEO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RVcGRhdGVkKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21hcmtVcGRhdGVkKCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VkUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUgPSB0aGlzLl91cGRhdGVTdGF0ZSAmIH5TVEFURV9VUERBVEVfUkVRVUVTVEVEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGNvbXBsZXRlZCB1cGRhdGluZy5cbiAgICAgKiBUaGUgUHJvbWlzZSB2YWx1ZSBpcyBhIGJvb2xlYW4gdGhhdCBpcyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQgY29tcGxldGVkIHRoZVxuICAgICAqIHVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW5vdGhlciB1cGRhdGUuIFRoZSBQcm9taXNlIHJlc3VsdCBpcyBgZmFsc2VgIGlmXG4gICAgICogYSBwcm9wZXJ0eSB3YXMgc2V0IGluc2lkZSBgdXBkYXRlZCgpYC4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGFuXG4gICAgICogZXhjZXB0aW9uIHdhcyB0aHJvd24gZHVyaW5nIHRoZSB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBUbyBhd2FpdCBhZGRpdGlvbmFsIGFzeW5jaHJvbm91cyB3b3JrLCBvdmVycmlkZSB0aGUgYF9nZXRVcGRhdGVDb21wbGV0ZWBcbiAgICAgKiBtZXRob2QuIEZvciBleGFtcGxlLCBpdCBpcyBzb21ldGltZXMgdXNlZnVsIHRvIGF3YWl0IGEgcmVuZGVyZWQgZWxlbWVudFxuICAgICAqIGJlZm9yZSBmdWxmaWxsaW5nIHRoaXMgUHJvbWlzZS4gVG8gZG8gdGhpcywgZmlyc3QgYXdhaXRcbiAgICAgKiBgc3VwZXIuX2dldFVwZGF0ZUNvbXBsZXRlKClgLCB0aGVuIGFueSBzdWJzZXF1ZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHJldHVybnMgYSBib29sZWFuIHRoYXQgaW5kaWNhdGVzIGlmIHRoZVxuICAgICAqIHVwZGF0ZSByZXNvbHZlZCB3aXRob3V0IHRyaWdnZXJpbmcgYW5vdGhlciB1cGRhdGUuXG4gICAgICovXG4gICAgZ2V0IHVwZGF0ZUNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlQ29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIHRoZSBgdXBkYXRlQ29tcGxldGVgIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBJdCBpcyBub3Qgc2FmZSB0byBvdmVycmlkZSB0aGUgYHVwZGF0ZUNvbXBsZXRlYCBnZXR0ZXIgZGlyZWN0bHkgZHVlIHRvIGFcbiAgICAgKiBsaW1pdGF0aW9uIGluIFR5cGVTY3JpcHQgd2hpY2ggbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGNhbGwgYVxuICAgICAqIHN1cGVyY2xhc3MgZ2V0dGVyIChlLmcuIGBzdXBlci51cGRhdGVDb21wbGV0ZS50aGVuKC4uLilgKSB3aGVuIHRoZSB0YXJnZXRcbiAgICAgKiBsYW5ndWFnZSBpcyBFUzUgKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzM4KS5cbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbnN0ZWFkLiBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAgICogICAgIGFzeW5jIF9nZXRVcGRhdGVDb21wbGV0ZSgpIHtcbiAgICAgKiAgICAgICBhd2FpdCBzdXBlci5fZ2V0VXBkYXRlQ29tcGxldGUoKTtcbiAgICAgKiAgICAgICBhd2FpdCB0aGlzLl9teUNoaWxkLnVwZGF0ZUNvbXBsZXRlO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICovXG4gICAgX2dldFVwZGF0ZUNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hldGhlciBvciBub3QgYHVwZGF0ZWAgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBlbGVtZW50IHJlcXVlc3RzXG4gICAgICogYW4gdXBkYXRlLiBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAsIGJ1dCB0aGlzIGNhbiBiZVxuICAgICAqIGN1c3RvbWl6ZWQgdG8gY29udHJvbCB3aGVuIHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfY2hhbmdlZFByb3BlcnRpZXMgTWFwIG9mIGNoYW5nZWQgcHJvcGVydGllcyB3aXRoIG9sZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBzaG91bGRVcGRhdGUoX2NoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBlbGVtZW50LiBUaGlzIG1ldGhvZCByZWZsZWN0cyBwcm9wZXJ0eSB2YWx1ZXMgdG8gYXR0cmlidXRlcy5cbiAgICAgKiBJdCBjYW4gYmUgb3ZlcnJpZGRlbiB0byByZW5kZXIgYW5kIGtlZXAgdXBkYXRlZCBlbGVtZW50IERPTS5cbiAgICAgKiBTZXR0aW5nIHByb3BlcnRpZXMgaW5zaWRlIHRoaXMgbWV0aG9kIHdpbGwgKm5vdCogdHJpZ2dlclxuICAgICAqIGFub3RoZXIgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqL1xuICAgIHVwZGF0ZShfY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAvLyBVc2UgZm9yRWFjaCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgZm9yL29mIGxvb3BzIGFyZSBjb21waWxlZCB0byBmb3JcbiAgICAgICAgICAgIC8vIGxvb3BzIGV4cGVjdGluZyBhcnJheXNcbiAgICAgICAgICAgIHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzLmZvckVhY2goKHYsIGspID0+IHRoaXMuX3Byb3BlcnR5VG9BdHRyaWJ1dGUoaywgdGhpc1trXSwgdikpO1xuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdGluZ1Byb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFya1VwZGF0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuZXZlciB0aGUgZWxlbWVudCBpcyB1cGRhdGVkLiBJbXBsZW1lbnQgdG8gcGVyZm9ybVxuICAgICAqIHBvc3QtdXBkYXRpbmcgdGFza3MgdmlhIERPTSBBUElzLCBmb3IgZXhhbXBsZSwgZm9jdXNpbmcgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCB0cmlnZ2VyIHRoZSBlbGVtZW50IHRvIHVwZGF0ZVxuICAgICAqIGFnYWluIGFmdGVyIHRoaXMgdXBkYXRlIGN5Y2xlIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfY2hhbmdlZFByb3BlcnRpZXMgTWFwIG9mIGNoYW5nZWQgcHJvcGVydGllcyB3aXRoIG9sZCB2YWx1ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVkKF9jaGFuZ2VkUHJvcGVydGllcykge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGVsZW1lbnQgaXMgZmlyc3QgdXBkYXRlZC4gSW1wbGVtZW50IHRvIHBlcmZvcm0gb25lIHRpbWVcbiAgICAgKiB3b3JrIG9uIHRoZSBlbGVtZW50IGFmdGVyIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCB0cmlnZ2VyIHRoZSBlbGVtZW50IHRvIHVwZGF0ZVxuICAgICAqIGFnYWluIGFmdGVyIHRoaXMgdXBkYXRlIGN5Y2xlIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfY2hhbmdlZFByb3BlcnRpZXMgTWFwIG9mIGNoYW5nZWQgcHJvcGVydGllcyB3aXRoIG9sZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBmaXJzdFVwZGF0ZWQoX2NoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgfVxufVxuX2EgPSBmaW5hbGl6ZWQ7XG4vKipcbiAqIE1hcmtzIGNsYXNzIGFzIGhhdmluZyBmaW5pc2hlZCBjcmVhdGluZyBwcm9wZXJ0aWVzLlxuICovXG5VcGRhdGluZ0VsZW1lbnRbX2FdID0gdHJ1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwZGF0aW5nLWVsZW1lbnQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuY29uc3QgbGVnYWN5Q3VzdG9tRWxlbWVudCA9ICh0YWdOYW1lLCBjbGF6eikgPT4ge1xuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgY2xhenopO1xuICAgIC8vIENhc3QgYXMgYW55IGJlY2F1c2UgVFMgZG9lc24ndCByZWNvZ25pemUgdGhlIHJldHVybiB0eXBlIGFzIGJlaW5nIGFcbiAgICAvLyBzdWJ0eXBlIG9mIHRoZSBkZWNvcmF0ZWQgY2xhc3Mgd2hlbiBjbGF6eiBpcyB0eXBlZCBhc1xuICAgIC8vIGBDb25zdHJ1Y3RvcjxIVE1MRWxlbWVudD5gIGZvciBzb21lIHJlYXNvbi5cbiAgICAvLyBgQ29uc3RydWN0b3I8SFRNTEVsZW1lbnQ+YCBpcyBoZWxwZnVsIHRvIG1ha2Ugc3VyZSB0aGUgZGVjb3JhdG9yIGlzXG4gICAgLy8gYXBwbGllZCB0byBlbGVtZW50cyBob3dldmVyLlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICByZXR1cm4gY2xheno7XG59O1xuY29uc3Qgc3RhbmRhcmRDdXN0b21FbGVtZW50ID0gKHRhZ05hbWUsIGRlc2NyaXB0b3IpID0+IHtcbiAgICBjb25zdCB7IGtpbmQsIGVsZW1lbnRzIH0gPSBkZXNjcmlwdG9yO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAvLyBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCBvbmNlIHRoZSBjbGFzcyBpcyBvdGhlcndpc2UgZnVsbHkgZGVmaW5lZFxuICAgICAgICBmaW5pc2hlcihjbGF6eikge1xuICAgICAgICAgICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBjbGF6eik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8qKlxuICogQ2xhc3MgZGVjb3JhdG9yIGZhY3RvcnkgdGhhdCBkZWZpbmVzIHRoZSBkZWNvcmF0ZWQgY2xhc3MgYXMgYSBjdXN0b20gZWxlbWVudC5cbiAqXG4gKiBgYGBcbiAqIEBjdXN0b21FbGVtZW50KCdteS1lbGVtZW50JylcbiAqIGNsYXNzIE15RWxlbWVudCB7XG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBgO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdGFnTmFtZSBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGVsZW1lbnQgdG8gZGVmaW5lLlxuICovXG5leHBvcnQgY29uc3QgY3VzdG9tRWxlbWVudCA9ICh0YWdOYW1lKSA9PiAoY2xhc3NPckRlc2NyaXB0b3IpID0+ICh0eXBlb2YgY2xhc3NPckRlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpID9cbiAgICBsZWdhY3lDdXN0b21FbGVtZW50KHRhZ05hbWUsIGNsYXNzT3JEZXNjcmlwdG9yKSA6XG4gICAgc3RhbmRhcmRDdXN0b21FbGVtZW50KHRhZ05hbWUsIGNsYXNzT3JEZXNjcmlwdG9yKTtcbmNvbnN0IHN0YW5kYXJkUHJvcGVydHkgPSAob3B0aW9ucywgZWxlbWVudCkgPT4ge1xuICAgIC8vIFdoZW4gZGVjb3JhdGluZyBhbiBhY2Nlc3NvciwgcGFzcyBpdCB0aHJvdWdoIGFuZCBhZGQgcHJvcGVydHkgbWV0YWRhdGEuXG4gICAgLy8gTm90ZSwgdGhlIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2sgaW4gYGNyZWF0ZVByb3BlcnR5YCBlbnN1cmVzIHdlIGRvbid0XG4gICAgLy8gc3RvbXAgb3ZlciB0aGUgdXNlcidzIGFjY2Vzc29yLlxuICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdtZXRob2QnICYmIGVsZW1lbnQuZGVzY3JpcHRvciAmJlxuICAgICAgICAhKCd2YWx1ZScgaW4gZWxlbWVudC5kZXNjcmlwdG9yKSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbGVtZW50KSwgeyBmaW5pc2hlcihjbGF6eikge1xuICAgICAgICAgICAgICAgIGNsYXp6LmNyZWF0ZVByb3BlcnR5KGVsZW1lbnQua2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGVQcm9wZXJ0eSgpIHRha2VzIGNhcmUgb2YgZGVmaW5pbmcgdGhlIHByb3BlcnR5LCBidXQgd2Ugc3RpbGxcbiAgICAgICAgLy8gbXVzdCByZXR1cm4gc29tZSBraW5kIG9mIGRlc2NyaXB0b3IsIHNvIHJldHVybiBhIGRlc2NyaXB0b3IgZm9yIGFuXG4gICAgICAgIC8vIHVudXNlZCBwcm90b3R5cGUgZmllbGQuIFRoZSBmaW5pc2hlciBjYWxscyBjcmVhdGVQcm9wZXJ0eSgpLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2luZDogJ2ZpZWxkJyxcbiAgICAgICAgICAgIGtleTogU3ltYm9sKCksXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICdvd24nLFxuICAgICAgICAgICAgZGVzY3JpcHRvcjoge30sXG4gICAgICAgICAgICAvLyBXaGVuIEBiYWJlbC9wbHVnaW4tcHJvcG9zYWwtZGVjb3JhdG9ycyBpbXBsZW1lbnRzIGluaXRpYWxpemVycyxcbiAgICAgICAgICAgIC8vIGRvIHRoaXMgaW5zdGVhZCBvZiB0aGUgaW5pdGlhbGl6ZXIgYmVsb3cuIFNlZTpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9pc3N1ZXMvOTI2MCBleHRyYXM6IFtcbiAgICAgICAgICAgIC8vICAge1xuICAgICAgICAgICAgLy8gICAgIGtpbmQ6ICdpbml0aWFsaXplcicsXG4gICAgICAgICAgICAvLyAgICAgcGxhY2VtZW50OiAnb3duJyxcbiAgICAgICAgICAgIC8vICAgICBpbml0aWFsaXplcjogZGVzY3JpcHRvci5pbml0aWFsaXplcixcbiAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgLy8gXSxcbiAgICAgICAgICAgIGluaXRpYWxpemVyKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5pbml0aWFsaXplciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2VsZW1lbnQua2V5XSA9IGVsZW1lbnQuaW5pdGlhbGl6ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluaXNoZXIoY2xhenopIHtcbiAgICAgICAgICAgICAgICBjbGF6ei5jcmVhdGVQcm9wZXJ0eShlbGVtZW50LmtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IGxlZ2FjeVByb3BlcnR5ID0gKG9wdGlvbnMsIHByb3RvLCBuYW1lKSA9PiB7XG4gICAgcHJvdG8uY29uc3RydWN0b3JcbiAgICAgICAgLmNyZWF0ZVByb3BlcnR5KG5hbWUsIG9wdGlvbnMpO1xufTtcbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3Igd2hpY2ggY3JlYXRlcyBhIExpdEVsZW1lbnQgcHJvcGVydHkgd2hpY2ggcmVmbGVjdHMgYVxuICogY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUgdmFsdWUuIEEgYFByb3BlcnR5RGVjbGFyYXRpb25gIG1heSBvcHRpb25hbGx5IGJlXG4gKiBzdXBwbGllZCB0byBjb25maWd1cmUgcHJvcGVydHkgZmVhdHVyZXMuXG4gKlxuICogVGhpcyBkZWNvcmF0b3Igc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgcHVibGljIGZpZWxkcy4gUHJpdmF0ZSBvciBwcm90ZWN0ZWRcbiAqIGZpZWxkcyBzaG91bGQgdXNlIHRoZSBpbnRlcm5hbFByb3BlcnR5IGRlY29yYXRvci5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICBjbGFzcyBNeUVsZW1lbnQge1xuICogICAgICAgQHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KVxuICogICAgICAgY2xpY2tlZCA9IGZhbHNlO1xuICogICAgIH1cbiAqXG4gKiBARXhwb3J0RGVjb3JhdGVkSXRlbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5KG9wdGlvbnMpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IGRlY29yYXRvclxuICAgIHJldHVybiAocHJvdG9PckRlc2NyaXB0b3IsIG5hbWUpID0+IChuYW1lICE9PSB1bmRlZmluZWQpID9cbiAgICAgICAgbGVnYWN5UHJvcGVydHkob3B0aW9ucywgcHJvdG9PckRlc2NyaXB0b3IsIG5hbWUpIDpcbiAgICAgICAgc3RhbmRhcmRQcm9wZXJ0eShvcHRpb25zLCBwcm90b09yRGVzY3JpcHRvcik7XG59XG4vKipcbiAqIERlY2xhcmVzIGEgcHJpdmF0ZSBvciBwcm90ZWN0ZWQgcHJvcGVydHkgdGhhdCBzdGlsbCB0cmlnZ2VycyB1cGRhdGVzIHRvIHRoZVxuICogZWxlbWVudCB3aGVuIGl0IGNoYW5nZXMuXG4gKlxuICogUHJvcGVydGllcyBkZWNsYXJlZCB0aGlzIHdheSBtdXN0IG5vdCBiZSB1c2VkIGZyb20gSFRNTCBvciBIVE1MIHRlbXBsYXRpbmdcbiAqIHN5c3RlbXMsIHRoZXkncmUgc29sZWx5IGZvciBwcm9wZXJ0aWVzIGludGVybmFsIHRvIHRoZSBlbGVtZW50LiBUaGVzZVxuICogcHJvcGVydGllcyBtYXkgYmUgcmVuYW1lZCBieSBvcHRpbWl6YXRpb24gdG9vbHMgbGlrZSBjbG9zdXJlIGNvbXBpbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJuYWxQcm9wZXJ0eShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5KHsgYXR0cmlidXRlOiBmYWxzZSwgaGFzQ2hhbmdlZDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhhc0NoYW5nZWQgfSk7XG59XG4vKipcbiAqIEEgcHJvcGVydHkgZGVjb3JhdG9yIHRoYXQgY29udmVydHMgYSBjbGFzcyBwcm9wZXJ0eSBpbnRvIGEgZ2V0dGVyIHRoYXRcbiAqIGV4ZWN1dGVzIGEgcXVlcnlTZWxlY3RvciBvbiB0aGUgZWxlbWVudCdzIHJlbmRlclJvb3QuXG4gKlxuICogQHBhcmFtIHNlbGVjdG9yIEEgRE9NU3RyaW5nIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc2VsZWN0b3JzIHRvIG1hdGNoLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L3F1ZXJ5U2VsZWN0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICBjbGFzcyBNeUVsZW1lbnQge1xuICogICAgICAgQHF1ZXJ5KCcjZmlyc3QnKVxuICogICAgICAgZmlyc3Q7XG4gKlxuICogICAgICAgcmVuZGVyKCkge1xuICogICAgICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgICAgICA8ZGl2IGlkPVwiZmlyc3RcIj48L2Rpdj5cbiAqICAgICAgICAgICA8ZGl2IGlkPVwic2Vjb25kXCI+PC9kaXY+XG4gKiAgICAgICAgIGA7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChwcm90b09yRGVzY3JpcHRvciwgXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBkZWNvcmF0b3JcbiAgICBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKG5hbWUgIT09IHVuZGVmaW5lZCkgP1xuICAgICAgICAgICAgbGVnYWN5UXVlcnkoZGVzY3JpcHRvciwgcHJvdG9PckRlc2NyaXB0b3IsIG5hbWUpIDpcbiAgICAgICAgICAgIHN0YW5kYXJkUXVlcnkoZGVzY3JpcHRvciwgcHJvdG9PckRlc2NyaXB0b3IpO1xuICAgIH07XG59XG4vLyBOb3RlLCBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgZXh0ZW5kIHRoaXMgZGVjb3JhdG9yIHRvIHN1cHBvcnQgdGhlIHVzZSBjYXNlXG4vLyB3aGVyZSB0aGUgcXVlcmllZCBlbGVtZW50IG1heSBuZWVkIHRvIGRvIHdvcmsgdG8gYmVjb21lIHJlYWR5IHRvIGludGVyYWN0XG4vLyB3aXRoIChlLmcuIGxvYWQgc29tZSBpbXBsZW1lbnRhdGlvbiBjb2RlKS4gSWYgc28sIHdlIG1pZ2h0IGVsZWN0IHRvXG4vLyBhZGQgYSBzZWNvbmQgYXJndW1lbnQgZGVmaW5pbmcgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG8gbWFrZSB0aGVcbi8vIHF1ZXJpZWQgZWxlbWVudCBsb2FkZWQvdXBkYXRlZC9yZWFkeS5cbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXIgdGhhdFxuICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzdWx0IG9mIGEgcXVlcnlTZWxlY3RvciBvbiB0aGVcbiAqIGVsZW1lbnQncyByZW5kZXJSb290IGRvbmUgYWZ0ZXIgdGhlIGVsZW1lbnQncyBgdXBkYXRlQ29tcGxldGVgIHByb21pc2VcbiAqIHJlc29sdmVzLiBXaGVuIHRoZSBxdWVyaWVkIHByb3BlcnR5IG1heSBjaGFuZ2Ugd2l0aCBlbGVtZW50IHN0YXRlLCB0aGlzXG4gKiBkZWNvcmF0b3IgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiByZXF1aXJpbmcgdXNlcnMgdG8gYXdhaXQgdGhlXG4gKiBgdXBkYXRlQ29tcGxldGVgIGJlZm9yZSBhY2Nlc3NpbmcgdGhlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciBBIERPTVN0cmluZyBjb250YWluaW5nIG9uZSBvciBtb3JlIHNlbGVjdG9ycyB0byBtYXRjaC5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9xdWVyeVNlbGVjdG9yXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgY2xhc3MgTXlFbGVtZW50IHtcbiAqICAgICAgIEBxdWVyeUFzeW5jKCcjZmlyc3QnKVxuICogICAgICAgZmlyc3Q7XG4gKlxuICogICAgICAgcmVuZGVyKCkge1xuICogICAgICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgICAgICA8ZGl2IGlkPVwiZmlyc3RcIj48L2Rpdj5cbiAqICAgICAgICAgICA8ZGl2IGlkPVwic2Vjb25kXCI+PC9kaXY+XG4gKiAgICAgICAgIGA7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBleHRlcm5hbCB1c2FnZVxuICogICAgIGFzeW5jIGRvU29tZXRoaW5nV2l0aEZpcnN0KCkge1xuICogICAgICAoYXdhaXQgYU15RWxlbWVudC5maXJzdCkuZG9Tb21ldGhpbmcoKTtcbiAqICAgICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUFzeW5jKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChwcm90b09yRGVzY3JpcHRvciwgXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBkZWNvcmF0b3JcbiAgICBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBhc3luYyBnZXQoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVDb21wbGV0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJSb290LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAobmFtZSAhPT0gdW5kZWZpbmVkKSA/XG4gICAgICAgICAgICBsZWdhY3lRdWVyeShkZXNjcmlwdG9yLCBwcm90b09yRGVzY3JpcHRvciwgbmFtZSkgOlxuICAgICAgICAgICAgc3RhbmRhcmRRdWVyeShkZXNjcmlwdG9yLCBwcm90b09yRGVzY3JpcHRvcik7XG4gICAgfTtcbn1cbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXJcbiAqIHRoYXQgZXhlY3V0ZXMgYSBxdWVyeVNlbGVjdG9yQWxsIG9uIHRoZSBlbGVtZW50J3MgcmVuZGVyUm9vdC5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgQSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2guXG4gKlxuICogU2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L3F1ZXJ5U2VsZWN0b3JBbGxcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICBjbGFzcyBNeUVsZW1lbnQge1xuICogICAgICAgQHF1ZXJ5QWxsKCdkaXYnKVxuICogICAgICAgZGl2cztcbiAqXG4gKiAgICAgICByZW5kZXIoKSB7XG4gKiAgICAgICAgIHJldHVybiBodG1sYFxuICogICAgICAgICAgIDxkaXYgaWQ9XCJmaXJzdFwiPjwvZGl2PlxuICogICAgICAgICAgIDxkaXYgaWQ9XCJzZWNvbmRcIj48L2Rpdj5cbiAqICAgICAgICAgYDtcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiAocHJvdG9PckRlc2NyaXB0b3IsIFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgZGVjb3JhdG9yXG4gICAgbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJvb3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChuYW1lICE9PSB1bmRlZmluZWQpID9cbiAgICAgICAgICAgIGxlZ2FjeVF1ZXJ5KGRlc2NyaXB0b3IsIHByb3RvT3JEZXNjcmlwdG9yLCBuYW1lKSA6XG4gICAgICAgICAgICBzdGFuZGFyZFF1ZXJ5KGRlc2NyaXB0b3IsIHByb3RvT3JEZXNjcmlwdG9yKTtcbiAgICB9O1xufVxuY29uc3QgbGVnYWN5UXVlcnkgPSAoZGVzY3JpcHRvciwgcHJvdG8sIG5hbWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIGRlc2NyaXB0b3IpO1xufTtcbmNvbnN0IHN0YW5kYXJkUXVlcnkgPSAoZGVzY3JpcHRvciwgZWxlbWVudCkgPT4gKHtcbiAgICBraW5kOiAnbWV0aG9kJyxcbiAgICBwbGFjZW1lbnQ6ICdwcm90b3R5cGUnLFxuICAgIGtleTogZWxlbWVudC5rZXksXG4gICAgZGVzY3JpcHRvcixcbn0pO1xuY29uc3Qgc3RhbmRhcmRFdmVudE9wdGlvbnMgPSAob3B0aW9ucywgZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnQpLCB7IGZpbmlzaGVyKGNsYXp6KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNsYXp6LnByb3RvdHlwZVtlbGVtZW50LmtleV0sIG9wdGlvbnMpO1xuICAgICAgICB9IH0pO1xufTtcbmNvbnN0IGxlZ2FjeUV2ZW50T3B0aW9ucyA9IFxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBsZWdhY3kgZGVjb3JhdG9yXG4ob3B0aW9ucywgcHJvdG8sIG5hbWUpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKHByb3RvW25hbWVdLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgb3B0aW9ucyB0byBhIG1ldGhvZCB1c2VkIGFzIGFuIGV2ZW50IGxpc3RlbmVyIGluIGFcbiAqIGxpdC1odG1sIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBldmVudCBsaXN0ZW5lciBvcHRpb25zIGFzIGFjY2VwdGVkIGJ5XG4gKiBgRXZlbnRUYXJnZXQjYWRkRXZlbnRMaXN0ZW5lcmAgYW5kIGBFdmVudFRhcmdldCNyZW1vdmVFdmVudExpc3RlbmVyYC5cbiAqXG4gKiBDdXJyZW50IGJyb3dzZXJzIHN1cHBvcnQgdGhlIGBjYXB0dXJlYCwgYHBhc3NpdmVgLCBhbmQgYG9uY2VgIG9wdGlvbnMuIFNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1BhcmFtZXRlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICBjbGFzcyBNeUVsZW1lbnQge1xuICogICAgICAgY2xpY2tlZCA9IGZhbHNlO1xuICpcbiAqICAgICAgIHJlbmRlcigpIHtcbiAqICAgICAgICAgcmV0dXJuIGh0bWxgXG4gKiAgICAgICAgICAgPGRpdiBAY2xpY2s9JHt0aGlzLl9vbkNsaWNrfWA+XG4gKiAgICAgICAgICAgICA8YnV0dG9uPjwvYnV0dG9uPlxuICogICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICBgO1xuICogICAgICAgfVxuICpcbiAqICAgICAgIEBldmVudE9wdGlvbnMoe2NhcHR1cmU6IHRydWV9KVxuICogICAgICAgX29uQ2xpY2soZSkge1xuICogICAgICAgICB0aGlzLmNsaWNrZWQgPSB0cnVlO1xuICogICAgICAgfVxuICogICAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgLy8gUmV0dXJuIHZhbHVlIHR5cGVkIGFzIGFueSB0byBwcmV2ZW50IFR5cGVTY3JpcHQgZnJvbSBjb21wbGFpbmluZyB0aGF0XG4gICAgLy8gc3RhbmRhcmQgZGVjb3JhdG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBUeXBlU2NyaXB0IGRlY29yYXRvclxuICAgIC8vIHNpZ25hdHVyZVxuICAgIC8vIFRPRE8oa3NjaGFhZik6IHVuY2xlYXIgd2h5IGl0IHdhcyBvbmx5IGZhaWxpbmcgb24gdGhpcyBkZWNvcmF0b3IgYW5kIG5vdFxuICAgIC8vIHRoZSBvdGhlcnNcbiAgICByZXR1cm4gKChwcm90b09yRGVzY3JpcHRvciwgbmFtZSkgPT4gKG5hbWUgIT09IHVuZGVmaW5lZCkgP1xuICAgICAgICBsZWdhY3lFdmVudE9wdGlvbnMob3B0aW9ucywgcHJvdG9PckRlc2NyaXB0b3IsIG5hbWUpIDpcbiAgICAgICAgc3RhbmRhcmRFdmVudE9wdGlvbnMob3B0aW9ucywgcHJvdG9PckRlc2NyaXB0b3IpKTtcbn1cbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXIgdGhhdFxuICogcmV0dXJucyB0aGUgYGFzc2lnbmVkTm9kZXNgIG9mIHRoZSBnaXZlbiBuYW1lZCBgc2xvdGAuIE5vdGUsIHRoZSB0eXBlIG9mXG4gKiB0aGlzIHByb3BlcnR5IHNob3VsZCBiZSBhbm5vdGF0ZWQgYXMgYE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+YC5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUFzc2lnbmVkTm9kZXMoc2xvdE5hbWUgPSAnJywgZmxhdHRlbiA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIChwcm90b09yRGVzY3JpcHRvciwgXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBkZWNvcmF0b3JcbiAgICBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBgc2xvdCR7c2xvdE5hbWUgPyBgW25hbWU9JHtzbG90TmFtZX1dYCA6ICcnfWA7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdCA9IHRoaXMucmVuZGVyUm9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2xvdCAmJiBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAobmFtZSAhPT0gdW5kZWZpbmVkKSA/XG4gICAgICAgICAgICBsZWdhY3lRdWVyeShkZXNjcmlwdG9yLCBwcm90b09yRGVzY3JpcHRvciwgbmFtZSkgOlxuICAgICAgICAgICAgc3RhbmRhcmRRdWVyeShkZXNjcmlwdG9yLCBwcm90b09yRGVzY3JpcHRvcik7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29yYXRvcnMuanMubWFwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE5IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmVcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0IENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzXG5wYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbyBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50XG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzID0gKCdhZG9wdGVkU3R5bGVTaGVldHMnIGluIERvY3VtZW50LnByb3RvdHlwZSkgJiZcbiAgICAoJ3JlcGxhY2UnIGluIENTU1N0eWxlU2hlZXQucHJvdG90eXBlKTtcbmNvbnN0IGNvbnN0cnVjdGlvblRva2VuID0gU3ltYm9sKCk7XG5leHBvcnQgY2xhc3MgQ1NTUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcihjc3NUZXh0LCBzYWZlVG9rZW4pIHtcbiAgICAgICAgaWYgKHNhZmVUb2tlbiAhPT0gY29uc3RydWN0aW9uVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NTUmVzdWx0IGlzIG5vdCBjb25zdHJ1Y3RhYmxlLiBVc2UgYHVuc2FmZUNTU2Agb3IgYGNzc2AgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNzc1RleHQgPSBjc3NUZXh0O1xuICAgIH1cbiAgICAvLyBOb3RlLCB0aGlzIGlzIGEgZ2V0dGVyIHNvIHRoYXQgaXQncyBsYXp5LiBJbiBwcmFjdGljZSwgdGhpcyBtZWFuc1xuICAgIC8vIHN0eWxlc2hlZXRzIGFyZSBub3QgY3JlYXRlZCB1bnRpbCB0aGUgZmlyc3QgZWxlbWVudCBpbnN0YW5jZSBpcyBtYWRlLlxuICAgIGdldCBzdHlsZVNoZWV0KCkge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGVTaGVldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBOb3RlLCBpZiBgYWRvcHRlZFN0eWxlU2hlZXRzYCBpcyBzdXBwb3J0ZWQgdGhlbiB3ZSBhc3N1bWUgQ1NTU3R5bGVTaGVldFxuICAgICAgICAgICAgLy8gaXMgY29uc3RydWN0YWJsZS5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZVNoZWV0ID0gbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZVNoZWV0LnJlcGxhY2VTeW5jKHRoaXMuY3NzVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZVNoZWV0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVTaGVldDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzc1RleHQ7XG4gICAgfVxufVxuLyoqXG4gKiBXcmFwIGEgdmFsdWUgZm9yIGludGVycG9sYXRpb24gaW4gYSBjc3MgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWwuXG4gKlxuICogVGhpcyBpcyB1bnNhZmUgYmVjYXVzZSB1bnRydXN0ZWQgQ1NTIHRleHQgY2FuIGJlIHVzZWQgdG8gcGhvbmUgaG9tZVxuICogb3IgZXhmaWx0cmF0ZSBkYXRhIHRvIGFuIGF0dGFja2VyIGNvbnRyb2xsZWQgc2l0ZS4gVGFrZSBjYXJlIHRvIG9ubHkgdXNlXG4gKiB0aGlzIHdpdGggdHJ1c3RlZCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuc2FmZUNTUyA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBuZXcgQ1NTUmVzdWx0KFN0cmluZyh2YWx1ZSksIGNvbnN0cnVjdGlvblRva2VuKTtcbn07XG5jb25zdCB0ZXh0RnJvbUNTU1Jlc3VsdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENTU1Jlc3VsdCkge1xuICAgICAgICByZXR1cm4gdmFsdWUuY3NzVGV4dDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIHBhc3NlZCB0byAnY3NzJyBmdW5jdGlvbiBtdXN0IGJlIGEgJ2NzcycgZnVuY3Rpb24gcmVzdWx0OiAke3ZhbHVlfS4gVXNlICd1bnNhZmVDU1MnIHRvIHBhc3Mgbm9uLWxpdGVyYWwgdmFsdWVzLCBidXRcbiAgICAgICAgICAgIHRha2UgY2FyZSB0byBlbnN1cmUgcGFnZSBzZWN1cml0eS5gKTtcbiAgICB9XG59O1xuLyoqXG4gKiBUZW1wbGF0ZSB0YWcgd2hpY2ggd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCBMaXRFbGVtZW50J3MgYHN0eWxlYCBwcm9wZXJ0eSB0b1xuICogc2V0IGVsZW1lbnQgc3R5bGVzLiBGb3Igc2VjdXJpdHkgcmVhc29ucywgb25seSBsaXRlcmFsIHN0cmluZyB2YWx1ZXMgbWF5IGJlXG4gKiB1c2VkLiBUbyBpbmNvcnBvcmF0ZSBub24tbGl0ZXJhbCB2YWx1ZXMgYHVuc2FmZUNTU2AgbWF5IGJlIHVzZWQgaW5zaWRlIGFcbiAqIHRlbXBsYXRlIHN0cmluZyBwYXJ0LlxuICovXG5leHBvcnQgY29uc3QgY3NzID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4ge1xuICAgIGNvbnN0IGNzc1RleHQgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHYsIGlkeCkgPT4gYWNjICsgdGV4dEZyb21DU1NSZXN1bHQodikgKyBzdHJpbmdzW2lkeCArIDFdLCBzdHJpbmdzWzBdKTtcbiAgICByZXR1cm4gbmV3IENTU1Jlc3VsdChjc3NUZXh0LCBjb25zdHJ1Y3Rpb25Ub2tlbik7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzLXRhZy5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5pbXBvcnQgeyByZW5kZXIgfSBmcm9tICdsaXQtaHRtbC9saWIvc2hhZHktcmVuZGVyLmpzJztcbmltcG9ydCB7IFVwZGF0aW5nRWxlbWVudCB9IGZyb20gJy4vbGliL3VwZGF0aW5nLWVsZW1lbnQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvdXBkYXRpbmctZWxlbWVudC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9kZWNvcmF0b3JzLmpzJztcbmV4cG9ydCB7IGh0bWwsIHN2ZywgVGVtcGxhdGVSZXN1bHQsIFNWR1RlbXBsYXRlUmVzdWx0IH0gZnJvbSAnbGl0LWh0bWwvbGl0LWh0bWwuanMnO1xuaW1wb3J0IHsgc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzIH0gZnJvbSAnLi9saWIvY3NzLXRhZy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9jc3MtdGFnLmpzJztcbi8vIElNUE9SVEFOVDogZG8gbm90IGNoYW5nZSB0aGUgcHJvcGVydHkgbmFtZSBvciB0aGUgYXNzaWdubWVudCBleHByZXNzaW9uLlxuLy8gVGhpcyBsaW5lIHdpbGwgYmUgdXNlZCBpbiByZWdleGVzIHRvIHNlYXJjaCBmb3IgTGl0RWxlbWVudCB1c2FnZS5cbi8vIFRPRE8oanVzdGluZmFnbmFuaSk6IGluamVjdCB2ZXJzaW9uIG51bWJlciBhdCBidWlsZCB0aW1lXG4od2luZG93WydsaXRFbGVtZW50VmVyc2lvbnMnXSB8fCAod2luZG93WydsaXRFbGVtZW50VmVyc2lvbnMnXSA9IFtdKSlcbiAgICAucHVzaCgnMi4zLjEnKTtcbi8qKlxuICogU2VudGluYWwgdmFsdWUgdXNlZCB0byBhdm9pZCBjYWxsaW5nIGxpdC1odG1sJ3MgcmVuZGVyIGZ1bmN0aW9uIHdoZW5cbiAqIHN1YmNsYXNzZXMgZG8gbm90IGltcGxlbWVudCBgcmVuZGVyYFxuICovXG5jb25zdCByZW5kZXJOb3RJbXBsZW1lbnRlZCA9IHt9O1xuZXhwb3J0IGNsYXNzIExpdEVsZW1lbnQgZXh0ZW5kcyBVcGRhdGluZ0VsZW1lbnQge1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYXJyYXkgb2Ygc3R5bGVzIHRvIGFwcGx5IHRvIHRoZSBlbGVtZW50LlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGludGVncmF0ZSBpbnRvIGEgc3R5bGUgbWFuYWdlbWVudCBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTdHlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlcztcbiAgICB9XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgc3RhdGljIF9nZXRVbmlxdWVTdHlsZXMoKSB7XG4gICAgICAgIC8vIE9ubHkgZ2F0aGVyIHN0eWxlcyBvbmNlIHBlciBjbGFzc1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfc3R5bGVzJywgdGhpcykpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFrZSBjYXJlIG5vdCB0byBjYWxsIGB0aGlzLmdldFN0eWxlcygpYCBtdWx0aXBsZSB0aW1lcyBzaW5jZSB0aGlzXG4gICAgICAgIC8vIGdlbmVyYXRlcyBuZXcgQ1NTUmVzdWx0cyBlYWNoIHRpbWUuXG4gICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IFNpbmNlIHdlIGRvIG5vdCBjYWNoZSBDU1NSZXN1bHRzIGJ5IGlucHV0LCBhbnlcbiAgICAgICAgLy8gc2hhcmVkIHN0eWxlcyB3aWxsIGdlbmVyYXRlIG5ldyBzdHlsZXNoZWV0IG9iamVjdHMsIHdoaWNoIGlzIHdhc3RlZnVsLlxuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhZGRyZXNzZWQgd2hlbiBhIGJyb3dzZXIgc2hpcHMgY29uc3RydWN0YWJsZVxuICAgICAgICAvLyBzdHlsZXNoZWV0cy5cbiAgICAgICAgY29uc3QgdXNlclN0eWxlcyA9IHRoaXMuZ2V0U3R5bGVzKCk7XG4gICAgICAgIGlmICh1c2VyU3R5bGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodXNlclN0eWxlcykpIHtcbiAgICAgICAgICAgIC8vIERlLWR1cGxpY2F0ZSBzdHlsZXMgcHJlc2VydmluZyB0aGUgX2xhc3RfIGluc3RhbmNlIGluIHRoZSBzZXQuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRvIGF2b2lkIGR1cGxpY2F0ZWQgc3R5bGVzIHRoYXQgY2FuXG4gICAgICAgICAgICAvLyBvY2N1ciBlc3BlY2lhbGx5IHdoZW4gY29tcG9zaW5nIHZpYSBzdWJjbGFzc2luZy5cbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IGl0ZW0gaXMga2VwdCB0byB0cnkgdG8gcHJlc2VydmUgdGhlIGNhc2NhZGUgb3JkZXIgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGFzc3VtcHRpb24gdGhhdCBpdCdzIG1vc3QgaW1wb3J0YW50IHRoYXQgbGFzdCBhZGRlZCBzdHlsZXMgb3ZlcnJpZGVcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHN0eWxlcy5cbiAgICAgICAgICAgIGNvbnN0IGFkZFN0eWxlcyA9IChzdHlsZXMsIHNldCkgPT4gc3R5bGVzLnJlZHVjZVJpZ2h0KChzZXQsIHMpID0+IFxuICAgICAgICAgICAgLy8gTm90ZTogT24gSUUgc2V0LmFkZCgpIGRvZXMgbm90IHJldHVybiB0aGUgc2V0XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHMpID8gYWRkU3R5bGVzKHMsIHNldCkgOiAoc2V0LmFkZChzKSwgc2V0KSwgc2V0KTtcbiAgICAgICAgICAgIC8vIEFycmF5LmZyb20gZG9lcyBub3Qgd29yayBvbiBTZXQgaW4gSUUsIG90aGVyd2lzZSByZXR1cm5cbiAgICAgICAgICAgIC8vIEFycmF5LmZyb20oYWRkU3R5bGVzKHVzZXJTdHlsZXMsIG5ldyBTZXQ8Q1NTUmVzdWx0PigpKSkucmV2ZXJzZSgpXG4gICAgICAgICAgICBjb25zdCBzZXQgPSBhZGRTdHlsZXModXNlclN0eWxlcywgbmV3IFNldCgpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgICAgICAgICAgc2V0LmZvckVhY2goKHYpID0+IHN0eWxlcy51bnNoaWZ0KHYpKTtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlcyA9IFt1c2VyU3R5bGVzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBlbGVtZW50IGluaXRpYWxpemF0aW9uLiBCeSBkZWZhdWx0IHRoaXMgY2FsbHMgYGNyZWF0ZVJlbmRlclJvb3RgXG4gICAgICogdG8gY3JlYXRlIHRoZSBlbGVtZW50IGByZW5kZXJSb290YCBub2RlIGFuZCBjYXB0dXJlcyBhbnkgcHJlLXNldCB2YWx1ZXMgZm9yXG4gICAgICogcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0VW5pcXVlU3R5bGVzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUm9vdCA9XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVJlbmRlclJvb3QoKTtcbiAgICAgICAgLy8gTm90ZSwgaWYgcmVuZGVyUm9vdCBpcyBub3QgYSBzaGFkb3dSb290LCBzdHlsZXMgd291bGQvY291bGQgYXBwbHkgdG8gdGhlXG4gICAgICAgIC8vIGVsZW1lbnQncyBnZXRSb290Tm9kZSgpLiBXaGlsZSB0aGlzIGNvdWxkIGJlIGRvbmUsIHdlJ3JlIGNob29zaW5nIG5vdCB0b1xuICAgICAgICAvLyBzdXBwb3J0IHRoaXMgbm93IHNpbmNlIGl0IHdvdWxkIHJlcXVpcmUgZGlmZmVyZW50IGxvZ2ljIGFyb3VuZCBkZS1kdXBpbmcuXG4gICAgICAgIGlmICh3aW5kb3cuU2hhZG93Um9vdCAmJiB0aGlzLnJlbmRlclJvb3QgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdGhpcy5hZG9wdFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5vZGUgaW50byB3aGljaCB0aGUgZWxlbWVudCBzaG91bGQgcmVuZGVyIGFuZCBieSBkZWZhdWx0XG4gICAgICogY3JlYXRlcyBhbmQgcmV0dXJucyBhbiBvcGVuIHNoYWRvd1Jvb3QuIEltcGxlbWVudCB0byBjdXN0b21pemUgd2hlcmUgdGhlXG4gICAgICogZWxlbWVudCdzIERPTSBpcyByZW5kZXJlZC4gRm9yIGV4YW1wbGUsIHRvIHJlbmRlciBpbnRvIHRoZSBlbGVtZW50J3NcbiAgICAgKiBjaGlsZE5vZGVzLCByZXR1cm4gYHRoaXNgLlxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IFJldHVybnMgYSBub2RlIGludG8gd2hpY2ggdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIGNyZWF0ZVJlbmRlclJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBzdHlsaW5nIHRvIHRoZSBlbGVtZW50IHNoYWRvd1Jvb3QgdXNpbmcgdGhlIGBzdGF0aWMgZ2V0IHN0eWxlc2BcbiAgICAgKiBwcm9wZXJ0eS4gU3R5bGluZyB3aWxsIGFwcGx5IHVzaW5nIGBzaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0c2Agd2hlcmVcbiAgICAgKiBhdmFpbGFibGUgYW5kIHdpbGwgZmFsbGJhY2sgb3RoZXJ3aXNlLiBXaGVuIFNoYWRvdyBET00gaXMgcG9seWZpbGxlZCxcbiAgICAgKiBTaGFkeUNTUyBzY29wZXMgc3R5bGVzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGRvY3VtZW50LiBXaGVuIFNoYWRvdyBET01cbiAgICAgKiBpcyBhdmFpbGFibGUgYnV0IGBhZG9wdGVkU3R5bGVTaGVldHNgIGlzIG5vdCwgc3R5bGVzIGFyZSBhcHBlbmRlZCB0byB0aGVcbiAgICAgKiBlbmQgb2YgdGhlIGBzaGFkb3dSb290YCB0byBbbWltaWMgc3BlY1xuICAgICAqIGJlaGF2aW9yXShodHRwczovL3dpY2cuZ2l0aHViLmlvL2NvbnN0cnVjdC1zdHlsZXNoZWV0cy8jdXNpbmctY29uc3RydWN0ZWQtc3R5bGVzaGVldHMpLlxuICAgICAqL1xuICAgIGFkb3B0U3R5bGVzKCkge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLmNvbnN0cnVjdG9yLl9zdHlsZXM7XG4gICAgICAgIGlmIChzdHlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlcmUgYXJlIHRocmVlIHNlcGFyYXRlIGNhc2VzIGhlcmUgYmFzZWQgb24gU2hhZG93IERPTSBzdXBwb3J0LlxuICAgICAgICAvLyAoMSkgc2hhZG93Um9vdCBwb2x5ZmlsbGVkOiB1c2UgU2hhZHlDU1NcbiAgICAgICAgLy8gKDIpIHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzIGF2YWlsYWJsZTogdXNlIGl0LlxuICAgICAgICAvLyAoMykgc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHMgcG9seWZpbGxlZDogYXBwZW5kIHN0eWxlcyBhZnRlclxuICAgICAgICAvLyByZW5kZXJpbmdcbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAhPT0gdW5kZWZpbmVkICYmICF3aW5kb3cuU2hhZHlDU1MubmF0aXZlU2hhZG93KSB7XG4gICAgICAgICAgICB3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0ucHJlcGFyZUFkb3B0ZWRDc3NUZXh0KHN0eWxlcy5tYXAoKHMpID0+IHMuY3NzVGV4dCksIHRoaXMubG9jYWxOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPVxuICAgICAgICAgICAgICAgIHN0eWxlcy5tYXAoKHMpID0+IHMuc3R5bGVTaGVldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIG11c3QgYmUgZG9uZSBhZnRlciByZW5kZXJpbmcgc28gdGhlIGFjdHVhbCBzdHlsZSBpbnNlcnRpb24gaXMgZG9uZVxuICAgICAgICAgICAgLy8gaW4gYHVwZGF0ZWAuXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1NoaW1BZG9wdGVkU3R5bGVTaGVldHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICAvLyBOb3RlLCBmaXJzdCB1cGRhdGUvcmVuZGVyIGhhbmRsZXMgc3R5bGVFbGVtZW50IHNvIHdlIG9ubHkgY2FsbCB0aGlzIGlmXG4gICAgICAgIC8vIGNvbm5lY3RlZCBhZnRlciBmaXJzdCB1cGRhdGUuXG4gICAgICAgIGlmICh0aGlzLmhhc1VwZGF0ZWQgJiYgd2luZG93LlNoYWR5Q1NTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZUVsZW1lbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZWxlbWVudC4gVGhpcyBtZXRob2QgcmVmbGVjdHMgcHJvcGVydHkgdmFsdWVzIHRvIGF0dHJpYnV0ZXNcbiAgICAgKiBhbmQgY2FsbHMgYHJlbmRlcmAgdG8gcmVuZGVyIERPTSB2aWEgbGl0LWh0bWwuIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGVcbiAgICAgKiB0aGlzIG1ldGhvZCB3aWxsICpub3QqIHRyaWdnZXIgYW5vdGhlciB1cGRhdGUuXG4gICAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqL1xuICAgIHVwZGF0ZShjaGFuZ2VkUHJvcGVydGllcykge1xuICAgICAgICAvLyBTZXR0aW5nIHByb3BlcnRpZXMgaW4gYHJlbmRlcmAgc2hvdWxkIG5vdCB0cmlnZ2VyIGFuIHVwZGF0ZS4gU2luY2VcbiAgICAgICAgLy8gdXBkYXRlcyBhcmUgYWxsb3dlZCBhZnRlciBzdXBlci51cGRhdGUsIGl0J3MgaW1wb3J0YW50IHRvIGNhbGwgYHJlbmRlcmBcbiAgICAgICAgLy8gYmVmb3JlIHRoYXQuXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlUmVzdWx0ID0gdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgc3VwZXIudXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgLy8gSWYgcmVuZGVyIGlzIG5vdCBpbXBsZW1lbnRlZCBieSB0aGUgY29tcG9uZW50LCBkb24ndCBjYWxsIGxpdC1odG1sIHJlbmRlclxuICAgICAgICBpZiAodGVtcGxhdGVSZXN1bHQgIT09IHJlbmRlck5vdEltcGxlbWVudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgLnJlbmRlcih0ZW1wbGF0ZVJlc3VsdCwgdGhpcy5yZW5kZXJSb290LCB7IHNjb3BlTmFtZTogdGhpcy5sb2NhbE5hbWUsIGV2ZW50Q29udGV4dDogdGhpcyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIG5hdGl2ZSBTaGFkb3cgRE9NIGlzIHVzZWQgYnV0IGFkb3B0ZWRTdHlsZXMgYXJlIG5vdCBzdXBwb3J0ZWQsXG4gICAgICAgIC8vIGluc2VydCBzdHlsaW5nIGFmdGVyIHJlbmRlcmluZyB0byBlbnN1cmUgYWRvcHRlZFN0eWxlcyBoYXZlIGhpZ2hlc3RcbiAgICAgICAgLy8gcHJpb3JpdHkuXG4gICAgICAgIGlmICh0aGlzLl9uZWVkc1NoaW1BZG9wdGVkU3R5bGVTaGVldHMpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzU2hpbUFkb3B0ZWRTdHlsZVNoZWV0cyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fc3R5bGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBzLmNzc1RleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSb290LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gZWFjaCB1cGRhdGUgdG8gcGVyZm9ybSByZW5kZXJpbmcgdGFza3MuIFRoaXMgbWV0aG9kIG1heSByZXR1cm5cbiAgICAgKiBhbnkgdmFsdWUgcmVuZGVyYWJsZSBieSBsaXQtaHRtbCdzIE5vZGVQYXJ0IC0gdHlwaWNhbGx5IGEgVGVtcGxhdGVSZXN1bHQuXG4gICAgICogU2V0dGluZyBwcm9wZXJ0aWVzIGluc2lkZSB0aGlzIG1ldGhvZCB3aWxsICpub3QqIHRyaWdnZXIgdGhlIGVsZW1lbnQgdG9cbiAgICAgKiB1cGRhdGUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gcmVuZGVyTm90SW1wbGVtZW50ZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhpcyBjbGFzcyBpcyBtYXJrZWQgYXMgYGZpbmFsaXplZGAgYXMgYW4gb3B0aW1pemF0aW9uIGVuc3VyaW5nXG4gKiBpdCB3aWxsIG5vdCBuZWVkbGVzc2x5IHRyeSB0byBgZmluYWxpemVgLlxuICpcbiAqIE5vdGUgdGhpcyBwcm9wZXJ0eSBuYW1lIGlzIGEgc3RyaW5nIHRvIHByZXZlbnQgYnJlYWtpbmcgQ2xvc3VyZSBKUyBDb21waWxlclxuICogb3B0aW1pemF0aW9ucy4gU2VlIHVwZGF0aW5nLWVsZW1lbnQudHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbkxpdEVsZW1lbnRbJ2ZpbmFsaXplZCddID0gdHJ1ZTtcbi8qKlxuICogUmVuZGVyIG1ldGhvZCB1c2VkIHRvIHJlbmRlciB0aGUgdmFsdWUgdG8gdGhlIGVsZW1lbnQncyBET00uXG4gKiBAcGFyYW0gcmVzdWx0IFRoZSB2YWx1ZSB0byByZW5kZXIuXG4gKiBAcGFyYW0gY29udGFpbmVyIE5vZGUgaW50byB3aGljaCB0byByZW5kZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyBFbGVtZW50IG5hbWUuXG4gKiBAbm9jb2xsYXBzZVxuICovXG5MaXRFbGVtZW50LnJlbmRlciA9IHJlbmRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdC1lbGVtZW50LmpzLm1hcCIsIi8vaW1wb3J0ICBldmUgZnJvbSAnZXZlanMvZGlzdC9ldmUuY3VzdG9tLmpzJztcclxuXHJcbmZ1bmN0aW9uIEhlbGxvQWdlbnQoaWQpe1xyXG4gIC8vIGV4ZWN1dGUgc3VwZXIgY29uc3RydWN0b3JcclxuICBldmUuQWdlbnQuY2FsbCh0aGlzLCBpZCk7XHJcbiAgLy8gY29ubmVjdCB0byBhbGwgdHJhbnNwb3J0cyBjb25maWd1cmVkIGJ5IHRoZSBzeXN0ZW1cclxuICB0aGlzLmNvbm5lY3QoZXZlLnN5c3RlbS50cmFuc3BvcnRzLmdldEFsbCgpKTtcclxufVxyXG5cclxuLy8gZXh0ZW5kIHRoZSBldmUuQWdlbnQgcHJvdG90eXBlXHJcbkhlbGxvQWdlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShldmUuQWdlbnQucHJvdG90eXBlKTtcclxuSGVsbG9BZ2VudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZWxsb0FnZW50O1xyXG5IZWxsb0FnZW50LnByb3RvdHlwZS5zYXlIZWxsbyA9IGZ1bmN0aW9uKHRvKSB7XHJcbiAgdGhpcy5zZW5kKHRvLCAnSGVsbG8gJyArIHRvICsgJyEnKTtcclxufTtcclxuXHJcbkhlbGxvQWdlbnQucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgLy9zbG9nKHRoaXMuaWQrXCIgcmVjZWl2ZWQgZnJvbSA6XCIrZnJvbSArICcgdGhpcyBtZXNzYWdlOiAnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xyXG4gIGNvbnNvbGUubG9nKHRoaXMuaWQrXCIgcmVjZWl2ZWQgZnJvbSA6XCIrZnJvbSArICcgdGhpcyBtZXNzYWdlOiAnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xyXG4gIGlmIChKU09OLnN0cmluZ2lmeShtZXNzYWdlKS5pbmRleE9mKCdIZWxsbycpID09PSAwKSB7XHJcbiAgICAvLyByZXBseSB0byB0aGUgZ3JlZXRpbmdcclxuICAgIHRoaXMuc2VuZChmcm9tLCAnSGkgJyArIGZyb20gKyAnLCBuaWNlIHRvIG1lZXQgeW91IScpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5IZWxsb0FnZW50LnByb3RvdHlwZS5icm9hZGNhc3QgPSBmdW5jdGlvbihtZXNzYWdlKXtcclxuICB2YXIgbWUgPSB0aGlzXHJcbiAgdmFyIGFsbEFnZW50cyA9IE9iamVjdC5rZXlzKHRoaXMuY29ubmVjdGlvbnNbMF0udHJhbnNwb3J0LmFnZW50cyk7XHJcbiBjb25zb2xlLmxvZyhhbGxBZ2VudHMpXHJcbiAgYWxsQWdlbnRzLmZvckVhY2goZnVuY3Rpb24gKGFnZW50KXtcclxuICAgIG1lLnNlbmQoYWdlbnQsIG1lc3NhZ2UpO1xyXG4gIH0pXHJcbn1cclxuXHJcbkhlbGxvQWdlbnQucHJvdG90eXBlLnNlbmRNdWx0aSA9IGZ1bmN0aW9uKHJlY2lwaWVudHMsIG1lc3NhZ2Upe1xyXG4gIHZhciBtZSA9IHRoaXNcclxuICByZWNpcGllbnRzLmZvckVhY2goZnVuY3Rpb24gKGFnZW50KXtcclxuICAvLyAgY29uc29sZS5sb2coYWdlbnQsIG1lc3NhZ2UpXHJcbiAgICBtZS5zZW5kKGFnZW50LCBtZXNzYWdlKTtcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQge0hlbGxvQWdlbnR9O1xyXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcclxuXHJcbmNsYXNzIEFwcFZpZXcgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGRlYnVnOiB7dHlwZTogQm9vbGVhbn0sXHJcbiAgICAgIHNoYXJlOiB7dHlwZTogT2JqZWN0fSxcclxuICAgICAgcGFuZWw6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICB3ZWJJZDoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIHF1ZXJ5OiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgcGFuZWxzOiB7dHlwZTogQXJyYXl9LFxyXG4gICAgICBhZ29yYVBvZDoge3R5cGU6IFN0cmluZ31cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIkFwcFwiXHJcbiAgICB0aGlzLmRlYnVnID0gZmFsc2VcclxuICAgIHRoaXMud2ViSWQgPSBudWxsXHJcbiAgICB0aGlzLnF1ZXJ5ID0gbnVsbFxyXG4gICAgdGhpcy5zaGFyZSA9IHt9XHJcbiAgICB0aGlzLmFnb3JhUG9kID0gXCJodHRwczovL2Fnb3JhLnNvbGlkLmNvbW11bml0eS9wcm9maWxlL2NhcmQjbWVcIlxyXG4gICAgdGhpcy5wYW5lbCA9IFwiRmxvd1wiXHJcbiAgICB0aGlzLnBhbmVscyA9IFtcclxuICAgICAge25hbWU6IFwiRmxvd1wiLCBpbWFnZTogXCIuL2ltZy9mbG93LnBuZ1wiLCB0ZXh0OlwiU2hvdyBQdWJsaWMsIEdyb3VwICYgUGVyc29ubmFsIEFjdGl2aXRpZXMuXCJ9LFxyXG4gICAgICB7bmFtZTogXCJDb21wb3NlXCIsIGltYWdlOiBcIi4vaW1nL2NvbXBvc2UucG5nXCIsIHRleHQ6XCJDcmVhdGUgJiBjb21wb3NlIG5ldyBOb3RlcywgTWVkaWFzLCBUcmlwbGVzICYgR3JhcGhzIVwifSxcclxuICAgICAge25hbWU6IFwiT3JnYW5pemF0aW9uXCIsIGltYWdlOiBcIi4vaW1nL29yZ2EucG5nXCIsIHRleHQ6XCJCdWlsZCBUZWFtcyB0byBjb2xsYWJvcmF0ZSBvbiBwcm9qZWN0cy5cIn0sXHJcbiAgICAgIHtuYW1lOiBcIlRhbGtcIiwgaW1hZ2U6IFwiLi9pbWcvdGFsay5wbmdcIiwgdGV4dDpcIkEgc3BhY2UgdG8gcmVhbHRpbWUgZXhjaGFuZ2VzISAoVE9ETylcIn1dXHJcbiAgICAgIHRoaXMub25Mb2FkKClcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCl7XHJcbiAgICAgIHJldHVybiBodG1sYFxyXG4gICAgICA8bGluayBocmVmPVwiY3NzL2Jvb3RzdHJhcC9ib290c3RyYXAubWluLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgICAgPGZhYi1lbGVtZW50IG5hbWU9XCJGYWJcIiA/aGlkZGVuPVwiJHt0aGlzLndlYklkID09IG51bGx9XCI+TG9hZGluZyBGYWIgZm9yICR7dGhpcy53ZWJJZH08L2ZhYi1lbGVtZW50PlxyXG4gICAgICA8c3RvcmUtZWxlbWVudCBuYW1lPVwiU3RvcmVcIj5TdG9yZSBMb2FkaW5nPC9zdG9yZS1lbGVtZW50PlxyXG4gICAgICA8ZGl2ID9oaWRkZW4gPSBcIiR7IXRoaXMuZGVidWd9XCI+XHJcbiAgICAgIEhlbGxvIGZyb208Yj4ke3RoaXMubmFtZX08L2I+PGJyPlxyXG4gICAgICBXZWJJZCA6ICR7dGhpcy53ZWJJZH08YnI+XHJcblxyXG4gICAgICA8L2Rpdj5cclxuXHJcbiAgICAgIDxoZWFkZXI+XHJcbiAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtaW5mb1wiICBAY2xpY2s9XCIke3RoaXMuc2hvd0RlZmF1bHR9XCI+QWdvcmE8L2J1dHRvbj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1pbmZvXCIgcGFuZWw9XCJJbmZvXCIgQGNsaWNrPVwiJHt0aGlzLnNob3dGcm9tQXR0fVwiPkhlbHA8L2J1dHRvbj5cclxuICAgICAgPGxvZ2luLWVsZW1lbnQgbmFtZT1cIkxvZ2luXCI+TG9hZGluZyBMb2dpbjwvbG9naW4tZWxlbWVudD5cclxuICAgICAgPCEtLSAgICAgIDxuYXYtZWxlbWVudCBuYW1lPVwiTmF2XCI+TG9hZGluZyBOYXY8L25hdi1lbGVtZW50Pi0tPlxyXG4gICAgICB2LmEyXHJcbiAgICAgIDwvaGVhZGVyPlxyXG5cclxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lci1mbHVpZFwiPlxyXG4gICAgICA8IS0tXHJcbiAgICAgIFBBTkVMIDogJHt0aGlzLnBhbmVsfSBmb3IgJHt0aGlzLndlYklkfVxyXG4gICAgICAtLT5cclxuICAgICAgPCEtLVxyXG5cclxuICAgICAgSElEREVOIFRFTVBPUkFSWSBGT1IgREVWLS0+XHJcbiAgICAgIDxmbHV4LWVsZW1lbnQgbmFtZT1cIkZsdXhcIiBhZ29yYVBvZD1cIiR7dGhpcy5hZ29yYVBvZH1cIiA/aGlkZGVuPVwiJHt0aGlzLnBhbmVsICE9ICdGbG93J31cIj5Mb2FkaW5nIEZsdXg8L2ZsdXgtZWxlbWVudD5cclxuICAgICAgPGZyaWVuZHMtdmlldyBuYW1lPVwiRnJpZW5kc1wiID9oaWRkZW49XCIke3RoaXMucGFuZWwgIT0gJ09yZ2FuaXphdGlvbid9XCI+TG9hZGluZyBPcmdhbml6YXRpb248L2ZyaWVuZHMtdmlldz5cclxuICAgICAgPHBvc3QtZWxlbWVudCBuYW1lPVwiUG9zdFwiIC5zaGFyZT1cIiR7dGhpcy5zaGFyZX1cIiA/aGlkZGVuPVwiJHt0aGlzLnBhbmVsICE9ICdDb21wb3NlJ31cIj5Mb2FkaW5nIFBvc3Q8L3Bvc3QtZWxlbWVudD5cclxuICAgICAgPGNvbmZpZy1nZXQtdmlldyBuYW1lPVwiQ29uZmlnXCIgd2ViSWQ9XCIke3RoaXMud2ViSWR9XCIgP2hpZGRlbj1cIiR7dGhpcy53ZWJJZCA9PSBudWxsIHx8IHRoaXMucGFuZWwgIT0gXCJDb25maWdcIn1cIj5Mb2FkaW5nIENvbmZpZyBmb3IgJHt0aGlzLndlYklkfTwvY29uZmlnLWdldC12aWV3PlxyXG4gICAgICA8cHJvZmlsZS1lbGVtZW50ID9oaWRkZW49XCIke3RoaXMucGFuZWwgIT0gXCJQcm9maWxlXCJ9XCIgbmFtZT1cIlByb2ZpbGVcIj5Mb2FkaW5nIFByb2ZpbDwvcHJvZmlsZS1lbGVtZW50PlxyXG4gICAgICA8IS0tLS0+XHJcblxyXG4gICAgICA8IS0tIERFRkFVTFQgLS0+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIiA/aGlkZGVuPVwiJHt0aGlzLnBhbmVsICE9ICdEZWZhdWx0J31cIj5cclxuICAgICAgJHt0aGlzLnBhbmVscy5tYXAoKHAsIGkpID0+XHJcbiAgICAgICAgaHRtbCBgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XHJcbiAgICAgICAgPHBhbmVsLWVsZW1lbnQgbmFtZT1cIiR7cC5uYW1lfVwiIC5wPVwiJHtwfVwiPkxvYWRpbmcgJHtwLm5hbWV9PC9wYW5lbC1lbGVtZW50PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIGApXHJcbiAgICAgIH1cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwhLS0gLS0+XHJcblxyXG5cclxuICAgICAgPCEtLSBTSEFSRSAtLT5cclxuICAgICAgPGRpdiA/aGlkZGVuPVwiJHt0aGlzLnBhbmVsICE9ICdTaGFyZSd9XCI+XHJcbiAgICAgICR7dGhpcy53ZWJJZCAhPSBudWxsXHJcbiAgICAgICAgP2h0bWwgYFNIQVJFIFBBTkVMICAgc2hhcmUgOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuc2hhcmUpfTxicj5gXHJcbiAgICAgICAgOmh0bWxgIFlPVSBNVVNUIExPR0lOIFRPIFNIQVJFXHJcbiAgICAgICAgYFxyXG4gICAgICB9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8IS0tIFFVRVJZIC0tPlxyXG4gICAgICA8ZGl2ID9oaWRkZW49XCIke3RoaXMucXVlcnkgPT0gbnVsbH1cIj5cclxuICAgICAgbXVzdCBzaG93IGFjdGl2aXR5IHdpdGggdXJpICR7dGhpcy5xdWVyeX1cclxuICAgICAgPC9kaXY+XHJcblxyXG4gICAgICA8IS0tIElORk8gLS0+XHJcbiAgICAgIDxpbmZvLWVsZW1lbnQgbmFtZT1cIkluZm9cIiA/aGlkZGVuPVwiJHt0aGlzLnBhbmVsICE9ICdJbmZvJ31cIj5Mb2FkaW5nIEluZm88L2luZm8tZWxlbWVudD5cclxuICAgICAgPCEtLS0tPlxyXG5cclxuICAgICAgPC9kaXY+XHJcblxyXG4gICAgICA8IS0tICAgICAgPGxvZy1lbGVtZW50IG5hbWU9XCJMb2dcIj5Mb2FkaW5nIExvZzwvbG9nLWVsZW1lbnQ+LS0+XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG4gICAgZmlyc3RVcGRhdGVkKCl7XHJcbiAgICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgICB0aGlzLmFnZW50ID0gbmV3IEhlbGxvQWdlbnQodGhpcy5uYW1lKTtcclxuICAgICAgY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICAgICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcIm1lc3NhaFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBcIndlYklkQ2hhbmdlZFwiOlxyXG4gICAgICAgICAgICBhcHAud2ViSWRDaGFuZ2VkKG1lc3NhZ2Uud2ViSWQpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5pdEZyb21TdG9yZVwiOlxyXG4gICAgICAgICAgICBhcHAuaW5pdEZyb21TdG9yZShtZXNzYWdlLnN0b3JlKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNob3dQYW5lbFwiOlxyXG4gICAgICAgICAgICBhcHAuc2hvd1BhbmVsKG1lc3NhZ2UucGFuZWwpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHdlYklkQ2hhbmdlZCh3ZWJJZCl7XHJcbiAgICAgIHRoaXMud2ViSWQgPSB3ZWJJZFxyXG4gICAgfVxyXG4gICAgaW5pdEZyb21TdG9yZShzdG9yZSl7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU1RPUkUgaW4gYXBwXCIsc3RvcmUpXHJcbiAgICAgIHN0b3JlLmluZm8gPT0gdHJ1ZSA/IHRoaXMucGFuZWwgPSBcIkluZm9cIiA6IFwiXCJcclxuICAgIH1cclxuXHJcbiAgICBzaG93UGFuZWwocGFuZWwgPSBcIk9yZ2FuaXphdGlvblwiKXtcclxuICAgICAgdGhpcy5wYW5lbCA9IHBhbmVsXHJcbiAgICAgIC8vXHJcbiAgICB9XHJcblxyXG4gICAgc2hvd0Zyb21BdHQoZSl7XHJcbiAgICAgIHRoaXMucGFuZWwgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJwYW5lbFwiKVxyXG4gICAgfVxyXG5cclxuICAgIHNob3dEZWZhdWx0KCl7XHJcbiAgICAgIHRoaXMucGFuZWwgPSBcIkRlZmF1bHRcIlxyXG4gICAgICAvL1xyXG4gICAgfVxyXG5cclxuICAgIG9uTG9hZCgpIHtcclxuICAgICAgdmFyIHBhcnNlZFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhwYXJzZWRVcmwpXHJcbiAgICAgIHRoaXMuc2hhcmUudGl0bGUgPSBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmdldChcInRpdGxlXCIpIHx8IG51bGxcclxuICAgICAgdGhpcy5zaGFyZS50ZXh0ID0gcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0ZXh0XCIpIHx8IG51bGxcclxuICAgICAgdGhpcy5zaGFyZS51cmwgPSBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmdldChcInVybFwiKSB8fCBudWxsXHJcbiAgICAgIGlmICh0aGlzLnNoYXJlLnRpdGxlICE9IG51bGwgfHwgdGhpcy5zaGFyZS50ZXh0ICE9IG51bGwgfHwgdGhpcy5zaGFyZS51cmwgIT0gbnVsbCl7XHJcbiAgICAgICAgdGhpcy5zaGFyZS5zaG93ID0gdHJ1ZVxyXG4gICAgICAgIHRoaXMucGFuZWwgPSBcIlNoYXJlXCJcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicXVlcnlcIikgfHwgbnVsbFxyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuc2hhcmUpXHJcbiAgICAgIGlmIChwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmdldChcIm9sZGFwaVwiKSkge1xyXG4gICAgICAgIGFsZXJ0KFwiWW91ciBicm93c2VyIGlzIHVzaW5nIHRoZSBkZXByZWNhdGVkICd1cmxfdGVtcGxhdGUnIFdlYiBTaGFyZSBcIlxyXG4gICAgICAgICsgXCJUYXJnZXQgQVBJLlwiKTtcclxuICAgICAgfVxyXG5cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYXBwLXZpZXcnLCBBcHBWaWV3KTtcclxuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgQmFzZVZpZXcgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuICBjcmVhdGVSZW5kZXJSb290KCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMubmFtZSlcclxuICAgIGlmICh0aGlzLm5hbWUgIT0gbnVsbCl7XHJcbiAgICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgICB0aGlzLmFnZW50ID0gbmV3IEhlbGxvQWdlbnQodGhpcy5uYW1lKTtcclxuICAgICAgY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICAgICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcIm1lc3NhaFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBcIndlYklkQ2hhbmdlZFwiOlxyXG4gICAgICAgICAgICBhcHAud2ViSWRDaGFuZ2VkKG1lc3NhZ2Uud2ViSWQpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwidGVzdFwiOlxyXG4gICAgICAgICAgICBhcHAudGVzdChtZXNzYWdlKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInBhZ2VDaGFuZ2VkXCI6XHJcbiAgICAgICAgICAgIGFwcC5wYWdlQ2hhbmdlZChtZXNzYWdlLnBhZ2UpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicGFuZWxDaGFuZ2VkXCI6XHJcbiAgICAgICAgICAgIGFwcC5wYW5lbENoYW5nZWQobWVzc2FnZS5wYW5lbClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHdlYklkQ2hhbmdlZCh3ZWJJZCl7XHJcbiAgICBjb25zb2xlLmxvZyhcIldJQ1wiLHRoaXMubmFtZSx3ZWJJZClcclxuICAgIHRoaXMud2ViSWQgPSB3ZWJJZFxyXG4gIH1cclxuICBwYWdlQ2hhbmdlZChwYWdlKXtcclxuICAgIHBhZ2UgPT0gXCJkZWZhdWx0XCIgPyB0aGlzLnBhZ2UgPSBcImZsdXhcIiA6IHRoaXMucGFnZSA9IHBhZ2VcclxuICB9XHJcblxyXG4gIHRlc3QobWVzc2FnZSl7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLm5hbWUsXCIgcmVjZWl2ZWQgXCIsbWVzc2FnZSlcclxuICB9XHJcblxyXG4gIGNsaWNrKGUpe1xyXG4gICAgY29uc29sZS5sb2coZSlcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgQmFzZVZpZXcgfSBmcm9tICcuL2Jhc2Utdmlldy5qcyc7XHJcblxyXG5jbGFzcyBTdG9yZUVsZW1lbnQgZXh0ZW5kcyBCYXNlVmlldyB7XHJcblxyXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nIH0sXHJcbiAgICAgIHN0b3JlOiB7dHlwZTogT2JqZWN0fSxcclxuICAgICAgZGVidWc6IHt0eXBlOiBCb29sZWFufSxcclxuICAgICAgd2ViSWQ6IHt0eXBlOiBTdHJpbmd9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJTdG9yZVwiXHJcbiAgICB0aGlzLnN0b3JlID0ge31cclxuICAgIHRoaXMuZGVidWcgPSBmYWxzZVxyXG4gICAgdGhpcy53ZWJJZCA9IG51bGxcclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIHJldHVybiBodG1sYFxyXG5cclxuICAgIDxkaXYgP2hpZGRlbiA9IFwiJHshdGhpcy5kZWJ1Z31cIj5cclxuICAgIEhlbGxvIGZyb208Yj4ke3RoaXMubmFtZX08L2I+PGJyPlxyXG4gICAgc3RvcmUgOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuc3RvcmUpfTwvYnI+XHJcbiAgICA8cD5cclxuICAgICR7dGhpcy5uYW1lfSA8YnI+ICAgIDxidXR0b24gQGNsaWNrPVwiJHt0aGlzLmNsZWFuU3RvcmFnZX1cIj5DbGVhbjwvYnV0dG9uPjxicj48YnI+XHJcbiAgICA8L3A+XHJcbiAgICA8L2Rpdj5cclxuICAgIGA7XHJcbiAgfVxyXG5cclxuICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLm5hbWUpXHJcbiAgICBzdXBlci5maXJzdFVwZGF0ZWQoKVxyXG4gICAgaWYgKHRoaXMubmFtZSAhPSBudWxsKXtcclxuICAgICAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgICAgIC8vICB0aGlzLmFnZW50ID0gbmV3IEhlbGxvQWdlbnQodGhpcy5uYW1lKTtcclxuICAgICAgY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICAgICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcIm1lc3NhaFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBcInNldFN0b3JhZ2VcIjpcclxuICAgICAgICAgICAgYXBwLnNldFN0b3JhZ2UobWVzc2FnZS52YWx1ZXMpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29uZmlnXCI6XHJcbiAgICAgICAgICAgIGFwcC5nZXRDb25maWcoZnJvbSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWJJZENoYW5nZWRcIjpcclxuICAgICAgICAgICAgYXBwLndlYklkQ2hhbmdlZChtZXNzYWdlLndlYklkKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGFjdGlvbiBcIixtZXNzYWdlKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlYWRTdG9yYWdlKClcclxuICAgIHRoaXMuYWdlbnQuc2VuZChcIkFwcFwiLCB7YWN0aW9uOiBcImluaXRGcm9tU3RvcmVcIiwgc3RvcmU6IHRoaXMuc3RvcmV9KVxyXG4gIH1cclxuXHJcbiAgd2ViSWRDaGFuZ2VkKHdlYklkKXtcclxuICAgIGNvbnNvbGUubG9nKFwiV0VCSUQgQ0hBTkdFRFwiLHdlYklkLCB0aGlzLndlYklkKVxyXG4gICAgLy8gIHRoaXMud2ViSWQgPSB3ZWJJZFxyXG4gICAgaWYgKHdlYklkICE9IG51bGwpe1xyXG4gICAgICBjb25zb2xlLmxvZyhcIldFQklEIE5PTiBOVUxMXCIsd2ViSWQsIHRoaXMud2ViSWQpXHJcbiAgICAgIGlmICh3ZWJJZCA9PSB0aGlzLnN0b3JlLmNvbmZpZy53ZWJJZCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJXRUJJRCBJREVOVElRVUVcIilcclxuICAgICAgICB0aGlzLnN0b3JlLmNvbmZpZy5zdGF0dXMgPSBcIldlYklkIGZyb20gc3RvcmUgOiBcIiwrd2ViSWRcclxuICAgICAgICB0aGlzLmFnZW50LnNlbmQoXCJBcHBcIiwge2FjdGlvbjogXCJzaG93UGFuZWxcIiwgcGFuZWw6IFwiRmxvd1wifSlcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJXRUJJRCBESUZGRVJFTlRcIiwgd2ViSWQsIHRoaXMud2ViSWQpXHJcbiAgICAgICAgdGhpcy5zdG9yZS5jb25maWcud2ViSWQgPSB3ZWJJZFxyXG4gICAgICAgIHRoaXMuc3RvcmUuY29uZmlnLnN0YXR1cyA9IFwiV2ViSWQgaGFzIGNoYW5nZWQgOiBcIiwrd2ViSWRcclxuICAgICAgICB0aGlzLmFnZW50LnNlbmQoXCJBcHBcIiwge2FjdGlvbjogXCJzaG93UGFuZWxcIiwgcGFuZWw6IFwiQ29uZmlnXCJ9KVxyXG4gICAgICAgIHRoaXMuYWdlbnQuc2VuZChcIkNvbmZpZ1wiLCB7YWN0aW9uOiBcIm5ld0NvbmZpZ1wiLCBjb25maWc6IHRoaXMuc3RvcmUuY29uZmlnfSlcclxuXHJcbiAgICAgIH1cclxuICAgIH1lbHNle1xyXG4gICAgICBjb25zb2xlLmxvZyhcIldFQklEIENIQU5HRUQgSVMgTlVMTFwiLHRoaXMud2ViSWQpXHJcbiAgICAgIHRoaXMuc3RvcmUuY29uZmlnID0ge31cclxuICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiRnJpZW5kc1wiLCB7YWN0aW9uOiBcImNvbmZpZ0NoYW5nZWRcIiwgY29uZmlnOiB0aGlzLnN0b3JlLmNvbmZpZ30pXHJcbiAgICAgIHRoaXMuYWdlbnQuc2VuZChcIlByb2ZpbGVcIiwge2FjdGlvbjogXCJjb25maWdDaGFuZ2VkXCIsIGNvbmZpZzogdGhpcy5zdG9yZS5jb25maWd9KVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2codGhpcy53ZWJJZClcclxuICAgIHRoaXMucG9wdWxhdGVTdG9yYWdlKClcclxuICB9XHJcblxyXG5cclxuICBnZXRDb25maWcoZnJvbSl7XHJcbiAgICB0aGlzLmFnZW50LnNlbmRNdWx0aShbZnJvbSwgXCJQb3N0VGFic1wiLCBcIlByb2ZpbGVcIiwgXCJGcmllbmRzXCIsIFwiUHJvZmlsZUNhcnRvdWNoZVwiXSwge2FjdGlvbjogXCJjb25maWdDaGFuZ2VkXCIsIGNvbmZpZzogdGhpcy5zdG9yZS5jb25maWd9KVxyXG4gIH1cclxuXHJcblxyXG4gIHJlYWRTdG9yYWdlKCl7XHJcbiAgICB0aGlzLnN0b3JlID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFnb3JhXCIpKSB8fCB7aW5mbzogdHJ1ZSwgY29uZmlnOiB7fX1cclxuICAgIGNvbnNvbGUubG9nKFwiU1RPUkUgOiBcIix0aGlzLnN0b3JlKVxyXG4gIH1cclxuXHJcbiAgc2V0U3RvcmFnZSh2YWx1ZXMpe1xyXG4gICAgY29uc29sZS5sb2codmFsdWVzKVxyXG5cclxuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAke2tleX06ICR7dmFsdWV9YCk7XHJcbiAgICAgIHRoaXMuc3RvcmVba2V5XSA9IHZhbHVlXHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLnN0b3JlKVxyXG4gICAgdGhpcy5wb3B1bGF0ZVN0b3JhZ2UoKVxyXG4gIH1cclxuXHJcbiAgcG9wdWxhdGVTdG9yYWdlKCl7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImFnb3JhXCIsSlNPTi5zdHJpbmdpZnkodGhpcy5zdG9yZSkpXHJcbiAgICB0aGlzLnJlYWRTdG9yYWdlKClcclxuICB9XHJcblxyXG4gIHVwZGF0ZVN0b3JhZ2UoZGF0YSl7XHJcbiAgICB0aGlzLnN0b3JlID0gZGF0YVxyXG4gICAgdGhpcy5wb3B1bGF0ZVN0b3JhZ2UoKVxyXG4gICAgdGhpcy5yZWFkU3RvcmFnZSgpXHJcbiAgfVxyXG5cclxuICBjbGVhblN0b3JhZ2UoKXtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiYWdvcmFcIilcclxuICAgIHRoaXMucmVhZFN0b3JhZ2UoKVxyXG4gIH1cclxuXHJcbn1cclxuXHJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc3RvcmUtZWxlbWVudCcsIFN0b3JlRWxlbWVudCk7XHJcbiIsImltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XHJcbmltcG9ydCB7IEhlbGxvQWdlbnQgfSBmcm9tICcuLi9hZ2VudHMvaGVsbG8tYWdlbnQuanMnO1xyXG5cclxuY2xhc3MgUGFuZWxFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XHJcblxyXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBwOiB7dHlwZTogT2JqZWN0fVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMubmFtZSA9IFwiUGFuZWxcIlxyXG4gICAgdGhpcy5wID0ge31cclxuICB9XHJcblxyXG4gIHJlbmRlcigpe1xyXG4gICAgcmV0dXJuIGh0bWxgXHJcbiAgICA8bGluayBocmVmPVwiY3NzL2Jvb3RzdHJhcC9ib290c3RyYXAubWluLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiY2FyZCBzaGFkb3cgbWItNFwiID5cclxuICAgIDxkaXYgY2xhc3M9XCJjYXJkLWhlYWRlciBweS0zXCI+XHJcbiAgICA8aDYgY2xhc3M9XCJtLTAgZm9udC13ZWlnaHQtYm9sZCB0ZXh0LXByaW1hcnlcIj4ke3RoaXMucC5uYW1lfTwvaDY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPlxyXG4gICAgPGltZyBjbGFzcz1cImltZy1mbHVpZCBweC0zIHB4LXNtLTQgbXQtMyBtYi00XCIgc3R5bGU9XCJoZWlnaHQ6IDEwcmVtO1wiIHNyYz1cIiR7dGhpcy5wLmltYWdlfVwiIGFsdD1cIlwiPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8cD4ke3RoaXMucC50ZXh0fTwvcD5cclxuICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtaW5mb1wiICBwYW5lbD1cIiR7dGhpcy5wLm5hbWV9XCIgQGNsaWNrPVwiJHt0aGlzLnNob3dQYW5lbH1cIj4ke3RoaXMucC5uYW1lfTwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICBgO1xyXG4gIH1cclxuXHJcbiAgc2hvd1BhbmVsKGUpe1xyXG4gICAgbGV0IHBhbmVsID1lLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJwYW5lbFwiKVxyXG4gICAgdGhpcy5hZ2VudC5zZW5kKFwiQXBwXCIsIHthY3Rpb246IFwic2hvd1BhbmVsXCIsIHBhbmVsOiBwYW5lbH0pXHJcbiAgfVxyXG5cclxuICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLmFnZW50KVxyXG4gICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAvLyAgY29uc29sZS5sb2coXCJtZXNzYWhcIixtZXNzYWdlKVxyXG4gICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgICBjYXNlIFwid2ViSWRDaGFuZ2VkXCI6XHJcbiAgICAgICAgICBhcHAud2ViSWRDaGFuZ2VkKG1lc3NhZ2Uud2ViSWQpXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgncGFuZWwtZWxlbWVudCcsIFBhbmVsRWxlbWVudCk7XHJcbiIsImltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XHJcbmltcG9ydCB7IEhlbGxvQWdlbnQgfSBmcm9tICcuLi9hZ2VudHMvaGVsbG8tYWdlbnQuanMnO1xyXG5cclxuY2xhc3MgSW5mb0VsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJJbmZvXCJcclxuICB9XHJcblxyXG4gIHJlbmRlcigpe1xyXG4gICAgcmV0dXJuIGh0bWxgXHJcbiAgICA8bGluayBocmVmPVwiY3NzL2Jvb3RzdHJhcC9ib290c3RyYXAubWluLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvZm9udGF3ZXNvbWUvY3NzL2FsbC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcblxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJqdW1ib3Ryb25cIj5cclxuICAgIDxoMSBjbGFzcz1cImRpc3BsYXktNFwiPkFnb3JhPC9oMT5cclxuICAgIDxwIGNsYXNzPVwibGVhZFwiPlxyXG4gICAgVGhlIERlY2VudHJhbGlTaGFyZSBhcHAgITxicj5cclxuICAgIDxiPkFnb3JhPC9iPiBpcyBhbiBQT0MgdG8gdXNlIEFjdGl2aXR5UHViXHJcbiAgICAoPGEgaHJlZj1cImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FjdGl2aXR5UHViXCIgdGFyZ2V0PVwiX2JsYW5rXCI+RW48L2E+KVxyXG4gICAgKDxhIGhyZWY9XCJodHRwczovL2ZyLndpa2lwZWRpYS5vcmcvd2lraS9BY3Rpdml0eVB1YlwiIHRhcmdldD1cIl9ibGFua1wiPkZyPC9hPilcclxuICAgIG9uIHRvcCBvZiB0aGUgU29saWQgUGxhdGZvcm0uPC9wPlxyXG4gICAgPGhyIGNsYXNzPVwibXktNFwiPlxyXG5cclxuICAgIDxwPklmIHlvdSB3YW50IHRvIHVzZSBBZ29yYSwgeW91IG11c3QgY29uZmlndXJlIHlvdXIgUE9ELjwvcD5cclxuICAgIDxwPlxyXG4gICAgQWdvcmEgbmVlZHMgSElHSCBDT05UUk9MIHRvIHlvdXIgUE9EIHRvIHNldCBhdXRob3JpemF0aW9ucyBvbiBkYXRhIGNyZWF0ZWQuPGJyPlxyXG4gICAgQWx0aG91Z2ggQWdvcmEgbGltaXRzIGl0cyBpbnRlcmFjdGlvbiB0byBhIHNwZWNpZmljIGZvbGRlciBvZiB5b3VyIFBPRCxcclxuICAgIGlmIHlvdSBkb24ndCB3YW50IEFnb3JhIHRvIGFjY2VzcyB5b3VyIGVudGlyZSBmYXZvcml0ZSBQT0QsXHJcbiAgICB5b3UgY2FuIDxhIGNsYXNzPVwiYnRuIGJ0bi1pbmZvIGJ0bi1zbVwiIGhyZWY9XCJodHRwczovL3NvbGlkLmlucnVwdC5jb20vZ2V0LWEtc29saWQtcG9kXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Y3JlYXRlIGEgbmV3IFBPRDwvYT5cclxuICAgIDwvcD5cclxuXHJcbiAgICA8cD5cclxuICAgIFRvIGNvbmZvcm0gdG8gQWN0aXZpdHlQdWIsIG9uZSB1c2VyICh5b3UpIG11c3QgaGF2ZSB0d28gZm9sZGVycyAoaW5ib3ggJiBvdXRib3gpLjxicj5cclxuICAgIFdlIGRlY2lkZWQgdG8gcHV0IHRoZW0gaW4geW91ciAvcHVibGljLyBmb2xkZXIgaW4gYSAvYWdvcmEvIChvbGQgL3NoaWdobF90ZXN0Lykgc3ViLWZvbGRlciAoYXJiaXRyYXJ5IGZvciB0aGUgbW9tZW50ICYgeW91IGNhbiBjaGFuZ2UgaXQgaW4gdGhlIHByb2ZpbC9jb25maWcgcGFuZWwpLjxicj5cclxuICAgIEluIHRoYXQgL2Fnb3JhLyBmb2xkZXJzIHRoZXJlIGlzIGFuIFwiaW5kZXgudHRsXCIgZmlsZSB0aGF0IHJlZmVyZW5jZVxyXG4gICAgXCJpbmJveFwiICYgXCJvdXRib3hcIiBmb2xkZXJzXHJcbiAgICAmIHRoYXQgaXMgcmVmZXJlbmNlZCBpbiB5b3VyIDxiPnB1YmxpY1R5cGVJbmRleDwvYj4gYXMgYSA8Yj5BZ29yYTwvYj4gaW5zdGFuY2UuPGJyPjxicj5cclxuICAgIFNvbWUgc3BlY2lhbHMgYXV0aG9yaXphdGlvbnMgYXJlIHNldCB0byB0aGUgL2luYm94LyAmIC9vdXRib3gvIGZvbGRlcnM6XHJcbiAgICA8dWw+XHJcbiAgICA8bGk+XHJcbiAgICA8Yj4vaW5ib3gvPC9iPiBmb2xkZXIgd2hlcmUgeW91IHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiBvdGhlciB1c2VycyBhY3Rpb25zLlxyXG4gICAgPGJyPllvdSBrZWVwIGZ1bGwgQ09OVFJPTC5cclxuICAgIEF1dGhlbnRpY2F0ZWQgQWdlbnQgKEV2ZXJ5b25lIHdpdGggYSBQT0QpIGlzIGEgU3VibWl0dGVyICh0aGV5IGNhbiB3cml0ZSBidXQgbm90IHJlYWQpLlxyXG4gICAgPC9saT5cclxuICAgIDxsaT5cclxuICAgIDxiPi9vdXRib3gvPC9iPiBmb2xkZXIgd2hlcmUgPGI+YWN0aXZpdGllczwvYj4gJiA8Yj5vYmplY3RzPC9iPiB0aGF0IHlvdSBjcmVhdGUgYXJlIHN0b3JlZC48YnI+XHJcbiAgICBZb3Uga2VlcCBmdWxsIENPTlRST0wuIEF1dGhvcml6YXRpb25zIGZvciBkYXRhIHN0b3JlZCBpbiAvYWN0aXZpdGllcy8gJiAvb2JqZWN0cy8gc3ViLWZvbGRlcnNcclxuICAgIGFyZSBzZXQgd2hlbiB5b3UgY3JlYXRlIHRoYXQgYWN0aXZpdGllcy9vYmplY3RzLFxyXG4gICAgYWNjb3JkaW5nIHRvIHRoZSByZWNpcGllbnQgb2YgdGhhdCBhY3Rpdml0eSAoUHVibGljLCBvciBhIHNwZWNpZmljIFBPRClcclxuICAgIDwvbGk+XHJcbiAgICA8L3VsPlxyXG5cclxuICAgIDxicj5cclxuICAgIDwvcD5cclxuXHJcbiAgICA8cD48Yj5UbyBhbGxvdyBBZ29yYSB0byBjb25maWd1cmUgeW91ciBQT0QsXHJcbiAgICB5b3UgbXVzdCBhY2NlcHQgQWdvcmEgY2FuIFwiQ09OVFJPTFwiIHlvdXIgUE9ELjwvYj5cclxuICAgIDwvcD5cclxuICAgIDxwPlxyXG4gICAgVGhpcyBjYW4gYmUgZG9uZSB3aGVuIHlvdSBsb2dpbiBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgIG9uIGFuIGFwcCBob3N0ZWQgb24gaHR0cHM6Ly9zY2VuYXJpc3RldXIuZ2l0aHViLmlvL1xyXG4gICAgYnkgY2hlY2tpbmcgdGhlIGxhc3QgbGluZSBvZiB0aGUgYXV0aG9yaXphdGlvbi5cclxuICAgIDxicj48YnI+XHJcbiAgICA8YSBocmVmPVwiLi9pbWcvY2hlY2tDb250cm9sLnBuZ1wiXHJcbiAgICB0YXJnZXQ9XCJfYmxhbmtcIj5cclxuICAgIDxpbWcgc3JjPVwiLi9pbWcvY2hlY2tDb250cm9sLnBuZ1wiXHJcbiAgICBjbGFzcz1cImltZy1mbHVpZCBpbWctdGh1bWJuYWlsXCJcclxuICAgIGFsdD1cIkFkZCBodHRwczovL3NjZW5hcmlzdGV1ci5naXRodWIuaW8gdG8gdHJ1c3RlZEFwcHNcIj5cclxuICAgIDwvYT5cclxuICAgIDxicj5cclxuICAgIDxicj5cclxuICAgIElmIHlvdSBtaXNzIGl0IG9yIGlmIHlvdSBoYXZlIGFscmVhZHkgbG9nZ2VkIG9uIGEgaHR0cHM6Ly9zY2VuYXJpc3RldXIuZ2l0aHViLmlvLyBhcHBcclxuICAgIGJ1dCBkaWQgbm90IGFsbG93IFwiQ09OVFJPTFwiXHJcbiAgICB5b3UgY2FuIGFkZCBpdCBpbiB0aGUgcHJlZmVyZW5jZXMgKHJpZ2h0IG1lbnUgb2YgeW91ciBQT0QpXHJcbiAgICBieSBjaGVja2luZyBhbGwgNCBcIkFjY2VzcyBNb2Rlc1wiIGxpa2Ugc2hvd24gYmVsb3cuXHJcbiAgICA8YnI+PGJyPlxyXG4gICAgPGEgaHJlZj1cIi4vaW1nL3RydXN0ZWRBcHBzLnBuZ1wiXHJcbiAgICB0YXJnZXQ9XCJfYmxhbmtcIj5cclxuICAgIDxpbWcgc3JjPVwiLi9pbWcvdHJ1c3RlZEFwcHMucG5nXCJcclxuICAgIGNsYXNzPVwiaW1nLWZsdWlkIGltZy10aHVtYm5haWxcIlxyXG4gICAgYWx0PVwiQWRkIGh0dHBzOi8vc2NlbmFyaXN0ZXVyLmdpdGh1Yi5pbyB0byB0cnVzdGVkQXBwc1wiPlxyXG4gICAgPC9hPlxyXG4gICAgPGJyPlxyXG4gICAgPC9wPlxyXG5cclxuICAgIDxwPlxyXG4gICAgQXQgdGhlIGVuZCBvZiB0aGUgY29uZmlndXJhdGlvbiwgeW91IHNob3VsZCBzZWUgYSBzdHJ1Y3R1cmUgbGlrZSB0aGlzIG9uZSBvbiB5b3VyIFBPRCAodGhpcyBleGFtcGxlIHNob3cgeW91IHN0cnVjdHVyZSAmIHNvbWUgZGF0YSBpbiBlYWNoIClcclxuICAgIChzaGlnaGxfdGVzdCBoYXMgYmVlbiByZXBsYWNlZCBieSBhZ29yYSAvIGZvbGxvd2VycywgZm9sbG93bmluZywgbGlrZWQgYXJlIG5vdCByZWFkeSwgV0lQKS5cclxuICAgIDxicj48YnI+XHJcbiAgICA8YSBocmVmPVwiLi9pbWcvYWdvcmFfZm9sZGVyLnBuZ1wiXHJcbiAgICB0YXJnZXQ9XCJfYmxhbmtcIj48aW1nIHNyYz1cIi4vaW1nL2Fnb3JhX2ZvbGRlci5wbmdcIlxyXG4gICAgY2xhc3M9XCJpbWctZmx1aWQgaW1nLXRodW1ibmFpbFwiXHJcbiAgICBtYXgtaGVpZ2h0PVwiMzAwcHhcIlxyXG4gICAgYWx0PVwiQWRkIGh0dHBzOi8vc2NlbmFyaXN0ZXVyLmdpdGh1Yi5pbyB0byB0cnVzdGVkQXBwc1wiPlxyXG4gICAgPC9hPlxyXG5cclxuICAgIDxwPlxyXG4gICAgSWYgeW91IGhhdmUgYW55IHF1ZXN0aW9uIG9yIHN1Z2dlc3Rpb24sIGZlZWwgZnJlZSB0byBhc2sgb25cclxuICAgIDxhIGhyZWY9XCJodHRwczovL2ZvcnVtLnNvbGlkcHJvamVjdC5vcmcvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+U29saWQgQ29tbXVuaXR5IEZvcnVtPC9hPixcclxuICAgIG9yIG9uIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vc2NlbmFyaXN0ZXVyL2Fnb3JhL2Jsb2IvbWFzdGVyL1JFQURNRS5tZFwiXHJcbiAgICB0YXJnZXQ9XCJfYmxhbmtcIj5BZ29yYSBwcm9qZWN0PC9hPiByZXBvc2l0b3J5LlxyXG4gICAgPC9wPlxyXG5cclxuICAgIDxwPjxiPkxhc3QsIGJ1dCBub3QgbGVhc3QgOjwvYj4gaWYgeW91IGluc3RhbGwgQWdvcmEgb24geW91ciBkZXZpY2UsIHlvdSBjYW4gdXNlIGl0IGFzIGEgXCJTaGFyZSB3aXRoLi4uXCIgYXBwLi4uIDstKSA8L3A+XHJcbiAgICA8cCBjbGFzcz1cImxlYWRcIj5cclxuICAgIElmIGFsbCBpcyBPSyBmb3IgeW91LFxyXG4gICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4taW5mb1wiIEBjbGljaz1cIiR7dGhpcy5zaG93UGFuZWx9XCI+Q2xvc2UgSGVscDwvYnV0dG9uPiBhbmQgTG9naW4uXHJcbiAgICA8IS0tICA8YSBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tbGdcIiBocmVmPVwiI1wiIHJvbGU9XCJidXR0b25cIj5MZWFybiBtb3JlPC9hPi0tPlxyXG4gICAgPC9wPlxyXG4gICAgPC9kaXY+XHJcbiAgICBgO1xyXG4gIH1cclxuXHJcblxyXG5cclxuICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLmFnZW50KVxyXG4gICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAvLyAgY29uc29sZS5sb2coXCJtZXNzYWhcIixtZXNzYWdlKVxyXG4gICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcblxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gIH1cclxuXHJcbiAgc2hvd1BhbmVsKCl7XHJcbiAgICB0aGlzLmFnZW50LnNlbmQoXCJBcHBcIiwge2FjdGlvbjogXCJzaG93UGFuZWxcIn0pXHJcbiAgICBjb25zb2xlLmxvZyhcImhpZGVcIilcclxuICAgIGxldCB2YWx1ZXMgPSBbXVxyXG4gICAgdmFsdWVzLmluZm8gPSBmYWxzZVxyXG4gICAgdGhpcy5hZ2VudC5zZW5kKFwiU3RvcmVcIiwge2FjdGlvbjogXCJzZXRTdG9yYWdlXCIsIHZhbHVlczogdmFsdWVzfSlcclxuICB9XHJcblxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2luZm8tZWxlbWVudCcsIEluZm9FbGVtZW50KTtcclxuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcbi8vaW1wb3J0IHsgQmFzZVZpZXcgfSBmcm9tICcuL2Jhc2Utdmlldy5qcyc7XHJcbi8vaW1wb3J0ICogYXMgYXV0aCBmcm9tICdzb2xpZC1hdXRoLWNsaWVudCc7XHJcbi8vLy9sZXQgZGF0YSA9IHNvbGlkLmRhdGFcclxuLy9jb25zb2xlLmxvZyhcIkxERksrTEVYXCIsZGF0YSlcclxuXHJcbmNsYXNzIExvZ2luRWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xyXG5cclxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgd2ViSWQ6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBkZXN0aW5hdGFpcmVzOiB7dHlwZTogU3RyaW5nfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMud2ViSWQgPSBudWxsXHJcbiAgLy8gIHRoaXMuZGVzdGluYXRhaXJlcyA9IFsnQXBwJywnQ29uZmlnJywgJ0NvbmZpZ0dldCcsICdGYWInLCAnUG9zdCcsICdQb3N0VGFicycsICdQcm9maWxlJywgJ1Byb2ZpbGVDYXJ0b3VjaGUnLCAnRnJpZW5kcyddXHJcbiAgICB0aGlzLmRlc3RpbmF0YWlyZXMgPSBbJ0FwcCcsICdTdG9yZScsJ0ZhYicsICdQb3N0JywgJ1Bvc3RUYWJzJ11cclxuXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICA8bGluayBocmVmPVwiY3NzL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG5cclxuICAgICR7dGhpcy53ZWJJZCA9PSBudWxsID9cclxuICAgICAgaHRtbGBcclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXN1Y2Nlc3NcIiBAY2xpY2s9JHt0aGlzLmxvZ2lufT5Mb2dpbjwvYnV0dG9uPlxyXG4gICAgICBgXHJcbiAgICAgIDogaHRtbGBcclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLWRhbmdlclwiIEBjbGljaz0ke3RoaXMubG9nb3V0fT5Mb2dvdXQ8L2J1dHRvbj5cclxuICAgICAgYFxyXG4gICAgfVxyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIGZpcnN0VXBkYXRlZCgpe1xyXG4gICAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgICB0aGlzLmFnZW50ID0gbmV3IEhlbGxvQWdlbnQodGhpcy5uYW1lKTtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMuYWdlbnQpXHJcbiAgICB0aGlzLmFnZW50LnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwibWVzc2FoXCIsbWVzc2FnZSlcclxuICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhtZXNzYWdlKVxyXG4gICAgICAgIHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xyXG4gICAgICAgICAgY2FzZSBcIndlYklkQ2hhbmdlZFwiOlxyXG4gICAgICAgICAgYXBwLndlYklkQ2hhbmdlZChtZXNzYWdlLndlYklkKVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGFjdGlvbiBcIixtZXNzYWdlKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNvbGlkLmF1dGgudHJhY2tTZXNzaW9uKGFzeW5jIGZ1bmN0aW9uKHNlc3Npb24pIHtcclxuICAgICAgaWYgKCFzZXNzaW9uKXtcclxuICAgICAgICBhcHAud2ViSWQ9bnVsbFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiV0VCSURcIixhcHAud2ViSWQpXHJcbiAgICAgICAgYXBwLmFnZW50LnNlbmRNdWx0aShhcHAuZGVzdGluYXRhaXJlcywgIHthY3Rpb246XCJ3ZWJJZENoYW5nZWRcIiwgd2ViSWQ6IGFwcC53ZWJJZH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICAgYXBwLndlYklkID0gc2Vzc2lvbi53ZWJJZFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiV0VCSURcIixhcHAud2ViSWQpXHJcbiAgICAgICAgYXBwLmFnZW50LnNlbmRNdWx0aShhcHAuZGVzdGluYXRhaXJlcywge2FjdGlvbjpcIndlYklkQ2hhbmdlZFwiLCB3ZWJJZDogYXBwLndlYklkfSk7XHJcbiAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgICBjYXNlIFwibG9nb3V0XCI6XHJcbiAgICAgICAgICBhcHAubG9nb3V0KG51bGwpXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgbG9naW4oKSB7XHJcbiAgICB0aGlzLnBvcHVwTG9naW4oKTtcclxuICB9XHJcblxyXG4gIGxvZ291dCgpIHtcclxuICAgIGxldCB3aSA9IHRoaXMud2ViSWRcclxuICAgIHNvbGlkLmF1dGgubG9nb3V0KCkudGhlbigoKSA9PiBhbGVydCgnR29vZGJ5ZSAnK3dpKycgIScpKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHBvcHVwTG9naW4oKSB7XHJcbiAgICBsZXQgc2Vzc2lvbiA9IGF3YWl0IHNvbGlkLmF1dGguY3VycmVudFNlc3Npb24oKTtcclxuICAgIGxldCBwb3B1cFVyaSA9ICcuL2Rpc3QtcG9wdXAvcG9wdXAuaHRtbCc7XHJcbiAgICAvLyAgbGV0IHBvcHVwVXJpID0gJ2h0dHBzOi8vc29saWQuY29tbXVuaXR5L2NvbW1vbi9wb3B1cC5odG1sJztcclxuICAgIGlmICghc2Vzc2lvbilcclxuICAgIHNlc3Npb24gPSBhd2FpdCBzb2xpZC5hdXRoLnBvcHVwTG9naW4oe8KgcG9wdXBVcmkgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xvZ2luLWVsZW1lbnQnLCBMb2dpbkVsZW1lbnQpO1xyXG4iLCJpbXBvcnQgeyBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBCYXNlVmlldyB9IGZyb20gJy4vYmFzZS12aWV3LmpzJztcclxuLy8vL2xldCBkYXRhID0gc29saWQuZGF0YVxyXG4vL2NvbnNvbGUubG9nKFwiTERGSytMRVhcIixkYXRhKVxyXG4vLy8vaW1wb3J0ICogYXMgYXV0aCBmcm9tICdzb2xpZC1hdXRoLWNsaWVudCc7XHJcbi8vaW1wb3J0ICcuL25vdGlmaWNhdGlvbi1saW5lLWVsZW1lbnQuanMnXHJcbi8vbGV0IGRhdGEgPSBzb2xpZC5kYXRhXHJcbi8vY29uc29sZS5sb2coXCJMREZLK0xFWFwiLGRhdGEpXHJcblxyXG5jbGFzcyBGbHV4RWxlbWVudCBleHRlbmRzIEJhc2VWaWV3IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGFnb3JhUG9kOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgbm90aWZpY2F0aW9uczoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGxvZzoge3R5cGU6IFN0cmluZ31cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIkZsdXhcIlxyXG4gICAgdGhpcy5hZ29yYVBvZCA9IFwiXCJcclxuICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IFtdXHJcbiAgICB0aGlzLmxvZyA9IFwiXCJcclxuICB9XHJcblxyXG4gIHJlbmRlcigpe1xyXG4gICAgcmV0dXJuIGh0bWxgXHJcblxyXG4gICAgPGRpdiBjbGFzcz1cInJvdyBib3JkZXJcIiBzdHlsZT1cIm92ZXJmbG93LXk6c2Nyb2xsO3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDogNDAwcHg7XCI+XHJcblxyXG4gICAgPGRpdiBjbGFzcz1cImxlYWRcIiA/aGlkZGVuID0gXCIke3RoaXMubm90aWZpY2F0aW9ucy5sZW5ndGggIT0gMH1cIj5cclxuICAgIExvYWRpbmc8YnI+QWN0aXZpdGllczxicj5mcm9tPGJyPiR7dGhpcy5hZ29yYVBvZH1cclxuICAgIDxicj4ke3RoaXMubG9nfVxyXG4gICAgPC9kaXY+XHJcbiAgICA8dWwgY2xhc3M9XCJsaXN0LWdyb3VwIGxpc3QtZ3JvdXAtZmx1c2hcIj5cclxuICAgICR7dGhpcy5ub3RpZmljYXRpb25zLm1hcCgobixpKSA9PiBodG1sIGBcclxuICAgICAgPGxpIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtXCIgaWQ9XCIke3RoaXMubmFtZX1cIj5cclxuICAgICAgPG5vdGlmaWNhdGlvbi1saW5lLWVsZW1lbnQgaWQ9XCIkeydOb3RpZmljYXRpb24nK2l9XCJcclxuICAgICAgbmFtZSA9IFwiJHsnTm90aWZpY2F0aW9uJytpfVwiXHJcbiAgICAgIC5ub3RpZmljYXRpb249XCIke259XCI+TG9hZGluZyBub3RpZmljYXRpb24uLi48L25vdGlmaWNhdGlvbi1saW5lLWVsZW1lbnQ+XHJcbiAgICAgIDwvbGk+XHJcbiAgICAgIGApfVxyXG4gICAgICA8L3VsPlxyXG5cclxuXHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICBgO1xyXG4gICAgfVxyXG5cclxuICAgIGZpcnN0VXBkYXRlZCgpe1xyXG4gICAgICBzdXBlci5maXJzdFVwZGF0ZWQoKVxyXG4gICAgICB0aGlzLmluaXQoKVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGluaXQoKXtcclxuICAgICAgbGV0IGFwcCA9IHRoaXNcclxuICAgICAgdGhpcy5sb2cgPSBcIkFnb3JhIFBvZCA6IFwiK3RoaXMuYWdvcmFQb2RcclxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLmFnb3JhUG9kKVxyXG4gICAgICBsZXQgcHRpX3VybCA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy5hZ29yYVBvZF0uc29saWQkcHVibGljVHlwZUluZGV4XHJcbiAgICAgIHRoaXMubG9nID0gJ1B0aSB1cmwgOiAnK3B0aV91cmxcclxuICAgICAgLy9jb25zb2xlLmxvZyhgJHtwdGlfdXJsfWApXHJcbiAgICAgIGxldCBpbnN0YW5jZSA9IGF3YWl0IHNvbGlkLmRhdGFbcHRpX3VybCtcIiNBZ29yYVwiXS5zb2xpZCRpbnN0YW5jZVxyXG4gICAgICB0aGlzLmxvZyA9ICdJbnN0YW5jZSB1cmwgOiAnK2luc3RhbmNlXHJcbiAgICAgIC8vY29uc29sZS5sb2coYCR7aW5zdGFuY2V9YClcclxuICAgICAgbGV0IGluYm94ID0gYXdhaXQgc29saWQuZGF0YVtpbnN0YW5jZV0uYXMkaW5ib3hcclxuICAgICAgdGhpcy5sb2cgPSAnSW5ib3ggOiAnK2luYm94XHJcbiAgICAgIC8vY29uc29sZS5sb2coYCR7aW5ib3h9YClcclxuXHJcbiAgICAgIGxldCBub3RpZmljYXRpb25zID0gW11cclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBzdWJqZWN0IG9mIHNvbGlkLmRhdGFbaW5ib3hdLnN1YmplY3RzKXtcclxuICAgIC8vICAgIGNvbnNvbGUubG9nKGAke3N1YmplY3R9YClcclxuICAgICAgICBpZihgJHtzdWJqZWN0fWAgIT0gaW5ib3gpe1xyXG4gICAgICAgICAgbGV0IG4gPSB7fVxyXG4gICAgICAgICAgbi51cmwgPSBgJHtzdWJqZWN0fWArJyN0aGlzJ1xyXG4gICAgICAgICAgLyogKi9cclxuICAgICAgICAgIG5vdGlmaWNhdGlvbnMucHVzaChuKVxyXG4gICAgICAgICAgYXBwLmxvZyA9IFwiTm90aWZpY2F0aW9ucyA6IFwiK25vdGlmaWNhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vY29uc29sZS5sb2cobm90aWZpY2F0aW9ucylcclxuICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gbm90aWZpY2F0aW9uc1xyXG4gICAgLy8gIHRoaXMubG9nID0gXCJSZWFkeVwiXHJcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucy5mb3JFYWNoKGFzeW5jIGZ1bmN0aW9uKG4pICB7XHJcbiAgICAgICAgbGV0IHB1Ymxpc2hlZCA9IG5ldyBEYXRlKGF3YWl0IHNvbGlkLmRhdGFbbi51cmxdLmFzJHB1Ymxpc2hlZClcclxuICAgICAgICBuLnB1Ymxpc2hlZCA9IGAke3B1Ymxpc2hlZH1gXHJcbiAgICAgICAgbi50aW1lc3RhbXAgPSBwdWJsaXNoZWQuZ2V0VGltZSgpXHJcbiAgICAgIH0pO1xyXG4gICAgLyogIGNvbnNvbGUubG9nKG5vdGlmaWNhdGlvbnMpXHJcbiAgICAgIHRoaXMubG9nID0gXCJTb3J0IE5vdGlmaWNhdGlvbnNcIlxyXG4gICAgICBub3RpZmljYXRpb25zLnNvcnQoZnVuY3Rpb24oYSwgYil7XHJcbiAgICAgICAgcmV0dXJuIGEudGltZXN0YW1wIDwgYi50aW1lc3RhbXA7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zKi9cclxuXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdmbHV4LWVsZW1lbnQnLCBGbHV4RWxlbWVudCk7XHJcbiIsImltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XHJcbmltcG9ydCB7IEhlbGxvQWdlbnQgfSBmcm9tICcuLi9hZ2VudHMvaGVsbG8tYWdlbnQuanMnO1xyXG5cclxuY2xhc3MgTm90aWZpY2F0aW9uTGluZUVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIG5vdGlmaWNhdGlvbjoge3R5cGU6IE9iamVjdH0sXHJcbiAgICAgIGNyZWF0b3I6IHt0eXBlOiBPYmplY3R9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJOb3RpZmljYXRpb25MaW5lXCJcclxuICAgIHRoaXMubm90aWZpY2F0aW9uID0ge31cclxuICAgIHRoaXMuY3JlYXRvciA9IHt9XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICA8bGluayBocmVmPVwiY3NzL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG5cclxuICAgIDxkaXYgdGltZXN0YW1wPVwiJHt0aGlzLm5vdGlmaWNhdGlvbi50aW1lc3RhbXB9XCJcclxuICAgIHVybD1cIiR7dGhpcy5ub3RpZmljYXRpb24udXJsfVwiPlxyXG5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY29sLTJcIj5cclxuICAgICR7dGhpcy5jcmVhdG9yLnBob3RvICE9IFwidW5kZWZpbmVkXCI/XHJcbiAgICBodG1sYDxpbWcgY2xhc3M9XCJyb3VuZGVkLWNpcmNsZSBtbC0wXCIgd2lkdGg9XCIzMnB4XCJcclxuICAgIHNyYz1cIi8vaW1hZ2VzLndlc2Vydi5ubC8/dXJsPSR7dGhpcy5jcmVhdG9yLnBob3RvfSZ3PTMyJmg9MzJcIlxyXG4gICAgdGl0bGU9XCIke3RoaXMuY3JlYXRvci5uYW1lfVwiXHJcbiAgICBhbHQ9XCJubyBpbWFnZVwiXHJcbiAgICB3ZWJJZD1cIiR7dGhpcy5jcmVhdG9yLndlYklkfVwiXHJcbiAgICBAY2xpY2s9XCIke3RoaXMuc2hvd1Byb2ZpbGV9XCI+YFxyXG4gICAgOmh0bWxgPGkgY2xhc3M9XCJmYXMgZmEtdXNlci1jaXJjbGUgZmEtMnhcIlxyXG4gICAgdGl0bGU9XCIke3RoaXMuY3JlYXRvci5uYW1lfVwiXHJcbiAgICB3ZWJJZD1cIiR7dGhpcy5jcmVhdG9yLndlYklkfVwiXHJcbiAgICBAY2xpY2s9XCIke3RoaXMuc2hvd1Byb2ZpbGV9XCI+PC9pPmBcclxuICB9XHJcblxyXG4gIDxwIGNsYXNzPVwidGV4dC1tdXRlZCBzbWFsbFwiPiR7dGhpcy5kZWxheSh0aGlzLm5vdGlmaWNhdGlvbi5wdWJsaXNoZWQpfTwvcD5cclxuICA8L2Rpdj5cclxuXHJcbiAgPGRpdiBjbGFzcz1cImNvbFwiPlxyXG4gIDxzbWFsbCBjbGFzcz1cInRleHQtbXV0ZWRcIiB3ZWJJZD1cIiR7dGhpcy5ub3RpZmljYXRpb24uYXR0cmlidXRlZFRvfVwiXHJcbiAgQGNsaWNrPVwiJHt0aGlzLnNob3dQcm9maWxlfVwiPlxyXG4gICR7dGhpcy5jcmVhdG9yLm5hbWV9XHJcbiAgPC9zbWFsbD5cclxuICA8YWN0aXZpdHktZWxlbWVudCBuYW1lPVwiJHt0aGlzLm5hbWUrJ19hY3Rpdml0eSd9XCJcclxuICB1cmw9XCIke3RoaXMubm90aWZpY2F0aW9uLmxpbmt9XCI+TG9hZGluZyBhY3Rpdml0eSAke3RoaXMubm90aWZpY2F0aW9uLmxpbmt9Li4uXHJcbiAgPC9hY3Rpdml0eS1lbGVtZW50PlxyXG4gIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG5cclxuXHJcbiAgPC9kaXY+XHJcbiAgYDtcclxufVxyXG5cclxuXHJcbnNob3dQcm9maWxlKCl7XHJcbiAgdGhpcy5hZ2VudC5zZW5kKFwiQXBwXCIsIHthY3Rpb246IFwic2hvd1BhbmVsXCIsIHBhbmVsOiBcIlByb2ZpbGVcIn0pXHJcbiAgdGhpcy5hZ2VudC5zZW5kKFwiUHJvZmlsZVwiLCB7YWN0aW9uOiBcInByb2ZpbGVDaGFuZ2VkXCIsIHByb2ZpbGU6IHRoaXMuY3JlYXRvcn0pXHJcbn1cclxuXHJcbmRlbGF5KHB1Ymxpc2hlZCl7XHJcbiAgbGV0IGRpZmYgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIG5ldyBEYXRlKHB1Ymxpc2hlZCkuZ2V0VGltZSgpXHJcbiAgbGV0IG1pbnV0ZSA9IDEwMDAgKiA2MDtcclxuICBsZXQgbWludXRlcyA9IE1hdGguZmxvb3IoZGlmZi9taW51dGUpO1xyXG4gIGxldCBoZXVyZXMgPSBNYXRoLmZsb29yKG1pbnV0ZXMvNjApO1xyXG4gIGxldCBqb3VycyA9IE1hdGguZmxvb3IoaGV1cmVzLzI0KTtcclxuICBsZXQgbW9pcyA9IE1hdGguZmxvb3Ioam91cnMvMzEpO1xyXG4gIGxldCBhbm5lZXMgPSBNYXRoLmZsb29yKG1vaXMvMTIpO1xyXG4gIGxldCBkdXJlZSA9IFwiXCJcclxuICBhbm5lZXMgPiAwID8gZHVyZWUrPSBhbm5lZXMrXCJ5XCIgOlxyXG4gIG1vaXMgPiAwID8gZHVyZWUrPSBtb2lzK1wibVwiIDpcclxuICBqb3VycyA+IDAgPyBkdXJlZSArPSBqb3VycytcImpcIjpcclxuICBoZXVyZXMgPiAwID8gZHVyZWUgKz0gaGV1cmVzK1wiaFwiOlxyXG4gIG1pbnV0ZXMgPiAwID8gZHVyZWUgKz0gbWludXRlcytcIm1cIjpcclxuICBkdXJlZSA9IGRpZmYvMTAwMCsgXCJzXCI7XHJcbiAgcmV0dXJuIGR1cmVlXHJcbn1cclxuXHJcblxyXG5cclxuZmlyc3RVcGRhdGVkKCl7XHJcbiAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgLy8gIGNvbnNvbGUubG9nKHRoaXMuYWdlbnQpXHJcbiAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgLy8gIGNvbnNvbGUubG9nKFwibWVzc2FoXCIsbWVzc2FnZSlcclxuICAgIGlmIChtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWN0aW9uXCIpKXtcclxuICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgIHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xyXG4gICAgICAgIGNhc2UgXCJ3ZWJJZENoYW5nZWRcIjpcclxuICAgICAgICBhcHAud2ViSWRDaGFuZ2VkKG1lc3NhZ2Uud2ViSWQpXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG4gIHRoaXMuaW5pdCgpXHJcbn1cclxuXHJcbmFzeW5jIGluaXQoKXtcclxuICAvLyAgICBjb25zb2xlLmxvZyh0aGlzLm5vdGlmaWNhdGlvbi51cmwpXHJcbiAgdGhpcy5jcmVhdG9yLndlYklkID0gYXdhaXQgc29saWQuZGF0YVt0aGlzLm5vdGlmaWNhdGlvbi51cmxdLmFzJGF0dHJpYnV0ZWRUb1xyXG4gIHRoaXMubm90aWZpY2F0aW9uLnN1bW1hcnkgPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMubm90aWZpY2F0aW9uLnVybF0uYXMkc3VtbWFyeVxyXG4gIHRoaXMubm90aWZpY2F0aW9uLnR5cGUgPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMubm90aWZpY2F0aW9uLnVybF0uYXMkdHlwZVxyXG4gIGxldCBsaW5rID0gYXdhaXQgc29saWQuZGF0YVt0aGlzLm5vdGlmaWNhdGlvbi51cmxdLmFzJGxpbmtcclxuICB0aGlzLm5vdGlmaWNhdGlvbi5saW5rID0gYCR7bGlua31gXHJcbiAgdGhpcy5jcmVhdG9yLm5hbWUgPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMuY3JlYXRvci53ZWJJZF0udmNhcmQkZm4gfHwgYCR7dGhpcy5jcmVhdG9yLndlYklkfWAuc3BsaXQoXCIvXCIpWzJdLnNwbGl0KCcuJylbMF07XHJcbiAgbGV0IHBob3RvID0gYXdhaXQgc29saWQuZGF0YVt0aGlzLmNyZWF0b3Iud2ViSWRdLnZjYXJkJGhhc1Bob3RvXHJcbiAgdGhpcy5jcmVhdG9yLnBob3RvID0gYCR7cGhvdG99YCAvLyE9IFwidW5kZWZpbmVkXCIgPyBgJHtwaG90b31gIDogXCJodHRwczovL3NvbGlkLmdpdGh1Yi5pby9zb2xpZC11aS9zcmMvaWNvbnMvbm91bl8xNTA1OS5zdmdcIlxyXG5cclxuICAvLyAgY29uc29sZS5sb2codGhpcy5ub3RpZmljYXRpb24pXHJcbiAgdGhpcy5yZXF1ZXN0VXBkYXRlKClcclxufVxyXG5cclxuXHJcbmxvY2FsTmFtZShzdHJQcm9taXNlKXtcclxuICBsZXQgc3RyID0gYCR7c3RyUHJvbWlzZX1gXHJcbiAgdmFyIGxuID0gc3RyLnN1YnN0cmluZyhzdHIubGFzdEluZGV4T2YoJyMnKSsxKTtcclxuICAvL2NvbnNvbGUubG9nKGxuKVxyXG4gIGxuID09IHN0ciA/IGxuID0gc3RyLnN1YnN0cmluZyhzdHIubGFzdEluZGV4T2YoJy8nKSsxKSA6IFwiXCI7XHJcbiAgcmV0dXJuIGxuXHJcbn1cclxuXHJcbn1cclxuXHJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbm90aWZpY2F0aW9uLWxpbmUtZWxlbWVudCcsIE5vdGlmaWNhdGlvbkxpbmVFbGVtZW50KTtcclxuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcbi8vbGV0IGRhdGEgPSBzb2xpZC5kYXRhXHJcbi8vY29uc29sZS5sb2coXCJMREZLK0xFWFwiLGRhdGEpXHJcbi8vaW1wb3J0ICcuL29iamVjdC1lbGVtZW50LmpzJ1xyXG5cclxuXHJcbmNsYXNzIEFjdGl2aXR5RWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xyXG5cclxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgdXJsOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgYWN0aXZpdHk6IHt0eXBlOiBPYmplY3R9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJBY3Rpdml0eVwiXHJcbiAgICB0aGlzLnVybCA9IFwiXCJcclxuICAgIHRoaXMuYWN0aXZpdHkgPSB7b2JqZWN0czpbXX1cclxuICB9XHJcblxyXG4gIHJlbmRlcigpe1xyXG4gICAgcmV0dXJuIGh0bWxgXHJcbiAgICA8bGluayBocmVmPVwiY3NzL2Jvb3RzdHJhcC9ib290c3RyYXAubWluLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvZm9udGF3ZXNvbWUvY3NzL2FsbC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcblxyXG4gICAgPGRpdiBjbGFzcz1cInJvd1wiIGlkPVwiJHt0aGlzLnVybH1cIj5cclxuICAgICAgPHAgY2xhc3M9XCJsZWFkXCI+XHJcbiAgICAke3RoaXMuYWN0aXZpdHkuc3VtbWFyeX1cclxuICAgIDwvcD5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgICR7dGhpcy5hY3Rpdml0eS5vYmplY3RzLm1hcChvYmplY3QgPT5odG1sYFxyXG4gICAgICA8b2JqZWN0LWVsZW1lbnQgbmFtZT1cIiR7dGhpcy5uYW1lKydfb2JqZWN0J31cIlxyXG4gICAgICB1cmw9XCIke29iamVjdH1cIj5cclxuICAgICAgTG9hZGluZyBvYmplY3RcclxuICAgICAgPC9vYmplY3QtZWxlbWVudD5cclxuICAgICAgYCl9XHJcblxyXG4gICAgICA8ZGl2IGNsYXNzPVwicm93IG10LTJcIj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1pbmZvIGJ0bi1zbVwiICBAY2xpY2s9XCIke3RoaXMucmVwbHlUb31cIj5SZXBseTwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLWluZm8gYnRuLXNtXCI+PGkgY2xhc3M9XCJmYXMgZmEtc2hhcmUtYWx0XCIgQGNsaWNrPVwiJHt0aGlzLnNoYXJlfVwiPjwvaT48L2J1dHRvbj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1pbmZvIGJ0bi1zbVwiPjxpIGNsYXNzPVwiZmFyIGZhLXRodW1icy11cFwiIEBjbGljaz1cIiR7dGhpcy5saWtlfVwiPjwvaT48L2J1dHRvbj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1pbmZvIGJ0bi1zbVwiPjxpIGNsYXNzPVwiZmFyIGZhLXRodW1icy1kb3duXCIgQGNsaWNrPVwiJHt0aGlzLmRpc2xpa2V9XCI+PC9pPjwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuXHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG4gICAgbGlrZSgpe1xyXG4gICAgICBhbGVydChcIi8vIFRPRE86IGNvbWUgYmFjayBsYXRlciA7LSkgXCIpXHJcbiAgICB9XHJcbiAgICBkaXNsaWtlKCl7XHJcbiAgICAgIGFsZXJ0KFwiLy8gVE9ETzogY29tZSBiYWNrIGxhdGVyIDstKSBcIilcclxuICAgIH1cclxuXHJcbiAgICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgICAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgICAgIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xyXG4gICAgICAvLyAgY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICAgICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcIm1lc3NhaFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBcIndlYklkQ2hhbmdlZFwiOlxyXG4gICAgICAgICAgICBhcHAud2ViSWRDaGFuZ2VkKG1lc3NhZ2Uud2ViSWQpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICAvLyAgdGhpcy5pbml0KClcclxuICAgIH1cclxuXHJcblxyXG4gICAgc2hhcmUoKXtcclxuICAgICAgaWYgKG5hdmlnYXRvci5zaGFyZSkge1xyXG4gICAgICAgIG5hdmlnYXRvci5zaGFyZSh7XHJcbiAgICAgICAgICB0aXRsZTogXCJUYWtlIGEgbG9vayBhdCB0aGF0IEFnb3JhIFNwb2cgOlxcblxcblwiLFxyXG4gICAgICAgICAgdGV4dDogdGhpcy5hY3Rpdml0eS5zdW1tYXJ5K1wiXFxuXFxuXCIsXHJcbiAgICAgICAgICB1cmw6ICdodHRwczovL3NjZW5hcmlzdGV1ci5naXRodWIuaW8vYWdvcmE/YWN0aXZpdHk9Jyt0aGlzLnVybCsnXFxuXFxuJyxcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsIHNoYXJlJykpXHJcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gY29uc29sZS5sb2coJ0Vycm9yIHNoYXJpbmcnLCBlcnJvcikpO1xyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICB2YXIgdG8gPSAnJztcclxuICAgICAgICB2YXIgc3ViID0gXCJBZ29yYSA6IFwiK3RoaXMuYWN0aXZpdHkuc3VtbWFyeTtcclxuICAgICAgICB2YXIgYm9keSA9ICdJIHdhbnQgdG8gc2hhcmUgdGhpcyBsaW5rIHdpdGggeW91IDogICBcXG4gaHR0cHM6Ly9zY2VuYXJpc3RldXIuZ2l0aHViLmlvL2Fnb3JhP2FjdGl2aXR5PScrdGhpcy51cmwrJyAgXFxuIFxcbiAnO1xyXG4gICAgICAgIHZhciBtYWlsYXJyID0gW107XHJcbiAgICAgICAgaWYoc3ViIT1cIlwiKXtcclxuICAgICAgICAgIHN1YiA9IFwic3ViamVjdD1cIitlbmNvZGVVUklDb21wb25lbnQoc3ViKTtcclxuICAgICAgICAgIG1haWxhcnIucHVzaChzdWIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihib2R5IT1cIlwiKXtcclxuICAgICAgICAgIGJvZHkgPSBcImJvZHk9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGJvZHkpO1xyXG4gICAgICAgICAgbWFpbGFyci5wdXNoKGJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWFpbHN0ciA9IG1haWxhcnIuam9pbihcIiZcIik7XHJcbiAgICAgICAgaWYobWFpbHN0ciE9XCJcIikgeyBtYWlsc3RyID0gXCI/XCIrbWFpbHN0cjsgfVxyXG4gICAgICAgIHdpbmRvdy5vcGVuKFwibWFpbHRvOlwiK3RvK21haWxzdHIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpIHtcclxuICAgICAgY2hhbmdlZFByb3BlcnRpZXMuZm9yRWFjaCgob2xkVmFsdWUsIHByb3BOYW1lKSA9PiB7XHJcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKGAke3Byb3BOYW1lfSBjaGFuZ2VkLiBvbGRWYWx1ZTogJHtvbGRWYWx1ZX1gKTtcclxuICAgICAgICBpZiAoYCR7cHJvcE5hbWV9YCA9PSBcInVybFwiICYmIHRoaXMudXJsICE9IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgICAgICAgdGhpcy5pbml0KClcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGluaXQoKXtcclxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLnVybClcclxuICAgICAgbGV0IG9iamVjdHMgPSBbXVxyXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IG9iamVjdCBvZiBzb2xpZC5kYXRhW3RoaXMudXJsXS5hcyRvYmplY3Qpe1xyXG5cclxuICAgICAgICBvYmplY3RzID0gWy4uLm9iamVjdHMsIGAke29iamVjdH1gXVxyXG4gICAgICB9XHJcbi8vICAgICAgY29uc29sZS5sb2coXCJPQkpFQ1RTXCIsb2JqZWN0cylcclxuICAgICAgdGhpcy5hY3Rpdml0eS5vYmplY3RzID0gb2JqZWN0cyAvLyA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy51cmxdLmFzJG9iamVjdFxyXG4gICAgICB0aGlzLmFjdGl2aXR5LnRhcmdldCA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy51cmxdLmFzJHRhcmdldFxyXG4gICAgICB0aGlzLmFjdGl2aXR5LnN1bW1hcnkgPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMudXJsXS5hcyRzdW1tYXJ5XHJcbiAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpXHJcbiAgICB9XHJcblxyXG4gICAgbG9jYWxOYW1lKHN0clByb21pc2Upe1xyXG4gICAgICBsZXQgc3RyID0gYCR7c3RyUHJvbWlzZX1gXHJcbiAgICAgIHZhciBsbiA9IHN0ci5zdWJzdHJpbmcoc3RyLmxhc3RJbmRleE9mKCcjJykrMSk7XHJcbiAgICAgIGxuID09IHN0ciA/IGxuID0gc3RyLnN1YnN0cmluZyhzdHIubGFzdEluZGV4T2YoJy8nKSsxKSA6IFwiXCI7XHJcbiAgICAgIHJldHVybiBsblxyXG4gICAgfVxyXG5cclxuICAgIHJlcGx5VG8oKXtcclxuICAgICAgY29uc29sZS5sb2codGhpcy51cmwpXHJcbiAgICAgIHRoaXMuYWdlbnQuc2VuZChcIkFwcFwiLCB7YWN0aW9uOiBcInNob3dQYW5lbFwiLCBwYW5lbDpcIkNvbXBvc2VcIn0pXHJcbiAgICAgIHRoaXMuYWdlbnQuc2VuZChcIlBvc3RcIiwge2FjdGlvbjogXCJ0b2dnbGVXcml0ZVwifSlcclxuICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiUG9zdFRhYnNcIiwge2FjdGlvbjpcInNldFJlcGx5VG9cIiwgcmVwbHlUbzogdGhpcy51cmwgfSlcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2FjdGl2aXR5LWVsZW1lbnQnLCBBY3Rpdml0eUVsZW1lbnQpO1xyXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcclxuLy9sZXQgZGF0YSA9IHNvbGlkLmRhdGFcclxuLy9jb25zb2xlLmxvZyhcIkxERksrTEVYXCIsZGF0YSlcclxuXHJcbmNsYXNzIE9iamVjdEVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIHVybDoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIG9iamVjdDoge3R5cGU6IE9iamVjdH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIk9iamVjdFwiXHJcbiAgICB0aGlzLnVybCA9IFwiXCJcclxuICAgIHRoaXMub2JqZWN0ID0ge31cclxuICB9XHJcblxyXG4gIHJlbmRlcigpe1xyXG5cclxuXHJcbiAgICByZXR1cm4gaHRtbGBcclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIiA+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY29sXCI+XHJcblxyXG4gICAgJHt0aGlzLm9iamVjdC5leHQgPT0gXCJqcGdcIiA/XHJcbiAgICBodG1sYDxpbWcgc3JjPVwiJHt0aGlzLnVybH1cIiBzdHlsZT0naGVpZ2h0OiBhdXRvOyB3aWR0aDogNzUlOyBtYXgtd2lkdGg6IDMwMHB4OyBvYmplY3QtZml0OiBjb250YWluJyBhbHQ9XCIke3RoaXMudXJsfVwiLz5gXHJcbiAgICA6aHRtbGAgYCB9XHJcbiAgPHNtYWxsPiA8ZGl2IGlkPVwiY29udGVudFwiPiR7dGhpcy5vYmplY3QuY29udGVudH08L2Rpdj48L3NtYWxsPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICBgO1xyXG4gIH1cclxuXHJcblxyXG4gIGxpbmtpZnkoaW5wdXRUZXh0KSB7XHJcbiAgICAvLyA8IS0tICAgICR7dGhpcy5saW5raWZ5KGAke3RoaXMub2JqZWN0LmNvbnRlbnR9YCl9LS0+XHJcbiAgICAvL2NvbnNvbGUubG9nKGlucHV0VGV4dClcclxuICAgIC8vVVJMcyBzdGFydGluZyB3aXRoIGh0dHA6Ly8sIGh0dHBzOi8vLCBvciBmdHA6Ly9cclxuICAgIHZhciByZXBsYWNlUGF0dGVybjEgPSAvKFxcYihodHRwcz98ZnRwKTpcXC9cXC9bLUEtWjAtOSsmQCNcXC8lPz1+X3whOiwuO10qWy1BLVowLTkrJkAjXFwvJT1+X3xdKS9naW07XHJcbiAgICB2YXIgcmVwbGFjZWRUZXh0ID0gaW5wdXRUZXh0LnJlcGxhY2UocmVwbGFjZVBhdHRlcm4xLCAnIDxzbWFsbD48YSBocmVmPVwiJDFcIiB0YXJnZXQ9XCJfYmxhbmtcIj4kMTwvYT48L3NtYWxsPiAnKTtcclxuXHJcbiAgICAvL1VSTHMgc3RhcnRpbmcgd2l0aCB3d3cuICh3aXRob3V0IC8vIGJlZm9yZSBpdCwgb3IgaXQnZCByZS1saW5rIHRoZSBvbmVzIGRvbmUgYWJvdmUpXHJcbiAgICB2YXIgcmVwbGFjZVBhdHRlcm4yID0gLyhefFteXFwvXSkod3d3XFwuW1xcU10rKFxcYnwkKSkvZ2ltO1xyXG4gICAgdmFyIHJlcGxhY2VkVGV4dCA9IHJlcGxhY2VkVGV4dC5yZXBsYWNlKHJlcGxhY2VQYXR0ZXJuMiwgJyA8c21hbGw+JDE8YSBocmVmPVwiaHR0cDovLyQyXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JDI8L2E+PC9zbWFsbD4gJyk7XHJcblxyXG4gICAgLy9DaGFuZ2UgZW1haWwgYWRkcmVzc2VzIHRvIG1haWx0bzo6IGxpbmtzXHJcbiAgICB2YXIgcmVwbGFjZVBhdHRlcm4zID0gLyhcXHcrQFthLXpBLVpfXSs/XFwuW2EtekEtWl17Miw2fSkvZ2ltO1xyXG4gICAgdmFyIHJlcGxhY2VkVGV4dCA9IHJlcGxhY2VkVGV4dC5yZXBsYWNlKHJlcGxhY2VQYXR0ZXJuMywgJzxhIGhyZWY9XCJtYWlsdG86JDFcIj4kMTwvYT4nKTtcclxuICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChcImNvbnRlbnRcIikuaW5uZXJIVE1MID0gcmVwbGFjZWRUZXh0XHJcbiAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKVxyXG4gICAgLy8gICAgcmV0dXJuIGh0bWxgJHtyZXBsYWNlZFRleHR9YFxyXG4gIH1cclxuXHJcblxyXG5cclxuXHJcbiAgZmlyc3RVcGRhdGVkKCl7XHJcbiAgICB2YXIgYXBwID0gdGhpcztcclxuICAgIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xyXG4gICAgLy8gIGNvbnNvbGUubG9nKHRoaXMuYWdlbnQpXHJcbiAgICB0aGlzLmFnZW50LnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgICAgIC8vICBjb25zb2xlLmxvZyhcIm1lc3NhaFwiLG1lc3NhZ2UpXHJcbiAgICAgIGlmIChtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWN0aW9uXCIpKXtcclxuICAgICAgICAvLyAgY29uc29sZS5sb2cobWVzc2FnZSlcclxuICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgIGNhc2UgXCJ3ZWJJZENoYW5nZWRcIjpcclxuICAgICAgICAgIGFwcC53ZWJJZENoYW5nZWQobWVzc2FnZS53ZWJJZClcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gIH1cclxuXHJcbiAgdXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcykge1xyXG4gICAgY2hhbmdlZFByb3BlcnRpZXMuZm9yRWFjaCgob2xkVmFsdWUsIHByb3BOYW1lKSA9PiB7XHJcbiAgICAgIC8vICBjb25zb2xlLmxvZyhgJHtwcm9wTmFtZX0gY2hhbmdlZC4gb2xkVmFsdWU6ICR7b2xkVmFsdWV9YCk7XHJcbiAgICAgIGlmIChgJHtwcm9wTmFtZX1gID09IFwidXJsXCIgJiYgdGhpcy51cmwgIT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgdGhpcy5pbml0KClcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbml0KCl7XHJcbiAgICAvL2NvbnNvbGUubG9nKHRoaXMudXJsKVxyXG4gICAgdGhpcy5vYmplY3QuZXh0ID0gdGhpcy51cmwuc3Vic3RyKHRoaXMudXJsLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcclxuXHJcbiAgICBpZiAodGhpcy5vYmplY3QuZXh0ID09IFwidHRsI3RoaXNcIil7XHJcbiAgICAgIGxldCBhcyA9IFwiaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNcIlxyXG4gICAgICAvLyAgdGhpcy5vYmplY3QubmFtZSA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy51cmxdLmFzJG5hbWVcclxuICAgICAgbGV0IHR5cGUgPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMudXJsXS5hcyR0eXBlXHJcbiAgICAgIHRoaXMub2JqZWN0LnR5cGUgPSBgJHt0eXBlfWBcclxuICAgICAgc3dpdGNoICh0aGlzLmxvY2FsTmFtZShgJHt0eXBlfWApKSB7XHJcbiAgICAgICAgY2FzZSBcIlRyaXBsZVwiOlxyXG4gICAgICAgIHRoaXMub2JqZWN0LmNvbnRlbnQ9IFwiXCIgLy9cIlt0b2RvIHBhcnNlIHRyaXBsZXMgbGlrZSBcIisgdGhpcy51cmwrXCI8L3NtYWxsPl1cIlxyXG4gICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIk5vdGVcIjpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRoaXMub2JqZWN0LmNvbnRlbnQgPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMudXJsXS5hcyRjb250ZW50XHJcbiAgICAgICAgdGhpcy5saW5raWZ5KGAke3RoaXMub2JqZWN0LmNvbnRlbnR9YClcclxuICAgICAgfVxyXG4gICAgfWVsc2V7XHJcbiAgICAvLyAgY29uc29sZS5sb2codGhpcy5vYmplY3QuZXh0LHRoaXMudXJsKVxyXG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKVxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIGxvY2FsTmFtZShzdHJQcm9taXNlKXtcclxuICAgIGxldCBzdHIgPSBgJHtzdHJQcm9taXNlfWBcclxuICAgIHZhciBsbiA9IHN0ci5zdWJzdHJpbmcoc3RyLmxhc3RJbmRleE9mKCcjJykrMSk7XHJcbiAgICBsbiA9PSBzdHIgPyBsbiA9IHN0ci5zdWJzdHJpbmcoc3RyLmxhc3RJbmRleE9mKCcvJykrMSkgOiBcIlwiO1xyXG4gICAgcmV0dXJuIGxuXHJcbiAgfVxyXG5cclxuXHJcbn1cclxuXHJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb2JqZWN0LWVsZW1lbnQnLCBPYmplY3RFbGVtZW50KTtcclxuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcblxyXG5pbXBvcnQgKiBhcyBTb2xpZEZpbGVDbGllbnQgZnJvbSBcInNvbGlkLWZpbGUtY2xpZW50XCJcclxuaW1wb3J0IHsgbmFtZWROb2RlIH0gZnJvbSAnQHJkZmpzL2RhdGEtbW9kZWwnO1xyXG5cclxuY2xhc3MgQ29uZmlnR2V0VmlldyBleHRlbmRzIExpdEVsZW1lbnQge1xyXG5cclxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZyB9LFxyXG4gICAgICBjb25maWc6IHt0eXBlOiBPYmplY3R9LFxyXG4gICAgICBsb2c6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBhY2xJbmJveDoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIHRleHRDb2xvcjoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGRlYnVnOiB7dHlwZTogQm9vbGVhbn0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJDb25maWcgR0VUXCJcclxuICAgIHRoaXMuY29uZmlnID0ge31cclxuICAgIHRoaXMubG9nID0gXCJJbml0XCJcclxuICAgIHRoaXMudGV4dENvbG9yID0gXCJ0ZXh0LXByaW1hcnlcIlxyXG4gICAgdGhpcy5kZWJ1ZyA9IGZhbHNlXHJcbiAgICB0aGlzLmFjbEluYm94Q29udGVudCA9IGBAcHJlZml4IDogPCM+LlxyXG4gICAgQHByZWZpeCBhY2w6IDxodHRwOi8vd3d3LnczLm9yZy9ucy9hdXRoL2FjbCM+LlxyXG4gICAgQHByZWZpeCBpbmJveDogPC4vPi5cclxuICAgIEBwcmVmaXggYzogPC9wcm9maWxlL2NhcmQjPi5cclxuXHJcbiAgICA6QXBwZW5kXHJcbiAgICBhIGFjbDpBdXRob3JpemF0aW9uO1xyXG4gICAgYWNsOmFjY2Vzc1RvIDwuLz47XHJcbiAgICBhY2w6YWdlbnRDbGFzcyBhY2w6QXV0aGVudGljYXRlZEFnZW50O1xyXG4gICAgYWNsOmRlZmF1bHQgPC4vPjtcclxuICAgIGFjbDptb2RlIGFjbDpBcHBlbmQuXHJcbiAgICA6Q29udHJvbFJlYWRXcml0ZVxyXG4gICAgYSBhY2w6QXV0aG9yaXphdGlvbjtcclxuICAgIGFjbDphY2Nlc3NUbyA8Li8+O1xyXG4gICAgYWNsOmFnZW50IGM6bWU7XHJcbiAgICBhY2w6ZGVmYXVsdCA8Li8+O1xyXG4gICAgYWNsOm1vZGUgYWNsOkNvbnRyb2wsIGFjbDpSZWFkLCBhY2w6V3JpdGUuXHJcbiAgICA6UmVhZFxyXG4gICAgYSBhY2w6QXV0aG9yaXphdGlvbjtcclxuICAgIGFjbDphY2Nlc3NUbyA8Li8+O1xyXG4gICAgYWNsOmRlZmF1bHQgPC4vPjtcclxuICAgIGFjbDptb2RlIGFjbDpSZWFkLmBcclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICA8bGluayBocmVmPVwiY3NzL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG5cclxuICAgIDxkaXYgP2hpZGRlbiA9IFwiJHshdGhpcy5kZWJ1Z31cIj5cclxuICAgIEhlbGxvIGZyb208Yj4ke3RoaXMubmFtZX08L2I+PGJyPlxyXG4gICAgY29uZmlnIDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNvbmZpZyl9PC9icj5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDxoND5Db25maWd1cmF0aW9uPC9oND5cclxuICAgIExvZyA6IDxzcGFuIGNsYXNzPVwiJHt0aGlzLnRleHRDb2xvcn1cIj4ke3RoaXMubG9nfTwvc3Bhbj48YnI+PGJyPlxyXG4gICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tZGFuZ2VyXCIgQGNsaWNrPVwiJHt0aGlzLmNoZWNrQ29uZmlnfVwiPlJFLWNoZWNrIGNvbmZpZ3VyYXRpb24gZnJvbSBQT0Q8L2J1dHRvbj5cclxuXHJcblxyXG4gICAgPHVsIGNsYXNzPVwibGlzdC1ncm91cFwiPlxyXG4gICAgJHtPYmplY3QuZW50cmllcyh0aGlzLmNvbmZpZykubWFwKChba2V5LCB2YWx1ZV0pID0+XHJcbiAgICAgIGh0bWxgXHJcbiAgICAgIDxsaSBjbGFzcz1cImxpc3QtZ3JvdXAtaXRlbSAke3ZhbHVlID09IFwidW5kZWZpbmVkXCIgPyBcImxpc3QtZ3JvdXAtaXRlbS1kYW5nZXIgbGlzdC1ncm91cC1pdGVtLWFjdGlvblwiIDogXCJsaXN0LWdyb3VwLWl0ZW0tc3VjY2Vzc1wifVwiPlxyXG4gICAgICAke2tleX0gOiA8c21hbGw+PGEgaHJlZj1cIiR7dmFsdWV9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+JHt2YWx1ZX08L2E+PC9zbWFsbD48L2xpPlxyXG4gICAgICBgKSB9XHJcbiAgICAgIDwvdWw+XHJcblxyXG5cclxuICAgICAgPGRpdiBpZD1cIm1vZGFsMVwiIGNsYXNzPVwibW9kYWxcIiB0YWJpbmRleD1cIi0xXCIgcm9sZT1cImRpYWxvZ1wiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZGlhbG9nIG1vZGFsLWxnXCIgcm9sZT1cImRvY3VtZW50XCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj5cclxuICAgICAgPGg1IGNsYXNzPVwibW9kYWwtdGl0bGVcIj4ke3RoaXMubG9nfTwvaDU+XHJcbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiIEBjbGljaz1cIiR7dGhpcy5oaWRlTW9kYWx9XCI+XHJcbiAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XHJcbiAgICAgIDwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj5cclxuICAgICAgPGZvcm0+XHJcblxyXG4gICAgICA8ZGl2IHN0eWxlPVwib3ZlcmZsb3cteDphdXRvXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxyXG4gICAgICA8bGFiZWwgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbFwiIGZvcj1cInBhdGhJbnB1dFwiPlBhdGg8L2xhYmVsPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cclxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cInBhdGhJbnB1dFwiXHJcbiAgICAgIHBsYWNlaG9sZGVyPVwiUGF0aFwiXHJcbiAgICAgIHZhbHVlPVwiJHt0aGlzLnBhdGh9XCJcclxuICAgICAgQGlucHV0PVwiJHt0aGlzLnBhdGhDaGFuZ2VkfVwiPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcblxyXG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cclxuICAgICAgPGxhYmVsIGZvcj1cInN0YXRpY0luYm94XCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbFwiPkluYm94PC9sYWJlbD5cclxuICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS05XCI+XHJcbiAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIHJlYWRvbmx5IGNsYXNzPVwiZm9ybS1jb250cm9sLXBsYWludGV4dFwiIGlkPVwic3RhdGljSW5ib3hcIiA+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxyXG4gICAgICA8bGFiZWwgZm9yPVwic3RhdGljT3V0Ym94XCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbFwiPk91dGJveDwvbGFiZWw+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tOVwiPlxyXG4gICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiByZWFkb25seSBjbGFzcz1cImZvcm0tY29udHJvbC1wbGFpbnRleHRcIiBpZD1cInN0YXRpY091dGJveFwiID5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9mb3JtPlxyXG5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBAY2xpY2s9XCIke3RoaXMuY3JlYXRlRm9sZGVyc31cIj5TYXZlIGNoYW5nZXM8L2J1dHRvbj5cclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeVwiXHJcbiAgICAgIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCIgQGNsaWNrPVwiJHt0aGlzLmhpZGVNb2RhbH1cIj5DbG9zZTwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgYDtcclxuICAgIH1cclxuXHJcbiAgICBuZXdDb25maWcoY29uZmlnKXtcclxuICAgICAgY29uc29sZS5sb2coXCJcIilcclxuICAgICAgdGhpcy5jb25maWcgPSBjb25maWdcclxuICAgICAgdGhpcy5jaGVja0NvbmZpZygpXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgY2hlY2tDb25maWcoKXtcclxuICAgICAgdGhpcy50ZXh0Q29sb3IgPSBcInRleHQtcHJpbWFyeVwiXHJcbiAgICAgIHRoaXMubG9nID0gXCJDaGVja2luZyBQdWJsaWNUeXBlSW5kZXhcIlxyXG4gICAgICB0aGlzLmNvbmZpZy5kYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgdGhpcy5jb25maWcuc3RhdHVzID0gXCJ1bmtub3duXCJcclxuICAgICAgdGhpcy5jb25maWcub3JpZ2luID0gXCJwb2RcIlxyXG4gICAgICB0aGlzLmNvbmZpZy5wdGk9IFwidW5kZWZpbmVkXCJcclxuICAgICAgbGV0IHB0aSA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy5jb25maWcud2ViSWRdLnB1YmxpY1R5cGVJbmRleFxyXG4gICAgICB0aGlzLmNvbmZpZy5wdGkgPSBgJHtwdGl9YFxyXG4gICAgICB0aGlzLmxvZyA9IFwiQ2hlY2tpbmcgSW5zdGFuY2VzXCJcclxuICAgICAgdGhpcy5jb25maWcuaW5zdGFuY2U9IFwidW5kZWZpbmVkXCJcclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBzdWJqZWN0IG9mIHNvbGlkLmRhdGFbdGhpcy5jb25maWcucHRpXS5zdWJqZWN0cyl7XHJcbiAgICAgICAgaWYodGhpcy5jb25maWcucHRpICE9IGAke3N1YmplY3R9YClcclxuICAgICAgICAvKmxldCBzID0gYCR7c3ViamVjdH1gXHJcbiAgICAgICAgY29uc29sZS5sb2cocykqL1xyXG4gICAgICAgIHRoaXMubG9nID0gXCJDaGVja2luZyBBZ29yYSBJbnN0YW5jZVwiXHJcblxyXG4gICAgICAgIGlmIChgJHtzdWJqZWN0fWAuZW5kc1dpdGgoJyNBZ29yYScpKXtcclxuICAgICAgICAgIGxldCBpbnN0YW5jZSAgPSBhd2FpdCBzb2xpZC5kYXRhW2Ake3N1YmplY3R9YF0uc29saWQkaW5zdGFuY2VcclxuICAgICAgICAgIHRoaXMuY29uZmlnLmluc3RhbmNlID0gYCR7aW5zdGFuY2V9YFxyXG4gICAgICAgICAgdGhpcy5sb2cgPSBcIkNoZWNraW5nIEluYm94XCJcclxuICAgICAgICAgIHRoaXMuY29uZmlnLmluYm94PSBcInVuZGVmaW5lZFwiXHJcbiAgICAgICAgICBsZXQgaW5ib3ggPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMuY29uZmlnLmluc3RhbmNlXS5hcyRpbmJveFxyXG4gICAgICAgICAgdGhpcy5jb25maWcuaW5ib3ggPSBgJHtpbmJveH1gXHJcbiAgICAgICAgICB0aGlzLmxvZyA9IFwiQ2hlY2tpbmcgT3V0Ym94XCJcclxuICAgICAgICAgIHRoaXMuY29uZmlnLm91dGJveD0gXCJ1bmRlZmluZWRcIlxyXG4gICAgICAgICAgbGV0IG91dGJveCA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy5jb25maWcuaW5zdGFuY2VdLmFzJG91dGJveFxyXG4gICAgICAgICAgdGhpcy5jb25maWcub3V0Ym94ID0gYCR7b3V0Ym94fWBcclxuICAgICAgICAgIHRoaXMubG9nID0gXCJDaGVja2luZyBGb2xsb3dlcnNcIlxyXG4gICAgICAgICAgdGhpcy5jb25maWcuZm9sbG93ZXJzPSBcInVuZGVmaW5lZFwiXHJcbiAgICAgICAgICBsZXQgZm9sbG93ZXJzID0gYXdhaXQgc29saWQuZGF0YVt0aGlzLmNvbmZpZy5pbnN0YW5jZV0uYXMkZm9sbG93ZXJzXHJcbiAgICAgICAgICB0aGlzLmNvbmZpZy5mb2xsb3dlcnMgPSBgJHtmb2xsb3dlcnN9YFxyXG4gICAgICAgICAgdGhpcy5sb2cgPSBcIkNoZWNraW5nIEZvbGxvd2luZ1wiXHJcbiAgICAgICAgICB0aGlzLmNvbmZpZy5mb2xsb3dpbmc9IFwidW5kZWZpbmVkXCJcclxuICAgICAgICAgIGxldCBmb2xsb3dpbmcgPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMuY29uZmlnLmluc3RhbmNlXS5hcyRmb2xsb3dpbmdcclxuICAgICAgICAgIHRoaXMuY29uZmlnLmZvbGxvd2luZyA9IGAke2ZvbGxvd2luZ31gXHJcbiAgICAgICAgICB0aGlzLmxvZyA9IFwiQ2hlY2tpbmcgTGlrZWRcIlxyXG4gICAgICAgICAgdGhpcy5jb25maWcubGlrZWQ9IFwidW5kZWZpbmVkXCJcclxuICAgICAgICAgIGxldCBsaWtlZCA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy5jb25maWcuaW5zdGFuY2VdLmFzJGxpa2VkXHJcbiAgICAgICAgICB0aGlzLmNvbmZpZy5saWtlZCA9IGAke2xpa2VkfWBcclxuICAgICAgICAgIHRoaXMubG9nID0gXCJDb29sLCB5b3VyIGNvbmZpZ3VyYXRpb24gc2VlbXMgT0tcIlxyXG4gICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0FjbCgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAgY29uc29sZS5sb2coT2JqZWN0LnZhbHVlcyh0aGlzLmNvbmZpZykpXHJcbiAgICAgIGlmKCBPYmplY3QudmFsdWVzKHRoaXMuY29uZmlnKS5pbmNsdWRlcyhcInVuZGVmaW5lZFwiKSl7XHJcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmxvZyArXCIgQ09ORklHVVJBVElPTiBOT1QgT0tcIlxyXG4gICAgICAgIHRoaXMudGV4dENvbG9yID0gXCJ0ZXh0LWRhbmdlclwiXHJcbiAgICAgICAgdGhpcy5jb25maWcuc3RhdHVzID0gXCJLT1wiXHJcbiAgICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiQXBwXCIsIHthY3Rpb246IFwic2hvd1BhbmVsXCIsIHBhbmVsOiBcIkNvbmZpZ1wifSlcclxuICAgICAgICB0aGlzLm9wZW5Db25maWdCb3goKVxyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmxvZyA9IFwiQ09ORklHVVJBVElPTiBPS1wiXHJcbiAgICAgICAgdGhpcy5jb25maWcuc3RhdHVzID0gXCJPS1wiXHJcbiAgICAgICAgdGhpcy50ZXh0Q29sb3IgPSBcInRleHQtc3VjY2Vzc1wiXHJcbiAgICAgICAgbGV0IGZyaWVuZHMgPSBbXVxyXG4gICAgICAgIGxldCBmb2xsb3dlcnMgPSBbXVxyXG4gICAgICAgIGxldCBmb2xsb3dpbmcgPSBbXVxyXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZnJpZW5kIG9mIHNvbGlkLmRhdGFbdGhpcy5jb25maWcud2ViSWRdLmZyaWVuZHMpe1xyXG4gICAgICAgICAgbGV0IGYgPSBgJHtmcmllbmR9YFxyXG4gICAgICAgICAgZnJpZW5kcyA9IFsuLi4gZnJpZW5kcywgZl1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25maWcuZnJpZW5kcyA9IGZyaWVuZHNcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcuZm9sbG93ZXJzX3VyaSA9IHRoaXMuY29uZmlnLmZvbGxvd2VycytcImluZGV4LnR0bCN0aGlzXCJcclxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGZfZXIgb2Ygc29saWQuZGF0YVt0aGlzLmNvbmZpZy5mb2xsb3dlcnNfdXJpXS5hcyRpdGVtcyl7XHJcbiAgICAgICAgICBsZXQgZmVyID0gYCR7Zl9lcn1gXHJcbiAgICAgICAgICBmb2xsb3dlcnMgPSBbLi4uIGZvbGxvd2VycywgZmVyXVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbmZpZy5mb2xsb3dlcnNMaXN0ID0gZm9sbG93ZXJzXHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnLmZvbGxvd2luZ191cmkgPSB0aGlzLmNvbmZpZy5mb2xsb3dpbmcrXCJpbmRleC50dGwjdGhpc1wiXHJcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBmX2luZyBvZiBzb2xpZC5kYXRhW3RoaXMuY29uZmlnLmZvbGxvd2luZ191cmldLmFzJGl0ZW1zKXtcclxuICAgICAgICAgIGxldCBmaW5nID0gYCR7Zl9pbmd9YFxyXG4gICAgICAgICAgZm9sbG93aW5nID0gWy4uLiBmb2xsb3dpbmcsIGZpbmddXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29uZmlnLmZvbGxvd2luZ0xpc3QgPSBmb2xsb3dpbmdcclxuXHJcbmxldCBzdG9yYWdlID0gYXdhaXQgc29saWQuZGF0YVt0aGlzLmNvbmZpZy53ZWJJZF0ucHVibGljVHlwZUluZGV4XHJcbnRoaXMuY29uZmlnLnN0b3JhZ2UgPSBgJHtzdG9yYWdlfWBcclxuXHJcbiAgICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiU3RvcmVcIiwge2FjdGlvbjogXCJzZXRTdG9yYWdlXCIsIHZhbHVlczoge2NvbmZpZzogdGhpcy5jb25maWd9fSlcclxuICAgICAgICB0aGlzLmFnZW50LnNlbmQoXCJBcHBcIiwge2FjdGlvbjogXCJzaG93UGFuZWxcIn0pXHJcbiAgICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiRnJpZW5kc1wiLCB7YWN0aW9uOiBcImNvbmZpZ0NoYW5nZWRcIiwgY29uZmlnOiB0aGlzLmNvbmZpZ30pXHJcbiAgICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiUHJvZmlsZVwiLCB7YWN0aW9uOiBcImNvbmZpZ0NoYW5nZWRcIiwgY29uZmlnOiB0aGlzLmNvbmZpZ30pXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBjaGVja0FjbCgpe1xyXG4gICAgICBsZXQgYXBwID0gdGhpc1xyXG4gICAgICB0aGlzLmxvZyA9IFwiQUNMIElOQk9YICYgRk9MTE9XRVJTIFZFUklGSUNBVElPTlwiXHJcbiAgICAgIHRoaXMuY29uZmlnLmFjbF9pbmJveD0gXCJ1bmRlZmluZWRcIlxyXG4gICAgICB0aGlzLmNvbmZpZy5hY2xfZm9sbG93ZXJzPSBcInVuZGVmaW5lZFwiXHJcbiAgICAgIGxldCBpbmJveGFjbCA9IHRoaXMuY29uZmlnLmluYm94K1wiLmFjbFwiXHJcbiAgICAgIGxldCBmb2xsb3dlcnNhY2wgPSB0aGlzLmNvbmZpZy5mb2xsb3dlcnMrXCIuYWNsXCJcclxuICAgICAgY29uc29sZS5sb2coaW5ib3hhY2wpXHJcbiAgICAgIGNvbnNvbGUubG9nKGZvbGxvd2Vyc2FjbClcclxuICAgICAgbGV0IGZjID0gbmV3IFNvbGlkRmlsZUNsaWVudChzb2xpZC5hdXRoKVxyXG5cclxuICAgICAgYXdhaXQgZmMuY3JlYXRlRmlsZSAoaW5ib3hhY2wsIHRoaXMuYWNsSW5ib3hDb250ZW50LCBcInRleHQvdHVydGxlXCIpIC50aGVuIChzdWNjZXNzID0+IHtcclxuICAgICAgICB0aGlzLmxvZyA9IFwiQ3JlYXRlZCBcIitpbmJveGFjbFxyXG4gICAgICAgIHRoaXMuY29uZmlnLmFjbF9pbmJveCA9IGluYm94YWNsXHJcbiAgICAgIH0sIGVyciA9PiB7XHJcbiAgICAgICAgdGhpcy5sb2cgPSBlcnJcclxuICAgICAgICBhbGVydChlcnIgKyBcIi4uLiBBcmUgeW91IHN1cmUgeW91IGdyYW50IEFHT1JBIHRvIEZVTEwgQ09OVFJPTCA/IHNlZSBIRUxQICFcIilcclxuICAgICAgICB0aGlzLmxvZyA9IGVyciArXCIuLi4gQXJlIHlvdSBzdXJlIHlvdSBncmFudCBBR09SQSB0byBGVUxMIENPTlRST0wgPyBQbGVhc2Ugc2VlIEhFTFAgIVwiXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgYXdhaXQgZmMuY3JlYXRlRmlsZSAoZm9sbG93ZXJzYWNsLCB0aGlzLmFjbEluYm94Q29udGVudCwgXCJ0ZXh0L3R1cnRsZVwiKSAudGhlbiAoc3VjY2VzcyA9PiB7XHJcbiAgICAgICAgdGhpcy5sb2cgPSBcIkNyZWF0ZWQgXCIrZm9sbG93ZXJzYWNsXHJcbiAgICAgICAgdGhpcy5jb25maWcuYWNsX2ZvbGxvd2VycyA9IGZvbGxvd2Vyc2FjbFxyXG4gICAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgIHRoaXMubG9nID0gZXJyXHJcbiAgICAgICAgYWxlcnQoZXJyICsgXCIuLi4gQXJlIHlvdSBzdXJlIHlvdSBncmFudCBBR09SQSB0byBGVUxMIENPTlRST0wgPyBzZWUgSEVMUCAhXCIpXHJcbiAgICAgICAgdGhpcy5sb2cgPSBlcnIgK1wiLi4uIEFyZSB5b3Ugc3VyZSB5b3UgZ3JhbnQgQUdPUkEgdG8gRlVMTCBDT05UUk9MID8gUGxlYXNlIHNlZSBIRUxQICFcIlxyXG4gICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBvcGVuQ29uZmlnQm94KCl7XHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuY29uZmlnLnB0aSlcclxuICAgICAgdGhpcy5zdG9yYWdlID0gYXdhaXQgc29saWQuZGF0YVt0aGlzLmNvbmZpZy53ZWJJZF0uc3RvcmFnZVxyXG4gICAgICBjb25zb2xlLmxvZyhgJHt0aGlzLnN0b3JhZ2V9YClcclxuICAgICAgdGhpcy5wYXRoID0gdGhpcy5zdG9yYWdlK1wicHVibGljL2Fnb3JhL1wiXHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMucGF0aClcclxuICAgICAgdGhpcy5zaG93TW9kYWwoKVxyXG4gICAgICBhd2FpdCB0aGlzLnJlcXVlc3RVcGRhdGUoKVxyXG4gICAgICB0aGlzLnBhdGhDaGFuZ2VkKClcclxuICAgIH1cclxuXHJcbiAgICBzaG93TW9kYWwoKXtcclxuICAgICAgY29uc29sZS5sb2coXCJzaG93XCIpXHJcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChcIm1vZGFsMVwiKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXHJcbiAgICB9XHJcblxyXG4gICAgaGlkZU1vZGFsKCl7XHJcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChcIm1vZGFsMVwiKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBjcmVhdGVGb2xkZXJzKCl7XHJcblxyXG4gICAgICBpZiAoIXRoaXMucGF0aC5pbmNsdWRlcyh0aGlzLnN0b3JhZ2UrXCJwdWJsaWMvXCIpKXtcclxuICAgICAgICBhbGVydChcIkVycm9yIHRoZSBwYXRoIG11c3QgYmUgaW4geW91ciAvcHVibGljIGZvbGRlclwiKVxyXG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMuc3RvcmFnZStcInB1YmxpYy9hZ29yYS9cIlxyXG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChcInBhdGhJbnB1dFwiKS52YWx1ZSA9IHRoaXMucGF0aFxyXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGF0aClcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3RVcGRhdGUoKVxyXG4gICAgICAgIHRoaXMucGF0aENoYW5nZWQoKVxyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmhpZGVNb2RhbCgpXHJcbiAgICAgICAgdGhpcy5sb2cgPSBcIkNyZWF0aW5nIEZvbGRlcnNcIlxyXG4gICAgICAgIGxldCBmYyA9IG5ldyBTb2xpZEZpbGVDbGllbnQoc29saWQuYXV0aClcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmZjKVxyXG4gICAgICAgIGxldCByb290ID0gdGhpcy5wYXRoXHJcbiAgICAgICAgbGV0IGluYm94ID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFwic3RhdGljSW5ib3hcIikudmFsdWVcclxuICAgICAgICBsZXQgb3V0Ym94ID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFwic3RhdGljT3V0Ym94XCIpLnZhbHVlXHJcbiAgICAgICAgY29uc29sZS5sb2cocm9vdCxpbmJveCwgb3V0Ym94KVxyXG5cclxuICAgICAgICB0aGlzLmxvZyA9IFwiQ3JlYXRpbmcgSW5ib3ggRm9sZGVyXCJcclxuXHJcbiAgICAgICAgbGV0IGZpbGUgPSBpbmJveCtcIi5hY2xcIlxyXG4gICAgICAgIGF3YWl0IGZjLmNyZWF0ZUZpbGUgKGZpbGUsIHRoaXMuYWNsSW5ib3hDb250ZW50LCBcInRleHQvdHVydGxlXCIpIC50aGVuIChzdWNjZXNzID0+IHtcclxuICAgICAgICAgIHRoaXMubG9nID0gXCJDcmVhdGVkIFwiK2ZpbGVcclxuICAgICAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgICAgdGhpcy5sb2cgPSBlcnJcclxuICAgICAgICAgIGFsZXJ0KGVycilcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgdGhpcy5sb2cgPSBcIm91dGJveCBGb2xkZXIgY3JlYXRpb24gOiBcIitvdXRib3hcclxuXHJcbiAgICAgICAgICBpZiggIShhd2FpdCBmYy5pdGVtRXhpc3RzKG91dGJveCkpICkge1xyXG4gICAgICAgICAgICBhd2FpdCBmYy5jcmVhdGVGb2xkZXIob3V0Ym94KSAvLyBvbmx5IGNyZWF0ZSBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMubG9nID0gXCJvdXRib3gvb2JqZWN0cyBGb2xkZXIgY3JlYXRpb24gOiBcIitvdXRib3grXCJvYmplY3RzL1wiXHJcbiAgICAgICAgICBpZiggIShhd2FpdCBmYy5pdGVtRXhpc3RzKG91dGJveCtcIm9iamVjdHMvXCIpKSApIHtcclxuICAgICAgICAgICAgYXdhaXQgZmMuY3JlYXRlRm9sZGVyKG91dGJveCtcIm9iamVjdHMvXCIpIC8vIG9ubHkgY3JlYXRlIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5sb2cgPSBcIm91dGJveC9hY3Rpdml0aWVzIEZvbGRlciBjcmVhdGlvbiA6IFwiK291dGJveCtcImFjdGl2aXRpZXMvXCJcclxuICAgICAgICAgIGlmKCAhKGF3YWl0IGZjLml0ZW1FeGlzdHMob3V0Ym94K1wiYWN0aXZpdGllcy9cIikpICkge1xyXG4gICAgICAgICAgICBhd2FpdCBmYy5jcmVhdGVGb2xkZXIob3V0Ym94K1wiYWN0aXZpdGllcy9cIikgLy8gb25seSBjcmVhdGUgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfWNhdGNoKGUpe1xyXG4gICAgICAgICAgdGhpcy5sb2c9ZVxyXG4gICAgICAgICAgYWxlcnQoZSlcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICBpZiggIShhd2FpdCBmYy5pdGVtRXhpc3RzKHJvb3QrXCJmb2xsb3dlcnMvXCIpKSApIHtcclxuICAgICAgICAgICAgYXdhaXQgZmMuY3JlYXRlRm9sZGVyKHJvb3QrXCJmb2xsb3dlcnMvXCIpIC8vIG9ubHkgY3JlYXRlIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgIHRoaXMubG9nPWVcclxuICAgICAgICAgIGFsZXJ0KGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICBpZiggIShhd2FpdCBmYy5pdGVtRXhpc3RzKHJvb3QrXCJmb2xsb3dpbmcvXCIpKSApIHtcclxuICAgICAgICAgICAgYXdhaXQgZmMuY3JlYXRlRm9sZGVyKHJvb3QrXCJmb2xsb3dpbmcvXCIpIC8vIG9ubHkgY3JlYXRlIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgIHRoaXMubG9nPWVcclxuICAgICAgICAgIGFsZXJ0KGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICBpZiggIShhd2FpdCBmYy5pdGVtRXhpc3RzKHJvb3QrXCJsaWtlZC9cIikpICkge1xyXG4gICAgICAgICAgICBhd2FpdCBmYy5jcmVhdGVGb2xkZXIocm9vdCtcImxpa2VkL1wiKSAvLyBvbmx5IGNyZWF0ZSBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcclxuICAgICAgICAgIH1cclxuICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICB0aGlzLmxvZz1lXHJcbiAgICAgICAgICBhbGVydChlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5e1xyXG5cclxuICAgICAgICAgIGxldCBpZCA9IFwiI0Fnb3JhXCJcclxuICAgICAgICAgIGxldCBpbnN0X3VyaSA9IHRoaXMuY29uZmlnLnB0aStpZFxyXG4gICAgICAgICAgbGV0IGluc3RfaW5kZXggPSByb290KydpbmRleC50dGwjdGhpcydcclxuICAgICAgICAgIHRoaXMubG9nID0gXCJJbnN0YW5jZSBDcmVhdGlvbiA6IFwiLGluc3RfdXJpXHJcbiAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW2luc3RfdXJpXS5zb2xpZCRmb3JDbGFzcy5hZGQobmFtZWROb2RlKCdodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI0NvbGxlY3Rpb24nKSlcclxuICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbaW5zdF91cmldLnNvbGlkJGluc3RhbmNlLnNldChuYW1lZE5vZGUoaW5zdF9pbmRleCkpXHJcbiAgICAgICAgICAvLyAgYXdhaXQgc29saWQuZGF0YVtpbnN0X3VyaV0ucmRmcyRsYWJlbC5hZGQoXCJBY3Rpdml0eSBTdHJlYW1zIENvbGxlY3Rpb25cIilcclxuICAgICAgICAgIHRoaXMubG9nID0gXCJJbmRleCBDcmVhdGlvbiA6IFwiLGluc3RfaW5kZXhcclxuICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbaW5zdF9pbmRleF0uYXMkaW5ib3guYWRkKG5hbWVkTm9kZShpbmJveCkpXHJcbiAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW2luc3RfaW5kZXhdLmFzJG91dGJveC5zZXQobmFtZWROb2RlKG91dGJveCkpXHJcbiAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW2luc3RfaW5kZXhdLmFzJGZvbGxvd2luZy5zZXQobmFtZWROb2RlKHJvb3QrJ2ZvbGxvd2luZy8nKSlcclxuICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbaW5zdF9pbmRleF0uYXMkZm9sbG93ZXJzLnNldChuYW1lZE5vZGUocm9vdCsnZm9sbG93ZXJzLycpKVxyXG4gICAgICAgICAgYXdhaXQgc29saWQuZGF0YVtpbnN0X2luZGV4XS5hcyRsaWtlZC5zZXQobmFtZWROb2RlKHJvb3QrJ2xpa2VkLycpKVxyXG4gICAgICAgICAgdGhpcy5sb2cgPSBcIllBSE9PT09PT09PT09PLCBBR09SQSBJUyBSRUFEWSwgQU5EIFdFTEwgQ09ORklHVVJFRCAhISFcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaChlKXtcclxuICAgICAgICAgIHRoaXMubG9nID0gXCJDYW4gbm90IGNyZWF0ZSBQdWJsaWNUeXBlSW5kZXggSW5zdGFuY2UgXCJcclxuICAgICAgICAgIGFsZXJ0KGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG4gICAgICB0aGlzLmNoZWNrQ29uZmlnKClcclxuICAgIH1cclxuXHJcbiAgICBwYXRoQ2hhbmdlZCgpe1xyXG4gICAgICBsZXQgcGF0aElucHV0ID0gIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChcInBhdGhJbnB1dFwiKS52YWx1ZVxyXG4gICAgICB0aGlzLnBhdGggPSBwYXRoSW5wdXQuZW5kc1dpdGgoXCIvXCIpID8gcGF0aElucHV0IDogcGF0aElucHV0K1wiL1wiXHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMucGF0aClcclxuICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFwic3RhdGljSW5ib3hcIikudmFsdWUgPSB0aGlzLnBhdGgrXCJpbmJveC9cIlxyXG4gICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0aWNPdXRib3hcIikudmFsdWUgPSB0aGlzLnBhdGgrXCJvdXRib3gvXCJcclxuICAgIH1cclxuXHJcbiAgICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgICAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgICAgIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xyXG4gICAgICAvLyAgY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICAgICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcIm1lc3NhaFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBcIm5ld0NvbmZpZ1wiOlxyXG4gICAgICAgICAgICBhcHAubmV3Q29uZmlnKG1lc3NhZ2UuY29uZmlnKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNvbmZpZ0NoYW5nZWRcIjpcclxuICAgICAgICAgICAgYXBwLmNvbmZpZ0NoYW5nZWQobWVzc2FnZS5jb25maWcpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICAvL2FwcC5hZ2VudC5zZW5kKFwiU3RvcmVcIiwge2FjdGlvbjpcImdldENvbmZpZ1wifSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnQ2hhbmdlZChjb25maWcpe1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkNPTkZJRyBDSEFOR0VEXCIsIGNvbmZpZylcclxuICAgICAgaWYgKGNvbmZpZyAhPSB1bmRlZmluZWQgJiYgY29uZmlnLndlYklkID09IHRoaXMuY29uZmlnLndlYklkKXtcclxuICAgICAgICBjb25maWcub3JpZ2luID0gXCJzdG9yZVwiXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWdcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuc3RhdHVzID09IFwiT0tcIil7XHJcbiAgICAgICAgICB0aGlzLmFnZW50LnNlbmQoXCJBcHBcIiwge2FjdGlvbjogXCJzaG93UGFuZWxcIn0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmFnZW50LnNlbmQoXCJBcHBcIiwge2FjdGlvbjogXCJzaG93UGFuZWxcIiwgcGFuZWw6IFwiQ29uZmlnXCJ9KVxyXG4gICAgICAgIHRoaXMuY2hlY2tDb25maWcoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogICAgd2ViSWRDaGFuZ2VkKHdlYklkKXtcclxuICAgIGNvbnNvbGUubG9nKFwiQ09ORklHIEdFVCBcIix3ZWJJZClcclxuICAgIHRoaXMuY29uZmlnLndlYklkID0gd2ViSWRcclxuICAgIGlmICh3ZWJJZCAhPSBudWxsKXtcclxuICAgIHRoaXMubG9nID0gXCJMb2dnZWRcIlxyXG4gICAgdGhpcy5hZ2VudC5zZW5kKFwiU3RvcmVcIiwge2FjdGlvbjogXCJnZXRDb25maWdcIn0pXHJcblxyXG4gICAgLy8gIHRoaXMuY2hlY2tDb25maWcoKVxyXG4gIH1lbHNle1xyXG4gIHRoaXMuY29uZmlnID0ge31cclxuICB0aGlzLmxvZyA9IFwiTm90IExvZ2dlZFwiXHJcbn1cclxufSovXHJcblxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2NvbmZpZy1nZXQtdmlldycsIENvbmZpZ0dldFZpZXcpO1xyXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcclxuXHJcbmNsYXNzIEZhYkVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIHdlYklkOiB7dHlwZTogU3RyaW5nfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMud2ViSWQgPSBudWxsXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPHN0eWxlPlxyXG4gICAgYm9keSB7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IH1cclxuICAgIC5idG4tZ3JvdXAtZmFiIHtcclxuICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICB3aWR0aDogNTBweDtcclxuICAgICAgaGVpZ2h0OiBhdXRvO1xyXG4gICAgICByaWdodDogMjBweDsgYm90dG9tOiAyMHB4O1xyXG4gICAgfVxyXG4gICAgLmJ0bi1ncm91cC1mYWIgZGl2IHtcclxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlOyB3aWR0aDogMTAwJTtcclxuICAgICAgaGVpZ2h0OiBhdXRvO1xyXG4gICAgfVxyXG4gICAgLmJ0bi1ncm91cC1mYWIgLmJ0biB7XHJcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgYm90dG9tOiAwO1xyXG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XHJcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICBtYXJnaW4tYm90dG9tOiA0cHg7XHJcbiAgICAgIHdpZHRoOiA0MHB4OyBoZWlnaHQ6IDQwcHg7XHJcbiAgICAgIG1hcmdpbjogNHB4IGF1dG87XHJcbiAgICB9XHJcbiAgICAuYnRuLWdyb3VwLWZhYiAuYnRuLW1haW4ge1xyXG4gICAgICB3aWR0aDogNTBweDsgaGVpZ2h0OiA1MHB4O1xyXG4gICAgICByaWdodDogNTAlOyBtYXJnaW4tcmlnaHQ6IC0yNXB4O1xyXG4gICAgICB6LWluZGV4OiA5O1xyXG4gICAgfVxyXG4gICAgLmJ0bi1ncm91cC1mYWIgLmJ0bi1zdWIge1xyXG4gICAgICBib3R0b206IDA7IHotaW5kZXg6IDg7XHJcbiAgICAgIHJpZ2h0OiA1MCU7XHJcbiAgICAgIG1hcmdpbi1yaWdodDogLTIwcHg7XHJcbiAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDJzO1xyXG4gICAgICB0cmFuc2l0aW9uOiBhbGwgMC41cztcclxuICAgIH1cclxuICAgIC5idG4td3JpdGUge1xyXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XHJcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgICAgd2lkdGg6IDUwcHg7XHJcbiAgICAgIGhlaWdodDogNTBweDtcclxuICAgICAgcmlnaHQ6IDEwcHg7IGJvdHRvbTogMTJweDtcclxuICAgICAgLypcclxuICAgICAgd2lkdGg6IDUwcHg7IGhlaWdodDogNTBweDtcclxuICAgICAgcmlnaHQ6IDEwMCU7IG1hcmdpbi1yaWdodDogMHB4OyovXHJcbiAgICAgIHotaW5kZXg6IDk7XHJcbiAgICB9XHJcbiAgICAuYnRuLWdyb3VwLWZhYi5hY3RpdmUgLmJ0bi1zdWI6bnRoLWNoaWxkKDIpIHtcclxuICAgICAgYm90dG9tOiA2MHB4O1xyXG4gICAgfVxyXG4gICAgLmJ0bi1ncm91cC1mYWIuYWN0aXZlIC5idG4tc3ViOm50aC1jaGlsZCgzKSB7XHJcbiAgICAgIGJvdHRvbTogMTEwcHg7XHJcbiAgICB9XHJcbiAgICAuYnRuLWdyb3VwLWZhYi5hY3RpdmUgLmJ0bi1zdWI6bnRoLWNoaWxkKDQpIHtcclxuICAgICAgYm90dG9tOiAxNjBweDtcclxuICAgIH1cclxuICAgIC5idG4tZ3JvdXAtZmFiIC5idG4tc3ViOm50aC1jaGlsZCg1KSB7XHJcbiAgICAgIGJvdHRvbTogMjEwcHg7XHJcbiAgICB9XHJcbiAgICA8L3N0eWxlPlxyXG5cclxuXHJcbiAgICAke3RoaXMud2ViSWQgIT0gbnVsbCA/XHJcbiAgICAgIGh0bWxgXHJcbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgIGNsYXNzPVwiYnRuIGJ0bi13cml0ZSBidG4taW5mbyBoYXMtdG9vbHRpcFwiXHJcbiAgICAgIGRhdGEtcGxhY2VtZW50PVwibGVmdFwiXHJcbiAgICAgIEBjbGljaz1cIiR7dGhpcy50b2dnbGVXcml0ZX1cIlxyXG4gICAgICB0aXRsZT1cIldyaXRlXCI+IDxpIGNsYXNzPVwiZmEgZmEtcGVuXCI+PC9pPiA8L2J1dHRvbj5cclxuICAgICAgYFxyXG4gICAgICA6aHRtbGBgXHJcblxyXG4gICAgfVxyXG5cclxuICAgIDwhLS1cclxuICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAtZmFiXCIgcm9sZT1cImdyb3VwXCIgQGNsaWNrPVwiJHt0aGlzLnRvZ2dsZUZhYn1cIiBhcmlhLWxhYmVsPVwiRkFCIE1lbnVcIj5cclxuICAgIDxkaXY+XHJcblxyXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW1haW4gYnRuLXByaW1hcnkgaGFzLXRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cImxlZnRcIiB0aXRsZT1cIk1lbnVcIj4gPGkgY2xhc3M9XCJmYSBmYS1iYXJzXCI+PC9pPiA8L2J1dHRvbj5cclxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zdWIgYnRuLWluZm8gaGFzLXRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cImxlZnRcIiB0aXRsZT1cIkZ1bGxzY3JlZW5cIj4gPGkgY2xhc3M9XCJmYSBmYS1hcnJvd3MtYWx0XCI+PC9pPiA8L2J1dHRvbj5cclxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zdWIgYnRuLWRhbmdlciBoYXMtdG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwibGVmdFwiIHRpdGxlPVwiU2F2ZVwiPiA8aSBjbGFzcz1cImZhciBmYS1zYXZlXCI+PC9pPiA8L2J1dHRvbj5cclxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zdWIgYnRuLXdhcm5pbmcgaGFzLXRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cImxlZnRcIiB0aXRsZT1cIkRvd25sb2FkXCI+IDxpIGNsYXNzPVwiZmEgZmEtZG93bmxvYWRcIj48L2k+IDwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8L2Rpdj4tLT5cclxuXHJcbiAgICBgO1xyXG4gIH1cclxuXHJcbiAgZmlyc3RVcGRhdGVkKCl7XHJcbiAgICB2YXIgYXBwID0gdGhpcztcclxuICAgIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xyXG4gICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgICBjYXNlIFwid2ViSWRDaGFuZ2VkXCI6XHJcbiAgICAgICAgICBhcHAud2ViSWRDaGFuZ2VkKG1lc3NhZ2Uud2ViSWQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGFjdGlvbiBcIixtZXNzYWdlKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHdlYklkQ2hhbmdlZCh3ZWJJZCl7XHJcbiAgICB0aGlzLndlYklkID0gd2ViSWRcclxuICB9XHJcblxyXG4gIHRvZ2dsZUZhYigpe1xyXG4gICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIuYnRuLWdyb3VwLWZhYlwiKS5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKVxyXG4gIH1cclxuXHJcbiAgdG9nZ2xlV3JpdGUoKXtcclxuICAgIGNvbnNvbGUubG9nKFwidG9nZ2xlV3JpdGVcIilcclxuICAgIHRoaXMuYWdlbnQuc2VuZChcIkFwcFwiLCB7YWN0aW9uOiBcInNob3dQYW5lbFwiLCBwYW5lbDogXCJDb21wb3NlXCJ9KVxyXG4gICAgdGhpcy5hZ2VudC5zZW5kKFwiUG9zdFwiLCB7YWN0aW9uOiBcInRvZ2dsZVdyaXRlXCJ9KVxyXG4gIH1cclxuXHJcbn1cclxuXHJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZmFiLWVsZW1lbnQnLCBGYWJFbGVtZW50KTtcclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuaW1wb3J0IHsgQXR0cmlidXRlUGFydCwgZGlyZWN0aXZlLCBQcm9wZXJ0eVBhcnQgfSBmcm9tICcuLi9saXQtaHRtbC5qcyc7XG4vLyBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBjbGFzc0xpc3Qgb24gU1ZHIGVsZW1lbnRzLCBzbyB3ZSBlbXVsYXRlIGl0IHdpdGggYSBTZXRcbmNsYXNzIENsYXNzTGlzdCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGZvciAoY29uc3QgY2xzIG9mIGNsYXNzTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzLmFkZChjbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZChjbHMpIHtcbiAgICAgICAgdGhpcy5jbGFzc2VzLmFkZChjbHMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZW1vdmUoY2xzKSB7XG4gICAgICAgIHRoaXMuY2xhc3Nlcy5kZWxldGUoY2xzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5jaGFuZ2VkKSB7XG4gICAgICAgICAgICBsZXQgY2xhc3NTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5mb3JFYWNoKChjbHMpID0+IGNsYXNzU3RyaW5nICs9IGNscyArICcgJyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogU3RvcmVzIHRoZSBDbGFzc0luZm8gb2JqZWN0IGFwcGxpZWQgdG8gYSBnaXZlbiBBdHRyaWJ1dGVQYXJ0LlxuICogVXNlZCB0byB1bnNldCBleGlzdGluZyB2YWx1ZXMgd2hlbiBhIG5ldyBDbGFzc0luZm8gb2JqZWN0IGlzIGFwcGxpZWQuXG4gKi9cbmNvbnN0IHByZXZpb3VzQ2xhc3Nlc0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBhcHBsaWVzIENTUyBjbGFzc2VzLiBUaGlzIG11c3QgYmUgdXNlZCBpbiB0aGUgYGNsYXNzYFxuICogYXR0cmlidXRlIGFuZCBtdXN0IGJlIHRoZSBvbmx5IHBhcnQgdXNlZCBpbiB0aGUgYXR0cmlidXRlLiBJdCB0YWtlcyBlYWNoXG4gKiBwcm9wZXJ0eSBpbiB0aGUgYGNsYXNzSW5mb2AgYXJndW1lbnQgYW5kIGFkZHMgdGhlIHByb3BlcnR5IG5hbWUgdG8gdGhlXG4gKiBlbGVtZW50J3MgYGNsYXNzYCBpZiB0aGUgcHJvcGVydHkgdmFsdWUgaXMgdHJ1dGh5OyBpZiB0aGUgcHJvcGVydHkgdmFsdWUgaXNcbiAqIGZhbHNleSwgdGhlIHByb3BlcnR5IG5hbWUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50J3MgYGNsYXNzYC4gRm9yIGV4YW1wbGVcbiAqIGB7Zm9vOiBiYXJ9YCBhcHBsaWVzIHRoZSBjbGFzcyBgZm9vYCBpZiB0aGUgdmFsdWUgb2YgYGJhcmAgaXMgdHJ1dGh5LlxuICogQHBhcmFtIGNsYXNzSW5mbyB7Q2xhc3NJbmZvfVxuICovXG5leHBvcnQgY29uc3QgY2xhc3NNYXAgPSBkaXJlY3RpdmUoKGNsYXNzSW5mbykgPT4gKHBhcnQpID0+IHtcbiAgICBpZiAoIShwYXJ0IGluc3RhbmNlb2YgQXR0cmlidXRlUGFydCkgfHwgKHBhcnQgaW5zdGFuY2VvZiBQcm9wZXJ0eVBhcnQpIHx8XG4gICAgICAgIHBhcnQuY29tbWl0dGVyLm5hbWUgIT09ICdjbGFzcycgfHwgcGFydC5jb21taXR0ZXIucGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgY2xhc3NNYXBgIGRpcmVjdGl2ZSBtdXN0IGJlIHVzZWQgaW4gdGhlIGBjbGFzc2AgYXR0cmlidXRlICcgK1xuICAgICAgICAgICAgJ2FuZCBtdXN0IGJlIHRoZSBvbmx5IHBhcnQgaW4gdGhlIGF0dHJpYnV0ZS4nKTtcbiAgICB9XG4gICAgY29uc3QgeyBjb21taXR0ZXIgfSA9IHBhcnQ7XG4gICAgY29uc3QgeyBlbGVtZW50IH0gPSBjb21taXR0ZXI7XG4gICAgbGV0IHByZXZpb3VzQ2xhc3NlcyA9IHByZXZpb3VzQ2xhc3Nlc0NhY2hlLmdldChwYXJ0KTtcbiAgICBpZiAocHJldmlvdXNDbGFzc2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV3JpdGUgc3RhdGljIGNsYXNzZXMgb25jZVxuICAgICAgICAvLyBVc2Ugc2V0QXR0cmlidXRlKCkgYmVjYXVzZSBjbGFzc05hbWUgaXNuJ3QgYSBzdHJpbmcgb24gU1ZHIGVsZW1lbnRzXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNvbW1pdHRlci5zdHJpbmdzLmpvaW4oJyAnKSk7XG4gICAgICAgIHByZXZpb3VzQ2xhc3Nlc0NhY2hlLnNldChwYXJ0LCBwcmV2aW91c0NsYXNzZXMgPSBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc0xpc3QgPSAoZWxlbWVudC5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChlbGVtZW50KSk7XG4gICAgLy8gUmVtb3ZlIG9sZCBjbGFzc2VzIHRoYXQgbm8gbG9uZ2VyIGFwcGx5XG4gICAgLy8gV2UgdXNlIGZvckVhY2goKSBpbnN0ZWFkIG9mIGZvci1vZiBzbyB0aGF0IHJlIGRvbid0IHJlcXVpcmUgZG93bi1sZXZlbFxuICAgIC8vIGl0ZXJhdGlvbi5cbiAgICBwcmV2aW91c0NsYXNzZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBpZiAoIShuYW1lIGluIGNsYXNzSW5mbykpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICAgICAgICBwcmV2aW91c0NsYXNzZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIG9yIHJlbW92ZSBjbGFzc2VzIGJhc2VkIG9uIHRoZWlyIGNsYXNzTWFwIHZhbHVlXG4gICAgZm9yIChjb25zdCBuYW1lIGluIGNsYXNzSW5mbykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNsYXNzSW5mb1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlICE9IHByZXZpb3VzQ2xhc3Nlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgd2FudCBhIGxvb3NlIHRydXRoeSBjaGVjayBvZiBgdmFsdWVgIGJlY2F1c2UgaXQgc2VlbXNcbiAgICAgICAgICAgIC8vIG1vcmUgY29udmVuaWVudCB0aGF0ICcnIGFuZCAwIGFyZSBza2lwcGVkLlxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NsYXNzZXMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NsYXNzZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2xhc3NMaXN0LmNvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjbGFzc0xpc3QuY29tbWl0KCk7XG4gICAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGFzcy1tYXAuanMubWFwIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4vLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDsgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcblxuICByZXR1cm4gW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJywgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJywgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXV0uam9pbignJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJ5dGVzVG9VdWlkOyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IGJ5dGVzVG9VdWlkIGZyb20gJy4vYnl0ZXNUb1V1aWQuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcblxyXG5jbGFzcyBOb3RlRWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xyXG5cclxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgc2hhcmU6IHt0eXBlOiBTdHJpbmd9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5zaGFyZSA9IHt9XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgIDwhLS0gICAgPGxhYmVsIGNsYXNzPVwidGV4dC1wcmltYXJ5XCIgZm9yPVwibm90ZWFyZWFcIj48L2xhYmVsPi0tPlxyXG4gICAgPHRleHRhcmVhIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJub3RlYXJlYVwiXHJcbiAgICBzdHlsZT1cIndpZHRoOjEwMCU7aGVpZ2h0OjM4dmhcIlxyXG4gICAgcGxhY2Vob2xkZXI9XCJXcml0ZSBhIG5vdGUgb24geW91ciBQb2QgJiBzaGFyZSBpdCBvbiBBZ29yYVwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuICAgIGA7XHJcbiAgfVxyXG5cclxuICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgICB0aGlzLmFnZW50LnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgICAgIGlmIChtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWN0aW9uXCIpKXtcclxuICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgIGNhc2UgXCJhc2tDb250ZW50XCI6XHJcbiAgICAgICAgICBhcHAuYXNrQ29udGVudChmcm9tLCBtZXNzYWdlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zb2xlLmxvZyhcIlNIQVJFXCIsIHRoaXMuc2hhcmUpXHJcbiAgICBpZih0aGlzLnNoYXJlLnRleHQgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFwibm90ZWFyZWFcIikuaW5uZXJIVE1MICs9IHRoaXMuc2hhcmUudGV4dCArIFwiXFxuXFxuXCIrdGhpcy5zaGFyZS51cmxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFza0NvbnRlbnQoZnJvbSwgbWVzc2FnZSl7XHJcbiAgICBjb25zb2xlLmxvZyhmcm9tLG1lc3NhZ2UpXHJcbiAgICB2YXIgdGV4dGFyZWEgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ25vdGVhcmVhJykvKi5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIuZm9ybS1jb250cm9sXCIpKi9cclxuICAgIHZhciBub3RlID0gdGV4dGFyZWEudmFsdWUudHJpbSgpXHJcbiAgICBjb25zb2xlLmxvZyhub3RlKVxyXG4gICAgdGhpcy5hZ2VudC5zZW5kKGZyb20sIHtcclxuICAgICAgYWN0aW9uOiBcInJlcG9uc2VDb250ZW50XCIsXHJcbiAgICAgIGNvbnRlbnQ6IG5vdGUsXHJcbiAgICAgIGlkOiBtZXNzYWdlLmlkLFxyXG4gICAgICB0eXBlOiBcIk5vdGVcIlxyXG4gICAgfSlcclxuICAgIHRleHRhcmVhLnZhbHVlID0gXCJcIlxyXG4gIH1cclxuXHJcbn1cclxuXHJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbm90ZS1lbGVtZW50JywgTm90ZUVsZW1lbnQpO1xyXG4iLCIvLyByZWRpbWVuc2lvbm5lciBsJ2ltYWdlIGF2YW50IGVudm9pIGh0dHA6Ly90ZWNoLm5vdmFwb3N0LmZyL3JlZGltZW5zaW9ubmVyLXVuZS1pbWFnZS1jb3RlLWNsaWVudC1hdmFudC1sdXBsb2FkLmh0bWxcclxuXHJcbmltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XHJcbmltcG9ydCB7IEhlbGxvQWdlbnQgfSBmcm9tICcuLi9hZ2VudHMvaGVsbG8tYWdlbnQuanMnO1xyXG5cclxuY2xhc3MgTWVkaWFFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XHJcblxyXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBjb3VudDoge3R5cGU6IE51bWJlcn0sXHJcbiAgICAgIGV4dGVuc2lvbjoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGZpbGVuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgaW5mbzoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGZvbGRlcnM6IHt0eXBlOiBBcnJheX1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmluZm8gPSBcIlwiXHJcbiAgICB0aGlzLmZvbGRlcnMgPSBbXCJwdWJsaWMvc3BvZ2d5L1wiLFwicHVibGljL3Nwb2dneS9BY3Rpdml0eS9cIixcInB1YmxpYy9zcG9nZ3kvSW1hZ2UvXCIsXCJwdWJsaWMvc3BvZ2d5L1ZpZGVvL1wiLFwicHVibGljL3Nwb2dneS9BdWRpby9cIixcInB1YmxpYy9zcG9nZ3kvRG9jdW1lbnQvXCJdXHJcbiAgICB0aGlzLmZpbGVuYW1lID0gXCJcIlxyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCl7XHJcbiAgICByZXR1cm4gaHRtbGBcclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvZm9udGF3ZXNvbWUvY3NzL2FsbC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICA8bGluayBocmVmPVwiY3NzL2Jvb3RzdHJhcC9ib290c3RyYXAubWluLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxzdHlsZT5cclxuICAgIGkge1xyXG4gICAgICBwYWRkaW5nOiAxMHB4XHJcbiAgICB9XHJcbiAgICA8L3N0eWxlPlxyXG4gICAgPCEtLSAgbGlzdCA6ICR7dGhpcy5ub3Rlc0xpc3RVcmx9IC0tPlxyXG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgPGZvcm0+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY3VzdG9tLWZpbGVcIj5cclxuICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiXHJcbiAgICBjbGFzcz1cImN1c3RvbS1maWxlLWlucHV0XCJcclxuICAgIEBjaGFuZ2U9XCIke3RoaXMuY3JlYXRlVGVtcH1cIlxyXG4gICAgaWQ9XCJtZWRpYUZpbGVcIlxyXG4gICAgYWNjZXB0PVwiaW1hZ2UvKjt2aWRlby8qO2F1ZGlvLypcIlxyXG4gICAgbGFuZz1cIiR7dGhpcy5sYW5nfVwiPlxyXG4gICAgPGxhYmVsIGNsYXNzPVwiY3VzdG9tLWZpbGUtbGFiZWxcIlxyXG4gICAgZm9yPVwibWVkaWFGaWxlXCI+XHJcbiAgICA8aSBjbGFzcz1cImZhcyBmYS1jYW1lcmEtcmV0cm9cIj48L2k+XHJcbiAgICA8aSBjbGFzcz1cImZhcyBmYS12aWRlb1wiPjwvaT5cclxuICAgIDxpIGNsYXNzPVwiZmFzIGZhLW1pY3JvcGhvbmVcIj48L2k+XHJcbiAgICA8L2xhYmVsPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8L2Zvcm0+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICAke3RoaXMuZmlsZW5hbWUubGVuZ3RoID4gMCA/XHJcbiAgICAgIGh0bWxgXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgPGxhYmVsIGNsYXNzPVwic3Itb25seVwiIGZvcj1cImZpbGVuYW1lXCI+RmlsZW5hbWU8L2xhYmVsPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgbWItMlwiPlxyXG4gICAgICA8aW5wdXQgaWQ9XCJmaWxlbmFtZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgdHlwZT1cInRleHRcIiB2YWx1ZT1cIiR7dGhpcy5maWxlbmFtZX1cIiBAY2hhbmdlPVwiJHt0aGlzLmZpbGVuYW1lQ2hhbmdlfVwiIHBsYWNlaG9sZGVyPVwiRmlsZW5hbWVcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLWFwcGVuZFwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPiR7dGhpcy5leHRlbnNpb259PC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcblxyXG5cclxuICAgICAgYFxyXG4gICAgICA6aHRtbCBgXHJcbiAgICAgIGB9XHJcblxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY29sLWF1dG9cIj48Y2FudmFzIHN0eWxlPVwibWF4LXdpZHRoOiAxMDAlOyBoZWlnaHQ6IGF1dG87XCIgaWQ9XCJjYW52YXNcIi8+PC9kaXY+XHJcblxyXG4gICAgICBgO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVRlbXAoZSkge1xyXG4gICAgICB0aGlzLmZpbGUgPSBlLnRhcmdldC5maWxlc1swXTtcclxuICAgICAgdGhpcy5maWxlbmFtZSA9IHRoaXMuZmlsZS5uYW1lLnN1YnN0cmluZygwLHRoaXMuZmlsZS5uYW1lLmxhc3RJbmRleE9mKFwiLlwiKSk7XHJcbiAgICAgIHRoaXMuZXh0ZW5zaW9uID0gdGhpcy5maWxlLm5hbWUuc3Vic3RyaW5nKHRoaXMuZmlsZS5uYW1lLmxhc3RJbmRleE9mKFwiLlwiKSk7XHJcblxyXG4gICAgICB2YXIgY2FudmFzID0gICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpXHJcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgdmFyIGN3ID0gY2FudmFzLndpZHRoO1xyXG4gICAgICB2YXIgY2ggPSBjYW52YXMuaGVpZ2h0O1xyXG4gICAgICB2YXIgbWF4Vz1jdztcclxuICAgICAgdmFyIG1heEg9Y2g7XHJcblxyXG4gICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2U7XHJcbiAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpdz1pbWFnZS53aWR0aDtcclxuICAgICAgICB2YXIgaWg9aW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBzY2FsZT1NYXRoLm1pbigobWF4Vy9pdyksKG1heEgvaWgpKTtcclxuICAgICAgICB2YXIgaXdTY2FsZWQ9aXcqc2NhbGU7XHJcbiAgICAgICAgdmFyIGloU2NhbGVkPWloKnNjYWxlO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aD1pd1NjYWxlZDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0PWloU2NhbGVkO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsMCwwLGl3U2NhbGVkLGloU2NhbGVkKTtcclxuICAgICAgICAvLyAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwwKTtcclxuICAgICAgICAvLyAgYWxlcnQoJ3RoZSBpbWFnZSBpcyBkcmF3bicpO1xyXG4gICAgICB9XHJcbiAgICAgIGltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5maWxlKTtcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuZmlsZS53aWR0aDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuZmlsZS5oZWlnaHQ7XHJcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcbiAgICAgIC8vIE90aGVyIGJyb3dzZXJzIHdpbGwgZmFsbCBiYWNrIHRvIGltYWdlL3BuZ1xyXG4gICAgICBpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2Uvd2VicCcpOyovXHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIGZpcnN0VXBkYXRlZCgpe1xyXG4gICAgICB2YXIgYXBwID0gdGhpcztcclxuICAgICAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgICAgIHRoaXMuYWdlbnQucmVjZWl2ZSA9IGZ1bmN0aW9uKGZyb20sIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBcImFza0NvbnRlbnRcIjpcclxuICAgICAgICAgICAgYXBwLmFza0NvbnRlbnQoZnJvbSwgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGFza0NvbnRlbnQoZnJvbSwgbWVzc2FnZSl7XHJcbiAgICAgIHZhciBhcHAgPSB0aGlzXHJcbiAgICAgIGNvbnNvbGUubG9nKGZyb20sbWVzc2FnZSlcclxuXHJcbiAgICAgIHRoaXMuY2xhc3NlID0gXCJEb2N1bWVudFwiXHJcbiAgICAgIGlmICh0aGlzLmZpbGUgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZmlsZS50eXBlXHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICBjYXNlICh0eXBlLm1hdGNoKC9eaW1hZ2UvKSB8fCB7fSkuaW5wdXQ6XHJcbiAgICAgICAgICB0aGlzLmNsYXNzZSA9IFwiSW1hZ2VcIlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICh0eXBlLm1hdGNoKC9edmlkZW8vKSB8fCB7fSkuaW5wdXQ6XHJcbiAgICAgICAgICB0aGlzLmNsYXNzZSA9IFwiVmlkZW9cIlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICh0eXBlLm1hdGNoKC9eYXVkaW8vKSB8fCB7fSkuaW5wdXQ6XHJcbiAgICAgICAgICB0aGlzLmNsYXNzZSA9IFwiQXVkaW9cIlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhpcy5jbGFzc2UgPSBcIkRvY3VtZW50XCJcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIHZhciByZXAgPSB7XHJcbiAgICAgICAgYWN0aW9uOiBcInJlcG9uc2VDb250ZW50XCIsXHJcbiAgICAgICAgY29udGVudDogdGhpcy5maWxlLFxyXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkLFxyXG4gICAgICAgIHR5cGU6IHRoaXMuY2xhc3NlXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuZmlsZW5hbWUubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgcmVwLm5ld0ZpbGVuYW1lID0gdGhpcy5maWxlbmFtZS5yZXBsYWNlKC8gL2csXCJfXCIpK3RoaXMuZXh0ZW5zaW9uXHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5hZ2VudC5zZW5kKGZyb20sIHJlcClcclxuICAgICAgdGhpcy5maWxlbmFtZSA9IFwiXCJcclxuICAgIH1cclxuXHJcbiAgICBmaWxlbmFtZUNoYW5nZSgpe1xyXG4gICAgICB2YXIgZmlsZW5hbWUgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlbmFtZVwiKS52YWx1ZVxyXG4gICAgICBpZiAoZmlsZW5hbWUubGVuZ3RoID09IDApe1xyXG4gICAgICAgIGFsZXJ0KFwiRmlsZW5hbWUgbXVzdCBub3QgYmUgYmxhbmtcIilcclxuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlbmFtZVwiKS52YWx1ZSA9IHRoaXMuZmlsZW5hbWVcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gIH1cclxuXHJcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdtZWRpYS1lbGVtZW50JywgTWVkaWFFbGVtZW50KTtcclxuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcblxyXG5jbGFzcyBHcmFwaEVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGNvdW50OiB7dHlwZTogTnVtYmVyfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuY291bnQgPSAwXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPHA+JHt0aGlzLm5hbWV9PC9wPlxyXG4gICAgPGJ1dHRvbiBAY2xpY2s9XCIke3RoaXMuc2VuZE1lc3NhZ2V9XCI+U2VuZCBtZXNzYWdlPC9idXR0b24+XHJcbiAgICBgO1xyXG4gIH1cclxuXHJcbiAgZmlyc3RVcGRhdGVkKCl7XHJcbiAgICB2YXIgYXBwID0gdGhpcztcclxuICAgIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xyXG4gICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgICBjYXNlIFwiZG9Tb21ldGhpbmdcIjpcclxuICAgICAgICAgIGFwcC5kb1NvbWV0aGluZyhtZXNzYWdlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBkb1NvbWV0aGluZyhtZXNzYWdlKXtcclxuICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgfVxyXG5cclxuICBzZW5kTWVzc2FnZSgpe1xyXG4gICAgdGhpcy5jb3VudCsrXHJcbiAgICB0aGlzLmFnZW50LnNlbmQoXCJNZXNzYWdlc1wiLCB7YWN0aW9uOlwiaW5mb1wiLCBpbmZvOlwiTm93IGNvdW50ZXIgaXMgXCIrdGhpcy5jb3VudH0gIClcclxuICB9XHJcblxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2dyYXBoLWVsZW1lbnQnLCBHcmFwaEVsZW1lbnQpO1xyXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcclxuXHJcbmNsYXNzIFRyaXBsZUVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGNvdW50OiB7dHlwZTogTnVtYmVyfSxcclxuICAgICAgdHJpcGxlczoge3R5cGU6IEFycmF5fSxcclxuICAgICAgZm9vdHByaW50OiAge3R5cGU6IE9iamVjdH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmNvdW50ID0gMFxyXG4gICAgdGhpcy50cmlwbGVzID0gW11cclxuICAgIHRoaXMuZm9vdHByaW50ICA9IHtpbmRleDogXCJwdWJsaWMvdHJpcGxlLnR0bFwiLCBwYXRoOlwicHVibGljL1RyaXBsZVwiLCB9XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuXHJcblxyXG4gICAgY29uc3QgdHJpcGxlc0xpc3QgPSAodHJpcGxlcykgPT4gaHRtbGBcclxuICAgIDx1bCBjbGFzcz1cImxpc3QtZ3JvdXAgbGlzdC1ncm91cC1mbHVzaFwiIHN0eWxlPVwiaGVpZ2h0OiAzMHZoOyB3aWR0aDoxMDAlOyBvdmVyZmxvdzogYXV0b1wiPlxyXG4gICAgJHt0cmlwbGVzLm1hcCgodCkgPT4gaHRtbGBcclxuICAgICAgPGxpIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCIgdHlwZT1cImJ1dHRvblwiPiR7dC5zdWJqZWN0fTwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIiB0eXBlPVwiYnV0dG9uXCI+JHt0LnByZWRpY2F0ZX08L2J1dHRvbj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCIgdHlwZT1cImJ1dHRvblwiPiR7dC5vYmplY3R9PC9idXR0b24+XHJcbiAgICAgIFtlZGl0XSBbZGVsZXRlXVxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9saT5cclxuICAgICAgYCl9XHJcbiAgICAgIDwvdWw+XHJcbiAgICAgIGA7XHJcblxyXG4gICAgICByZXR1cm4gaHRtbGBcclxuICAgICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIG1iLTNcIj5cclxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgaWQ9XCJ0cmlwbGVJbnB1dFwiXHJcbiAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcclxuICAgICAgcGxhY2Vob2xkZXI9XCJleDogUGFyaXMgdHlwZSBUb3duLlwiXHJcbiAgICAgIGFyaWEtbGFiZWw9XCJXcml0ZSBzb21lIFRyaXBsZXNcIlxyXG4gICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiYmFzaWMtYWRkb24yXCJcclxuICAgICAgQGtleWRvd249JHt0aGlzLmtleWRvd259PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XHJcbiAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeVwiIEBjbGljaz1cIiR7dGhpcy5hZGRfdHJpcGxlfVwiIHR5cGU9XCJidXR0b25cIj5BZGQ8L2J1dHRvbj5cclxuXHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8IS0tICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj4/PC9kaXY+LS0+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuXHJcbiR7dGhpcy50cmlwbGVzLmxlbmd0aCA+IDAgP1xyXG5odG1sIGAgICR7dHJpcGxlc0xpc3QodGhpcy50cmlwbGVzKX1gXHJcbjpodG1sIGBcclxuPHNtYWxsPlxyXG5Zb3UgY2FuIGFkZCB0cmlwbGVzIHRvIHlvdXIgU3BvZy48YnI+XHJcblRvIGRvIHNvLCBqdXN0IHR5cGUgMyB3b3JkcyBpbiB0aGUgYWJvdmUgaW5wdXQgYW5kIDpcclxuPHVsPlxyXG48bGk+ZW5kcyB3aXRoIGEgY29tbWEgaWYgeW91IHdhbnQgdG8ga2VlcCBzdWJqZWN0ICYgcHJlZGljYXRlLCA8L2xpPlxyXG48bGk+ZW5kcyB3aXRoIGEgc2VtaWNvbG9uIGlmIHlvdSB3YW50IHRvIGtlZXAganVzdCB0aGUgc3ViamVjdCw8L2xpPlxyXG48bGk+ZW5kcyB3aXRoIGEgZG90IGlmIHlvdSBkb24ndCB3YW50IHRvIGtlZXAgYW55dGhpbmcsPC9saT5cclxuPGxpPmVuZHMgd2l0aCBhIGRhc2ggaWYgeW91IHdhbnQgdGhhdCB0aGUgb2JqZWN0IGJlY29tZSB0aGUgc3ViamVjdCBvZiB0aGUgbmV4dCB0cmlwbGUuPC9saT5cclxuPC91bD5cclxuZXg6IERhdiBhIG1hbixcclxuPC9zbWFsbD5cclxuYFxyXG5cclxuXHJcbn1cclxuXHJcblxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgYDtcclxuICAgIH1cclxuXHJcbiAgICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgICAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgICAgIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xyXG4gICAgICB0aGlzLmFnZW50LnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhc2tDb250ZW50XCI6XHJcbiAgICAgICAgICAgIGFwcC5hc2tDb250ZW50KGZyb20sIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGFjdGlvbiBcIixtZXNzYWdlKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBhc2tDb250ZW50KGZyb20sIG1lc3NhZ2Upe1xyXG4gICAgICBjb25zb2xlLmxvZyhmcm9tLG1lc3NhZ2UpXHJcbiAgICAgIHRoaXMuYWdlbnQuc2VuZChmcm9tLCB7XHJcbiAgICAgICAgYWN0aW9uOiBcInJlcG9uc2VDb250ZW50XCIsXHJcbiAgICAgICAgY29udGVudDogdGhpcy50cmlwbGVzLFxyXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkLFxyXG4gICAgICAgIHR5cGU6IFwiVHJpcGxlXCJcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBhZGRfdHJpcGxlKCl7XHJcbiAgICAgIHZhciBuZXdfdHJpcGxlID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0cmlwbGVJbnB1dCcpLnZhbHVlLnRyaW0oKVxyXG4gICAgICBpZiAobmV3X3RyaXBsZS5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgYWxlcnQoXCJ5b3UgY2FuJ3QgYWRkIGFuIGVtcHR5IFRyaXBsZVwiKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUubG9nKG5ld190cmlwbGUpXHJcbiAgICAgIHZhciByZXMgPSB0aGlzLnVwZGF0ZUlucHV0KG5ld190cmlwbGUpXHJcbiAgICAgIGNvbnNvbGUubG9nKHJlcylcclxuICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0cmlwbGVJbnB1dCcpLnZhbHVlID0gcmVzLmlucHV0TmV3XHJcbiAgICAgIGlmIChyZXMudHlwZSA9PSBcInRyaXBsZXRcIil7XHJcbiAgICAgICAgdmFyIHRyaXBsZSA9IHJlcy52YWx1ZVxyXG4gICAgICAgIHRoaXMudHJpcGxlcy5yZXZlcnNlKClcclxuICAgICAgICB0aGlzLnRyaXBsZXMgPSBbLi4uIHRoaXMudHJpcGxlcywgdHJpcGxlXVxyXG4gICAgICAgIHRoaXMudHJpcGxlcy5yZXZlcnNlKClcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgYWxlcnQgKFwiVHJpcGxlIG11c3QgZW5kIHdpdGggJywnLCBvciAnOycgb3IgJy4nXCIpXHJcbiAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgLy8gdm9pciB0cmFpdGVUcmlwbGV0IGRhbnMganMvc3BvZ2d5LmpzIGRlIHNwb2dneS1zaW1wbGVcclxuICAgIH1cclxuXHJcblxyXG4gICAgdXBkYXRlSW5wdXQobWVzc2FnZSl7XHJcbiAgICAgIHZhciByZXN1bHQgPSB7fVxyXG4gICAgICB2YXIgaW5wdXROZXcgPSBcIlwiO1xyXG4gICAgICBsZXQgbGFzdENoYXIgPSBtZXNzYWdlLnNsaWNlKC0xKTtcclxuICAgICAgbGV0IG1lc3NhZ2VDdXQgPSBtZXNzYWdlLnNsaWNlKDAsLTEpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgbGV0IGlzVHJpcGxldCA9IHRydWU7XHJcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2VDdXQpO1xyXG5cclxuICAgICAgbGV0IGRldGVjdExpdGVyYWwgPSBcIlwiO1xyXG4gICAgICBsZXQgbWVzc2FnZUN1dFRlbXAgPSBbXTtcclxuICAgICAgbWVzc2FnZUN1dC5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgIHBhcnQgPSBwYXJ0LnRyaW0oKTtcclxuICAgICAgICAvLyAgY29uc29sZS5sb2cocGFydCk7XHJcbiAgICAgICAgaWYgKHBhcnQuc3RhcnRzV2l0aCgnXCInKSl7XHJcbiAgICAgICAgICBkZXRlY3RMaXRlcmFsID1cImRlYnV0XCI7XHJcbiAgICAgICAgICAvLyAgY29uc29sZS5sb2coZGV0ZWN0TGl0ZXJhbCk7XHJcbiAgICAgICAgICBtZXNzYWdlQ3V0VGVtcC5wdXNoKHBhcnQuc3Vic3RyKDEpKTtcclxuICAgICAgICB9ZWxzZSBpZiAocGFydC5lbmRzV2l0aCgnXCInKSl7XHJcbiAgICAgICAgICBkZXRlY3RMaXRlcmFsID0gXCJmaW5cIjtcclxuICAgICAgICAgIC8vY29uc29sZS5sb2coZGV0ZWN0TGl0ZXJhbCk7XHJcbiAgICAgICAgICBtZXNzYWdlQ3V0VGVtcC5wdXNoKG1lc3NhZ2VDdXRUZW1wLnBvcCgpK1wiIFwiK3BhcnQuc2xpY2UoMCwtMSkpO1xyXG4gICAgICAgIH1lbHNlIGlmIChkZXRlY3RMaXRlcmFsID09IFwiZGVidXRcIil7XHJcbiAgICAgICAgICAvLyAgY29uc29sZS5sb2coXCJyZWN1cGVyZSBsZSBkZXJuaWVyIGV0IGx1aSBham91dGUgcGFydFwiIClcclxuICAgICAgICAgIG1lc3NhZ2VDdXRUZW1wLnB1c2gobWVzc2FnZUN1dFRlbXAucG9wKCkrXCIgXCIrcGFydClcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICBtZXNzYWdlQ3V0VGVtcC5wdXNoKHBhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChtZXNzYWdlQ3V0VGVtcC5sZW5ndGggPiAwKXtcclxuICAgICAgICBtZXNzYWdlQ3V0ID0gbWVzc2FnZUN1dFRlbXA7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoKGxhc3RDaGFyKXtcclxuICAgICAgICBjYXNlICcuJzpcclxuICAgICAgICBpbnB1dE5ldyA9IFwiXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnOyc6XHJcbiAgICAgICAgaWYgKG1lc3NhZ2VDdXRbMF0uaW5kZXhPZihcIiBcIikgPiAtMSl7XHJcbiAgICAgICAgICBpbnB1dE5ldyA9ICdcIicrbWVzc2FnZUN1dFswXSsnXCInKycgJztcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIGlucHV0TmV3ID0gbWVzc2FnZUN1dFswXSsnICc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJywnOlxyXG4gICAgICAgIGlmIChtZXNzYWdlQ3V0WzBdLmluZGV4T2YoXCIgXCIpID4gLTEpe1xyXG4gICAgICAgICAgaW5wdXROZXcgPSAnXCInK21lc3NhZ2VDdXRbMF0rJ1wiICc7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICBpbnB1dE5ldyA9IG1lc3NhZ2VDdXRbMF0rJyAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVzc2FnZUN1dFsxXS5pbmRleE9mKFwiIFwiKSA+IC0xKXtcclxuICAgICAgICAgIGlucHV0TmV3ICs9ICdcIicrbWVzc2FnZUN1dFsxXSsnXCIgJztcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIGlucHV0TmV3ICs9IG1lc3NhZ2VDdXRbMV0rJyAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICctJzpcclxuICAgICAgICBpZiAobWVzc2FnZUN1dFsyXS5pbmRleE9mKFwiIFwiKSA+IC0xKXtcclxuICAgICAgICAgIGlucHV0TmV3ID0gJ1wiJyttZXNzYWdlQ3V0WzJdKydcIicrJyAnO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgaW5wdXROZXcgPSBtZXNzYWdlQ3V0WzJdKycgJztcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm1lc3NhZ2UgdG8gY2hhdCBcIittZXNzYWdlKVxyXG4gICAgICAgIC8vdGhpcy5zZW5kTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAvLyAgdGhpcy5hZ2VudElucHV0LnNlbmQoJ2FnZW50U29ja2V0Jywge3R5cGU6IFwic2VuZE1lc3NhZ2VcIiwgbWVzc2FnZTptZXNzYWdlfSk7XHJcbiAgICAgICAgLy8gIHRoaXMuY2F0Y2hUcmlwbGV0KG1lc3NhZ2Uuc2xpY2UoMCwtMSksIHRoaXMubmV0d29yayk7IC8vIEEgUkVNUExBQ0VSIFBBUiBDQVRDSFRSSVBMRVRTIFYyXHJcbiAgICAgICAgaW5wdXROZXcgPSBcIlwiO1xyXG4gICAgICAgIGlzVHJpcGxldCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1RyaXBsZXQpe1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcImVzdCBUcmlwbGV0XCIsbWVzc2FnZUN1dClcclxuICAgICAgICByZXN1bHQudHlwZSA9IFwidHJpcGxldFwiO1xyXG4gICAgICAgIHZhciB0cmlwbGV0dmFsdWUgPSB7fTtcclxuICAgICAgICB0cmlwbGV0dmFsdWUuc3ViamVjdCA9IG1lc3NhZ2VDdXRbMF07XHJcbiAgICAgICAgdHJpcGxldHZhbHVlLnByZWRpY2F0ZSA9IG1lc3NhZ2VDdXRbMV07XHJcbiAgICAgICAgdHJpcGxldHZhbHVlLm9iamVjdCA9IG1lc3NhZ2VDdXRbMl07XHJcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gdHJpcGxldHZhbHVlO1xyXG4gICAgICAgIHJlc3VsdC5pbnB1dE5ldyA9IGlucHV0TmV3O1xyXG4gICAgICB9ZWxzZSB7XHJcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwibidlc3QgcGFzIHRyaXBsZXRcIilcclxuICAgICAgICByZXN1bHQudHlwZSA9IFwibWVzc2FnZVwiO1xyXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgcmVzdWx0LmlucHV0TmV3ID0gaW5wdXROZXc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGtleWRvd24oZSl7XHJcbiAgICAgIGlmICggZS53aGljaCA9PT0gMTMgKSB7XHJcbiAgICAgICAgdGhpcy5hZGRfdHJpcGxlKClcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RyaXBsZS1lbGVtZW50JywgVHJpcGxlRWxlbWVudCk7XHJcbiIsImltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XHJcbmltcG9ydCB7IEhlbGxvQWdlbnQgfSBmcm9tICcuLi9hZ2VudHMvaGVsbG8tYWdlbnQuanMnO1xyXG5cclxuLy9pbXBvcnQgeyBQb2RIZWxwZXIgfSBmcm9tICcuLi90b29scy9wb2QtaGVscGVyLmpzJztcclxuLyppbXBvcnQgeyBmZXRjaERvY3VtZW50IH0gZnJvbSAndHJpcGxlZG9jJzsqL1xyXG4vL2ltcG9ydCB7IHNvbGlkLCBzY2hlbWEsIHJkZiwgcmRmcyB9IGZyb20gJ3JkZi1uYW1lc3BhY2VzJztcclxuaW1wb3J0IHsgbmFtZWROb2RlIH0gZnJvbSAnQHJkZmpzL2RhdGEtbW9kZWwnO1xyXG4vL2ltcG9ydCAgZGF0YSAgZnJvbSBcIkBzb2xpZC9xdWVyeS1sZGZsZXhcIjtcclxuXHJcbmltcG9ydCAqIGFzIGF1dGggZnJvbSAnc29saWQtYXV0aC1jbGllbnQnO1xyXG5pbXBvcnQgKiBhcyBTb2xpZEZpbGVDbGllbnQgZnJvbSBcInNvbGlkLWZpbGUtY2xpZW50XCJcclxuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XHJcblxyXG5cclxuaW1wb3J0ICcuL25vdGUtZWxlbWVudC5qcydcclxuaW1wb3J0ICcuL21lZGlhLWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi9ncmFwaC1lbGVtZW50LmpzJ1xyXG5pbXBvcnQgJy4vdHJpcGxlLWVsZW1lbnQuanMnXHJcblxyXG5cclxuY2xhc3MgUG9zdFRhYnNFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XHJcblxyXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBzdWJlbGVtZW50czoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIHJlcXVldGVzOiB7dHlwZTogT2JqZWN0fSxcclxuICAgICAgcmVzcG9uc2VzOiB7dHlwZTogQXJyYXl9LFxyXG4gICAgICBhZ29yYU5vdGVzTGlzdFVybDogeyB0eXBlOiBTdHJpbmd9LFxyXG4gICAgICB3ZWJJZDoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGluZm86IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICByZXBseVRvOiB7dHlwZTogT2JqZWN0fSxcclxuICAgICAgZnJpZW5kczoge3R5cGU6IEFycmF5fSxcclxuICAgICAgc2hhcmU6IHt0eXBlOiBPYmplY3R9LFxyXG4gICAgICBjb25maWRlbnRpYWxpdGU6IHt0eXBlOiBBcnJheX0sXHJcbiAgICAgIHRpdGxlOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgbG9nOiB7dHlwZTogU3RyaW5nfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuZmlsZUNsaWVudCA9IG5ldyBTb2xpZEZpbGVDbGllbnQoYXV0aClcclxuICAgIHRoaXMud2ViSWQgPSBudWxsXHJcbiAgICB0aGlzLnN1YmVsZW1lbnRzID0gW1wiTm90ZVwiLCBcIk1lZGlhXCIsIFwiVHJpcGxlXCJdIC8vLCBcIk1lZGlhXCIsIFwiVHJpcGxlXCJdICwgXCJHcmFwaFwiXHJcbiAgICB0aGlzLnJlcXVldGVzID0ge31cclxuICAgIHRoaXMucmVzcG9uc2VzID0gW11cclxuICAgIHRoaXMuaW5mbyA9IFwiXCJcclxuICAgIHRoaXMucmVwbHlUbyA9IHt9XHJcbiAgICB0aGlzLmZyaWVuZHMgPSBbXVxyXG4gICAgdGhpcy5zaGFyZSA9IHt9XHJcbiAgICB0aGlzLmNvbmZpZGVudGlhbGl0ZSA9IFt7bGV2ZWw6IFwiUHVibGljXCIsIHNlbGVjdGVkOiB0cnVlLCB2YWx1ZTogXCJwdWJsaWNcIiwgZGVzY3JpcHRpb246IFwiRXZlcnlvbmVcIiwgaWNvbjpcImZhcyBmYS1nbG9iZVwifSxcclxuICAgIHtsZXZlbDogXCJOb3QgbGlzdGVkXCIsIHZhbHVlOiBcIm5vdF9saXN0ZWRcIiwgZGVzY3JpcHRpb246IFwiTm90IGxpc3RlZCBpbiBwdWJsaWMgP1wiLCBpY29uOiBcImZhcyBmYS1sb2NrLW9wZW5cIn0sXHJcbiAgICB7bGV2ZWw6IFwiRm9sbG93ZXJzXCIsIHZhbHVlOiBcImZvbGxvd2Vyc1wiLCBkZXNjcmlwdGlvbjogXCJPbmx5IHlvdXIgZm9sbG93ZXJzXCIsIGljb246IFwiZmFzIGZhLWxvY2tcIn0sXHJcbiAgICB7bGV2ZWw6IFwiRGlyZWN0XCIsIHZhbHVlOiBcImRpcmVjdFwiLCBkZXNjcmlwdGlvbjogXCJPbmx5IGxpc3RlZCB1c2Vyc1wiLCBpY29uOiBcImZhcyBmYS1lbnZlbG9wXCJ9XVxyXG4gICAgdGhpcy5sb2cgPSBcIlwiXHJcbiAgICAvLyAgdGhpcy5hZ29yYU5vdGVzTGlzdFVybCA9IFwiaHR0cHM6Ly9hZ29yYS5zb2xpZC5jb21tdW5pdHkvcHVibGljL25vdGVzLnR0bFwiXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPHN0eWxlPlxyXG4gICAgYm9keSB7Zm9udC1mYW1pbHk6IEFyaWFsO31cclxuXHJcbiAgICAvKiBTdHlsZSB0aGUgdGFiICovXHJcbiAgICAudGFiIHtcclxuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2YxZjFmMTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBTdHlsZSB0aGUgYnV0dG9ucyBpbnNpZGUgdGhlIHRhYiAqL1xyXG4gICAgLnRhYiBidXR0b24ge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xyXG4gICAgICBmbG9hdDogbGVmdDtcclxuICAgICAgYm9yZGVyOiBub25lO1xyXG4gICAgICBvdXRsaW5lOiBub25lO1xyXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgIHBhZGRpbmc6IDVweCA4cHg7XHJcbiAgICAgIHRyYW5zaXRpb246IDAuM3M7XHJcbiAgICAgIGZvbnQtc2l6ZTogMTdweDtcclxuICAgIH1cclxuXHJcbiAgICAvKiBDaGFuZ2UgYmFja2dyb3VuZCBjb2xvciBvZiBidXR0b25zIG9uIGhvdmVyICovXHJcbiAgICAudGFiIGJ1dHRvbjpob3ZlciB7XHJcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyogQ3JlYXRlIGFuIGFjdGl2ZS9jdXJyZW50IHRhYmxpbmsgY2xhc3MgKi9cclxuICAgIC50YWIgYnV0dG9uLmFjdGl2ZSB7XHJcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNjY2M7XHJcbiAgICB9XHJcblxyXG4gICAgLyogU3R5bGUgdGhlIHRhYiBjb250ZW50ICovXHJcbiAgICAudGFiY29udGVudCB7XHJcbiAgICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgICAgIHBhZGRpbmc6IDZweCAxMnB4O1xyXG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjO1xyXG4gICAgICBib3JkZXItdG9wOiBub25lO1xyXG4gICAgICB3aWR0aDogMTAwJTtcclxuICAgIH1cclxuICAgIDwvc3R5bGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcblxyXG4gICAgJHt0aGlzLnJlcGx5VG8udXJsICE9IG51bGwgP1xyXG4gICAgICBodG1sIGBcclxuICAgICAgVE9ETzxicj5cclxuICAgICAgcmVwbHlUbyB1cmwgICR7dGhpcy5yZXBseVRvLnVybH08YnI+XHJcbiAgICAgIHJlcGx5VG8gYXR0cmlidXRlZFRvICAke3RoaXMucmVwbHlUby5hdHRyaWJ1dGVkVG99IDxicj5cclxuICAgICAgcmVwbHlUbyBuYW1lICAke3RoaXMucmVwbHlUby5uYW1lfSA8YnI+XHJcblxyXG4gICAgICA8bGFiZWwgY2xhc3M9XCJzci1vbmx5XCIgZm9yPVwicmVwbHlcIj5SZXBseSB0bzwvbGFiZWw+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0yXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hcHBlbmRcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj5SZXBseSB0bzwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGlucHV0IGlkPVwicmVwbHlcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIHR5cGU9XCJ0ZXh0XCIgdmFsdWU9XCIke3RoaXMucmVwbHlUby51cmx9XCIgc3R5bGU9XCJ0ZXh0LWFsaWduOnJpZ2h0O1wiICBwbGFjZWhvbGRlcj1cIlJlcGx5VG9cIj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIGBcclxuICAgICAgOmh0bWxgYFxyXG4gICAgfVxyXG5cclxuICAgIDxsYWJlbCBjbGFzcz1cInNyLW9ubHlcIiBmb3I9XCJ0aXRsZVwiPlRpdGxlPC9sYWJlbD5cclxuICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0yXCI+XHJcblxyXG4gICAgPGlucHV0IGlkPVwidGl0bGVcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIHR5cGU9XCJ0ZXh0XCIgdmFsdWU9XCIke3RoaXMudGl0bGV9XCIgcGxhY2Vob2xkZXI9XCJUaXRsZVwiPlxyXG5cclxuICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcblxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIj48IS0tc3R5bGU9XCJoZWlnaHQ6NTB2aFwiLS0+XHJcbiAgICA8ZGl2IGlkPVwiTm90ZVwiIGNsYXNzPVwidGFiY29udGVudFwiIHN0eWxlPVwiZGlzcGxheTpibG9jaztoZWlnaHQ6IDQwdmhcIj5cclxuICAgIDxub3RlLWVsZW1lbnQgbmFtZT1cIk5vdGVcIiAuc2hhcmU9XCIke3RoaXMuc2hhcmV9XCI+PC9ub3RlLWVsZW1lbnQ+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IGlkPVwiTWVkaWFcIiBjbGFzcz1cInRhYmNvbnRlbnRcIiBzdHlsZT1cImhlaWdodDogNDB2aFwiPlxyXG4gICAgPG1lZGlhLWVsZW1lbnQgbmFtZT1cIk1lZGlhXCI+PC9tZWRpYS1lbGVtZW50PlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPGRpdiBpZD1cIlRyaXBsZVwiIGNsYXNzPVwidGFiY29udGVudFwiIHN0eWxlPVwiaGVpZ2h0OiA0MHZoXCI+XHJcbiAgICA8dHJpcGxlLWVsZW1lbnQgbmFtZT1cIlRyaXBsZVwiPjwvdHJpcGxlLWVsZW1lbnQ+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IGlkPVwiR3JhcGhcIiBjbGFzcz1cInRhYmNvbnRlbnRcIiBzdHlsZT1cImhlaWdodDogNDB2aFwiPlxyXG4gICAgPGgzIGNsYXNzPVwidGV4dC1wcmltYXJ5XCI+R3JhcGg8L2gzPlxyXG4gICAgPHAgY2xhc3M9XCJ0ZXh0LXByaW1hcnlcIj50b2RvLjwvcD5cclxuICAgIDxncmFwaC1lbGVtZW50IG5hbWU9XCJHcmFwaFwiPjwvZ3JhcGgtZWxlbWVudD5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJ0YWJcIj5cclxuICAgIDxidXR0b24gY2xhc3M9XCJ0YWJsaW5rcyBhY3RpdmVcIiB0YWJOYW1lPSdOb3RlJyBAY2xpY2s9XCIke3RoaXMub3BlblRhYn1cIj48aSBjbGFzcz1cImZhciBmYS1zdGlja3ktbm90ZVwiPjwvaT48L2J1dHRvbj5cclxuICAgIDxidXR0b24gY2xhc3M9XCJ0YWJsaW5rc1wiIHRhYk5hbWU9J01lZGlhJyBAY2xpY2s9XCIke3RoaXMub3BlblRhYn1cIj48aSBjbGFzcz1cImZhcyBmYS1waG90by12aWRlb1wiPjwvaT48L2J1dHRvbj5cclxuICAgIDxidXR0b24gY2xhc3M9XCJ0YWJsaW5rc1wiIHRhYk5hbWU9J1RyaXBsZScgQGNsaWNrPVwiJHt0aGlzLm9wZW5UYWJ9XCI+PGkgY2xhc3M9XCJmYXMgZmEtcmVjZWlwdFwiPjwvaT48L2J1dHRvbj5cclxuICAgIDwhLS08YnV0dG9uIGNsYXNzPVwidGFibGlua3NcIiB0YWJOYW1lPSdHcmFwaCcgQGNsaWNrPVwiJHt0aGlzLm9wZW5UYWJ9XCI+PGkgY2xhc3M9XCJmYXMgZmEtZGljZS1kMjBcIj48L2k+PC9idXR0b24+LS0+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICA8bGFiZWwgY2xhc3M9XCJzci1vbmx5XCIgZm9yPVwidGl0bGVcIj5UYWdzPC9sYWJlbD5cclxuICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0yXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPlRhZ3M8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPGlucHV0IGlkPVwidGFnc1wiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cInRhZ3MsIGNvbW1hIHNlcGFyYXRlZFwiPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuXHJcblxyXG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG5cclxuICAgIDxzZWxlY3QgaWQ9XCJjb25maWRcIiBjbGFzcz1cImN1c3RvbS1zZWxlY3RcIiBAY2hhbmdlPVwiJHt0aGlzLmNoYW5nZX1cIiBAaW5wdXQ9XCIke3RoaXMuaW5wdXR9XCIgQHNlbGVjdD1cIiR7dGhpcy5zZWxlY3R9XCI+IDwhLS1tdWx0aXBsZS0tPlxyXG4gICAgJHt0aGlzLmNvbmZpZGVudGlhbGl0ZS5tYXAoYyA9PlxyXG4gICAgICBodG1sYFxyXG4gICAgICA8b3B0aW9uXHJcblxyXG4gICAgICB2YWx1ZT1cIiR7Yy52YWx1ZX1cIiB0aXRsZT1cIiR7Yy5kZXNjcmlwdGlvbn1cIj5cclxuICAgICAgJHtjLmxldmVsfVxyXG4gICAgICA8L29wdGlvbj5cclxuICAgICAgYFxyXG4gICAgKX1cclxuICAgIDwvc2VsZWN0PlxyXG4gICAgPGhyPlxyXG5cclxuICAgIDxzZWxlY3QgaWQ9XCJyZWNpcGllbnRzXCIgY2xhc3M9XCJjdXN0b20tc2VsZWN0XCIgbXVsdGlwbGU+IDwhLS1tdWx0aXBsZS0tPlxyXG4gICAgPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3QgTXVsdGkgUmVjaXBpZW50PC9vcHRpb24+XHJcbiAgICA8IS0tICA8b3B0aW9uICB2YWx1ZT1cIiNtZVwiPlBlcnNvbm5hbCAoTWUpPC9vcHRpb24+XHJcbiAgICA8b3B0aW9uIHNlbGVjdGVkIHZhbHVlPVwiaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNQdWJsaWNcIj5QdWJsaWMgKEFnb3JhKTwvb3B0aW9uPi0tPlxyXG4gICAgJHt0aGlzLmZyaWVuZHMubWFwKGYgPT5cclxuICAgICAgaHRtbCBgXHJcbiAgICAgIDxvcHRpb24gdmFsdWU9XCIke2Yud2ViSWR9XCI+ICR7Zi5uYW1lfSA8L29wdGlvbj5cclxuICAgICAgYCl9XHJcbiAgICAgIDwhLS0gICAgICA8b3B0aW9uIHZhbHVlPVwic29tZW9uZVwiIGRpc2FibGVkPlNvbWVvbmUgRWxzZSAodG9kbyk8L29wdGlvbj4tLT5cclxuICAgICAgPC9zZWxlY3Q+XHJcblxyXG5cclxuXHJcbiAgICAgIDwvZGl2PlxyXG5cclxuXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25zXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImNvbC00XCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XHJcbiAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIlwiIGlkPVwiYWdvcmFfcHViXCIgbmFtZT1cImFnb3JhX3B1YlwiIGNoZWNrZWQ+XHJcbiAgICAgIDxsYWJlbCBjbGFzcz1cInRleHQtcHJpbWFyeVwiIGZvcj1cImFnb3JhX3B1YlwiPlxyXG4gICAgICBQdXNoIHRvIEFnb3JhXHJcbiAgICAgIDwvbGFiZWw+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cImNvbC00XCI+XHJcbiAgICAgIExvZyA6ICR7dGhpcy5sb2d9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY29sXCI+XHJcbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgcHJpbWFyeSBAY2xpY2s9JHt0aGlzLmFkZE5vdGV9PlxyXG4gICAgICBTZW5kIDxpIGNsYXNzPVwiZmFyIGZhLXBhcGVyLXBsYW5lXCI+PC9pPjwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPCEtLVxyXG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNhbmNlbCBidG4gYnRuLXByaW1hcnlcIiBAY2xpY2s9XCIke3RoaXMudG9nZ2xlV3JpdGV9XCI+PGkgY2xhc3M9XCJmYXMgZmEtd2luZG93LWNsb3NlXCI+PC9pPiA8L2J1dHRvbj4tLT5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICA8IS0tXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25zXCI+XHJcblxyXG4gICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJjb2wtNVwiPlxyXG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIHByaW1hcnkgQGNsaWNrPSR7dGhpcy5hZGROb3RlfT48aSBjbGFzcz1cImZhciBmYS1wYXBlci1wbGFuZVwiPjwvaT48L2J1dHRvbj5cclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjYW5jZWwgYnRuIGJ0bi1wcmltYXJ5XCIgQGNsaWNrPVwiJHt0aGlzLnRvZ2dsZVdyaXRlfVwiPjxpIGNsYXNzPVwiZmFzIGZhLXdpbmRvdy1jbG9zZVwiPjwvaT4gPC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY29sXCI+XHJcblxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2Pi0tPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgYDtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3QoZSl7XHJcbiAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0LnZhbHVlKVxyXG4gICAgfVxyXG5cclxuICAgIGlucHV0KGUpe1xyXG4gICAgICBjb25zb2xlLmxvZyhlLnRhcmdldC52YWx1ZSlcclxuICAgIH1cclxuXHJcbiAgICBjaGFuZ2UoZSl7XHJcbiAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0LnZhbHVlKVxyXG4gICAgfVxyXG5cclxuICAgIGFkZE5vdGUoKXtcclxuICAgICAgdGhpcy5sb2cgPSBcIkFkZCBOb3RlXCJcclxuICAgICAgbGV0IGNvbmZpZCA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChcImNvbmZpZFwiKS52YWx1ZVxyXG4gICAgICBjb25zb2xlLmxvZyhjb25maWQpXHJcbiAgICAgIHZhciB0aXRsZSA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndGl0bGUnKS52YWx1ZS50cmltKCk7XHJcbiAgICAgIGlmICh0aXRsZS5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgYWxlcnQgKFwiRG9uJ3QgeW91IHdhbnQgdG8gcHJvdmlkZSBhICBiZWF1dGlmdWwgdGl0bGUgdG8geW91ciB3b25kZXIgcG9zdCA/XCIpXHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIHZhciBpZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcgKClcclxuICAgICAgICB0aGlzLnJlcXVldGVzW2lkXSA9IHRoaXMuc3ViZWxlbWVudHMubGVuZ3RoXHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5yZXF1ZXRlcylcclxuICAgICAgICB0aGlzLmxvZyA9IFwiQXNrIFN1YkVsZW1lbnRzIENvbnRlbnRcIlxyXG4gICAgICAgIHZhciBtZXNzID0ge2FjdGlvbjogXCJhc2tDb250ZW50XCIsIGlkIDogaWR9XHJcbiAgICAgICAgdGhpcy5hZ2VudC5zZW5kTXVsdGkodGhpcy5zdWJlbGVtZW50cywgbWVzcylcclxuXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0b2dnbGVXcml0ZSgpe1xyXG4gICAgICB0aGlzLmFnZW50LnNlbmQoXCJQb3N0XCIsIHthY3Rpb246IFwidG9nZ2xlV3JpdGVcIn0pXHJcbiAgICB9XHJcblxyXG5cclxuICAgIG9wZW5UYWIoZSkge1xyXG4gICAgICB2YXIgbm9kZSA9IGUudGFyZ2V0XHJcbiAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiSVwiKXtcclxuICAgICAgICBub2RlID0gZS50YXJnZXQucGFyZW50Tm9kZVxyXG4gICAgICB9XHJcbiAgICAgIHZhciB0YWJOYW1lID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYk5hbWUnKVxyXG4gICAgICB2YXIgaSwgdGFiY29udGVudCwgdGFibGlua3M7XHJcbiAgICAgIHRhYmNvbnRlbnQgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbChcIi50YWJjb250ZW50XCIpO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGFiY29udGVudC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRhYmNvbnRlbnRbaV0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICB9XHJcbiAgICAgIHRhYmxpbmtzID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFibGlua3NcIik7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWJsaW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRhYmxpbmtzW2ldLmNsYXNzTmFtZSA9IHRhYmxpbmtzW2ldLmNsYXNzTmFtZS5yZXBsYWNlKFwiIGFjdGl2ZVwiLCBcIlwiKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQodGFiTmFtZSkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgbm9kZS5jbGFzc05hbWUgKz0gXCIgYWN0aXZlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgZmlyc3RVcGRhdGVkKCl7XHJcbiAgICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgICAvLyAgdGhpcy5waCA9IG5ldyBQb2RIZWxwZXIoKTtcclxuICAgICAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuYWdlbnQpXHJcbiAgICAgIHRoaXMuYWdlbnQucmVjZWl2ZSA9IGZ1bmN0aW9uKGZyb20sIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBcInJlcG9uc2VDb250ZW50XCI6XHJcbiAgICAgICAgICAgIGFwcC5yZXBvbnNlQ29udGVudChmcm9tLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWJJZENoYW5nZWRcIjpcclxuICAgICAgICAgICAgYXBwLndlYklkQ2hhbmdlZChtZXNzYWdlLndlYklkKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZXRSZXBseVRvXCI6XHJcbiAgICAgICAgICAgIGFwcC5zZXRSZXBseVRvKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNvbmZpZ0NoYW5nZWRcIjpcclxuICAgICAgICAgICAgYXBwLmNvbmZpZ0NoYW5nZWQobWVzc2FnZS5jb25maWcpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGFjdGlvbiBcIixtZXNzYWdlKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgaWYodGhpcy5zaGFyZS50aXRsZSAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSB0aGlzLnNoYXJlLnRpdGxlXHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiU3RvcmVcIiwge2FjdGlvbjogXCJnZXRDb25maWdcIn0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnQ2hhbmdlZChjb25maWcpe1xyXG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xyXG4gICAgICB0aGlzLmZyaWVuZHMgPSBjb25maWcuZnJpZW5kcyB8fCBbXVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHNldFJlcGx5VG8obWVzc2FnZSl7XHJcbiAgICAgIGlmIChtZXNzYWdlLnJlcGx5VG8gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICB0aGlzLnJlcGx5VG8gPXt9XHJcbiAgICAgICAgdGhpcy5yZXBseVRvLnVybCAgPSBtZXNzYWdlLnJlcGx5VG9cclxuICAgICAgICBsZXQgYXR0cmlidXRlZFRvID0gYXdhaXQgc29saWQuZGF0YVt0aGlzLnJlcGx5VG8udXJsXS5hcyRhdHRyaWJ1dGVkVG9cclxuICAgICAgICBsZXQgbmFtZSA9IGF3YWl0IHNvbGlkLmRhdGFbYCR7YXR0cmlidXRlZFRvfWBdLnZjYXJkJGZuIHx8IGAke2ZyaWVuZH1gLnNwbGl0KFwiL1wiKVsyXS5zcGxpdCgnLicpWzBdO1xyXG4gICAgICAgIHRoaXMucmVwbHlUby5hdHRyaWJ1dGVkVG8gPSBgJHthdHRyaWJ1dGVkVG99YFxyXG4gICAgICAgIHRoaXMucmVwbHlUby5uYW1lID0gYCR7bmFtZX1gXHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5yZXBseVRvKVxyXG4gICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpXHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMucmVwbHlUbyA9IHt9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3ZWJJZENoYW5nZWQod2ViSWQpe1xyXG4gICAgICBjb25zb2xlLmxvZyh3ZWJJZClcclxuICAgICAgdGhpcy53ZWJJZCA9IHdlYklkXHJcbiAgICB9XHJcblxyXG4gICAgcmVwb25zZUNvbnRlbnQoZnJvbSwgbWVzc2FnZSl7XHJcbiAgICAgIGNvbnNvbGUubG9nKGZyb20sIG1lc3NhZ2UpXHJcbiAgICAgIHRoaXMucmVxdWV0ZXNbbWVzc2FnZS5pZF0tLVxyXG4gICAgICAvLyBzaSB0b3V0ZXMgcmVwb25zZXNcclxuICAgICAgdGhpcy5yZXNwb25zZXMucHVzaCh7ZnJvbTpmcm9tLCBtZXNzYWdlOiBtZXNzYWdlfSlcclxuICAgICAgaWYgKHRoaXMucmVxdWV0ZXNbbWVzc2FnZS5pZF0gPT0gMCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJVUERBVEVcIilcclxuICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXRlc1ttZXNzYWdlLmlkXVxyXG4gICAgICAgIHRoaXMucHJlcGFyZVBvc3QoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBhc3luYyBwcmVwYXJlUG9zdCgpe1xyXG4gICAgICB2YXIgYXBwID0gdGhpc1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkNPTkZJR1wiLHRoaXMuY29uZmlnKVxyXG4gICAgICBjb25zb2xlLmxvZyhcIk9VVEJPWFwiLCB0aGlzLmNvbmZpZy5vdXRib3gpXHJcbiAgICAgIGxldCByZWNpcGllbnRfc2VsZWN0ID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFwicmVjaXBpZW50c1wiKVxyXG4gICAgICBsZXQgcmVjaXBpZW50cyA9IEFycmF5KC4uLnJlY2lwaWVudF9zZWxlY3Qub3B0aW9ucykucmVkdWNlKChhY2MsIG9wdGlvbikgPT4ge1xyXG4gICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgIGFjYy5wdXNoKG9wdGlvbi52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgIH0sIFtdKTtcclxuICAgICAgLy8gIGNvbnNvbGUubG9nKFwiUkVDSVBJRU5UU1wiLHJlY2lwaWVudHMpXHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMucmVzcG9uc2VzKVxyXG4gICAgICB2YXIgdGl0bGUgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3RpdGxlJykudmFsdWUudHJpbSgpO1xyXG4gICAgICB2YXIgdGFncyA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndGFncycpLnZhbHVlLnNwbGl0KCcsJyk7XHJcbiAgICAgIHZhciBhZ29yYV9wdWIgPSBhcHAuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnYWdvcmFfcHViJykuY2hlY2tlZFxyXG4gICAgICB2YXIgaW5SZXBseVRvID0gbnVsbDtcclxuICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgncmVwbHknKSAhPSBudWxsKXtcclxuICAgICAgICBpblJlcGx5VG8gPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3JlcGx5JykudmFsdWUudHJpbSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndGl0bGUnKS52YWx1ZSA9IFwiXCJcclxuICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0YWdzJykudmFsdWUgPSBcIlwiXHJcbiAgICAgIHRoaXMuc3RvcmFnZSA9IGF3YWl0IHNvbGlkLmRhdGEudXNlci5zdG9yYWdlXHJcblxyXG4gICAgICAvLyBUUkVBVCBPQkpFQ1RTXHJcbiAgICAgIGxldCBkYXRlT2JqID0gbmV3IERhdGUoKTtcclxuICAgICAgbGV0IGRhdGUgPSBkYXRlT2JqLnRvSVNPU3RyaW5nKClcclxuICAgICAgLy8gICAgbGV0IHRvID0gYWN0Lm9iamVjdC50YXJnZXQgPT0gXCJQdWJsaWNcIiA/IFwiaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNQdWJsaWNcIiA6IGFjdC5vYmplY3QudGFyZ2V0O1xyXG5cclxuICAgICAgbGV0IG9iamVjdHMgPSBbXVxyXG5cclxuICAgICAgdGhpcy5yZXNwb25zZXMuZm9yRWFjaChhc3luYyBmdW5jdGlvbihyKXtcclxuICAgICAgICAvL29iamVjdCBjcmVhdGVcclxuXHJcbiAgICAgICAgbGV0IG9iamVjdF9JZCA9IHV1aWR2NCgpOyAvLyDih6ggJzliMWRlYjRkLTNiN2QtNGJhZC05YmRkLTJiMGQ3YjNkY2I2ZCdcclxuICAgICAgICAvLyAgICBsZXQgb2JqZWN0X3VyaSA9IG91dGJveCtcIm9iamVjdHMvXCIrb2JqZWN0X0lkK1wiL2luZGV4LnR0bCN0aGlzXCJcclxuICAgICAgICBsZXQgb2JqZWN0X2ZpbGUgPSBhcHAuY29uZmlnLm91dGJveCtcIm9iamVjdHMvXCIrb2JqZWN0X0lkK1wiLnR0bFwiXHJcbiAgICAgICAgbGV0IG9iamVjdF91cmkgPSBvYmplY3RfZmlsZStcIiN0aGlzXCJcclxuICAgICAgICBzd2l0Y2ggKHIubWVzc2FnZS50eXBlKSB7XHJcbiAgICAgICAgICBjYXNlIFwiTm90ZVwiOlxyXG4gICAgICAgICAgaWYoci5tZXNzYWdlLmNvbnRlbnQubGVuZ3RoID4wKXtcclxuICAgICAgICAgICAgb2JqZWN0cy5wdXNoKHt1cmk6IG9iamVjdF91cmksIGZpbGU6IG9iamVjdF9maWxlfSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDUkVBVEUgTk9URSBXSVRIXCIsIHIubWVzc2FnZS5jb250ZW50LCBvYmplY3RfdXJpKVxyXG4gICAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW29iamVjdF91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI3R5cGUnXS5hZGQobmFtZWROb2RlKCdodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI05vdGUnKSlcclxuICAgICAgICAgICAgYXdhaXQgc29saWQuZGF0YVtvYmplY3RfdXJpXVsnaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNuYW1lJ10uYWRkKHRpdGxlKVxyXG4gICAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW29iamVjdF91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI2NvbnRlbnQnXS5hZGQoci5tZXNzYWdlLmNvbnRlbnQpXHJcbiAgICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbb2JqZWN0X3VyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjcHVibGlzaGVkJ10uYWRkKGRhdGUpXHJcbiAgICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbb2JqZWN0X3VyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjYXR0cmlidXRlZFRvJ10uYWRkKG5hbWVkTm9kZShhcHAuY29uZmlnLndlYklkKSlcclxuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJJbWFnZVwiOlxyXG4gICAgICAgICAgY2FzZSBcIlZpZGVvXCI6XHJcbiAgICAgICAgICBjYXNlIFwiQXVkaW9cIjpcclxuICAgICAgICAgIGNhc2UgXCJEb2N1bWVudFwiOlxyXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL3dpa2kvU29jaWFsQ0cvQWN0aXZpdHlQdWIvTWVkaWFVcGxvYWQgbXVzdCBub3JtYWxseSBiZSB1cGxvYWRlZCB0byByZWNpcGllbnQgZW5kcG9pbnRcclxuICAgICAgICAgIGlmKHIubWVzc2FnZS5jb250ZW50ICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHZhciBmaWxlID0gci5tZXNzYWdlLmNvbnRlbnRcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gZmlsZS5jb250ZW50VHlwZVxyXG4gICAgICAgICAgICB2YXIgbmV3RmlsZW5hbWUgPSByLm1lc3NhZ2UubmV3RmlsZW5hbWVcclxuICAgICAgICAgICAgdmFyIGNsYXNzZSA9IHIubWVzc2FnZS50eXBlXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbb2JqZWN0X3VyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjdHlwZSddLmFkZChuYW1lZE5vZGUoJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjJytyLm1lc3NhZ2UudHlwZSkpXHJcbiAgICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbb2JqZWN0X3VyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjbmFtZSddLmFkZCh0aXRsZSlcclxuICAgICAgICAgICAgYXdhaXQgc29saWQuZGF0YVtvYmplY3RfdXJpXVsnaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNjb250ZW50J10uYWRkKHIubWVzc2FnZS5jb250ZW50KVxyXG4gICAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW29iamVjdF91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI3B1Ymxpc2hlZCddLmFkZChkYXRlKVxyXG4gICAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW29iamVjdF91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI2F0dHJpYnV0ZWRUbyddLmFkZChuYW1lZE5vZGUoYXBwLmNvbmZpZy53ZWJJZCkpXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gY3JlYXRlIGFuIE9iamVjdC50dGwsIHJlcGxjZSBieSBmaWxlID9cclxuICAgICAgICAgICAgbGV0IG9iamVjdF9maWxlID0gYXBwLmNvbmZpZy5vdXRib3grXCJvYmplY3RzL1wiK2NsYXNzZStcIi9cIituZXdGaWxlbmFtZVxyXG4gICAgICAgICAgICBsZXQgb2JqZWN0X3VyaSA9IG9iamVjdF9maWxlIC8vIHBhcyBkZSAjdGhpc1xyXG4gICAgICAgICAgICAvLyB2YXIgb2JqZWN0X3VyaSA9IGFwcC5zdG9yYWdlK1wicHVibGljL3Nwb2dneS9cIitjbGFzc2UrXCIvXCIrbmV3RmlsZW5hbWVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDUkVBVEUgRE9DVU1FTlQgV0lUSFwiLHIubWVzc2FnZSwgb2JqZWN0X3VyaSlcclxuICAgICAgICAgICAgYXdhaXQgYXBwLnNlbmRGaWxlKG9iamVjdF9maWxlLCBmaWxlLCBjb250ZW50VHlwZSlcclxuICAgICAgICAgICAgLy8gICBhd2FpdCAgZGF0YVt1c2VyQWN0aXZpdHldLmFzJG9iamVjdC5hZGQobmFtZWROb2RlKHVzZXJNZWRpYSkpXHJcblxyXG4gICAgICAgICAgICBvYmplY3RzLnB1c2goe3VyaTogb2JqZWN0X3VyaSwgZmlsZTogb2JqZWN0X2ZpbGV9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwiVHJpcGxlXCI6XHJcbiAgICAgICAgICBpZihyLm1lc3NhZ2UuY29udGVudC5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgb2JqZWN0cy5wdXNoKHt1cmk6IG9iamVjdF91cmksIGZpbGU6IG9iamVjdF9maWxlfSlcclxuICAgICAgICAgICAgY29udGVudCA9IHIubWVzc2FnZS5jb250ZW50XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ1JFQVRFIERPQ1VNRU5UIFdJVEhcIixyLm1lc3NhZ2UsIG9iamVjdF91cmkpXHJcbiAgICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbb2JqZWN0X3VyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjdHlwZSddLmFkZChuYW1lZE5vZGUoJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjJytyLm1lc3NhZ2UudHlwZSkpXHJcbiAgICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbb2JqZWN0X3VyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjbmFtZSddLmFkZCh0aXRsZSlcclxuICAgICAgICAgICAgYXdhaXQgc29saWQuZGF0YVtvYmplY3RfdXJpXVsnaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNwdWJsaXNoZWQnXS5hZGQoZGF0ZSlcclxuICAgICAgICAgICAgYXdhaXQgc29saWQuZGF0YVtvYmplY3RfdXJpXVsnaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNhdHRyaWJ1dGVkVG8nXS5hZGQobmFtZWROb2RlKGFwcC5jb25maWcud2ViSWQpKVxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgYXdhaXQgc29saWQuZGF0YVtvYmplY3RfdXJpXVsnaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNjb250ZW50J10uYWRkKHIubWVzc2FnZS5jb250ZW50KVxyXG5cclxuICAgICAgICAgICAgLy93cml0ZSBzdWJqZWN0IGh0dHBzOi8vZ2l0aHViLmNvbS9MRGZsZXgvTERmbGV4L2lzc3Vlcy81M1xyXG4gICAgICAgICAgICByLm1lc3NhZ2UuY29udGVudC5mb3JFYWNoKGFzeW5jIGZ1bmN0aW9uKHRyaXBsZSwgaSkge1xyXG4gICAgICAgICAgICAvLyAgY29uc29sZS5sb2codHJpcGxlKVxyXG4gICAgICAgICAgICAgIGxldCBzdWJqZWN0ID0gb2JqZWN0X2ZpbGUrXCIjXCIrdHJpcGxlLnN1YmplY3RcclxuICAgICAgICAgICAgICBsZXQgcHJlZGljYXRlID0gb2JqZWN0X2ZpbGUrXCIjXCIrdHJpcGxlLnByZWRpY2F0ZVxyXG4gICAgICAgICAgICAgIGxldCBvYmplY3QgPSBvYmplY3RfZmlsZStcIiNcIit0cmlwbGUub2JqZWN0XHJcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdClcclxuICAgICAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW3N1YmplY3RdW3ByZWRpY2F0ZV0uYWRkKG5hbWVkTm9kZShvYmplY3QpKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhyLm1lc3NhZ2UudHlwZSAsIFwibm9uIHRyYWl0ZVwiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICB0aGlzLnJlc3BvbnNlcyA9IFtdXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyA6IEFDTCBGSUxFUyAmIFJFUExZVE9cIilcclxuICAgICAgY29uc29sZS5sb2coXCJPQkpFQ1RTXCIsb2JqZWN0cylcclxuXHJcblxyXG5cclxuICAgICAgLypcclxuICAgICAgaWYgKHRvID09IFwiaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNQdWJsaWNcIil7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU2VuZCB0byBBZ29yYVwiKVxyXG4gICAgICB0byA9IFwiaHR0cHM6Ly9hZ29yYS5zb2xpZC5jb21tdW5pdHkvcHJvZmlsZS9jYXJkI21lXCJcclxuICAgIH1cclxuICAgICovXHJcblxyXG4gICAgLy9hY3Rpdml0eSBjcmVhdGVcclxuICAgIGxldCBhY3Rpdml0eV9JZCA9IHV1aWR2NCgpO1xyXG4gICAgLy8gICAgICBsZXQgYWN0aXZpdHlfdXJpID0gb3V0Ym94K1wiYWN0aXZpdGllcy9cIithY3Rpdml0eV9JZCtcIi9pbmRleC50dGwjdGhpc1wiXHJcbiAgICBsZXQgYWN0aXZpdHlfZmlsZSA9IGFwcC5jb25maWcub3V0Ym94K1wiYWN0aXZpdGllcy9cIithY3Rpdml0eV9JZCtcIi50dGxcIlxyXG4gICAgbGV0IGFjdGl2aXR5X3VyaSA9IGFjdGl2aXR5X2ZpbGUrXCIjdGhpc1wiXHJcblxyXG4gICAgYXdhaXQgc29saWQuZGF0YVthY3Rpdml0eV91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI3R5cGUnXS5hZGQobmFtZWROb2RlKCdodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI0NyZWF0ZScpKVxyXG4gICAgYXdhaXQgc29saWQuZGF0YVthY3Rpdml0eV91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI3N1bW1hcnknXS5hZGQodGl0bGUpXHJcbiAgICBhd2FpdCBzb2xpZC5kYXRhW2FjdGl2aXR5X3VyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjcHVibGlzaGVkJ10uYWRkKGRhdGUpXHJcbiAgICBhd2FpdCBzb2xpZC5kYXRhW2FjdGl2aXR5X3VyaV0ucmRmcyRsYWJlbC5hZGQodGl0bGUpXHJcblxyXG4gICAgLyogIGlmIChyZWNpcGllbnRzLmxlbmd0aD09IDApe1xyXG4gICAgYXdhaXQgc29saWQuZGF0YVtvLnVyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjdG8nXS5hZGQobmFtZWROb2RlKGFwcC5jb25maWcud2ViSWQpKVxyXG4gICAgYXdhaXQgc29saWQuZGF0YVthY3Rpdml0eV91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI3RhcmdldCddLmFkZChuYW1lZE5vZGUoYXBwLmNvbmZpZy53ZWJJZCkpXHJcbiAgfSovXHJcblxyXG4gIC8vIEFDTCBPQkpFQ1RcclxuICBsZXQgcmVjaXBpZW50c1dlYklkcyA9IFtdXHJcbiAgcmVjaXBpZW50cy5mb3JFYWNoKChyLCBpKSA9PiB7XHJcbiAgICByZWNpcGllbnRzV2ViSWRzLnB1c2goJzwnK3IrJz4nKVxyXG4gIH0pO1xyXG4gIGxldCBhY2xTdHJpbmdXZWJJZHMgPSByZWNpcGllbnRzV2ViSWRzLmpvaW4oJywgJylcclxuICBjb25zb2xlLmxvZyhcIkFDTCBTVFJJTkdcIiwgYWNsU3RyaW5nV2ViSWRzKVxyXG5cclxuICBvYmplY3RzLmZvckVhY2goYXN5bmMgZnVuY3Rpb24obywgaSkge1xyXG4gICAgYXBwLnNldEFjbChvLCBhY2xTdHJpbmdXZWJJZHMsIGFnb3JhX3B1YilcclxuICAgIGF3YWl0IHNvbGlkLmRhdGFbYWN0aXZpdHlfdXJpXVsnaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNvYmplY3QnXS5hZGQobmFtZWROb2RlKG8udXJpKSlcclxuICAgIHJlY2lwaWVudHMuZm9yRWFjaChhc3luYyBmdW5jdGlvbih0bywgaSkge1xyXG4gICAgICBpZiAoby51cmkuZW5kc1dpdGgoXCIjdGhpc1wiKSl7XHJcbiAgICAgICAgYXdhaXQgc29saWQuZGF0YVtvLnVyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjdG8nXS5hZGQobmFtZWROb2RlKHRvKSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIGlmIChhZ29yYV9wdWIgPT0gdHJ1ZSl7XHJcbiAgICAgIGF3YWl0IHNvbGlkLmRhdGFbby51cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI3RvJ10uYWRkKG5hbWVkTm9kZShcImh0dHBzOi8vYWdvcmEuc29saWQuY29tbXVuaXR5L3Byb2ZpbGUvY2FyZCNtZVwiKSlcclxuICAgICAgYXdhaXQgc29saWQuZGF0YVtvLnVyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjdG8nXS5hZGQobmFtZWROb2RlKFwiaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNQdWJsaWNcIikpXHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHRoaXMubG9nID0gYWN0aXZpdHlfdXJpKyBcIkRPTkVcIlxyXG4gIGNvbnNvbGUubG9nKFwiQWN0aXZpdHkgT0tcIixhY3Rpdml0eV91cmkpXHJcbiAgbGV0IGFjdGl2aXR5ID0ge3VybDogYWN0aXZpdHlfdXJpLCBmaWxlOiBhY3Rpdml0eV9maWxlfVxyXG4gIGFwcC5zZXRBY2woYWN0aXZpdHksIGFjbFN0cmluZ1dlYklkcywgYWdvcmFfcHViKVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgLyogQUNMIHBvdXIgcGx1c2lldXJzIGNyZWF0ZUZvbGRlcnNcclxuICBAcHJlZml4IDogPCM+LlxyXG4gIEBwcmVmaXggbjA6IDxodHRwOi8vd3d3LnczLm9yZy9ucy9hdXRoL2FjbCM+LlxyXG4gIEBwcmVmaXggYzogPC9wcm9maWxlL2NhcmQjPi5cclxuICBAcHJlZml4IGMwOiA8aHR0cHM6Ly9zcG9nZ3ktdGVzdDIuc29saWQuY29tbXVuaXR5L3Byb2ZpbGUvY2FyZCM+LlxyXG4gIEBwcmVmaXggYzE6IDxodHRwczovL3Nwb2dneS10ZXN0My5zb2xpZC5jb21tdW5pdHkvcHJvZmlsZS9jYXJkIz4uXHJcblxyXG4gIDpDb250cm9sUmVhZFdyaXRlXHJcbiAgYSBuMDpBdXRob3JpemF0aW9uO1xyXG4gIG4wOmFjY2Vzc1RvIDxmYTg3NDBjYy04ZWFmLTRhZTgtODQ4OS1iNGQ5Njc4M2QyMjQudHRsPjtcclxuICBuMDphZ2VudCBjOm1lO1xyXG4gIG4wOm1vZGUgbjA6Q29udHJvbCwgbjA6UmVhZCwgbjA6V3JpdGUuXHJcbiAgOlJlYWRcclxuICBhIG4wOkF1dGhvcml6YXRpb247XHJcbiAgbjA6YWNjZXNzVG8gPGZhODc0MGNjLThlYWYtNGFlOC04NDg5LWI0ZDk2NzgzZDIyNC50dGw+O1xyXG4gIG4wOmFnZW50IGMwOm1lLCBjMTptZTtcclxuICBuMDptb2RlIG4wOlJlYWQuKi9cclxuXHJcblxyXG4gIC8qIEFDTCBwbHVzaWV1cnMgcmVhZGVycyAmIHB1YmxpY1xyXG4gIEBwcmVmaXggOiA8Iz4uXHJcbiAgQHByZWZpeCBuMDogPGh0dHA6Ly93d3cudzMub3JnL25zL2F1dGgvYWNsIz4uXHJcbiAgQHByZWZpeCBjOiA8L3Byb2ZpbGUvY2FyZCM+LlxyXG4gIEBwcmVmaXggYzA6IDxodHRwczovL3Nwb2dneS10ZXN0Mi5zb2xpZC5jb21tdW5pdHkvcHJvZmlsZS9jYXJkIz4uXHJcbiAgQHByZWZpeCBjMTogPGh0dHBzOi8vc3BvZ2d5LXRlc3QzLnNvbGlkLmNvbW11bml0eS9wcm9maWxlL2NhcmQjPi5cclxuICBAcHJlZml4IG4xOiA8aHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS8+LlxyXG5cclxuICA6Q29udHJvbFJlYWRXcml0ZVxyXG4gIGEgbjA6QXV0aG9yaXphdGlvbjtcclxuICBuMDphY2Nlc3NUbyA8ZmE4NzQwY2MtOGVhZi00YWU4LTg0ODktYjRkOTY3ODNkMjI0LnR0bD47XHJcbiAgbjA6YWdlbnQgYzptZTtcclxuICBuMDptb2RlIG4wOkNvbnRyb2wsIG4wOlJlYWQsIG4wOldyaXRlLlxyXG4gIDpSZWFkXHJcbiAgYSBuMDpBdXRob3JpemF0aW9uO1xyXG4gIG4wOmFjY2Vzc1RvIDxmYTg3NDBjYy04ZWFmLTRhZTgtODQ4OS1iNGQ5Njc4M2QyMjQudHRsPjtcclxuICBuMDphZ2VudCBjMDptZSwgYzE6bWU7XHJcbiAgbjA6YWdlbnRDbGFzcyBuMTpBZ2VudDtcclxuICBuMDptb2RlIG4wOlJlYWQuXHJcbiAgKi9cclxuXHJcblxyXG5cclxuXHJcblxyXG4gIGlmIChhZ29yYV9wdWIgPT0gdHJ1ZSl7XHJcbiAgICB0aGlzLmxvZyA9IFwiQWRkIFB1YmxpYyB0byByZWNpcGllbnRzXCJcclxuICAgIGNvbnNvbGUubG9nKFwiUFVCTElDXCIsYWdvcmFfcHViKVxyXG4gICAgYXdhaXQgc29saWQuZGF0YVthY3Rpdml0eV91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI3RvJ10uYWRkKG5hbWVkTm9kZShcImh0dHBzOi8vYWdvcmEuc29saWQuY29tbXVuaXR5L3Byb2ZpbGUvY2FyZCNtZVwiKSlcclxuICAgIGF3YWl0IHNvbGlkLmRhdGFbYWN0aXZpdHlfdXJpXVsnaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyN0byddLmFkZChuYW1lZE5vZGUoXCJodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI1B1YmxpY1wiKSlcclxuICAgIHJlY2lwaWVudHMucHVzaChcImh0dHBzOi8vYWdvcmEuc29saWQuY29tbXVuaXR5L3Byb2ZpbGUvY2FyZCNtZVwiKVxyXG4gIH1cclxuXHJcblxyXG5cclxuXHJcbiAgcmVjaXBpZW50cy5mb3JFYWNoKGFzeW5jIGZ1bmN0aW9uKHRvLCBpKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlRPXCIsdG8pXHJcbiAgICBhcHAubG9nID0gXCJub3RpZmljYXRpb24gdG8gXCIrdG9cclxuICAgIGF3YWl0IHNvbGlkLmRhdGFbYWN0aXZpdHlfdXJpXVsnaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyN0YXJnZXQnXS5hZGQobmFtZWROb2RlKHRvKSlcclxuXHJcbiAgICAvLyByZWNpcGllbnQgbm90aWZpY2F0aW9uXHJcbiAgICBsZXQgbm90aWZpY2F0aW9uX0lkID0gdXVpZHY0KCk7XHJcbiAgICBsZXQgcHRpID0gYXdhaXQgc29saWQuZGF0YVt0b10ucHVibGljVHlwZUluZGV4XHJcbiAgICBjb25zb2xlLmxvZyhwdGkpXHJcblxyXG4gICAgbGV0IGluc3RhbmNlVHJvdXZlZSA9IGZhbHNlXHJcblxyXG4gICAgZm9yIGF3YWl0IChjb25zdCBzdWJqZWN0IG9mIHNvbGlkLmRhdGFbcHRpXS5zdWJqZWN0cyl7XHJcbiAgICAgIGxldCBzID0gYCR7c3ViamVjdH1gXHJcbiAgICAgIC8vICBjb25zb2xlLmxvZyhzKVxyXG4gICAgICBpZihwdGkgIT0gYCR7c3ViamVjdH1gKXtcclxuXHJcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKHMpXHJcbiAgICAgICAgaWYgKGAke3N1YmplY3R9YC5lbmRzV2l0aCgnI0Fnb3JhJykpe1xyXG4gICAgICAgICAgaW5zdGFuY2VUcm91dmVlID0gdHJ1ZVxyXG4gICAgICAgICAgY29uc29sZS5sb2cocylcclxuICAgICAgICAgIGxldCBpbnN0YW5jZSAgPSBhd2FpdCBzb2xpZC5kYXRhW2Ake3N1YmplY3R9YF0uc29saWQkaW5zdGFuY2VcclxuICAgICAgICAgIGxldCBpYiA9IGF3YWl0IHNvbGlkLmRhdGFbYCR7aW5zdGFuY2V9YF0uYXMkaW5ib3hcclxuICAgICAgICAgIGxldCByZWNpcF9pbmJveCA9IGAke2lifWBcclxuICAgICAgICAgIGxldCBub3RpZmljYXRpb25fdXJpID0gcmVjaXBfaW5ib3grbm90aWZpY2F0aW9uX0lkK1wiLnR0bCN0aGlzXCJcclxuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhub3RpZmljYXRpb25fdXJpKVxyXG5cclxuICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbbm90aWZpY2F0aW9uX3VyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjdHlwZSddLmFkZChuYW1lZE5vZGUoJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjQ3JlYXRlJykpXHJcbiAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW25vdGlmaWNhdGlvbl91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI2F0dHJpYnV0ZWRUbyddLmFkZChuYW1lZE5vZGUoYXBwLmNvbmZpZy53ZWJJZCkpXHJcbiAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW25vdGlmaWNhdGlvbl91cmldWydodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI3N1bW1hcnknXS5hZGQodGl0bGUpXHJcbiAgICAgICAgICBhd2FpdCBzb2xpZC5kYXRhW25vdGlmaWNhdGlvbl91cmldLnJkZnMkbGFiZWwuYWRkKHRpdGxlKVxyXG4gICAgICAgICAgYXdhaXQgc29saWQuZGF0YVtub3RpZmljYXRpb25fdXJpXVsnaHR0cHM6Ly93d3cudzMub3JnL25zL2FjdGl2aXR5c3RyZWFtcyNwdWJsaXNoZWQnXS5hZGQoZGF0ZSlcclxuICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbbm90aWZpY2F0aW9uX3VyaV1bJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjbGluayddLmFkZChuYW1lZE5vZGUoYWN0aXZpdHlfdXJpKSlcclxuICAgICAgICAgIGFwcC5sb2cgPSBub3RpZmljYXRpb25fdXJpKyBcIkRPTkVcIlxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGluc3RhbmNlVHJvdXZlZSA9PSBmYWxzZSA/IGFsZXJ0KFwiTm8gQWdvcmEgSW5zdGFuY2UgZm91bmQgaW4gXCIrdG8rXCIgUHVibGljIFR5cGUgSW5kZXggXCIpIDogXCJcIjtcclxuICB9KTtcclxuICB0aGlzLmxvZyA9IFwiU2VuZCBPS1wiXHJcbiAgdGhpcy50b2dnbGVXcml0ZSgpXHJcbn1cclxuXHJcblxyXG5hc3luYyBzZXRBY2wobywgYWNsU3RyaW5nV2ViSWRzLCBhZ29yYV9wdWIpe1xyXG4gIHRoaXMubG9nID0gXCJTZXQgQUNMIGZvciBcIixvLmZpbGVcclxuICBsZXQgYWNsU3RyaW5nID0gYFxyXG4gIEBwcmVmaXggOiA8Iz4uXHJcbiAgQHByZWZpeCBhY2w6IDxodHRwOi8vd3d3LnczLm9yZy9ucy9hdXRoL2FjbCM+LlxyXG4gIEBwcmVmaXggYzogPC9wcm9maWxlL2NhcmQjPi5cclxuXHJcbiAgOkNvbnRyb2xSZWFkV3JpdGVcclxuICBhIGFjbDpBdXRob3JpemF0aW9uO1xyXG4gIGFjbDphY2Nlc3NUbyA8JHtvLmZpbGV9PjtcclxuICBhY2w6YWdlbnQgYzptZTtcclxuICBhY2w6bW9kZSBhY2w6Q29udHJvbCwgYWNsOlJlYWQsIGFjbDpXcml0ZS5cclxuICA6UmVhZFxyXG4gIGEgYWNsOkF1dGhvcml6YXRpb247XHJcbiAgYWNsOmFjY2Vzc1RvIDwke28uZmlsZX0+O1xyXG4gICR7YWNsU3RyaW5nV2ViSWRzLmxlbmd0aCA+IDAgPyAgIGAgYWNsOmFnZW50ICR7YWNsU3RyaW5nV2ViSWRzfTtgICA6IFwiXCIgfVxyXG4gICR7YWdvcmFfcHViID09IHRydWUgPyAgIFwiYWNsOmFnZW50Q2xhc3MgPGh0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvQWdlbnQ+IDtcIiA6IFwiXCJ9XHJcbiAgYWNsOm1vZGUgYWNsOlJlYWQuYFxyXG5cclxuICBjb25zb2xlLmxvZyhhY2xTdHJpbmcpXHJcbiAgdHJ5e1xyXG4gICAgYXdhaXQgdGhpcy5maWxlQ2xpZW50LmNyZWF0ZUZpbGUgKG8uZmlsZSsnLmFjbCcsIGFjbFN0cmluZywgXCJ0ZXh0L3R1cnRsZVwiKVxyXG4gICAgdGhpcy5sb2cgPSBvLmZpbGUrJy5hY2wgQ3JlYXRlZCdcclxuICB9Y2F0Y2goZSl7XHJcbiAgICBhbGVydChlKVxyXG4gIH1cclxufVxyXG5cclxuLypcclxuYXN5bmMgc2VuZEZpbGUodXJpLCBmaWxlLCBjb250ZW50VHlwZSl7XHJcbmF3YWl0IHRoaXMuZmlsZUNsaWVudC5jcmVhdGVGaWxlKHVyaSwgZmlsZSwgY29udGVudFR5cGUpXHJcbi50aGVuKFxyXG5zdWNjZXNzID0+e1xyXG5jb25zb2xlLmxvZyhzdWNjZXNzKVxyXG4vLyAgdGhpcy5hZ2VudC5zZW5kKFwiTWVzc2FnZXNcIiwge2FjdGlvbjogXCJpbmZvXCIsIHN0YXR1czogXCJTYXZlIGZpbGUgT0tcIiwgZmlsZTogc3VjY2Vzc30pXHJcbn0sXHJcbmVyciA9PiB7XHJcbmNvbnNvbGUubG9nKGVycilcclxufSk7XHJcbn0qL1xyXG5cclxuYXN5bmMgcHJlcGFyZVBvc3QyKCl7XHJcbiAgdmFyIGFwcCA9IHRoaXNcclxuICBjb25zb2xlLmxvZyh0aGlzLnJlc3BvbnNlcylcclxuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkpXHJcbiAgdmFyIGlkID0gZGF0ZS5nZXRUaW1lKClcclxuICB2YXIgdGl0bGUgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3RpdGxlJykudmFsdWUudHJpbSgpO1xyXG4gIHZhciB0YWdzID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0YWdzJykudmFsdWUuc3BsaXQoJywnKTtcclxuICB2YXIgYWdvcmFfcHViID0gYXBwLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2Fnb3JhX3B1YicpLmNoZWNrZWRcclxuICB2YXIgaW5SZXBseVRvID0gbnVsbDtcclxuICBpZiAodGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdyZXBseScpICE9IG51bGwpe1xyXG4gICAgaW5SZXBseVRvID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdyZXBseScpLnZhbHVlLnRyaW0oKTtcclxuICB9XHJcbiAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0aXRsZScpLnZhbHVlID0gXCJcIlxyXG4gIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndGFncycpLnZhbHVlID0gXCJcIlxyXG4gIHRoaXMuc3RvcmFnZSA9IGF3YWl0IHNvbGlkLmRhdGEudXNlci5zdG9yYWdlXHJcbiAgdmFyIHVzZXJBY3Rpdml0eSA9IHRoaXMuc3RvcmFnZStcInB1YmxpYy9zcG9nZ3kvYWN0aXZpdHkudHRsI1wiK2lkXHJcbiAgY29uc29sZS5sb2coXCJDcmVhdGlvbiBcIiwgdXNlckFjdGl2aXR5KVxyXG4gIGF3YWl0IHNvbGlkLmRhdGFbdXNlckFjdGl2aXR5XS5hcyRuYW1lLnNldCh0aXRsZSlcclxuICBhd2FpdCBzb2xpZC5kYXRhW3VzZXJBY3Rpdml0eV0ucmRmcyRsYWJlbC5zZXQodGl0bGUpXHJcbiAgYXdhaXQgc29saWQuZGF0YVt1c2VyQWN0aXZpdHldLnNjaGVtYSRkYXRlQ3JlYXRlZC5zZXQoZGF0ZS50b0lTT1N0cmluZygpKVxyXG4gIGF3YWl0IHNvbGlkLmRhdGFbdXNlckFjdGl2aXR5XS5yZGYkdHlwZS5hZGQobmFtZWROb2RlKCdodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI0NyZWF0ZScpKVxyXG4gIGluUmVwbHlUbyE9IG51bGwgJiYgaW5SZXBseVRvLmxlbmd0aCA+IDAgPyBhd2FpdCBzb2xpZC5kYXRhW3VzZXJBY3Rpdml0eV0uYXMkaW5SZXBseVRvLmFkZChuYW1lZE5vZGUoaW5SZXBseVRvKSkgOiBcIlwiO1xyXG5cclxuICBpZiAoYWdvcmFfcHViID09IHRydWUpe1xyXG4gICAgdmFyIGFnb3JhQWN0aXZpdHkgPSBcImh0dHBzOi8vYWdvcmEuc29saWQuY29tbXVuaXR5L3B1YmxpYy9zcG9nZ3kvYWN0aXZpdHkudHRsI1wiK2lkXHJcbiAgICBhd2FpdCBzb2xpZC5kYXRhW2Fnb3JhQWN0aXZpdHldLmFzJG5hbWUuYWRkKHRpdGxlKVxyXG4gICAgYXdhaXQgc29saWQuZGF0YVthZ29yYUFjdGl2aXR5XS5yZGZzJGxhYmVsLmFkZCh0aXRsZSlcclxuICAgIGF3YWl0IHNvbGlkLmRhdGFbYWdvcmFBY3Rpdml0eV0uc2NoZW1hJGRhdGVDcmVhdGVkLmFkZChkYXRlLnRvSVNPU3RyaW5nKCkpXHJcbiAgICBhd2FpdCBzb2xpZC5kYXRhW2Fnb3JhQWN0aXZpdHldLnJkZiR0eXBlLmFkZChuYW1lZE5vZGUoJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjQ3JlYXRlJykpXHJcbiAgICBhd2FpdCBzb2xpZC5kYXRhW2Fnb3JhQWN0aXZpdHldLmFzJGFjdG9yLmFkZChuYW1lZE5vZGUoYXBwLndlYklkKSlcclxuICAgIGF3YWl0IHNvbGlkLmRhdGFbYWdvcmFBY3Rpdml0eV0uYXMkdGFyZ2V0LmFkZChuYW1lZE5vZGUodXNlckFjdGl2aXR5KSlcclxuICAgIGluUmVwbHlUbyE9IG51bGwgJiYgIGluUmVwbHlUby5sZW5ndGggPiAwID8gYXdhaXQgc29saWQuZGF0YVthZ29yYUFjdGl2aXR5XS5hcyRpblJlcGx5VG8uYWRkKG5hbWVkTm9kZShpblJlcGx5VG8pKSA6IFwiXCI7XHJcbiAgfVxyXG5cclxuICB0aGlzLnJlc3BvbnNlcy5mb3JFYWNoKGFzeW5jIGZ1bmN0aW9uKHIpe1xyXG4gICAgc3dpdGNoIChyLm1lc3NhZ2UudHlwZSkge1xyXG4gICAgICBjYXNlIFwiTm90ZVwiOlxyXG4gICAgICBpZiAoci5tZXNzYWdlLmNvbnRlbnQubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgdmFyIHVzZXJOb3RlID0gYXBwLnN0b3JhZ2UrXCJwdWJsaWMvTm90ZXMvXCIraWQrXCIudHRsXCJcclxuICAgICAgICB2YXIgY29udGVudCA9IHIubWVzc2FnZS5jb250ZW50XHJcbiAgICAgICAgYXdhaXQgc29saWQuZGF0YVt1c2VyTm90ZV0uc2NoZW1hJHRleHQuYWRkKGNvbnRlbnQpO1xyXG4gICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbdXNlck5vdGVdLnJkZiR0eXBlLmFkZChuYW1lZE5vZGUoJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjTm90ZScpKVxyXG4gICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbdXNlckFjdGl2aXR5XS5zY2hlbWEkdGV4dC5hZGQoY29udGVudCk7XHJcbiAgICAgICAgYXdhaXQgc29saWQuZGF0YVt1c2VyQWN0aXZpdHldLmFzJG9iamVjdC5hZGQobmFtZWROb2RlKHVzZXJOb3RlKSlcclxuXHJcbiAgICAgICAgaWYgKGFnb3JhX3B1YiA9PSB0cnVlKXtcclxuICAgICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbYWdvcmFBY3Rpdml0eV0uc2NoZW1hJHRleHQuYWRkKGNvbnRlbnQpO1xyXG4gICAgICAgICAgYXdhaXQgc29saWQuZGF0YVthZ29yYUFjdGl2aXR5XS5hcyRvYmplY3QuYWRkKG5hbWVkTm9kZSh1c2VyTm90ZSkpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiSW1hZ2VcIjpcclxuICAgICAgY2FzZSBcIlZpZGVvXCI6XHJcbiAgICAgIGNhc2UgXCJBdWRpb1wiOlxyXG4gICAgICBjYXNlIFwiRG9jdW1lbnRcIjpcclxuICAgICAgaWYoci5tZXNzYWdlLmNvbnRlbnQgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICB2YXIgZmlsZSA9IHIubWVzc2FnZS5jb250ZW50XHJcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gZmlsZS5jb250ZW50VHlwZVxyXG4gICAgICAgIHZhciBuZXdGaWxlbmFtZSA9IHIubWVzc2FnZS5uZXdGaWxlbmFtZVxyXG4gICAgICAgIHZhciBjbGFzc2UgPSByLm1lc3NhZ2UudHlwZVxyXG4gICAgICAgIHZhciB1c2VyTWVkaWEgPSBhcHAuc3RvcmFnZStcInB1YmxpYy9zcG9nZ3kvXCIrY2xhc3NlK1wiL1wiK25ld0ZpbGVuYW1lXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJjcmVhdGlvbiBcIix1c2VyTWVkaWEpXHJcbiAgICAgICAgYXdhaXQgYXBwLnNlbmRGaWxlKHVzZXJNZWRpYSwgZmlsZSwgY29udGVudFR5cGUpXHJcbiAgICAgICAgYXdhaXQgIHNvbGlkLmRhdGFbdXNlckFjdGl2aXR5XS5hcyRvYmplY3QuYWRkKG5hbWVkTm9kZSh1c2VyTWVkaWEpKVxyXG4gICAgICAgIGF3YWl0ICBzb2xpZC5kYXRhW2Fnb3JhQWN0aXZpdHldLmFzJG9iamVjdC5hZGQobmFtZWROb2RlKHVzZXJNZWRpYSkpXHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJUcmlwbGVcIjpcclxuICAgICAgaWYoci5tZXNzYWdlLmNvbnRlbnQubGVuZ3RoID4wKXtcclxuICAgICAgICBjb250ZW50ID0gci5tZXNzYWdlLmNvbnRlbnRcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgY29uc29sZS5sb2coci5tZXNzYWdlLnR5cGUgLCBcIm5vbiB0cmFpdGVcIilcclxuICAgIH1cclxuICB9KVxyXG4gIHRoaXMucmVzcG9uc2VzID0gW11cclxufVxyXG5cclxuYXN5bmMgcHJlcGFyZVBvc3QxKCl7XHJcbiAgdmFyIGFwcCA9IHRoaXNcclxuICAvLyAgYXBwLndlYklkID0gdGhpcy5waC5nZXRQb2QoXCJ3ZWJJZFwiKVxyXG4gIC8vICBjb25zb2xlLmxvZyh0aGlzLndlYklkKVxyXG4gIGNvbnNvbGUubG9nKHRoaXMucmVzcG9uc2VzKVxyXG4gIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSlcclxuICB2YXIgaWQgPSBkYXRlLmdldFRpbWUoKVxyXG4gIHZhciB0aXRsZSA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndGl0bGUnKS52YWx1ZS50cmltKCk7XHJcbiAgdmFyIHRhZ3MgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3RhZ3MnKS52YWx1ZS5zcGxpdCgnLCcpO1xyXG4gIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndGl0bGUnKS52YWx1ZSA9IFwiXCJcclxuICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ3RhZ3MnKS52YWx1ZSA9IFwiXCJcclxuICB0aGlzLnN0b3JhZ2UgPSBhd2FpdCBzb2xpZC5kYXRhLnVzZXIuc3RvcmFnZVxyXG5cclxuXHJcbiAgdmFyIHVzZXJBY3Rpdml0eSA9IHRoaXMuc3RvcmFnZStcInB1YmxpYy9zcG9nZ3kvYWN0aXZpdHkudHRsI1wiK2lkXHJcbiAgY29uc29sZS5sb2coXCJDcmVhdGlvbiBcIiwgdXNlckFjdGl2aXR5KVxyXG4gIGF3YWl0ICBzb2xpZC5kYXRhW3VzZXJBY3Rpdml0eV0ucmRmcyRsYWJlbC5hZGQodGl0bGUpXHJcbiAgYXdhaXQgIHNvbGlkLmRhdGFbdXNlckFjdGl2aXR5XS5zY2hlbWEkZGF0ZUNyZWF0ZWQuYWRkKGRhdGUudG9JU09TdHJpbmcoKSlcclxuXHJcbiAgYXdhaXQgc29saWQuZGF0YVt1c2VyQWN0aXZpdHldLmFzJG5hbWUuYWRkKHRpdGxlKVxyXG4gIGF3YWl0IHNvbGlkLmRhdGFbdXNlckFjdGl2aXR5XS5hcyRnZW5lcmF0b3IuYWRkKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pXHJcbiAgYXdhaXQgc29saWQuZGF0YVt1c2VyQWN0aXZpdHldLnJkZiR0eXBlLmFkZChuYW1lZE5vZGUoJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjQ3JlYXRlJykpXHJcbiAgY29uc29sZS5sb2codXNlckFjdGl2aXR5KyBcIiAtLSA+Y3JlYXRlZFwiKVxyXG4gIGF3YWl0IHNvbGlkLmRhdGFbYXBwLnN0b3JhZ2UrXCJwdWJsaWMvc3BvZ2d5L3RhZ3MudHRsXCJdLnJkZnMkbGFiZWwuYWRkKFwiVGFnc1wiKVxyXG5cclxuICB2YXIgYWdvcmFfcHViID0gYXBwLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2Fnb3JhX3B1YicpLmNoZWNrZWRcclxuICBpZiAoYWdvcmFfcHViID09IHRydWUpe1xyXG4gICAgY29uc29sZS5sb2coXCJDcmVhdGlvbiBcIiwgdXNlckFjdGl2aXR5KVxyXG4gICAgdmFyIGFnb3JhQWN0aXZpdHkgPSBcImh0dHBzOi8vYWdvcmEuc29saWQuY29tbXVuaXR5L3B1YmxpYy9zcG9nZ3kvYWN0aXZpdHkudHRsI1wiK2lkXHJcbiAgICBhd2FpdCBzb2xpZC5kYXRhW2Fnb3JhQWN0aXZpdHldLnNjaGVtYSRkYXRlQ3JlYXRlZC5hZGQoZGF0ZS50b0lTT1N0cmluZygpKVxyXG4gICAgYXdhaXQgc29saWQuZGF0YVthZ29yYUFjdGl2aXR5XS5yZGZzJGxhYmVsLmFkZCh0aXRsZSlcclxuICAgIGF3YWl0IHNvbGlkLmRhdGFbYWdvcmFBY3Rpdml0eV0uYXMkbmFtZS5hZGQodGl0bGUpXHJcbiAgICBhd2FpdCBzb2xpZC5kYXRhW2Fnb3JhQWN0aXZpdHldLmFzJHRhcmdldC5hZGQobmFtZWROb2RlKHVzZXJBY3Rpdml0eSkpXHJcbiAgICBhd2FpdCBzb2xpZC5kYXRhW2Fnb3JhQWN0aXZpdHldLnJkZiR0eXBlLmFkZChuYW1lZE5vZGUoJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjQWRkJykpXHJcbiAgICBhd2FpdCBzb2xpZC5kYXRhW2Fnb3JhQWN0aXZpdHldLnNjaGVtYSRjcmVhdG9yLmFkZChuYW1lZE5vZGUoYXBwLndlYklkKSlcclxuICAgIGF3YWl0IHNvbGlkLmRhdGFbYWdvcmFBY3Rpdml0eV0uYXMkYWN0b3IuYWRkKG5hbWVkTm9kZShhcHAud2ViSWQpKVxyXG4gICAgY29uc29sZS5sb2coYWdvcmFBY3Rpdml0eSsgXCIgLS0gPmNyZWF0ZWRcIilcclxuICB9XHJcblxyXG4gIHRhZ3MuZm9yRWFjaChhc3luYyBmdW5jdGlvbih0KXtcclxuICAgIHZhciB0YWd1cmkgPSBhcHAuc3RvcmFnZStcInB1YmxpYy9zcG9nZ3kvdGFncy50dGwjXCIrdC50cmltKCk7XHJcbiAgICBhd2FpdCAgc29saWQuZGF0YVt1c2VyQWN0aXZpdHldLmFzJHRhZy5hZGQobmFtZWROb2RlKHRhZ3VyaSkpXHJcbiAgICAvLyAgICBjb25zb2xlLmxvZyh0YWd1cmkrIFwiIC0tID5jcmVhdGVkXCIpXHJcbiAgfSlcclxuXHJcbiAgLy8gIHZhciBwYXRoID0gdGhpcy5zdG9yYWdlK1wicHVibGljL05vdGVzL1wiK2lkK1wiLnR0bFwiXHJcbiAgLy8gIGNvbnNvbGUubG9nKGRhdGEpXHJcbiAgLy8gIHZhciB0aXQgPSBhd2FpdCAgc29saWQuZGF0YVtwYXRoXS5yZGZzJGxhYmVsLmFkZChcInRpdGxlIE9ORVwiKVxyXG4gIC8vICB2YXIgY29udCA9IGF3YWl0IHNvbGlkLmRhdGFbcGF0aF0uc2NoZW1hJHRleHQuYWRkKFwiY29udGVudCBPTkVcIik7XHJcblxyXG5cclxuICB0aGlzLnJlc3BvbnNlcy5mb3JFYWNoKGFzeW5jIGZ1bmN0aW9uKHIpe1xyXG4gICAgc3dpdGNoIChyLm1lc3NhZ2UudHlwZSkge1xyXG4gICAgICBjYXNlIFwiTm90ZVwiOlxyXG4gICAgICB2YXIgdXNlck5vdGUgPSBhcHAuc3RvcmFnZStcInB1YmxpYy9zcG9nZ3kvTm90ZXMvXCIraWQrXCIudHRsXCJcclxuICAgICAgdmFyIGNvbnRlbnQgPSByLm1lc3NhZ2UuY29udGVudFxyXG4gICAgICBhd2FpdCBzb2xpZC5kYXRhW3VzZXJOb3RlXS5yZGZzJGxhYmVsLmFkZCh0aXRsZSlcclxuICAgICAgYXdhaXQgc29saWQuZGF0YVt1c2VyTm90ZV0uc2NoZW1hJHRleHQuYWRkKGNvbnRlbnQpO1xyXG4gICAgICBhd2FpdCBzb2xpZC5kYXRhW3VzZXJOb3RlXS5yZGYkdHlwZS5hZGQobmFtZWROb2RlKCdodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI05vdGUnKSlcclxuICAgICAgLy8hISEgYXMkTm90ZSBuZSBmb25jdGlvbm5lIHBhc1xyXG4gICAgICBhd2FpdCAgc29saWQuZGF0YVt1c2VyQWN0aXZpdHldLmFzJGF0dGFjaG1lbnQuYWRkKG5hbWVkTm9kZSh1c2VyTm90ZSkpXHJcbiAgICAgIGF3YWl0IHNvbGlkLmRhdGFbdXNlckFjdGl2aXR5XS5zY2hlbWEkdGV4dC5hZGQoY29udGVudCk7XHJcblxyXG4gICAgICB2YXIgYWdvcmFfcHViID0gYXBwLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2Fnb3JhX3B1YicpLmNoZWNrZWRcclxuICAgICAgaWYgKGFnb3JhX3B1YiA9PSB0cnVlKXtcclxuICAgICAgICAvLyEhISBhcyROb3RlIG5lIGZvbmN0aW9ubmUgcGFzXHJcbiAgICAgICAgYXdhaXQgIHNvbGlkLmRhdGFbYWdvcmFBY3Rpdml0eV0uYXMkb2JqZWN0LmFkZChuYW1lZE5vZGUodXNlck5vdGUpKVxyXG4gICAgICAgIGF3YWl0IHNvbGlkLmRhdGFbYWdvcmFBY3Rpdml0eV0uc2NoZW1hJHRleHQuYWRkKGNvbnRlbnQpO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJJbWFnZVwiOlxyXG4gICAgICBjYXNlIFwiVmlkZW9cIjpcclxuICAgICAgY2FzZSBcIkF1ZGlvXCI6XHJcbiAgICAgIGNhc2UgXCJEb2N1bWVudFwiOlxyXG4gICAgICBpZihyLm1lc3NhZ2UuY29udGVudCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHZhciBmaWxlID0gci5tZXNzYWdlLmNvbnRlbnRcclxuICAgICAgICB2YXIgY29udGVudFR5cGUgPSBmaWxlLmNvbnRlbnRUeXBlXHJcbiAgICAgICAgdmFyIG5ld0ZpbGVuYW1lID0gci5tZXNzYWdlLm5ld0ZpbGVuYW1lXHJcbiAgICAgICAgdmFyIGNsYXNzZSA9IHIubWVzc2FnZS50eXBlXHJcbiAgICAgICAgdmFyIHVzZXJNZWRpYSA9IGFwcC5zdG9yYWdlK1wicHVibGljL3Nwb2dneS9cIitjbGFzc2UrXCIvXCIrbmV3RmlsZW5hbWVcclxuICAgICAgICBjb25zb2xlLmxvZyhcImNyZWF0aW9uIFwiLHVzZXJNZWRpYSlcclxuICAgICAgICBhd2FpdCBhcHAuc2VuZEZpbGUodXNlck1lZGlhLCBmaWxlLCBjb250ZW50VHlwZSlcclxuICAgICAgICBhd2FpdCAgc29saWQuZGF0YVt1c2VyQWN0aXZpdHldLmFzJGF0dGFjaG1lbnQuYWRkKG5hbWVkTm9kZSh1c2VyTWVkaWEpKVxyXG4gICAgICAgIGlmIChhZ29yYV9wdWIgPT0gdHJ1ZSl7XHJcbiAgICAgICAgICAvLyEhISBhcyROb3RlIG5lIGZvbmN0aW9ubmUgcGFzXHJcbiAgICAgICAgICBhd2FpdCAgc29saWQuZGF0YVthZ29yYUFjdGl2aXR5XS5hcyRvYmplY3QuYWRkKG5hbWVkTm9kZSh1c2VyTWVkaWEpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgIGNvbnNvbGUubG9nKHIubWVzc2FnZS50eXBlICwgXCJub24gdHJhaXRlXCIpXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgYXdhaXQgc29saWQuZGF0YVthcHAuc3RvcmFnZStcInB1YmxpYy9zcG9nZ3kvdGFncy50dGxcIl0ucmRmcyRsYWJlbC5hZGQoXCJUYWdzXCIpXHJcbiAgdGFncy5mb3JFYWNoKGFzeW5jIGZ1bmN0aW9uKHQpe1xyXG4gICAgdmFyIHRhZ3VyaSA9IGFwcC5zdG9yYWdlK1wicHVibGljL3Nwb2dneS90YWdzLnR0bCNcIit0LnRyaW0oKTtcclxuICAgIGF3YWl0ICBzb2xpZC5kYXRhW3VzZXJBY3Rpdml0eV0uYXMkdGFnLmFkZChuYW1lZE5vZGUodGFndXJpKSlcclxuICAgIC8vICAgIGNvbnNvbGUubG9nKHRhZ3VyaSsgXCIgLS0gPmNyZWF0ZWRcIilcclxuICB9KVxyXG5cclxuICB0aGlzLnJlc3BvbnNlcyA9IFtdXHJcbiAgLy8gIHRoaXMudXBkYXRlUG9kKGRhdGEpXHJcblxyXG59XHJcblxyXG5cclxuXHJcbnNlbmRGaWxlKHVyaSwgZmlsZSwgY29udGVudFR5cGUpe1xyXG4gIHRoaXMuZmlsZUNsaWVudC5jcmVhdGVGaWxlKHVyaSwgZmlsZSwgY29udGVudFR5cGUpXHJcbiAgLnRoZW4oXHJcbiAgICBzdWNjZXNzID0+e1xyXG4gICAgICBjb25zb2xlLmxvZyhzdWNjZXNzKVxyXG4gICAgICAvLyAgdGhpcy5hZ2VudC5zZW5kKFwiTWVzc2FnZXNcIiwge2FjdGlvbjogXCJpbmZvXCIsIHN0YXR1czogXCJTYXZlIGZpbGUgT0tcIiwgZmlsZTogc3VjY2Vzc30pXHJcbiAgICB9LFxyXG4gICAgZXJyID0+IHtcclxuICAgICAgY29uc29sZS5sb2coZXJyKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdwb3N0LXRhYnMtZWxlbWVudCcsIFBvc3RUYWJzRWxlbWVudCk7XHJcbiIsIi8vaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vRXJpa0hlbGxtYW4vOWUxN2YyZWE2YTc4NjY5Mjk0ZWYyYWY0YmMzZjU4NzhcclxuLy9odHRwczovL3ZhYWRpbi5jb20vbGVhcm4vdHV0b3JpYWxzL2xpdC1lbGVtZW50L2xpdC1lbGVtZW50LXRlbXBsYXRpbmctcHJvcGVydGllcy1hbmQtZXZlbnRzXHJcbmltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XHJcbmltcG9ydCB7IGNsYXNzTWFwIH0gZnJvbSAnbGl0LWh0bWwvZGlyZWN0aXZlcy9jbGFzcy1tYXAnXHJcblxyXG5pbXBvcnQgICcuL3Bvc3QtdGFicy1lbGVtZW50LmpzJztcclxuXHJcbmNsYXNzIFBvc3REaWFsb2dFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9wZW5lZDoge3R5cGU6IEJvb2xlYW59LFxyXG4gICAgICBzaGFyZToge3R5cGU6IE9iamVjdH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yICgpIHtcclxuICAgIHN1cGVyKClcclxuICAgIHRoaXMub3BlbmVkID0gZmFsc2VcclxuICAgIHRoaXMuc2hhcmUgPSB7fVxyXG4gIH1cclxuXHJcbiAgcmVuZGVyICgpIHtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPHN0eWxlPlxyXG5cclxuICAgIC8qIFRoZSBNb2RhbCAoYmFja2dyb3VuZCkgKi9cclxuICAgIC5tb2RhbCB7XHJcbiAgICAgIGRpc3BsYXk6IG5vbmU7IC8qIEhpZGRlbiBieSBkZWZhdWx0ICovXHJcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDsgLyogU3RheSBpbiBwbGFjZSAqL1xyXG4gICAgICB6LWluZGV4OiAxMDUwOyAvKiBTaXQgb24gdG9wICovXHJcbiAgICAgIHBhZGRpbmctdG9wOiAxMDBweDsgLyogTG9jYXRpb24gb2YgdGhlIGJveCAqL1xyXG4gICAgICBsZWZ0OiAtMTZweDtcclxuICAgICAgdG9wOiAtMTZweDtcclxuICAgICAgd2lkdGg6IDEwMCU7IC8qIEZ1bGwgd2lkdGggKi9cclxuICAgICAgaGVpZ2h0OiAxMDAlOyAvKiBGdWxsIGhlaWdodCAqL1xyXG4gICAgICBvdmVyZmxvdzogYXV0bzsgLyogRW5hYmxlIHNjcm9sbCBpZiBuZWVkZWQgKi9cclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAsMCwwKTsgLyogRmFsbGJhY2sgY29sb3IgKi9cclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDAsMCwwLjQpOyAvKiBCbGFjayB3LyBvcGFjaXR5ICovXHJcbiAgICB9XHJcbiAgICAvKiBNb2RhbCBDb250ZW50ICovXHJcbiAgICAubW9kYWwtY29udGVudCB7XHJcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZWZlZmU7XHJcbiAgICAgIG1hcmdpbjogYXV0bztcclxuICAgICAgcGFkZGluZzogMjBweDtcclxuICAgICAgYm9yZGVyOiAxcHggc29saWQgIzg4ODtcclxuICAgICAgd2lkdGg6IDgwJTtcclxuICAgICAgbWluLXdpZHRoOiAzMjBweFxyXG4gICAgfVxyXG4gICAgLmNvbnRlbnR7XHJcbiAgICAgIG92ZXJmbG93ID0gJ2F1dG8nO1xyXG4gICAgICBtYXhIZWlnaHQgPSAnMTAwcHgnXHJcbiAgICB9XHJcblxyXG4gICAgLyogVGhlIENsb3NlIEJ1dHRvbiAqL1xyXG4gICAgLmNsb3NlIHtcclxuICAgICAgY29sb3I6ICNhYWFhYWE7XHJcbiAgICAgIGZsb2F0OiByaWdodDtcclxuICAgICAgZm9udC1zaXplOiAyOHB4O1xyXG4gICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgIH1cclxuXHJcbiAgICAuY2xvc2U6aG92ZXIsXHJcbiAgICAuY2xvc2U6Zm9jdXMge1xyXG4gICAgICBjb2xvcjogIzAwMDtcclxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLm9wZW5lZCB7XHJcbiAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICB9XHJcbiAgICAuY2xvc2VkIHtcclxuICAgICAgZGlzcGxheTogbm9uZTtcclxuICAgIH1cclxuICAgIC5kaWFsb2cge1xyXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgICBib3JkZXI6IDJweCBvdXRzZXQgYmxhY2s7XHJcbiAgICAgIHBhZGRpbmc6IDFlbTtcclxuICAgICAgbWFyZ2luOiAxZW07XHJcbiAgICB9XHJcbiAgICAuYnV0dG9ucyB7XHJcbiAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XHJcbiAgICB9XHJcbiAgICAuYWNjZXB0IHtcclxuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XHJcbiAgICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcclxuICAgIH1cclxuICAgIC5jYW5jZWwge1xyXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcclxuICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kO1xyXG4gICAgfVxyXG5cclxuICAgIEBtZWRpYShtYXgtd2lkdGg6NzY3cHgpe1xyXG4gICAgICAuZGlhbG9nIHtcclxuICAgICAgICBwYWRkaW5nOiAwZW07XHJcbiAgICAgIH1cclxuICAgICAgLm1vZGFsLWNvbnRlbnQge1xyXG4gICAgICAgIHBhZGRpbmctdG9wOiAyMHB4O1xyXG4gICAgICAgIHBhZGRpbmctYm90dG9tOiAyMHB4O1xyXG4gICAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICA8L3N0eWxlPlxyXG5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiJHtjbGFzc01hcCh7ZGlhbG9nOiB0cnVlLCBvcGVuZWQ6IHRoaXMub3BlbmVkLCBjbG9zZWQ6ICF0aGlzLm9wZW5lZCwgbW9kYWw6IHRydWV9KX1cIj5cclxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+XHJcbiAgICA8aDYgY2xhc3M9XCJtLTAgZm9udC13ZWlnaHQtYm9sZCB0ZXh0LXByaW1hcnkgdGl0bGVcIj5OZXcgU3BvZ1xyXG4gICAgPGkgQGNsaWNrPVwiJHsoKSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkaWFsb2cuY2FuY2VsJykpfVwiIGNsYXNzPVwiY2xvc2UgZmFzIGZhLXdpbmRvdy1jbG9zZVwiPjwvaT5cclxuICAgIDwvaDY+XHJcbiAgICA8ZGl2PlxyXG4gICAgPHBvc3QtdGFicy1lbGVtZW50IG5hbWU9XCJQb3N0VGFic1wiIC5zaGFyZT1cIiR7dGhpcy5zaGFyZX1cIj48L3Bvc3QtdGFicy1lbGVtZW50PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDwvZGl2PmBcclxuICB9XHJcbn1cclxuXHJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgncG9zdC1kaWFsb2ctZWxlbWVudCcsIFBvc3REaWFsb2dFbGVtZW50KVxyXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcclxuXHJcbmltcG9ydCAgJy4vcG9zdC1kaWFsb2ctZWxlbWVudC5qcyc7IC8vaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vRXJpa0hlbGxtYW4vOWUxN2YyZWE2YTc4NjY5Mjk0ZWYyYWY0YmMzZjU4NzhcclxuXHJcbmNsYXNzIFBvc3RFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XHJcblxyXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcyAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgZGlhbG9nVmlzaWJsZToge3R5cGU6IEJvb2xlYW59LFxyXG4gICAgICB3ZWJJZDoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIHNoYXJlOiB7dHlwZTogT2JqZWN0fVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgdGhpcy5kaWFsb2dWaXNpYmxlID0gZmFsc2VcclxuICAgIHRoaXMud2ViSWQgPSBudWxsXHJcbiAgICB0aGlzLnNoYXJlID0ge31cclxuICB9XHJcblxyXG4gIHJlbmRlciAoKSB7XHJcbiAgICBjb25zb2xlLmxvZygnRGlhbG9nIHZpc2libGU6JywgdGhpcy5kaWFsb2dWaXNpYmxlKVxyXG4gICAgcmV0dXJuIGh0bWxgXHJcbiAgICA8bGluayBocmVmPVwiY3NzL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICA8bGluayBocmVmPVwiY3NzL29mZmNhbnZhcy5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcblxyXG4gICAgJHt0aGlzLndlYklkICE9IG51bGwgP1xyXG4gICAgICBodG1sYFxyXG4gICAgICA8ZGl2PlxyXG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tc21cIiBAY2xpY2s9XCIke3RoaXMudG9nZ2xlRGlhbG9nLmJpbmQodGhpcyl9XCI+PGkgY2xhc3M9XCJmYSBmYS1wZW5cIj48L2k+PC9idXR0b24+XHJcbiAgICAgIDxwb3N0LWRpYWxvZy1lbGVtZW50ID9vcGVuZWQ9XCIke3RoaXMuZGlhbG9nVmlzaWJsZX1cIlxyXG4gICAgICBAZGlhbG9nLmFjY2VwdD1cIiR7dGhpcy5jbG9zZURpYWxvZy5iaW5kKHRoaXMpfVwiXHJcbiAgICAgIEBkaWFsb2cuY2FuY2VsPVwiJHt0aGlzLmNsb3NlRGlhbG9nLmJpbmQodGhpcyl9XCJcclxuICAgICAgLnNoYXJlPVwiJHt0aGlzLnNoYXJlfVwiPlxyXG4gICAgICA8L3Bvc3QtZGlhbG9nLWVsZW1lbnQ+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICBgXHJcbiAgICAgIDpodG1sYFxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tb3V0bGluZS1pbmZvXCI+XHJcbiAgICAgIFlvdSBtdXN0IGxvZ2luIHRvIHBvc3QgYSBzcG9nIVxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgYFxyXG5cclxuICAgIH1cclxuXHJcbiAgICBgXHJcbiAgfVxyXG5cclxuICB0b2dnbGVEaWFsb2cgKGUpIHtcclxuICAgIHRoaXMuZGlhbG9nVmlzaWJsZSA9ICF0aGlzLmRpYWxvZ1Zpc2libGVcclxuICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLmRpYWxvZ1Zpc2libGUpXHJcbiAgICB2YXIgbWVzc1JlcCA9IHthY3Rpb246XCJzZXRSZXBseVRvXCIgfVxyXG4gICAgdGhpcy5hZ2VudC5zZW5kKFwiUG9zdFRhYnNcIiwgbWVzc1JlcClcclxuICB9XHJcblxyXG4gIGNsb3NlRGlhbG9nIChlKSB7XHJcbiAgICAvLyAgY29uc29sZS5sb2coZSlcclxuICAgIHRoaXMuZGlhbG9nVmlzaWJsZSA9IGZhbHNlXHJcbiAgfVxyXG5cclxuXHJcblxyXG4gIGZpcnN0VXBkYXRlZCgpe1xyXG4gICAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgICB0aGlzLmFnZW50ID0gbmV3IEhlbGxvQWdlbnQodGhpcy5uYW1lKTtcclxuICAgIHRoaXMuYWdlbnQucmVjZWl2ZSA9IGZ1bmN0aW9uKGZyb20sIG1lc3NhZ2UpIHtcclxuICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgIHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xyXG4gICAgICAgICAgY2FzZSBcInRvZ2dsZVdyaXRlXCI6XHJcbiAgICAgICAgICBhcHAudG9nZ2xlV3JpdGUobWVzc2FnZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJ3ZWJJZENoYW5nZWRcIjpcclxuICAgICAgICAgIGFwcC53ZWJJZENoYW5nZWQobWVzc2FnZS53ZWJJZCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5zaGFyZS5zaG93ID09IHRydWUgPyB0aGlzLnRvZ2dsZVdyaXRlKCkgOiBcIlwiO1xyXG4gIH1cclxuXHJcbiAgdG9nZ2xlV3JpdGUobWVzc2FnZSl7XHJcbiAgICBjb25zb2xlLmxvZyhtZXNzYWdlKVxyXG4gICAgdGhpcy50b2dnbGVEaWFsb2cobWVzc2FnZSlcclxuICB9XHJcblxyXG4gIHdlYklkQ2hhbmdlZCh3ZWJJZCl7XHJcbiAgICB0aGlzLndlYklkID0gd2ViSWRcclxuICB9XHJcblxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3Bvc3QtZWxlbWVudCcsIFBvc3RFbGVtZW50KTtcclxuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcbi8vbGV0IGRhdGEgPSBzb2xpZC5kYXRhXHJcbi8vY29uc29sZS5sb2coXCJMREZLK0xFWFwiLGRhdGEpXHJcblxyXG5cclxuY2xhc3MgRnJpZW5kc1ZpZXcgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGZyaWVuZHM6IHt0eXBlOiBBcnJheX0sXHJcbiAgICAgIGZvbGxvd2Vyczoge3R5cGU6IEFycmF5fSxcclxuICAgICAgZm9sbG93aW5nOiB7dHlwZTogQXJyYXl9LFxyXG4gICAgICB0YWI6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBjb25maWc6IHt0eXBlOiBPYmplY3R9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJGcmllbmRzXCJcclxuICAgIHRoaXMuY29uZmlnID0ge31cclxuICAgIHRoaXMuZnJpZW5kcyA9IFtdXHJcbiAgICB0aGlzLmZvbGxvd2VycyA9IFtdXHJcbiAgICB0aGlzLmZvbGxvd2luZyA9IFtdXHJcbiAgICB0aGlzLnRhYiA9IFwiZnJpZW5kc1wiXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICA8bGluayBocmVmPVwiY3NzL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lci1mbHVpZFwiPlxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJjYXJkIHRleHQtY2VudGVyXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1oZWFkZXJcIj5cclxuICAgIDx1bCBjbGFzcz1cIm5hdiBuYXYtdGFicyBjYXJkLWhlYWRlci10YWJzXCI+XHJcbiAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiPlxyXG4gICAgPGEgY2xhc3M9XCJuYXYtbGluayBhY3RpdmVcIiB0YWI9XCJmcmllbmRzXCIgQGNsaWNrPVwiJHt0aGlzLm9wZW5UYWJ9XCIgaHJlZj1cIiNcIj5GcmllbmRzPC9hPlxyXG4gICAgPC9saT5cclxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XHJcbiAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgdGFiPVwiZm9sbG93aW5nXCIgQGNsaWNrPVwiJHt0aGlzLm9wZW5UYWJ9XCIgaHJlZj1cIiNcIj5Gb2xsb3dpbmc8L2E+XHJcbiAgICA8L2xpPlxyXG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIj5cclxuICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiB0YWI9XCJmb2xsb3dlcnNcIiBAY2xpY2s9XCIke3RoaXMub3BlblRhYn1cIiBocmVmPVwiI1wiPkZvbGxvd2VyczwvYT5cclxuICAgIDwvbGk+XHJcbiAgICA8L3VsPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPGRpdiBzdHlsZT1cIm92ZXJmbG93LXk6c2Nyb2xsO3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDogODB3aDtcIj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1kZWNrXCIgP2hpZGRlbj1cIiR7dGhpcy50YWIgIT0gXCJmcmllbmRzXCJ9XCI+XHJcbiAgICAke3RoaXMuZnJpZW5kcy5tYXAoKGYsIGkpID0+IGh0bWxgXHJcbiAgICAgIDxmcmllbmQtdmlldyBuYW1lPVwiJHtcIkZyaWVuZF9cIitpfVwiIGZfd2ViSWQ9JHtmfT5Mb2FkaW5nIEZyaWVuZDwvZnJpZW5kLXZpZXc+XHJcbiAgICAgIGBcclxuICAgICl9XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1kZWNrXCIgP2hpZGRlbj1cIiR7dGhpcy50YWIgIT0gXCJmb2xsb3dpbmdcIn1cIj5cclxuICAgICR7dGhpcy5mb2xsb3dpbmcubWFwKChmLCBpKSA9PiBodG1sYFxyXG4gICAgICA8ZnJpZW5kLXZpZXcgbmFtZT1cIiR7XCJGb2xsb3dpbmdfXCIraX1cIiBmX3dlYklkPSR7Zn0+TG9hZGluZyBGb2xsb3dpbmc8L2ZyaWVuZC12aWV3PlxyXG4gICAgICBgXHJcbiAgICApfVxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPGRpdiBjbGFzcz1cImNhcmQtZGVja1wiID9oaWRkZW49XCIke3RoaXMudGFiICE9IFwiZm9sbG93ZXJzXCJ9XCI+XHJcbiAgICAke3RoaXMuZm9sbG93ZXJzLm1hcCgoZiwgaSkgPT4gaHRtbGBcclxuICAgICAgPGZyaWVuZC12aWV3IG5hbWU9XCIke1wiRm9sbG93ZXJzX1wiK2l9XCIgZl93ZWJJZD0ke2Z9PkxvYWRpbmcgRm9sbG93ZXJzPC9mcmllbmQtdmlldz5cclxuICAgICAgYFxyXG4gICAgKX1cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDwvZGl2PlxyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIG9wZW5UYWIoZSl7XHJcbiAgICB0aGlzLnRhYiA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcInRhYlwiKVxyXG4gICAgLy9jb25zb2xlLmxvZyh0aGlzLnRhYilcclxuICAgIGxldCB0YWJsaW5rcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiLm5hdi1saW5rXCIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsaW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB0YWJsaW5rc1tpXS5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xyXG4gICAgfVxyXG4gICAgZS50YXJnZXQuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKVxyXG4gIH1cclxuXHJcbiAgY29uZmlnQ2hhbmdlZChjb25maWcpe1xyXG4gICAgIGNvbnNvbGUubG9nKFwiQ09ORklHXCIsY29uZmlnKVxyXG4gICAgdGhpcy5jb25maWcgPSBjb25maWdcclxuICAgIC8vICB0aGlzLmdldEZvbGxvd2VycygpXHJcbiAgICAvLyAgdGhpcy5nZXRGb2xsb3dpbmcoKVxyXG4gICAgdGhpcy5mcmllbmRzID0gdGhpcy5jb25maWcuZnJpZW5kcyB8fCBbXVxyXG4gICAgdGhpcy5mb2xsb3dlcnMgPSB0aGlzLmNvbmZpZy5mb2xsb3dlcnNMaXN0IHx8IFtdXHJcbiAgICB0aGlzLmZvbGxvd2luZyA9IHRoaXMuY29uZmlnLmZvbGxvd2luZ0xpc3QgfHwgW11cclxuICAgIC8vY29uc29sZS5sb2coXCJISUlJSEFBQUFcIix0aGlzLmZvbGxvd2VycylcclxuICB9XHJcblxyXG4gIGZpcnN0VXBkYXRlZCgpe1xyXG4gICAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgICB0aGlzLmFnZW50ID0gbmV3IEhlbGxvQWdlbnQodGhpcy5uYW1lKTtcclxuICAgIC8vY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICAgIHRoaXMuYWdlbnQucmVjZWl2ZSA9IGZ1bmN0aW9uKGZyb20sIG1lc3NhZ2UpIHtcclxuICAgICAgLy8gIGNvbnNvbGUubG9nKFwibWVzc2FoXCIsbWVzc2FnZSlcclxuICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhtZXNzYWdlKVxyXG4gICAgICAgIHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xyXG4gICAgICAgICAgY2FzZSBcImNvbmZpZ0NoYW5nZWRcIjpcclxuICAgICAgICAgIGFwcC5jb25maWdDaGFuZ2VkKG1lc3NhZ2UuY29uZmlnKVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGFjdGlvbiBcIixtZXNzYWdlKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2ZyaWVuZHMtdmlldycsIEZyaWVuZHNWaWV3KTtcclxuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcblxyXG5jbGFzcyBGcmllbmRWaWV3IGV4dGVuZHMgTGl0RWxlbWVudCB7XHJcblxyXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBmX3dlYklkOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgZnJpZW5kOiB7dHlwZTogT2JqZWN0fSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIkZyaWVuZFwiXHJcbiAgICB0aGlzLmZfd2ViSWQgPSBcIlwiXHJcbiAgICB0aGlzLmZyaWVuZCA9IHt3ZWJJZDpcIlwiLCBuYW1lOlwiXCIsIHBob3RvOiBcIlwifVxyXG4gIH1cclxuXHJcbiAgcmVuZGVyMSgpe1xyXG4gICAgcmV0dXJuIGh0bWxgXHJcbiAgICA8bGluayBocmVmPVwiY3NzL2Jvb3RzdHJhcC9ib290c3RyYXAubWluLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvZm9udGF3ZXNvbWUvY3NzL2FsbC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcblxyXG4gICAgPGRpdiBjbGFzcz1cImNhcmRcIiBzdHlsZT1cIndpZHRoOiAxOHJlbTtcIj5cclxuICAgIDxpbWcgY2xhc3M9XCJjYXJkLWltZy10b3BcIiBzcmM9XCIuLi5cIiBhbHQ9XCJDYXJkIGltYWdlIGNhcFwiPlxyXG4gICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxyXG4gICAgPGg1IGNsYXNzPVwiY2FyZC10aXRsZVwiPkNhcmQgdGl0bGU8L2g1PlxyXG4gICAgPHAgY2xhc3M9XCJjYXJkLXRleHRcIj5UaGlzIGlzIGEgbG9uZ2VyIGNhcmQgd2l0aCBzdXBwb3J0aW5nIHRleHQgYmVsb3cgYXMgYSBuYXR1cmFsIGxlYWQtaW4gdG8gYWRkaXRpb25hbCBjb250ZW50LiBUaGlzIGNvbnRlbnQgaXMgYSBsaXR0bGUgYml0IGxvbmdlci48L3A+XHJcbiAgICA8cCBjbGFzcz1cImNhcmQtdGV4dFwiPjxzbWFsbCBjbGFzcz1cInRleHQtbXV0ZWRcIj5MYXN0IHVwZGF0ZWQgMyBtaW5zIGFnbzwvc21hbGw+PC9wPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIGB9XHJcblxyXG5cclxuXHJcbiAgcmVuZGVyKCl7XHJcbiAgICByZXR1cm4gaHRtbGBcclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiY2FyZCBiZy1saWdodCBtLTNcIiBzdHlsZT1cIndpZHRoOiA4cmVtO1wiPlxyXG4gICAgJHt0aGlzLmZyaWVuZC5waG90by5sZW5ndGggPiAwID9cclxuICAgICAgaHRtbGA8aW1nIGNsYXNzPVwicm91bmRlZC1jaXJjbGUgY2FyZC1pbWctdG9wXCJcclxuICAgICAgc3JjPVwiLy9pbWFnZXMud2VzZXJ2Lm5sLz91cmw9JHt0aGlzLmZyaWVuZC5waG90b30mdz0xMDAmaD0xMDBcIlxyXG4gICAgICBzdHlsZT1cImhlaWdodDo1cmVtLHdpZHRoOjVyZW1cIlxyXG4gICAgICB0aXRsZT1cIiR7dGhpcy5mcmllbmQucGhvdG99XCJcclxuICAgICAgYWx0PVwibm8gaW1hZ2VcIj5gXHJcbiAgICAgIDpodG1sYDxpIGNsYXNzPVwiZmFzIGZhLXVzZXItY2lyY2xlIGZhLTJ4XCIgdGl0bGU9XCIke3RoaXMuZnJpZW5kLm5hbWV9XCI+PC9pPmBcclxuICAgIH1cclxuXHJcbiAgICA8IS0tICAgIDxpbWcgY2xhc3M9XCJjYXJkLWltZy10b3BcIiBzcmM9XCIvL2ltYWdlcy53ZXNlcnYubmwvP3VybD0ke3RoaXMuZnJpZW5kLnBob3RvfSZ3PTE1MCZoPTE1MFwiICBhbHQ9XCIke3RoaXMuZnJpZW5kLm5hbWV9XCI+LS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5IHAtMVwiPlxyXG4gICAgPCEtLSAgPGg1IGNsYXNzPVwiY2FyZC10aXRsZVwiPiR7dGhpcy5mcmllbmQubmFtZX08L2g1PlxyXG4gICAgPHAgY2xhc3M9XCJjYXJkLXRleHRcIj4gJHt0aGlzLmZyaWVuZC53ZWJJZH0gV2l0aCBzdXBwb3J0aW5nIHRleHQgYmVsb3cgYXMgYSBuYXR1cmFsIGxlYWQtaW4gdG8gYWRkaXRpb25hbCBjb250ZW50LjwvcD4tLT5cclxuICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtaW5mbyBidG4tc21cIiB3ZWJJZD1cIiR7dGhpcy5mcmllbmQud2ViSWR9XCJcclxuICAgIEBjbGljaz1cIiR7dGhpcy5zaG93UHJvZmlsZX1cIj4ke3RoaXMuZnJpZW5kLm5hbWV9PC9idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIC8qIHRlc3QgcGhvdG9cclxuICAke3RoaXMuZl9waG90by5sZW5ndGggPiAwID9cclxuICBodG1sYDxpbWcgY2xhc3M9XCJyb3VuZGVkLWNpcmNsZSB1c2VyX2ltZ19tc2dcIiBzcmM9XCIvL2ltYWdlcy53ZXNlcnYubmwvP3VybD0ke3RoaXMuZl9waG90b30mdz0xNDQmaD0xNDRcIiB0aXRsZT1cIiR7dGhpcy5mX3Bob3RvfVwiIGFsdD1cIm5vIGltYWdlXCI+YFxyXG4gIDpodG1sYDxpIGNsYXNzPVwiZmFzIGZhLXVzZXItY2lyY2xlIGZhLTJ4XCIgdGl0bGU9XCIke3RoaXMuZl9uYW1lfVwiPjwvaT5gXHJcbn1cclxuKi9cclxuXHJcbnNob3dQcm9maWxlKCl7XHJcbiAgLy8gIGxldCB3ZWJJZCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcIndlYklkXCIpXHJcbiAgY29uc29sZS5sb2coXCJDTElDS0VEIGZyaWVuZFwiLHRoaXMuZnJpZW5kKVxyXG4gIHRoaXMuYWdlbnQuc2VuZChcIkFwcFwiLCB7YWN0aW9uOiBcInNob3dQYW5lbFwiLCBwYW5lbDogXCJQcm9maWxlXCJ9KVxyXG4gIHRoaXMuYWdlbnQuc2VuZChcIlByb2ZpbGVcIiwge2FjdGlvbjogXCJwcm9maWxlQ2hhbmdlZFwiLCBwcm9maWxlOiB0aGlzLmZyaWVuZH0pXHJcbn1cclxuXHJcbmZpcnN0VXBkYXRlZCgpe1xyXG4gIHZhciBhcHAgPSB0aGlzO1xyXG4gIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xyXG4gIC8vY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICB0aGlzLmFnZW50LnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgICAvLyAgY29uc29sZS5sb2coXCJtZXNzYWhcIixtZXNzYWdlKVxyXG4gICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAvLyAgY29uc29sZS5sb2cobWVzc2FnZSlcclxuICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBcIndlYklkQ2hhbmdlZFwiOlxyXG4gICAgICAgIGFwcC53ZWJJZENoYW5nZWQobWVzc2FnZS53ZWJJZClcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbiAgdGhpcy5mcmllbmQud2ViSWQgPSB0aGlzLmZfd2ViSWRcclxuXHJcbiAgdGhpcy5pbml0KClcclxufVxyXG5cclxuYXN5bmMgaW5pdCgpe1xyXG4gIGxldCBuYW1lID0gYXdhaXQgc29saWQuZGF0YVtgJHt0aGlzLmZfd2ViSWR9YF0udmNhcmQkZm4gfHwgYCR7dGhpcy5mX3dlYklkfWAuc3BsaXQoXCIvXCIpWzJdLnNwbGl0KCcuJylbMF07XHJcbiAgbGV0IHBob3RvID0gYXdhaXQgc29saWQuZGF0YVtgJHt0aGlzLmZfd2ViSWR9YF0udmNhcmQkaGFzUGhvdG8gfHwgXCJodHRwczovL3NvbGlkLmdpdGh1Yi5pby9zb2xpZC11aS9zcmMvaWNvbnMvbm91bl8xNTA1OS5zdmdcIlxyXG4gIHRoaXMuZnJpZW5kLm5hbWUgPSBgJHtuYW1lfWBcclxuICB0aGlzLmZyaWVuZC5waG90byA9IGAke3Bob3RvfWAhPSBcInVuZGVmaW5lZFwiID8gYCR7cGhvdG99YCA6IFwiaHR0cHM6Ly9zb2xpZC5naXRodWIuaW8vc29saWQtdWkvc3JjL2ljb25zL25vdW5fMTUwNTkuc3ZnXCJcclxuICAvLyAgY29uc29sZS5sb2coXCJmcmllbmRcIiwgdGhpcy5mcmllbmQsIHRoaXMuZl93ZWJJZClcclxuXHJcbiAgdGhpcy5yZXF1ZXN0VXBkYXRlKClcclxufVxyXG5cclxufVxyXG5cclxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdmcmllbmQtdmlldycsIEZyaWVuZFZpZXcpO1xyXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcclxuXHJcbmNsYXNzIExvZ0VsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJMb2dcIlxyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCl7XHJcbiAgICByZXR1cm4gaHRtbGBcclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxzdHlsZT5cclxuICAgIC8qIFRoZSBzbmFja2JhciAtIHBvc2l0aW9uIGl0IGF0IHRoZSBib3R0b20gYW5kIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbiAqL1xyXG4gICAgI3NuYWNrYmFyIHtcclxuICAgICAgdmlzaWJpbGl0eTogaGlkZGVuOyAvKiBIaWRkZW4gYnkgZGVmYXVsdC4gVmlzaWJsZSBvbiBjbGljayAqL1xyXG4gICAgICBtaW4td2lkdGg6IDI1MHB4OyAvKiBTZXQgYSBkZWZhdWx0IG1pbmltdW0gd2lkdGggKi9cclxuICAgICAgbWFyZ2luLWxlZnQ6IC0xMjVweDsgLyogRGl2aWRlIHZhbHVlIG9mIG1pbi13aWR0aCBieSAyICovXHJcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7IC8qIEJsYWNrIGJhY2tncm91bmQgY29sb3IgKi9cclxuICAgICAgY29sb3I6ICNmZmY7IC8qIFdoaXRlIHRleHQgY29sb3IgKi9cclxuICAgICAgdGV4dC1hbGlnbjogY2VudGVyOyAvKiBDZW50ZXJlZCB0ZXh0ICovXHJcbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweDsgLyogUm91bmRlZCBib3JkZXJzICovXHJcbiAgICAgIHBhZGRpbmc6IDE2cHg7IC8qIFBhZGRpbmcgKi9cclxuICAgICAgcG9zaXRpb246IGZpeGVkOyAvKiBTaXQgb24gdG9wIG9mIHRoZSBzY3JlZW4gKi9cclxuICAgICAgei1pbmRleDogMTsgLyogQWRkIGEgei1pbmRleCBpZiBuZWVkZWQgKi9cclxuICAgICAgbGVmdDogNTAlOyAvKiBDZW50ZXIgdGhlIHNuYWNrYmFyICovXHJcbiAgICAgIGJvdHRvbTogMzBweDsgLyogMzBweCBmcm9tIHRoZSBib3R0b20gKi9cclxuICAgIH1cclxuXHJcbiAgICAvKiBTaG93IHRoZSBzbmFja2JhciB3aGVuIGNsaWNraW5nIG9uIGEgYnV0dG9uIChjbGFzcyBhZGRlZCB3aXRoIEphdmFTY3JpcHQpICovXHJcbiAgICAjc25hY2tiYXIuc2hvdyB7XHJcbiAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7IC8qIFNob3cgdGhlIHNuYWNrYmFyICovXHJcbiAgICAgIC8qIEFkZCBhbmltYXRpb246IFRha2UgMC41IHNlY29uZHMgdG8gZmFkZSBpbiBhbmQgb3V0IHRoZSBzbmFja2Jhci5cclxuICAgICAgSG93ZXZlciwgZGVsYXkgdGhlIGZhZGUgb3V0IHByb2Nlc3MgZm9yIDIuNSBzZWNvbmRzICovXHJcbiAgICAgIC13ZWJraXQtYW5pbWF0aW9uOiBmYWRlaW4gMC41cywgZmFkZW91dCAwLjVzIDIuNXM7XHJcbiAgICAgIGFuaW1hdGlvbjogZmFkZWluIDAuNXMsIGZhZGVvdXQgMC41cyAyLjVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEFuaW1hdGlvbnMgdG8gZmFkZSB0aGUgc25hY2tiYXIgaW4gYW5kIG91dCAqL1xyXG4gICAgQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVpbiB7XHJcbiAgICAgIGZyb20ge2JvdHRvbTogMDsgb3BhY2l0eTogMDt9XHJcbiAgICAgIHRvIHtib3R0b206IDMwcHg7IG9wYWNpdHk6IDE7fVxyXG4gICAgfVxyXG5cclxuICAgIEBrZXlmcmFtZXMgZmFkZWluIHtcclxuICAgICAgZnJvbSB7Ym90dG9tOiAwOyBvcGFjaXR5OiAwO31cclxuICAgICAgdG8ge2JvdHRvbTogMzBweDsgb3BhY2l0eTogMTt9XHJcbiAgICB9XHJcblxyXG4gICAgQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVvdXQge1xyXG4gICAgICBmcm9tIHtib3R0b206IDMwcHg7IG9wYWNpdHk6IDE7fVxyXG4gICAgICB0byB7Ym90dG9tOiAwOyBvcGFjaXR5OiAwO31cclxuICAgIH1cclxuXHJcbiAgICBAa2V5ZnJhbWVzIGZhZGVvdXQge1xyXG4gICAgICBmcm9tIHtib3R0b206IDMwcHg7IG9wYWNpdHk6IDE7fVxyXG4gICAgICB0byB7Ym90dG9tOiAwOyBvcGFjaXR5OiAwO31cclxuICAgIH1cclxuICAgIDwvc3R5bGU+XHJcbiAgICA8IS0tICA8c3R5bGU+XHJcbiAgICAubXlBbGVydC10b3B7XHJcbiAgICBwb3NpdGlvbjogZml4ZWQ7XHJcbiAgICB0b3A6IDVweDtcclxuICAgIGxlZnQ6MiU7XHJcbiAgICB3aWR0aDogOTYlO1xyXG4gIH1cclxuXHJcbiAgLm15QWxlcnQtYm90dG9te1xyXG4gIHBvc2l0aW9uOiBmaXhlZDtcclxuICBib3R0b206IDVweDtcclxuICBsZWZ0OjIlO1xyXG4gIHdpZHRoOiA5NiU7XHJcbn1cclxuXHJcbmRpdi5mdWxsc2NyZWVuIHtcclxucG9zaXRpb246IGFic29sdXRlO1xyXG53aWR0aDoxMDAlO1xyXG5oZWlnaHQ6OTYwcHg7XHJcbnRvcDogMDtcclxubGVmdDogMDtcclxuYmFja2dyb3VuZC1jb2xvcjogbGlnaHRibHVlO1xyXG59XHJcblxyXG4uYWxlcnR7XHJcbmRpc3BsYXk6IG5vbmU7XHJcbn1cclxuPC9zdHlsZT5cclxuLS0+XHJcblxyXG48ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCI+XHJcbkhlbGxvIDxiPiR7dGhpcy5uYW1lfTwvYj4gZnJvbSBhcHAtZWxlbWVudFxyXG5cclxuPCEtLSBVc2UgYSBidXR0b24gdG8gb3BlbiB0aGUgc25hY2tiYXIgLS0+XHJcbjxidXR0b24gQGNsaWNrPVwiJHt0aGlzLm15RnVuY3Rpb259XCI+U2hvdyBTbmFja2JhcjwvYnV0dG9uPlxyXG5cclxuPCEtLSBUaGUgYWN0dWFsIHNuYWNrYmFyIC0tPlxyXG48IS0tPGRpdiBpZD1cInNuYWNrYmFyXCI+U29tZSB0ZXh0IHNvbWUgbWVzc2FnZS4uPC9kaXY+LS0+XHJcblxyXG5cclxuXHJcblxyXG48ZGl2IGNsYXNzPVwidG9hc3RcIiBpZD1cInNuYWNrYmFyXCIgcm9sZT1cImFsZXJ0XCIgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgYXJpYS1hdG9taWM9XCJ0cnVlXCI+XHJcbjxkaXYgY2xhc3M9XCJ0b2FzdC1oZWFkZXJcIj5cclxuPGltZyBzcmM9XCIuLi5cIiBjbGFzcz1cInJvdW5kZWQgbXItMlwiIGFsdD1cIi4uLlwiPlxyXG48c3Ryb25nIGNsYXNzPVwibXItYXV0b1wiPkJvb3RzdHJhcDwvc3Ryb25nPlxyXG48c21hbGw+MTEgbWlucyBhZ288L3NtYWxsPlxyXG48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm1sLTIgbWItMSBjbG9zZVwiIGRhdGEtZGlzbWlzcz1cInRvYXN0XCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+XHJcbjxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XHJcbjwvYnV0dG9uPlxyXG48L2Rpdj5cclxuPGRpdiBjbGFzcz1cInRvYXN0LWJvZHlcIj5cclxuSGVsbG8sIHdvcmxkISBUaGlzIGlzIGEgdG9hc3QgbWVzc2FnZS4gSGVsbG8sIHdvcmxkISBUaGlzIGlzIGEgdG9hc3QgbWVzc2FnZS4gSGVsbG8sIHdvcmxkISBUaGlzIGlzIGEgdG9hc3QgbWVzc2FnZS4gSGVsbG8sIHdvcmxkISBUaGlzIGlzIGEgdG9hc3QgbWVzc2FnZS5cclxuPC9kaXY+XHJcbjwvZGl2PlxyXG5cclxuPCEtLTxkaXYgY2xhc3M9XCJmdWxsc2NyZWVuXCI+XHJcbjxkaXYgY2xhc3M9XCJjb2wtc20tNlwiPlxyXG48YnV0dG9uIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgQGNsaWNrPVwiJHt0aGlzLm15QWxlcnRUb3B9XCI+c2hvdyBhbGVydCB0b3A8L2J1dHRvbj5cclxuPC9kaXY+XHJcbjxkaXYgY2xhc3M9XCJjb2wtc20tNlwiPlxyXG48YnV0dG9uIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgQGNsaWNrPVwiJHt0aGlzLm15QWxlcnRCb3R0b219XCI+c2hvdyBhbGVydCBib3R0b208L2J1dHRvbj5cclxuPC9kaXY+XHJcbjwvZGl2PlxyXG48ZGl2IGlkPVwidG9wXCIgY2xhc3M9XCJteUFsZXJ0LXRvcCBhbGVydCBhbGVydC1zdWNjZXNzXCI+XHJcbjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cImFsZXJ0XCIgYXJpYS1sYWJlbD1cImNsb3NlXCI+JnRpbWVzOzwvYT5cclxuPHN0cm9uZz5TdWNjZXNzITwvc3Ryb25nPiBJbmRpY2F0ZXMgYSBzdWNjZXNzZnVsIG9yIHBvc2l0aXZlIGFjdGlvbi5cclxuPC9kaXY+XHJcbjxkaXYgaWQ9XCJib3R0b21cIiBjbGFzcz1cIm15QWxlcnQtYm90dG9tIGFsZXJ0IGFsZXJ0LWRhbmdlclwiPlxyXG48YSBocmVmPVwiI1wiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJhbGVydFwiIGFyaWEtbGFiZWw9XCJjbG9zZVwiPiZ0aW1lczs8L2E+XHJcbjxzdHJvbmc+RGFuZ2VyITwvc3Ryb25nPiBUaGlzIGFsZXJ0IGJveCBjb3VsZCBpbmRpY2F0ZSBhIGRhbmdlcm91cyBvciBwb3RlbnRpYWxseSBuZWdhdGl2ZSBhY3Rpb24uXHJcbjwvZGl2Pi0tPlxyXG48IS0tXHJcbjxwYXBlci10b2FzdCB0ZXh0PVwiSGVsbG8gVGFrZSB5b3VyIDxhIGhyZWY9JyN0Jz5QT0Q8L2E+IGFuZCBsb29rIGF0IGhlbHAhXCIgb3BlbmVkPiBCb288L3BhcGVyLXRvYXN0Pi0tPlxyXG48L2Rpdj5cclxuYDtcclxufVxyXG5cclxuZmlyc3RVcGRhdGVkKCl7XHJcbiAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICB0aGlzLmFnZW50LnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgICAvLyAgY29uc29sZS5sb2coXCJtZXNzYWhcIixtZXNzYWdlKVxyXG4gICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAvLyAgY29uc29sZS5sb2cobWVzc2FnZSlcclxuICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBcIndlYklkQ2hhbmdlZFwiOlxyXG4gICAgICAgIGFwcC53ZWJJZENoYW5nZWQobWVzc2FnZS53ZWJJZClcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG59XHJcblxyXG5teUZ1bmN0aW9uKCkge1xyXG4gIC8vIEdldCB0aGUgc25hY2tiYXIgRElWXHJcbiAgdmFyIHggPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoXCJzbmFja2JhclwiKTtcclxuICBjb25zb2xlLmxvZyhcIlhcIix4KVxyXG4gIC8vIEFkZCB0aGUgXCJzaG93XCIgY2xhc3MgdG8gRElWXHJcbiAgeC5jbGFzc05hbWUgPSBcInNob3dcIjtcclxuXHJcbiAgLy8gQWZ0ZXIgMyBzZWNvbmRzLCByZW1vdmUgdGhlIHNob3cgY2xhc3MgZnJvbSBESVZcclxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHguY2xhc3NOYW1lID0geC5jbGFzc05hbWUucmVwbGFjZShcInNob3dcIiwgXCJcIik7IH0sIDMwMDApO1xyXG59XHJcblxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xvZy1lbGVtZW50JywgTG9nRWxlbWVudCk7XHJcbiIsImltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XHJcbmltcG9ydCB7IEhlbGxvQWdlbnQgfSBmcm9tICcuLi9hZ2VudHMvaGVsbG8tYWdlbnQuanMnO1xyXG4vL2xldCBkYXRhID0gc29saWQuZGF0YVxyXG4vL2NvbnNvbGUubG9nKFwiTERGSytMRVhcIixkYXRhKVxyXG5pbXBvcnQgeyBuYW1lZE5vZGUgfSBmcm9tICdAcmRmanMvZGF0YS1tb2RlbCc7XHJcblxyXG5cclxuY2xhc3MgUHJvZmlsZUVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGNvbmZpZzoge3R5cGU6IE9iamVjdH0sIC8vIGNvbmZpZyA6IGN1cnJlbnQgbG9nZWQgdXNlclxyXG4gICAgICBwX2NvbmZpZyA6IHt0eXBlOiBPYmplY3R9LCAvLyBwX2NvbmZpZyA6IHRoZSB1c2VyIHRoYXQgdGhlIHByb2ZpbGUtZWxlbWVudCBzaG93c1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMubmFtZSA9IFwiUHJvZmlsZVwiXHJcbiAgICB0aGlzLmNvbmZpZyA9IHt9XHJcbiAgICB0aGlzLnBfY29uZmlnID0ge3N0b3JhZ2U6IFwiTG9hZGluZy4uLlwifVxyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCl7XHJcbiAgICByZXR1cm4gaHRtbGBcclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxzdHlsZT5cclxuICAgIC5jbG9zZSB7XHJcbiAgICAgIGNvbG9yOiBcIiNhYWFhYWFcIjtcclxuICAgICAgZmxvYXQ6IHJpZ2h0O1xyXG4gICAgICBmb250LXNpemU6IDI4cHg7XHJcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgfVxyXG5cclxuICAgIC5jbG9zZTpob3ZlcixcclxuICAgIC5jbG9zZTpmb2N1cyB7XHJcbiAgICAgIGNvbG9yOiBcIiMwMDBcIjtcclxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB9XHJcbiAgICA8L3N0eWxlPlxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJjYXJkXCIgc3R5bGU9XCJ3aWR0aDogMThyZW07XCI+XHJcbiAgICA8aSBAY2xpY2s9XCIke3RoaXMuY2xvc2V9XCIgY2xhc3M9XCJjbG9zZSBmYXMgZmEtd2luZG93LWNsb3NlXCI+PC9pPlxyXG5cclxuICAgIDxpbWcgY2xhc3M9XCJjYXJkLWltZy10b3BcIiBzcmM9XCIke3RoaXMucF9jb25maWcucGhvdG99XCIgYWx0PVwiQ2FyZCBpbWFnZSBjYXBcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIj5cclxuICAgIDxoNSBjbGFzcz1cImNhcmQtdGl0bGVcIj48Yj4ke3RoaXMucF9jb25maWcubmFtZX08L2I+PC9oNT5cclxuXHJcbiAgICA8cCBjbGFzcz1cImNhcmQtdGV4dFwiPlxyXG5cclxuICAgIFVzZXIgIHdlYklkIDo8Yj4ke3RoaXMucF9jb25maWcud2ViSWR9PC9iPjxicj5cclxuICAgIFN0b3JhZ2UgOiA8YVxyXG4gICAgaHJlZj1cImh0dHBzOi8vc2NlbmFyaXN0ZXVyLmdpdGh1Yi5pby9zcG9nZ3ktc2ltcGxlLz9zb3VyY2U9JHt0aGlzLnBfY29uZmlnLnN0b3JhZ2V9XCJcclxuICAgIHRhcmdldD1cIl9ibGFua1wiID4ke3RoaXMucF9jb25maWcuc3RvcmFnZX08L2E+PGJyPlxyXG48IS0tc3RyaW5nVmFyaWFibGUuc3Vic3RyaW5nKDAsIHN0cmluZ1ZhcmlhYmxlLmxhc3RJbmRleE9mKCcjJykpOy0tPlxyXG4gICAgUm9sZTogJHt0aGlzLnBfY29uZmlnLnJvbGV9PGJyPlxyXG4gICAgT3JnYW5pc2F0aW9uOiAke3RoaXMucF9jb25maWcub3JnYW5pemF0aW9ufTxicj5cclxuICAgIDxicj5cclxuICAgIDxicj4gIFlvdXIgV2ViSWQgOiAke3RoaXMuY29uZmlnLndlYklkfTxicj5cclxuICAgIDwvcD5cclxuXHJcbiAgICAke3RoaXMuY29uZmlnLndlYklkICE9IG51bGwgP1xyXG4gICAgICBodG1sYFxyXG4gICAgICAke3RoaXMuY29uZmlnLndlYklkICE9IHRoaXMucF9jb25maWcud2ViSWQgP1xyXG4gICAgICAgIGh0bWwgYDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtaW5mbyBidG4tc21cIiBAY2xpY2s9XCIke3RoaXMuZm9sbG93fVwiPjxpIGNsYXNzPVwiZmFzIGZhLXVzZXItcGx1c1wiPjwvaT5Gb2xsb3c8L2J1dHRvbj5cclxuICAgICAgICBgXHJcbiAgICAgICAgOmh0bWwgYFxyXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJicm4gYnRuLW91dGxpbmUtcHJpbWFyeSBidG4tc21cIiBAY2xpY2s9XCIke3RoaXMuZWRpdH1cIj5FZGl0IE15IFByb2ZpbGUgKFdJUCk8L2J1dHRvbj5cclxuICAgICAgICBgfVxyXG4gICAgICAgIGBcclxuICAgICAgICA6aHRtbGBgXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgYDtcclxuICAgIH1cclxuXHJcbiAgICBlZGl0KCl7XHJcbiAgICAgIGFsZXJ0KFwiLy8gVE9ETzogY29tZSBiYWNrIGxhdGVyIDstKSBcIilcclxuICAgIH1cclxuXHJcbiAgICBjbG9zZSgpe1xyXG4gICAgICB0aGlzLmFnZW50LnNlbmQoXCJBcHBcIiwge2FjdGlvbjogXCJzaG93UGFuZWxcIn0pXHJcbiAgICB9XHJcblxyXG4gICAgZmlyc3RVcGRhdGVkKCl7XHJcbiAgICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgICB0aGlzLmFnZW50ID0gbmV3IEhlbGxvQWdlbnQodGhpcy5uYW1lKTtcclxuICAgICAgY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICAgICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcIm1lc3NhaFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgICBzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBcInByb2ZpbGVDaGFuZ2VkXCI6XHJcbiAgICAgICAgICAgIGFwcC5wcm9maWxlQ2hhbmdlZChtZXNzYWdlLnByb2ZpbGUpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiY29uZmlnQ2hhbmdlZFwiOlxyXG4gICAgICAgICAgICBhcHAuY29uZmlnQ2hhbmdlZChtZXNzYWdlLmNvbmZpZylcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdCgpe1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlRPRE8gY2hlY2sgaWYgdXNlciB3ZWJJZCBmb2xsb3cgdGhpcyBwcm9maWxlXCIpXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZ0NoYW5nZWQoY29uZmlnKXtcclxuICAgICAgdGhpcy5jb25maWcgPSBjb25maWdcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyAgZm9sbG93KCl7XHJcbiAgICAgIC8vIE11c3QgY3JlYXRlIGEgZm9sbG93IEFjdGl2aXR5IHdpdGggYWNjZXB0ID9cclxuICAgICAgLy8gIGFsZXJ0KFwiLy8gVE9ETzogY29tZSBiYWNrIGxhdGVyIDstKSBcIilcclxuICAgICAgY29uc29sZS5sb2coXCJDT05GSUdcIiwgdGhpcy5jb25maWcpXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiUF9DT05GSUdcIiwgdGhpcy5wX2NvbmZpZylcclxuICAgICAgbGV0IHByb2ZpbGVfZm9sbG93ZXJzID0gdGhpcy5wX2NvbmZpZy5mb2xsb3dlcnMrJ2luZGV4LnR0bCN0aGlzJ1xyXG4gICAgICBjb25zb2xlLmxvZyhwcm9maWxlX2ZvbGxvd2VycylcclxuICAgICAgbGV0IHVzZXJfZm9sbG93aW5nID0gdGhpcy5jb25maWcuZm9sbG93aW5nKydpbmRleC50dGwjdGhpcydcclxuICAgICAgY29uc29sZS5sb2codXNlcl9mb2xsb3dpbmcpXHJcbiAgICAgIGF3YWl0IHNvbGlkLmRhdGFbdXNlcl9mb2xsb3dpbmddLmFzJGl0ZW1zLmFkZChuYW1lZE5vZGUodGhpcy5wX2NvbmZpZy53ZWJJZCkpXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiISEhIE11c3QgZmlyc3Qgc2V0IGF1dGhlbnRpY2F0ZWQgYWdlbnQgdG8gcHVibGlzaGVyIGluIGNvbmZpZ1wiKVxyXG4gICAgICBhd2FpdCBzb2xpZC5kYXRhW3Byb2ZpbGVfZm9sbG93ZXJzXS5hcyRpdGVtcy5hZGQobmFtZWROb2RlKHRoaXMuY29uZmlnLndlYklkKSlcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGFzeW5jIHByb2ZpbGVDaGFuZ2VkKHByb2ZpbGUpe1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlVTRVJcIixwcm9maWxlKVxyXG4gICAgICB0aGlzLnBfY29uZmlnID0gcHJvZmlsZVxyXG4gICAgICB0aGlzLnBfY29uZmlnLnB0aSA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy5wX2NvbmZpZy53ZWJJZF0ucHVibGljVHlwZUluZGV4XHJcbiAgICAgIGZvciBhd2FpdCAoY29uc3Qgc3ViamVjdCBvZiBzb2xpZC5kYXRhW3RoaXMucF9jb25maWcucHRpXS5zdWJqZWN0cyl7XHJcbiAgICAgICAgaWYodGhpcy5wX2NvbmZpZy5wdGkgIT0gYCR7c3ViamVjdH1gKVxyXG4gICAgICAgIC8qbGV0IHMgPSBgJHtzdWJqZWN0fWBcclxuICAgICAgICBjb25zb2xlLmxvZyhzKSovXHJcbiAgICAgICAgaWYgKGAke3N1YmplY3R9YC5lbmRzV2l0aCgnI0Fnb3JhJykpe1xyXG4gICAgICAgICAgbGV0IGluc3RhbmNlICA9IGF3YWl0IHNvbGlkLmRhdGFbYCR7c3ViamVjdH1gXS5zb2xpZCRpbnN0YW5jZVxyXG4gICAgICAgICAgdGhpcy5wX2NvbmZpZy5pbnN0YW5jZSA9IGAke2luc3RhbmNlfWBcclxuICAgICAgICAgIGxldCBpbmJveCA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy5wX2NvbmZpZy5pbnN0YW5jZV0uYXMkaW5ib3hcclxuICAgICAgICAgIHRoaXMucF9jb25maWcuaW5ib3ggPSBgJHtpbmJveH1gXHJcbiAgICAgICAgICBsZXQgb3V0Ym94ID0gYXdhaXQgc29saWQuZGF0YVt0aGlzLnBfY29uZmlnLmluc3RhbmNlXS5hcyRvdXRib3hcclxuICAgICAgICAgIHRoaXMucF9jb25maWcub3V0Ym94ID0gYCR7b3V0Ym94fWBcclxuICAgICAgICAgIGxldCBmb2xsb3dlcnMgPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMucF9jb25maWcuaW5zdGFuY2VdLmFzJGZvbGxvd2Vyc1xyXG4gICAgICAgICAgdGhpcy5wX2NvbmZpZy5mb2xsb3dlcnMgPSBgJHtmb2xsb3dlcnN9YFxyXG4gICAgICAgICAgbGV0IGZvbGxvd2luZyA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy5wX2NvbmZpZy5pbnN0YW5jZV0uYXMkZm9sbG93aW5nXHJcbiAgICAgICAgICB0aGlzLnBfY29uZmlnLmZvbGxvd2luZyA9IGAke2ZvbGxvd2luZ31gXHJcbiAgICAgICAgICBsZXQgbGlrZWQgPSBhd2FpdCBzb2xpZC5kYXRhW3RoaXMucF9jb25maWcuaW5zdGFuY2VdLmFzJGxpa2VkXHJcbiAgICAgICAgICB0aGlzLnBfY29uZmlnLmxpa2VkID0gYCR7bGlrZWR9YFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBsZXQgc3RvcmFnZSA9IGF3YWl0IHNvbGlkLmRhdGFbdGhpcy5wX2NvbmZpZy53ZWJJZF0uc3RvcmFnZVxyXG4gICAgICB0aGlzLnBfY29uZmlnLnN0b3JhZ2UgPSBgJHtzdG9yYWdlfWBcclxudGhpcy5wX2NvbmZpZy5vcmdhbml6YXRpb24gPSAgYXdhaXQgc29saWQuZGF0YVt0aGlzLnBfY29uZmlnLndlYklkXVtcImh0dHA6Ly93d3cudzMub3JnLzIwMDYvdmNhcmQvbnMjb3JnYW5pemF0aW9uLW5hbWVcIl1cclxudGhpcy5wX2NvbmZpZy5yb2xlID0gIGF3YWl0IHNvbGlkLmRhdGFbdGhpcy5wX2NvbmZpZy53ZWJJZF1bXCJodHRwOi8vd3d3LnczLm9yZy8yMDA2L3ZjYXJkL25zI3JvbGVcIl1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiUF9QUk9GSUxFXCIsdGhpcy5wX2NvbmZpZylcclxuICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKClcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3Byb2ZpbGUtZWxlbWVudCcsIFByb2ZpbGVFbGVtZW50KTtcclxuIiwiLy9HRU5FUkFMXHJcbmltcG9ydCAnLi9jc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzJztcclxuaW1wb3J0ICcuL3N0eWxlcy5jc3MnO1xyXG5pbXBvcnQgJy4vdmlld3MvYXBwLXZpZXcuanMnO1xyXG5pbXBvcnQgJy4vdmlld3Mvc3RvcmUtZWxlbWVudC5qcydcclxuaW1wb3J0ICcuL3ZpZXdzL3BhbmVsLWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi92aWV3cy9pbmZvLWVsZW1lbnQuanMnO1xyXG5cclxuLy8gU09MSURcclxuaW1wb3J0ICcuL3ZpZXdzL2xvZ2luLWVsZW1lbnQuanMnO1xyXG5cclxuLy8gRkxVWFxyXG5pbXBvcnQgJy4vdmlld3MvZmx1eC1lbGVtZW50LmpzJztcclxuaW1wb3J0ICcuL3ZpZXdzL25vdGlmaWNhdGlvbi1saW5lLWVsZW1lbnQuanMnO1xyXG5pbXBvcnQgJy4vdmlld3MvYWN0aXZpdHktZWxlbWVudC5qcyc7XHJcbmltcG9ydCAnLi92aWV3cy9vYmplY3QtZWxlbWVudC5qcyc7XHJcblxyXG4vL0NPTkZJR1xyXG5pbXBvcnQgJy4vdmlld3MvY29uZmlnLWdldC12aWV3LmpzJ1xyXG5cclxuLy9QT1NUXHJcbmltcG9ydCAnLi92aWV3cy9mYWItZWxlbWVudC5qcydcclxuaW1wb3J0ICcuL3ZpZXdzL3Bvc3QtZWxlbWVudC5qcydcclxuaW1wb3J0ICcuL3ZpZXdzL3Bvc3QtZGlhbG9nLWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi92aWV3cy9wb3N0LXRhYnMtZWxlbWVudC5qcydcclxuaW1wb3J0ICcuL3ZpZXdzL25vdGUtZWxlbWVudC5qcydcclxuaW1wb3J0ICcuL3ZpZXdzL21lZGlhLWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi92aWV3cy90cmlwbGUtZWxlbWVudC5qcydcclxuaW1wb3J0ICcuL3ZpZXdzL2dyYXBoLWVsZW1lbnQuanMnXHJcblxyXG4vL09SR0FOSVpBVElPTlxyXG5pbXBvcnQgJy4vdmlld3MvZnJpZW5kcy12aWV3LmpzJ1xyXG5pbXBvcnQgJy4vdmlld3MvZnJpZW5kLXZpZXcuanMnXHJcblxyXG4vLyBMT0dcclxuaW1wb3J0ICcuL3ZpZXdzL2xvZy1lbGVtZW50LmpzJ1xyXG5cclxuLy8gUFJPRklMRVxyXG5pbXBvcnQgJy4vdmlld3MvcHJvZmlsZS1lbGVtZW50LmpzJ1xyXG4vKlxyXG5pbXBvcnQgJy4vdmlld3MvY29tcG9zZS12aWV3LmpzJztcclxuaW1wb3J0ICcuL3ZpZXdzL29yZ2Etdmlldy5qcyc7XHJcbmltcG9ydCAnLi92aWV3cy9mbG93LXZpZXcuanMnO1xyXG5pbXBvcnQgJy4vdmlld3MvdGFsay12aWV3LmpzJzsqL1xyXG4vL2ltcG9ydCAnLi92aWV3cy9jb25maWctdmlldy5qcyc7XHJcblxyXG5cclxuLy9pbXBvcnQgJy4vY3NzL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzJztcclxuLy9pbXBvcnQgJy4vdmlld3Mvc3RvcmUtZWxlbWVudC5qcydcclxuLy9pbXBvcnQgJy4vdmlld3MvZnJpZW5kcy12aWV3LmpzJ1xyXG4vL2ltcG9ydCAnLi92aWV3cy9mcmllbmQtdmlldy5qcydcclxuLy9pbXBvcnQgJy4vdmlld3MvaW5mby1lbGVtZW50LmpzJztcclxuLy9cclxuLy9pbXBvcnQgJy4vdmlld3MvdXNlci1wcm9maWxlLXZpZXcuanMnXHJcbi8vaW1wb3J0ICcuL3ZpZXdzL2NvbmZpZy1zZXQtdmlldy5qcydcclxuXHJcbi8qaW1wb3J0ICcuL3ZpZXdzL3RvZG8tdmlldy5qcyc7XHJcbmltcG9ydCAnLi92aWV3cy9zdGF0cy12aWV3LmpzJztcclxuaW1wb3J0ICcuL3ZpZXdzL25vdC1mb3VuZC12aWV3LmpzJztcclxuaW1wb3J0ICcuL3ZpZXdzL2FjdGl2aXR5LWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi92aWV3cy9vYmplY3QtZWxlbWVudC5qcydcclxuaW1wb3J0ICcuL3ZpZXdzL25vdGlmaWNhdGlvbi1saW5lLWVsZW1lbnQuanMnXHJcbi8vaW1wb3J0ICcuL3ZpZXdzL2xvZ2luLWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi92aWV3cy9wb3N0LWJhc2ljLWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi92aWV3cy9mbHV4LWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi92aWV3cy9tZW51LWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi92aWV3cy9wcm9maWxlLWVsZW1lbnQuanMnXHJcbi8vaW1wb3J0ICcuL3ZpZXdzL3Byb2ZpbGUtY2FydG91Y2hlLWVsZW1lbnQuanMnXHJcblxyXG5pbXBvcnQgJy4vdmlld3MvY29uZmlnLWVsZW1lbnQuanMnXHJcbmltcG9ydCAnLi92aWV3cy9mYWItZWxlbWVudC5qcydcclxuaW1wb3J0ICcuL3ZpZXdzL3Bvc3QtZWxlbWVudC5qcydcclxuLy9pbXBvcnQgJy4vYXBwLW9sZC1lbGVtZW50LmpzJyovXHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///86\n')}]);